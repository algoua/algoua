[{"title":"Алгоритм Евкліда знаходження НСД","type":0,"sectionRef":"#","url":"/algorithms/algebra/euclid_algorithm","content":"","keywords":"Алгоритм Евклід НСД НСК GCD LCM"},{"title":"Алгоритм​","type":1,"pageTitle":"Алгоритм Евкліда знаходження НСД","url":"/algorithms/algebra/euclid_algorithm#алгоритм","content":"Сам алгоритм надзвичайно простий і описується наступною формулою: gcd(a,b)={a,якщо b=0gcd(b,a mod b),інакше{\\rm gcd}(a,b) = \\begin{cases} a, &amp; \\text{якщо }b=0 \\cr {\\rm gcd} (b, a\\ {\\rm mod}\\ b), &amp; \\text{інакше} \\end{cases}gcd(a,b)={a,gcd(b,a mod b),​якщо b=0інакше​ "},{"title":"Реалізація​","type":1,"pageTitle":"Алгоритм Евкліда знаходження НСД","url":"/algorithms/algebra/euclid_algorithm#реалізація","content":"int gcd(int a, int b) { if (b == 0) { return a; } else { return gcd(b, a % b); } }  Використовуючи тернарний умовний оператор C++, алгоритм можна записати ще коротше: int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }  Оптимальніша нерекурсивна форма алгоритму: int gcd(int a, int b) { while (b) { a %= b; swap(a, b); } return a; }  "},{"title":"Доведення коректності​","type":1,"pageTitle":"Алгоритм Евкліда знаходження НСД","url":"/algorithms/algebra/euclid_algorithm#доведення-коректності","content":"Спочатку зауважимо, що при кожній ітерації алгоритму Евкліда його другий аргумент завжди зменшується, а отже, оскільки він невід'ємний, алгоритм Евкліда завжди завершується. Для доведення коректності нам необхідно показати, що gcd(a,b)=gcd(b,a mod b){\\rm gcd}(a,b) = {\\rm gcd} (b, a\\ {\\rm mod}\\ b)gcd(a,b)=gcd(b,a mod b) для будь-яких a≥0,b&gt;0a \\ge 0, b &gt; 0a≥0,b&gt;0. Покажемо, що величина, що стоїть в лівій частини рівності, ділиться на величину у правій, а та, шо стоїть у правій - ділиться на величину у лівій. Очевидно, це буде означати, що ліва і права частини збігаються, що і доведе коректність алгоритму Евкліда. Позначимо d=gcd(a,b)d = {\\rm gcd}(a,b)d=gcd(a,b). Значить, за визначенням, d∣ad|ad∣a і d∣bd|bd∣b. Далі, розкладемо залишок від ділення aaa на bbb через їх частку: a mod b=a−b⌊ab⌋a\\ {\\rm mod}\\ b = a - b \\left\\lfloor \\frac{a}{b} \\right\\rfloora mod b=a−b⌊ba​⌋ Звідси випливає: d ∣ (a mod b)d\\ |\\ (a\\ {\\rm mod}\\ b)d ∣ (a mod b) Отже, згадуючи твердження d∣bd|bd∣b, отримуємо систему: {d ∣ b,d ∣ (a mod b)\\begin{cases} d\\ |\\ b, \\cr d\\ |\\ (a\\ {\\rm mod}\\ b) \\end{cases}{d ∣ b,d ∣ (a mod b)​ Скористаємося тепер наступним простим фактом: якщо для якихось трьох чисел p,q,rp,q,rp,q,r виконуються: p∣qp|qp∣q і p∣rp|rp∣r, то виконується і: p ∣ gcd(q,r)p\\ |\\ {\\rm gcd}(q,r)p ∣ gcd(q,r). У нашій ситуації отримуємо: d ∣ gcd(b,a mod b)d\\ |\\ {\\rm gcd}(b, a\\ {\\rm mod}\\ b)d ∣ gcd(b,a mod b) Або, підставляючи замість ddd його визначення як gcd(a,b){\\rm gcd}(a,b)gcd(a,b), отримуємо: gcd(a,b) ∣ gcd(b,a mod b){\\rm gcd}(a,b)\\ |\\ {\\rm gcd}(b, a\\ {\\rm mod}\\ b)gcd(a,b) ∣ gcd(b,a mod b) Отже, ми здійснили половину доведення: показали, що ліва частина ділить праву. Друга половина доведення аналогічна. "},{"title":"Час роботи​","type":1,"pageTitle":"Алгоритм Евкліда знаходження НСД","url":"/algorithms/algebra/euclid_algorithm#час-роботи","content":"Час роботи алгоритму оцінюється теоремою Ламе, яка встановлює дивовижний зв'язок алгоритму Евкліда і послідовності Фібоначчі: Якщо a&gt;b≥1a &gt; b \\ge 1a&gt;b≥1 і b&lt;Fnb &lt; F_nb&lt;Fn​ для деякого nnn, то алгоритм Евкліда виконає не більше n−2n-2n−2 рекурсивних викликів. Більше того, можна показати, що верхня межа цієї теореми - оптимальна. При a=Fn,b=Fn−1a = F_n, b = F_{n-1}a=Fn​,b=Fn−1​ буде виконано саме n−2n-2n−2 рекурсивних викликів. Іншими словами, послідовні числа Фібоначчі - найгірші вхідні дані для алгоритму Евкліда. Враховуючи, що числа Фібоначчі ростуть експоненціально (як константа в степені nnn), отримуємо, що алгоритм Евкліда виконується за O(log⁡min⁡(a,b))O(\\log \\min(a,b))O(logmin(a,b)) операцій множення. "},{"title":"Застосування​","type":1,"pageTitle":"Алгоритм Евкліда знаходження НСД","url":"/algorithms/algebra/euclid_algorithm#застосування","content":""},{"title":"НСК​","type":1,"pageTitle":"Алгоритм Евкліда знаходження НСД","url":"/algorithms/algebra/euclid_algorithm#нск","content":"Обчислення найменшого спільного кратного (least common multiplier, lcm) зводиться до обчислення gcd\\rm gcdgcd наступним простим твердженням: lcm(a,b)=a⋅bgcd(a,b){\\rm lcm}(a,b) = \\frac{ a \\cdot b }{ {\\rm gcd}(a,b) }lcm(a,b)=gcd(a,b)a⋅b​ Таким чином, обчислення НСК також можна здійснити за допомогою алгоритму Евкліда, з тією ж асимптотикою: int lcm(int a, int b) { return a / gcd(a, b) * b; }  Зауваження Варто спочатку поділити на gcd\\rm gcdgcd, а тільки потім помножити на bbb, оскільки це допоможе уникнути переповнення типу у деяких випадках. "},{"title":"Задачі​","type":1,"pageTitle":"Алгоритм Евкліда знаходження НСД","url":"/algorithms/algebra/euclid_algorithm#задачі","content":"CodeChef - FLOW016 - GCD and LCM "},{"title":"Функція Ейлера","type":0,"sectionRef":"#","url":"/algorithms/algebra/euler_function","content":"","keywords":"Алгоритм Ейлер Функція"},{"title":"Визначення​","type":1,"pageTitle":"Функція Ейлера","url":"/algorithms/algebra/euler_function#визначення","content":"Функція Ейлера ϕ(n)\\phi (n)ϕ(n) (інколи позначається як φ(n)\\varphi(n)φ(n) або phi(n){\\it phi}(n)phi(n)) - це кількість чисел від 111 до nnn, взаємно простих з nnn. Іншими словами, це кількість таких чисел у відрізку [1;n][1; n][1;n], для яких найбільший спільний дільник з nnn рівний одиниці. Декілька перших значення цієї функції (A000010 в енциклопедії OEIS): n123456789101112131415ϕ(n)11224264641041268\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|} \\hline n &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 &amp; 9 &amp; 10 &amp; 11 &amp; 12 &amp; 13 &amp; 14 &amp; 15 \\\\ \\hline \\phi(n) &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 4 &amp; 2 &amp; 6 &amp; 4 &amp; 6 &amp; 4 &amp; 10 &amp; 4 &amp; 12 &amp; 6 &amp; 8 \\\\ \\hline \\end{array}nϕ(n)​11​21​32​42​54​62​76​84​96​104​1110​124​1312​146​158​​ "},{"title":"Властивості​","type":1,"pageTitle":"Функція Ейлера","url":"/algorithms/algebra/euler_function#властивості","content":"Трьох наступних властивостей функції Ейлера достатньо, щоб навчитися обчислювати її для будь-яких чисел: Якщо ppp - просте число, то ϕ(p)=p−1\\phi (p)=p-1ϕ(p)=p−1. Оскільки будь-яке число, крім самого ppp, взаємно просте з ним. Якщо ppp - просте, aaa - натуральне число, то ϕ(pa)=pa−pa−1\\phi (p^a)=p^a-p^{a-1}ϕ(pa)=pa−pa−1. Оскільки з числом pap^apa не взаємно прості тільки числа виду pkpkpk (k∈N)(k \\in \\mathcal{N})(k∈N), яких pa/p=pa−1p^a / p = p^{a-1}pa/p=pa−1 штук. Якщо aaa і bbb взаємно прості, то ϕ(ab)=ϕ(a)ϕ(b)\\phi(ab) = \\phi(a) \\phi(b)ϕ(ab)=ϕ(a)ϕ(b) (&quot;мультиплікативність&quot; функції Ейлера). Цей факт слідує з китайської теореми про остачі. Розглянемо довільне число z≤abz \\le abz≤ab. Позначимо через xxx і yyy залишки від ділення zzz на aaa і bbb відповідно. Тоді zzz взаємно просте з ababab тоді і тільки тоді, коли zzz взаємно просте з aaa і з bbb окремо, або, що означає xxx взаємно просте з aaa, та yyy взаємно просте з bbb. Застосовуючи китайську теорему про остачі, отримаємо, що будь-якій парі чисел xxx і yyy (x≤a, y≤b)(x \\le a, ~ y \\le b)(x≤a, y≤b) взаємно однозначно відповідає число zzz (z≤ab)(z \\le ab)(z≤ab), що і завершує доведення. Звідси можна отримати функцію Ейлера для будь-якого n\\it nn через його факторизацію (розкладання nnn на прості множники): якщо n=p1a1⋅p2a2⋅…⋅pkakn = p_1^{a_1} \\cdot p_2^{a_2} \\cdot \\ldots \\cdot p_k^{a_k}n=p1a1​​⋅p2a2​​⋅…⋅pkak​​ (де всі pip_ipi​ - прості), то ϕ(n)=ϕ(p1a1)⋅ϕ(p2a2)⋅…⋅ϕ(pkak)=\\phi(n) = \\phi(p_1^{a_1}) \\cdot \\phi(p_2^{a_2}) \\cdot \\ldots \\cdot \\phi(p_k^{a_k}) =ϕ(n)=ϕ(p1a1​​)⋅ϕ(p2a2​​)⋅…⋅ϕ(pkak​​)= =(p1a1−p1a1−1)⋅(p2a2−p2a2−1)⋅…⋅(pkak−pkak−1)== (p_1^{a_1} - p_1^{a_1-1}) \\cdot (p_2^{a_2} - p_2^{a_2-1}) \\cdot \\ldots \\cdot (p_k^{a_k} - p_k^{a_k-1}) ==(p1a1​​−p1a1​−1​)⋅(p2a2​​−p2a2​−1​)⋅…⋅(pkak​​−pkak​−1​)= =n⋅(1−1p1)⋅(1−1p2)⋅…⋅(1−1pk).= n \\cdot \\left( 1-{1\\over p_1} \\right) \\cdot \\left( 1-{1\\over p_2} \\right) \\cdot \\ldots \\cdot \\left( 1-{1\\over p_k} \\right).=n⋅(1−p1​1​)⋅(1−p2​1​)⋅…⋅(1−pk​1​). "},{"title":"Реалізація​","type":1,"pageTitle":"Функція Ейлера","url":"/algorithms/algebra/euler_function#реалізація","content":"Код, що обчислює функцію Ейлера, факторизуючи число за O(n)O(\\sqrt n)O(n​): int phi(int n) { int res = n; for (int i = 2; i*i &lt;= n; i++) { if (n % i == 0) { while (n % i == 0) { n /= i; } res -= res / i; } } if (n &gt; 1) { res -= res / n; } return res; }  Ключовим моментом при обчисленні функції Ейлера є знаходження факторизації числа nnn. Її можна знайти за час, значно менший O(n)O(\\sqrt{n})O(n​): див. Ефективні алгоритми факторизації. "},{"title":"Застосування​","type":1,"pageTitle":"Функція Ейлера","url":"/algorithms/algebra/euler_function#застосування","content":"Найважливіша і найвідоміша властивість функції Ейлера виражається у теоремі Ейлера: aϕ(m)≡1(modm),a^{\\phi(m)} \\equiv 1 \\pmod m,aϕ(m)≡1(modm), де a\\it aa і m\\it mm взаємно прості. Зокрема, коли m\\it mm просте, теорема Ейлера перетворюється у так звану малу теорему Ферма: am−1≡1(modm)a^{m-1} \\equiv 1 \\pmod mam−1≡1(modm) Теорема Ейлера достатньо часто зустрічається на практиці, наприклад, див. Обернений елемент в кільці за модулем. "},{"title":"Задачі​","type":1,"pageTitle":"Функція Ейлера","url":"/algorithms/algebra/euler_function#задачі","content":"Online Judge - 10179 - Irreducible Basic Fractions Online Judge - 11327 - Enumerating Rational Numbers Timus - 1673 - Admission to Exam "},{"title":"Біноміальні коефіцієнти","type":0,"sectionRef":"#","url":"/algorithms/algebra/binomial_coefficients","content":"","keywords":"Алгоритм Комбінаторика"},{"title":"Визначення​","type":1,"pageTitle":"Біноміальні коефіцієнти","url":"/algorithms/algebra/binomial_coefficients#визначення","content":"Біномиальним коефіцієнтом CnkC_n^kCnk​ називається кількість способів вибрати набір kkk елементів з nnn різних елементів без врахування порядку розташування цих елементів (тобто кількість невпрорядкованих наборів). Також біноміальні коефіцієнти - це кофіцієнти в розкладі (a+b)n(a+b)^n(a+b)n (біном Ньютона): (a+b)n=Cn0an+Cn1an−1b+Cn2an−2b2+…+Cnkan−kbk+…+Cnnbn(a+b)^n = C_n^0 a^n + C_n^1 a^{n-1} b + C_n^2 a^{n-2} b^2 + \\ldots + C_n^k a^{n-k} b^k + \\ldots + C_n^n b^n(a+b)n=Cn0​an+Cn1​an−1b+Cn2​an−2b2+…+Cnk​an−kbk+…+Cnn​bn Вважається, що цю формулу, як і трикутник, що дозволяє ефективно знаходити ці коефіцієнти, відкрив Блез Паскаль (Blaise Pascal), що жив у 17 ст. Тим не менш, вона була відома ще китайскому математику Яну Хуею (Yang Hui), що жив у 13 ст. Можливо, її відкрив перський вчений Омар Хаям (Omar Khayyam). Більше того, індійський математик Пінгала (Pingala), що жив ще у 3 ст. до н.е., отримав близькі результати. Заслуга ж Ньютона полягає в тому, що він узагальнив цю формулу для степенів, що не є натуральними. "},{"title":"Обчислення​","type":1,"pageTitle":"Біноміальні коефіцієнти","url":"/algorithms/algebra/binomial_coefficients#обчислення","content":"Аналітична формула для обчислення: Cnk=n!k!(n−k)!C_n^k = \\frac{n!}{k! (n-k)!}Cnk​=k!(n−k)!n!​ Цю формулу легко вивести із задачі про невпорядковану вибірку (кількість способів невпрорядковано вибрати kkk елементів з nnn елементів). Спочатку порахуємо кількість впрорядкованих вибірок. Вибрати перший елемент є nnn способів, другий - n−1n-1n−1, третій - n−2n-2n−2, і так далі. В результаті для кількості впорядкованих вибірок отримуємо формулу: n(n−1)(n−2)…(n−k+1)=n!(n−k)!n(n-1)(n-2) \\ldots (n-k+1) = \\frac{n!}{(n-k)!}n(n−1)(n−2)…(n−k+1)=(n−k)!n!​. До невпрорядкованих вибірок легко перейти, якщо замітити, що кожній невпорядкованій вибірці відповідає рівно k!k!k! впорядкованих (тобто це кількість різних перестановок kkk елементів). В результаті, при діленні n!(n−k)!\\frac{n!}{(n-k)!}(n−k)!n!​ на k!k!k!, ми і отримуємо шукану формулу. Рекурсивна формула (з якою вз'язаний славнозвісний &quot;трикутник Паскаля&quot;): Cnk=Cn−1k−1+Cn−1kC_n^k = C_{n-1}^{k-1} + C_{n-1}^kCnk​=Cn−1k−1​+Cn−1k​ Її легко вивести через попередню формулу. Варто замітити, що при n&lt;kn&lt;kn&lt;k значення CnkC_n^kCnk​ завжди рівне нулю. "},{"title":"Властивості​","type":1,"pageTitle":"Біноміальні коефіцієнти","url":"/algorithms/algebra/binomial_coefficients#властивості","content":"Біноміальні коефіцієнти мають безліч різних властивостей, наведемо найбільш прості з них: Правило симетрії: Cnk=Cnn−kC_n^k = C_n^{n-k}Cnk​=Cnn−k​ Вніс-виніс: Cnk=nkCn−1k−1C_n^k = \\frac{n}{k} C_{n-1}^{k-1}Cnk​=kn​Cn−1k−1​ Сума по kkk: ∑k=0nCnk=2n\\sum_{k=0}^n C_n^k = 2^nk=0∑n​Cnk​=2n Сума по nnn: ∑m=0nCmk=Cn+1k+1\\sum_{m=0}^n C_m^k = C_{n+1}^{k+1}m=0∑n​Cmk​=Cn+1k+1​ Сума по nnn і kkk: ∑k=0mCn+kk=Cn+m+1m\\sum_{k=0}^{m} C_{n+k}^k = C_{n+m+1}^mk=0∑m​Cn+kk​=Cn+m+1m​ Сума квадратів: (Cn0)2+(Cn1)2+…+(Cnn)2=C2nn(C_n^0)^2 + (C_n^1)^2 + \\ldots + (C_n^n)^2 = C_{2n}^n(Cn0​)2+(Cn1​)2+…+(Cnn​)2=C2nn​ Зважена сума: 1Cn1+2Cn2+…+nCnn=n2n−11 C_n^1 + 2 C_n^2 + \\ldots + n C_n^n = n 2^{n-1}1Cn1​+2Cn2​+…+nCnn​=n2n−1 Зв'язок з числами Фібоначчі: Cn0+Cn−11+…+Cn−kk+…+C0n=Fn+1C_n^0 + C_{n-1}^1 + \\ldots + C_{n-k}^k + \\ldots + C_0^n = F_{n+1}Cn0​+Cn−11​+…+Cn−kk​+…+C0n​=Fn+1​ "},{"title":"Реалізація​","type":1,"pageTitle":"Біноміальні коефіцієнти","url":"/algorithms/algebra/binomial_coefficients#реалізація","content":""},{"title":"Обчислення за допомогою аналітичної формули​","type":1,"pageTitle":"Біноміальні коефіцієнти","url":"/algorithms/algebra/binomial_coefficients#обчислення-за-допомогою-аналітичної-формули","content":"Обчислення за допомогою аналітичної формули легко програмується, однак цей спосіб схильний до переповнення навіть при відносно невеликих значениях nnn та kkk (навіть якщо відповідь цілком поміщається в деякий тип даних, обчислення проміжних факторіалів може привести до переповненню). Тому дуже часто цей спосіб можна застосовувати тільки разом з довгою арифметикою: int binomial_coefficient(int n, int k) { int res = 1; for (int i = n-k+1; i &lt;= n; i++) { res *= i; } for (int i = 2; i &lt;= k; i++) { res /= i; } }  "},{"title":"Покращена реалізація​","type":1,"pageTitle":"Біноміальні коефіцієнти","url":"/algorithms/algebra/binomial_coefficients#покращена-реалізація","content":"Можна помітити, що в наведеній вище реалізації у чисельнику і знаменнику однакова кількість множників (kkk), кожний з яких не менший одиниці. Тому можна замінити наш дріб на добуток kkk дробів. Однак, можна замітити, що після домножения поточної відповіді на кожен наступний дріб все рівно отримуватимемо ціле число (випливає з властивості &quot;вніс-виніс&quot;). Тому отримуємо таку реалізацію: int binomial_coefficient(int n, int k) { double res = 1; for (int i = 1; i &lt;= k; i++) { res = res * (n-k+i) / i; } return (int) (res + 0.01); }  TODO: rewrite without double? Вкінці перетворюємо дробове число до цілого, враховуючи, що через накопичення похибок воно може виявитися трохи меншим шуканого значення (наприклад, 2.999992.999992.99999 замість 333). "},{"title":"Трикутник Паскаля​","type":1,"pageTitle":"Біноміальні коефіцієнти","url":"/algorithms/algebra/binomial_coefficients#трикутник-паскаля","content":"Використавши рекуррентне співвідношення можна побудувати таблицю біноміальних коефіцієнтів (фактично, трикутник Паскаля), і з неї брати результат. Перевага цього методу в тому, що проміжні результати ніколи не є більшими за шукане значення, і для обчислення кожного нового елементу таблиці треба всього лише одне додавання. Недоліком є повільна робота при великих nnn та kkk, коли насправді таблица не потрібна, а потрібне лише одне шукане значення (тому що для обчислення CnkC_n^kCnk​ знадобиться побудувати таблицю для всіх Cij, 1≤i≤n, 1≤j≤nC_i^j,\\ \\ 1 \\le i \\le n,\\ \\ 1 \\le j \\le nCij​, 1≤i≤n, 1≤j≤n, або хоча б до 1≤j≤min⁡(i,2k)1 \\le j \\le \\min(i,2k)1≤j≤min(i,2k)). const int maxn = ...; int C[maxn+1][maxn+1]; for (int n = 0; n &lt;= maxn; n++) { C[n][0] = C[n][n] = 1; for (int k = 1; k &lt; n; k++) { C[n][k] = C[n-1][k-1] + C[n-1][k]; } }  Якщо вся таблица значень не потрібна, то достатньо зберігати від неї тільки два рядки (поточний - nnn-ий і попередній - n−1n-1n−1-ий). "},{"title":"Обчислення за O(1)O(1)O(1)​","type":1,"pageTitle":"Біноміальні коефіцієнти","url":"/algorithms/algebra/binomial_coefficients#обчислення-за-o1","content":"У деяких ситуациях виявляється вигідно заздалегідь обрахувати значення всіх факторіалів для того, щоб будь-який необхідний біноміальний коефіцієнт можна було обрахувати за допомогою лише двох ділень. Такий підхід може бути корисним при використанні довгої арифметики, коли пам'ять не дозваляє обрахувати зазделегідь весь трикутник Паскаля, або ж коли потрібно проводити розрахунки за деяким простим модулем (якщо модуль не простий, то виникають труднощі при діленні чисельника на знаменник; їх можна побороти, якщо факторизувати модуль і зберігати всі числа у вигляді векторів із степенями цих простих; див. розділ про довгу арифметику у факторизованому вигляді. "},{"title":"Застосування​","type":1,"pageTitle":"Біноміальні коефіцієнти","url":"/algorithms/algebra/binomial_coefficients#застосування","content":"TODO: add applications "},{"title":"Задачі​","type":1,"pageTitle":"Біноміальні коефіцієнти","url":"/algorithms/algebra/binomial_coefficients#задачі","content":"TODO: add problems "},{"title":"Розширений алгоритм Евкліда","type":0,"sectionRef":"#","url":"/algorithms/algebra/extended_euclid_algorithm","content":"","keywords":"Алгоритм Евклід Коефіцієнти НСД GCD"},{"title":"Алгоритм​","type":1,"pageTitle":"Розширений алгоритм Евкліда","url":"/algorithms/algebra/extended_euclid_algorithm#алгоритм","content":"Введемо обчислення цих коефіцієнтів в алгоритм Евкліда. Для цього достатньо вивести формули, по яким вони змінюються при переході від пари (a,b)(a,b)(a,b) до пари (b mod a,a)(b\\ {\\rm mod}\\ a, a)(b mod a,a). Отже, нехай ми знайшли розв'язок (x1,y1)(x_1,y_1)(x1​,y1​) для задачі з новою парою (b mod a,a)(b\\ {\\rm mod}\\ a,a)(b mod a,a): (b mod a)⋅x1+a⋅y1=g,(b\\ {\\rm mod}\\ a) \\cdot x_1 + a \\cdot y_1 = g,(b mod a)⋅x1​+a⋅y1​=g, і хочемо отримати розв'язок (x,y)(x,y)(x,y) для задачі з парою (a,b)(a,b)(a,b): a⋅x+b⋅y=g.a \\cdot x + b \\cdot y = g.a⋅x+b⋅y=g. Для цього перетворимо величину b mod ab\\ {\\rm mod}\\ ab mod a наступним чином: b mod a=b−⌊ba⌋⋅a.b\\ {\\rm mod}\\ a = b - \\left\\lfloor \\frac{b}{a} \\right\\rfloor \\cdot a.b mod a=b−⌊ab​⌋⋅a. Підставимо у вираз з x1x_1x1​ та y1y_1y1​ і отримаємо: g=(b mod a)⋅x1+a⋅y1=(b−⌊ba⌋⋅a)⋅x1+a⋅y1,g = (b\\ {\\rm mod}\\ a) \\cdot x_1 + a \\cdot y_1 = \\left( b - \\left\\lfloor \\frac{b}{a} \\right\\rfloor \\cdot a \\right) \\cdot x_1 + a \\cdot y_1,g=(b mod a)⋅x1​+a⋅y1​=(b−⌊ab​⌋⋅a)⋅x1​+a⋅y1​, і, виконавши перегрупування доданків, отримуємо: g=b⋅x1+a⋅(y1−⌊ba⌋⋅x1).g = b \\cdot x_1 + a \\cdot \\left( y_1 - \\left\\lfloor \\frac{b}{a} \\right\\rfloor \\cdot x_1 \\right).g=b⋅x1​+a⋅(y1​−⌊ab​⌋⋅x1​). Порівнявши результат з початковим виразом з невідомими xxx та yyy, отримуємо необхідні рівності: {x=y1−⌊ba⌋⋅x1,y=x1.\\begin{cases} x = y_1 - \\left\\lfloor \\frac{b}{a} \\right\\rfloor \\cdot x_1, \\cr y = x_1. \\end{cases}{x=y1​−⌊ab​⌋⋅x1​,y=x1​.​ "},{"title":"Реалізація​","type":1,"pageTitle":"Розширений алгоритм Евкліда","url":"/algorithms/algebra/extended_euclid_algorithm#реалізація","content":"int gcd(int a, int b, int&amp; x, int&amp; y) { if (a == 0) { x = 0; y = 1; return b; } int x1, y1; int d = gcd(b % a, a, x1, y1); x = y1 - (b / a) * x1; y = x1; return d; }  Це рекурсивна функція як і раніше повертає значення НСД від чисел aaa та bbb, але крім цього також шукані коефіцієнти xxx та yyy у вигляді параметрів функції, що передаються у вигляді посилань. База рекурсії a=0a = 0a=0. Значить НСД рівний bbb, і, очевидно, необхідні коефіцієнти xxx та yyy рівні 000 та 111 відповідно. В інших випадках коефіцієнти перераховуються по вищеописаним формулами. Розширений алгоритм Евкліда у такій реалізації працює правильно навіть для від'ємних чисел. "},{"title":"Застосування​","type":1,"pageTitle":"Розширений алгоритм Евкліда","url":"/algorithms/algebra/extended_euclid_algorithm#застосування","content":"TODO: add applications "},{"title":"Задачі​","type":1,"pageTitle":"Розширений алгоритм Евкліда","url":"/algorithms/algebra/extended_euclid_algorithm#задачі","content":"Online Judge - 10104 - Euclid Problem Online Judge - 12775 - Gift Dilemma "},{"title":"Бінарне піднесення у степінь","type":0,"sectionRef":"#","url":"/algorithms/algebra/binary_pow","content":"","keywords":"Алгоритм Бінарний Степінь"},{"title":"Алгоритм​","type":1,"pageTitle":"Бінарне піднесення у степінь","url":"/algorithms/algebra/binary_pow#алгоритм","content":"Зауважимо, що для будь-якого числа aaa і парного числа nnn виконується тотожність (випливає з асоціативності операції множення): an=(an/2)2=an/2⋅an/2a^n = (a^{n/2})^2 = a^{n/2} \\cdot a^{n/2}an=(an/2)2=an/2⋅an/2 Вона і є основною в методі бінарного піднесення у степінь. Дійсно, для парного nnn ми показали, як, витративши всього лиш одну операцію множення, можна звести до задачі з вдвічі меншим степенем. Залишилося зрозуміти, що робити, якщо степінь nnn непарна. Тут все дуже просто: перейдемо до степені n−1n-1n−1, яка вже буде парною: an=an−1⋅aa^n = a^{n-1} \\cdot aan=an−1⋅a Отже, ми фактично знайшли рекурентну формулу: від степені nnn ми переходимо, якщо вона парна, до n/2n/2n/2, а інакше - до n−1n-1n−1. Зрозуміло, що всього буде не більше 2⋅log⁡n2 \\cdot \\log n2⋅logn переходів, перш ніж ми прийдемо до n=0n = 0n=0 (до бази рекурентної формули). Таким чином, ми отримали алгоритм, що працює за O(log⁡n)O(\\log n)O(logn) множень. "},{"title":"Реалізація​","type":1,"pageTitle":"Бінарне піднесення у степінь","url":"/algorithms/algebra/binary_pow#реалізація","content":"Рекурсивна реалізація: int binpow(int a, int n) { if (n == 0) { return 1; } else if (n % 2 == 1) { return binpow(a, n-1) * a; } else { int b = binpow(a, n/2); return b * b; } }  Нерекурсивна реалізація із оптимізованими діленнями на 2, які замінені бітовими операціями: int binpow(int a, int n) { int res = 1; while (n) { if (n &amp; 1) { res *= a; --n; } else { a *= a; n &gt;&gt;= 1; } } return res; }  Цю реалізацію можна ще трішки оптимізувати, помітивши, що піднесення aaa в квадрат здійснюється завжди, незалежно від того, спрацювала умова непарності nnn чи ні: int binpow(int a, int n) { int res = 1; while (n) { if (n &amp; 1) { res *= a; } a *= a; n &gt;&gt;= 1; } return res; }  Також, варто підмітити, що бінарне піднесення у степінь вже реалізовано у мові Java, але тільки для класу з довгою арифметикою BigInteger (функція pow цього класу працює використовуючи описаний алгоритм). "},{"title":"Застосування​","type":1,"pageTitle":"Бінарне піднесення у степінь","url":"/algorithms/algebra/binary_pow#застосування","content":""},{"title":"Ефективне обчислення чисел Фібоначчі​","type":1,"pageTitle":"Бінарне піднесення у степінь","url":"/algorithms/algebra/binary_pow#ефективне-обчислення-чисел-фібоначчі","content":"Умова. Дано число nnn. Потрібно обчислити FnF_nFn​, де FiF_iFi​ - послідовність чисел Фібоначчі. Розв'язок. Більш детально цей розв'язок описано у статті про послідовності Фібоначчі. Тут ми лише коротко наведемо його суть. Основна ідея наступна. Обчислення чергового числа Фібоначчі базується на знанні двох попередніх чисел Фібоначчі: а саме, кожне наступне число Фібоначчі обчислюється як сума двох попередніх. Це означає, що ми можемо побудувати матрицю 2×22 \\times 22×2, яка буде відповідати наступному перетворенню: як маючи два числа Фібоначчі FiF_iFi​ та Fi+1F_{i+1}Fi+1​ обчислити наступне число, тобто перейти до пари Fi+1F_{i+1}Fi+1​, Fi+2F_{i+2}Fi+2​. Застосовуючи це перетворення nnn раз до пари F0F_0F0​ та F1F_1F1​, ми отримаємо пару FnF_nFn​ і Fn+1F_{n+1}Fn+1​. Таким чином, підносячи матрицю цього перетворення в nnn-у степінь, ми знайдемо шукане FnF_nFn​ за час O(log⁡n)O(\\log n)O(logn), що нам і було потрібно. "},{"title":"Піднесення перестановки в kkk-у степінь​","type":1,"pageTitle":"Бінарне піднесення у степінь","url":"/algorithms/algebra/binary_pow#піднесення-перестановки-в-k-у-степінь","content":"Умова. Дано перестановку ppp довжини nnn. Потрібно піднести її в kkk-у степінь, тобто знайти, що вийде, якщо до тотожної перестановки kkk раз застосувати перестановку ppp. Розв'язок. Застосуємо до перестановки ppp описаний вище алгоритм бінарного піднесення у степінь. Жодних відмінностей із піднесенням чисел у степінь немає. Одержуємо розв'язок з асимптотикою O(n⋅log⁡k)O(n \\cdot \\log k)O(n⋅logk). Зауваження Дану задачу можна розв'язати ефективніше - за лінійний час. Для цього достатньо виділити у перестановці всі цикли, після чого розглянути окремо кожний цикл і, взявши kkk за модулем довжини поточного циклу, знайти відповідь для цього циклу. "},{"title":"Швидке застосування набору геометричних операцій до точок​","type":1,"pageTitle":"Бінарне піднесення у степінь","url":"/algorithms/algebra/binary_pow#швидке-застосування-набору-геометричних-операцій-до-точок","content":"Умова. Дано nnn точок pip_ipi​ та mmm перетворень, які треба застосувати до кожної з цих точок. Кожне перетворення - це або переміщення на заданий вектор, або масштабування (множення координат на задані коефіцієнти), або обертання навколо заданої осі на заданий кут. Крім того, є складена операція циклічного повторення, яка має вигляд - &quot;повторити задане число раз заданий список перетворень&quot; (операції циклічного повторення можуть вкладатися один в одного). Потрібно обчислити результат застосування заданих операцій до всіх точок за час, менший ніж O(n⋅length)O(n \\cdot length)O(n⋅length), де lengthlengthlength - загальна кількість операцій, які необхідно зробити. Розв'язок. Розглянемо різні види перетворень з точки зору того, як вони змінюють координати: Операція переміщення - додає до всіх координат одиницю, помножену на деякі константи.Операція масштабування - множить кожну координату на деяку константу.Операція обертання навколо осі - нові координати можна записати у вигляді лінійної комбінації старих. Наприклад, у вигляді комбінації п'яти двовимірних поворотів: спочатку в площинах OXYOXYOXY і OXZOXZOXZ так, аби вісь обертання співпала з додатнім напрямом осі OXOXOX, потім необхідний поворот навколо осі в площині YZYZYZ, потім зворотні повороти в площинах OXZOXZOXZ і OXYOXYOXY так, аби вісь обертання повернулась у своє вихідне положення. Кожне з цих перетворень - це переобчислення координат за лінійними формулами. Таким чином, будь-яке таке перетворення можна записати у вигляді матриці 4×44 \\times 44×4: (a11a12a13a14a21a22a23a24a31a32a33a34a41a42a43a44),\\begin{pmatrix} a_{11} &amp; a_{12} &amp; a_{13} &amp; a_{14} \\\\ a_{21} &amp; a_{22} &amp; a_{23} &amp; a_{24} \\\\ a_{31} &amp; a_{32} &amp; a_{33} &amp; a_{34} \\\\ a_{41} &amp; a_{42} &amp; a_{43} &amp; a_{44} \\\\ \\end{pmatrix},⎝⎛​a11​a21​a31​a41​​a12​a22​a32​a42​​a13​a23​a33​a43​​a14​a24​a34​a44​​⎠⎞​, яке при множенні (ліворуч) на рядок з старими координатами і константою-одиницею дає рядок з новими координатами і теж константою-одиницею: (xyz1)⋅(a11a12a13a14a21a22a23a24a31a32a33a34a41a42a43a44)=\\begin{pmatrix} x &amp; y &amp; z &amp; 1 \\end{pmatrix} \\cdot \\begin{pmatrix} a_{11} &amp; a_{12} &amp; a_{13} &amp; a_{14} \\\\ a_{21} &amp; a_{22} &amp; a_{23} &amp; a_{24} \\\\ a_{31} &amp; a_{32} &amp; a_{33} &amp; a_{34} \\\\ a_{41} &amp; a_{42} &amp; a_{43} &amp; a_{44} \\\\ \\end{pmatrix} =(x​y​z​1​)⋅⎝⎛​a11​a21​a31​a41​​a12​a22​a32​a42​​a13​a23​a33​a43​​a14​a24​a34​a44​​⎠⎞​= (x′y′z′1).\\begin{pmatrix} x' &amp; y' &amp; z' &amp; 1 \\end{pmatrix}.(x′​y′​z′​1​). Зауваження Для чого введено фіктивну четверту координату, що завжди рівна одиниці? Без цього не вийшло б реалізувати операцію переміщення, адже переміщення - це як раз доданок до координат одиниці, що помножена на деякі коефіцієнти. Без фіктивної одиниці ми б змогли тільки реалізовувати лінійні комбінації самих координат, а додавати до них задані константи - не змогли б. Тепер розв'язок задачі стає простим. Оскільки кожна елементарна операція описується матрицею, то послідовність операцій описується добутком цих матриць, а операція циклічного повторення - піднесення цієї матриці у степінь. Таким чином, ми за час O(m⋅log⁡repetition)O(m \\cdot \\log repetition)O(m⋅logrepetition) можемо заздалегідь обчислити матрицю 4×44 \\times 44×4, що описує всі перетворення, і потім просто помножити кожну точку pip_ipi​ на цю матрицю - тим самим, ми дамо відповідь на всі запити за час O(n)O(n)O(n). "},{"title":"Кількість шляхів фіксованої довжини у графі​","type":1,"pageTitle":"Бінарне піднесення у степінь","url":"/algorithms/algebra/binary_pow#кількість-шляхів-фіксованої-довжини-у-графі","content":"Умова. Дано неорієнтований граф GGG з nnn вершинами, і дано число kkk. Потрібно для кожної пари вершин iii і jjj знайти кількість шляхів між ними, що містять рівно kkk ребер. Розв'язок. Більш детально цю задачу розглянуто у окремій статті. Тут лише описано суть цього розв'язку: ми підносимо в kkk-у степінь матрицю суміжності цього графа, і елементи цієї матриці будуть мати шукані значення. Асимптотика - O(n3⋅log⁡k)O(n^3 \\cdot \\log k)O(n3⋅logk). Зауваження У згаданій статті розглядається також й інший варіант цієї задачі: коли граф зважений, і потрібно знайти шлях мінімальної ваги, що містить рівно kkk ребер. Дана задача також вирішується за допомогою бінарного піднесення у степінь матриці суміжності графа, однак замість звичайної операції перемноження двох матриць використовують модифіковану: замість множень береться сума, а замість підсумовування - взяття мінімуму. "},{"title":"Добуток двох чисел за модулем​","type":1,"pageTitle":"Бінарне піднесення у степінь","url":"/algorithms/algebra/binary_pow#добуток-двох-чисел-за-модулем","content":"Умова. Дано два додатних цілих числа aaa і bbb. Потрібно знайти значення їх добутку за модулем mmm: a⋅b(modm)a \\cdot b \\pmod ma⋅b(modm) Припустимо, що числа можуть бути достатньо великі: настільки, що самі числа поміщаються у базові типи даних, а ось їх добуток a⋅ba \\cdot ba⋅b - вже ні (відзначимо, що нам також буде потрібно, аби сума чисел поміщалась у базові типи даних). Відповідно, задача в тому, щоб порахувати шукану величину (a⋅b)(modm)(a \\cdot b) \\pmod m(a⋅b)(modm), не застосовуючи довгу арифметику. Розв'язок. Застосуємо алгоритм бінарного піднесення, описаний вище, тільки замість операції множення ми будемо використовувати додавання. Іншими словами, перемноження двох чисел ми звели до O(log⁡m)O(\\log m)O(logm) операцій додавання і множення на два (що теж, по суті, є додавання). f(a,b)={0якщо a=0f(a2,2b)якщо a&gt;0 і a парнеf(a−12,2b)+bякщо a&gt;0 і a непарнеf(a, b) = \\begin{cases} 0 &amp;\\text{якщо }a = 0 \\\\\\\\ f(\\frac{a}{2}, 2 b) &amp;\\text{якщо }a &gt; 0 \\text{ і }a \\text{ парне} \\\\\\\\ f(\\frac{a-1}{2}, 2 b) + b &amp;\\text{якщо }a &gt; 0 \\text{ і }a \\text{ непарне} \\end{cases}f(a,b)=⎩⎨⎧​0f(2a​,2b)f(2a−1​,2b)+b​якщо a=0якщо a&gt;0 і a парнеякщо a&gt;0 і a непарне​ Реалізація: int binprod_mod(int a, int b, int m) { int res = 0; a %= m; b %= m; while (a) { if (a &amp; 1) { res = (res + b) % m; } b = (2 * b) % m; a &gt;&gt;= 1; } return res; }  Зауваження Дану задачу можна розв'язати і по-іншому, використавши операції над числами з рухомою точкою. А саме, порахуємо в числах з рухомою точкою вираз a⋅b/ma \\cdot b / ma⋅b/m, і заокруглимо його до найближчого цілого числа. Так ми знайдемо приблизну частку. Віднявши її від добутку a⋅ba \\cdot ba⋅b (проігнорувавши переповнення), ми, швидше всього, отримаємо деяке невелике число, яке можна взяти за модулем mmm і повернути результат в якості відповіді. Цей розв'язок виглядає досить надійним та швидким і він дуже коротко реалізується. "},{"title":"Задачі​","type":1,"pageTitle":"Бінарне піднесення у степінь","url":"/algorithms/algebra/binary_pow#задачі","content":"Codeforces - 630 - Parking Lot Online Judge - 374 - Big Mod Spoj - LASTDIG - The last digit | Розв'язки: C++, Python "},{"title":"Довжина об'єднання відрізків на прямій","type":0,"sectionRef":"#","url":"/algorithms/geometry/length_of_segments_union","content":"","keywords":"Алгоритм Геометрія Довжина о'бєднання відрізків Пряма"},{"title":"Алгоритм​","type":1,"pageTitle":"Довжина об'єднання відрізків на прямій","url":"/algorithms/geometry/length_of_segments_union#алгоритм","content":"Алгоритм був запропонований Клі (Klee) в 1977 році. Алгоритм працює за O(n⋅log⁡n)O(n \\cdot \\log n)O(n⋅logn). Було доведено, що цей алгоритм є найшвидший (асимптотично). Покладемо всі координати кінців відрізків в масив x[]x[]x[] і відсортуємо його по значенням координати. Додаткова умова при сортування - при рівності координат першими повинні йти ліві кінці. Крім того, для кожного елементу масиву будемо зберігати, чи відноситься він до лівого, чи до правому кінця відрузку. Тепер пройдемося по всьому масиву, маючи лічильник ccc відрізків, що перетинаються. Якщо ccc не рівний нулю, то до результату додаємо різницю xi−xi−1x_i - x_{i-1}xi​−xi−1​. Якщо поточний елемент відноситься до лівого кінця, то збільшуємо лічильник ccc, інакше зменшуємо його. "},{"title":"Реалізація​","type":1,"pageTitle":"Довжина об'єднання відрізків на прямій","url":"/algorithms/geometry/length_of_segments_union#реалізація","content":"int segments_union_length(const vector&lt;pair&lt;int, int&gt;&gt;&amp; a) { int n = a.size(); vector&lt;pair&lt;int, bool&gt;&gt; x(n*2); for (int i = 0; i &lt; n; i++) { x[i*2] = make_pair(a[i].first, false); x[i*2+1] = make_pair(a[i].second, true); } sort(x.begin(), x.end()); int result = 0; int c = 0; for (int i = 0; i &lt; n*2; i++) { if (c &amp;&amp; i) { result += x[i].first - x[i-1].first; } if (x[i].second) { ++c; } else { --c; } } return result; }  "},{"title":"Застосування​","type":1,"pageTitle":"Довжина об'єднання відрізків на прямій","url":"/algorithms/geometry/length_of_segments_union#застосування","content":"TODO: add applications "},{"title":"Задачі​","type":1,"pageTitle":"Довжина об'єднання відрізків на прямій","url":"/algorithms/geometry/length_of_segments_union#задачі","content":"TODO: add problems "},{"title":"Пошук компонент зв'язності у графі","type":0,"sectionRef":"#","url":"/algorithms/graphs/connected_components","content":"","keywords":"Алгоритм Пошук Графи Зв'язність Компоненти зв'язності"},{"title":"Алгоритм​","type":1,"pageTitle":"Пошук компонент зв'язності у графі","url":"/algorithms/graphs/connected_components#алгоритм","content":"Для розв'язку можна скористатися як пошуком в глибину, так і пошуком в ширину. Фактично, ми будемо проводити серію обходів: спочатку запустимо обхід з першої вершини, і всі вершини, які він при цьому обійшов - утворюють першу компоненту зв'язності. Потім найдемо першу вершину з тих, які ще не були відвідані, і запустимо обхід з неї, знайшовши тим самим одному компоненту зв'язності. І так далі, поки всі вершини не стануть відвіданими. Підсумкова асимптотика складе O(n+m)O(n + m)O(n+m): насправді, такий алгоритм не буде запускаться від однієї і тією ж вершини двічі, а, значить, кожне ребро буде переглянуто рівне два рази (з одного кінця і з іншого кінця). "},{"title":"Реалізація​","type":1,"pageTitle":"Пошук компонент зв'язності у графі","url":"/algorithms/graphs/connected_components#реалізація","content":"Для реалізації трішки більш зручним є обхід в глибину: void find_connected_components_dfs(int v, const vector&lt;vector&lt;int&gt;&gt;&amp; g, vector&lt;bool&gt;&amp; visited, vector&lt;int&gt;&amp; component) { visited[v] = true; component.push_back(v); for (int i = 0; i &lt; g[v].size(); i++) { int to = g[v][i]; if (!visited[to]) { find_connected_components_dfs(to, g, visited, component); } } } vector&lt;vector&lt;int&gt;&gt; find_connected_components(const vector&lt;vector&lt;int&gt;&gt;&amp; g) { int n = g.size(); // кількість вершин vector&lt;bool&gt; visited(n); // відвідані вершини vector&lt;vector&lt;int&gt;&gt; components; // знайдені компоненти зв'язності for (int i = 0; i &lt; n; i++) { if (!visited[i]) { components.emplace_back(); // додаємо нову пусту компоненту в кінець масиву find_connected_components_dfs(i, g, visited, components.back()); } } return components; }  "},{"title":"Застосування​","type":1,"pageTitle":"Пошук компонент зв'язності у графі","url":"/algorithms/graphs/connected_components#застосування","content":"TODO: add applications "},{"title":"Задачі​","type":1,"pageTitle":"Пошук компонент зв'язності у графі","url":"/algorithms/graphs/connected_components#задачі","content":"TODO: add problems "},{"title":"Алгоритм Крускала","type":0,"sectionRef":"#","url":"/algorithms/graphs/mst_kruskal","content":"","keywords":"Алгоритм Графи Каркасне дерево MST DSU"},{"title":"Властивості мінімального каркасу​","type":1,"pageTitle":"Алгоритм Крускала","url":"/algorithms/graphs/mst_kruskal#властивості-мінімального-каркасу","content":"Мінімальний каркас унікальний, якщо ваги всіх ребер різні. В іншому випадку, можле існувати декілька мінімальних каркасів (алгоритми зазвичай отримують один з можливих каркасів).Мінімальний каркас є також і каркасом з мінімальним добутком ваг ребер. (доводиться заміною ваг всіх ребер на їх логарифми)Мінімальний каркас є також і каркасом з мінімальною вагою найважчого ребра.Каркас максимальної ваги шукається аналогічно каркасу мінімального ваги, достатньо поміняти знаки всіх ребер на протилежні і виконати будь-який з алгоритмів пошуку мінімального каркасу. "},{"title":"Алгоритм​","type":1,"pageTitle":"Алгоритм Крускала","url":"/algorithms/graphs/mst_kruskal#алгоритм","content":"Даний алгоритм був описаний Крускалом (Kruskal) в 1956 р. Алгоритм Крускала спершу розташовує кожну вершину в своє незалежне дерево (розміром в одну вершину), а потім поступово об'єднує ці дерева, об'єднуючи на кожній ітерації два деяких дерева деяким ребром. Перед початком виконання алгоритму, всі ребра впорядковано по зростанню ваги. Потім починається процес з'єднання: перебираются всі ребра від першого до останнього (в порядку сортування), і якщо у поточного ребра його кінці належать різним деревам, то ці дерева об'єднуються, а ребро додається до відповіді. При закінченні перебору всіх ребер всі вершини опиняться в одному дереві, яке і є шуваним. "},{"title":"Реалізація​","type":1,"pageTitle":"Алгоритм Крускала","url":"/algorithms/graphs/mst_kruskal#реалізація","content":""},{"title":"Найпростіша за O(m⋅log⁡n+n2)O(m \\cdot \\log n + n^2)O(m⋅logn+n2)​","type":1,"pageTitle":"Алгоритм Крускала","url":"/algorithms/graphs/mst_kruskal#найпростіша-за-om-cdot-log-n--n2","content":"Дана реалізація є найпростішою і виконується за O(m⋅log⁡n+n2)O(m \\cdot \\log n + n^2)O(m⋅logn+n2). Сортування ребер займає O(m⋅log⁡n)O(m \\cdot \\log n)O(m⋅logn) операцій. Належність вершини тому чи іншому дереву зберігається за допомогою масиву tree_id - в ньому для кожної вершини зберігається номер дерева, якому вона належить. Для кожного ребра ми за O(1)O(1)O(1) визначаємо чи належать його кінці різним деревам. Нарешті, об'єднання двох дерев здійснюється за O(n)O(n)O(n) простим проходом по масиву tree_id. Враховуючи, що всього операцій з'єднання буде n−1n-1n−1, ми і отримуємо асимптотику O(m⋅log⁡n+n2)O(m \\cdot \\log n + n^2)O(m⋅logn+n2). int m; vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; g(m); // список ребер у форматі - {вага, {вершина 1, вершина 2}} int cost = 0; vector&lt;pair&lt;int, int&gt;&gt; res; sort(g.begin(), g.end()); vector&lt;int&gt; tree_id(n); for (int i = 0; i &lt; n; i++) { tree_id[i] = i; } for (int i = 0; i &lt; m; i++) { int a = g[i].second.first, b = g[i].second.second, l = g[i].first; if (tree_id[a] != tree_id[b]) { cost += l; res.push_back(make_pair(a, b)); int old_id = tree_id[b], new_id = tree_id[a]; for (int j = 0; j &lt; n; j++) { if (tree_id[j] == old_id) { tree_id[j] = new_id; } } } }  "},{"title":"Із системою множин, що не перетинаються за O(m⋅log⁡n)O(m \\cdot \\log n)O(m⋅logn)​","type":1,"pageTitle":"Алгоритм Крускала","url":"/algorithms/graphs/mst_kruskal#із-системою-множин-що-не-перетинаються-за-om-cdot-log-n","content":"Розглянемо реалізацію з використанням структури данних &quot;система множин, що не перетинаються&quot; (DSU), яка дозволить досягти асимптотики O(m⋅log⁡n)O(m \\cdot \\log n)O(m⋅logn). Так само, як і в простий версії алгоритму Крускала, відсортуємо всі ребра по зростанню ваги. Потім розташуємо кожну вершину в своє дерево (тобто у свою множину) - на це піде в сумі O(n)O(n)O(n). Перебираємо всі ребра (в порядку сортування) і для кожного ребра за O(1)O(1)O(1) визначаємо, чи належать його кінці різним деревам за допомогою двох викликів dsu_get за O(1)O(1)O(1). Об'єднання двох дерев буде звійснюватись викликом dsu_unite - також за O(1)O(1)O(1). Разом ми отримуємо асимптотику O(m⋅log⁡n+n+m)=O(m⋅log⁡n)O(m \\cdot \\log n + n + m) = O(m \\cdot \\log n)O(m⋅logn+n+m)=O(m⋅logn). Тут представленій реалізації використовуватися рандомізована версія DSU. vector&lt;int&gt; p(n); int dsu_get(int v) { return (v == p[v]) ? v : (p[v] = dsu_get(p[v])); } void dsu_unite(int a, int b) { a = dsu_get(a); b = dsu_get(b); if (rand() &amp; 1) { swap(a, b); } if (a != b) { p[a] = b; } } ... у функції main(): ... int m; vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; g; // список ребер у форматі - {вага, {вершина 1, вершина 2}} ... читання графа ... int cost = 0; vector&lt;pair&lt;int, int&gt;&gt; res; sort(g.begin(), g.end()); p.resize(n); for (int i = 0; i &lt; n; i++) { p[i] = i; } for (int i = 0; i &lt; m; i++) { int a = g[i].second.first, b = g[i].second.second, l = g[i].first; if (dsu_get(a) != dsu_get(b)) { cost += l; res.push_back(g[i].second); dsu_unite(a, b); } }  "},{"title":"Застосування​","type":1,"pageTitle":"Алгоритм Крускала","url":"/algorithms/graphs/mst_kruskal#застосування","content":"TODO: add applications "},{"title":"Задачі​","type":1,"pageTitle":"Алгоритм Крускала","url":"/algorithms/graphs/mst_kruskal#задачі","content":"TODO: add problems "},{"title":"Пошук в глибину","type":0,"sectionRef":"#","url":"/algorithms/graphs/dfs","content":"","keywords":"Алгоритм Пошук Графи DFS"},{"title":"Алгоритм​","type":1,"pageTitle":"Пошук в глибину","url":"/algorithms/graphs/dfs#алгоритм","content":"TODO: add detailed description for DFS. "},{"title":"Реалізація​","type":1,"pageTitle":"Пошук в глибину","url":"/algorithms/graphs/dfs#реалізація","content":"Найпростіша реалізація: vector&lt;vector&lt;int&gt;&gt; g; // граф, список суміжності int n; // кількість вершин vector&lt;bool&gt; visited(n); // відвідані вершини void dfs(int v) { visited[v] = true; for (int i = 0; i &lt; g[v].size(); i++) { int to = g[v][i]; if (!visited[to]) { dfs(to); } } }  Інколи необхідно знати кольори вершин (0 - не відвідана вершина; 1 - відвідана вершина, але досі у стеці; 2 - відвідана і більше немає у стеці) та &quot;час&quot; заходу та виходу з вершин. Ці допоміжні величини використовуються у декількох наведених прикладах застосування алгоритму. vector&lt;vector&lt;int&gt;&gt; g; // граф, список суміжності int n; // кількість вершин vector&lt;int&gt; color; // кольори вершин (0, 1, або 2) vector&lt;int&gt; time_in, time_out; // &quot;часи&quot; заходу та виходу з вершин int dfs_timer = 0; // &quot;таймер&quot; для визначення &quot;часів&quot; void dfs(int v) { time_in[v] = dfs_timer++; color[v] = 1; for (int i = 0; i &lt; g[v].size(); i++) { int to = g[v][i]; if (color[to] == 0) { dfs(to); } } color[v] = 2; time_out[v] = dfs_timer++; }  "},{"title":"Застосування​","type":1,"pageTitle":"Пошук в глибину","url":"/algorithms/graphs/dfs#застосування","content":"Пошук будь-якого шляху у графі. Пошук лексикографічно першого шляху в графі. Перевірка чи одна вершина дерева є предком іншої. На початку і у кінці ітерації пошуку в глибину будемо запам'ятовувати &quot;час&quot; заходу і виходу з кожної вершині. Тепер за O(1)O(1)O(1) можна знайти відповідь: вершина aaa є предком вершини bbb тоді і тільки тоді, коли time_in[a]&lt;time_in[b]\\rm time\\_in[a] &lt; time\\_in[b]time_in[a]&lt;time_in[b] та time_out[a]&gt;time_out[b]\\rm time\\_out[a] &gt; time\\_out[b]time_out[a]&gt;time_out[b]. Найменший спільний предок. Топологічне сортування. Запускаємо серію пошуків в глибину, щоб обійти всі вершини графа. Відсортуємо вершини по спаданню часу виходу - це і буде відповіддю. Перевірка графа на ациклічність і знаходження циклу. Пошук компонент сильної зв'язності. Спочатку проводимо топологічне сортування, а потім транспонуємо граф. Після того знову проводимо серію пошуків у глибину, але в порядку вершин, який було отримано топологічним сортуванням. Кожне дерево пошуку - сильнозв'язана компонента. Пошук мостів. Спочатку перетворюємо граф в орієнтований, роблячи серію пошуків в глибину, і орієнтуючи кожне ребро так, як ми намагалися по ньому пройти. Потім знаходимо сильнозв'язані компоненти. Мостами є ті ребра, кінці яких належать різним сильнозв'язаним компонентам. "},{"title":"Задачі​","type":1,"pageTitle":"Пошук в глибину","url":"/algorithms/graphs/dfs#задачі","content":"e-olymp - 122 - Маршрути в горах | Розв'язки: C++ e-olymp - 977 - Дерево? | Розв'язки: C++ e-olymp - 978 - Отримай дерево | Розв'язки: C# e-olymp - 1941 - Предок | Розв'язки: C++ e-olymp - 2270 - Пошук циклу | Розв'язки: C++ e-olymp - 2382 - Графічна маска | Розв'язки: C++ e-olymp - 2383 - Електричні провода | Розв'язки: C++ e-olymp - 3165 - Двокольоровість | Розв'язки: C++ e-olymp - 4077 - Зарплата в корпорації | Розв'язки: C++ "},{"title":"Топологічне сортування","type":0,"sectionRef":"#","url":"/algorithms/graphs/topological_sort","content":"","keywords":"Алгоритм Сортування Топологічний порядок Графи"},{"title":"Алгоритм​","type":1,"pageTitle":"Топологічне сортування","url":"/algorithms/graphs/topological_sort#алгоритм","content":"Для розв'язку скористаємось пошуком в глибину. Припустимо, що граф ациклічний, тобто розв'язок існує. Що робить пошук в глибину? При запуску з якоїсь вершини vvv він намагається запуститися уздовж всіх ребер, вихідних з vvv. Уздовж тих ребер, кінці яких вже були відвідані раніше, він не проходить, а уздовж всіх інших - проходить і викликає себе від їх кінців. Таким чином, на момент виходу з виклику dfs(v){\\rm dfs}(v)dfs(v) всі вершини, досяжні з vvv як безпосередньо (по ребру), так і дотично (по деякому шляху), вже відвідані пошуком в глибину. Отже, якщо ми будемо в момент виходу з dfs(v){\\rm dfs}(v)dfs(v) додавати нашу вершину в початок деякого списку, то у кінці алгоритму в цьому списку отримаємо топологічне сортування. Пояснити можна також за допомогою поняття &quot;часу виходу&quot; пошуку в глибину. Час виходу для кожної вершини vvv - це момент часу, в який закінчив працювати виклик dfs(v){\\rm dfs}(v)dfs(v) пошуку в глибину. Часи виходу можна пронумерувати від 111 до nnn. Легко зрозуміти, що при пошуці в глибину час виходу з будь-якої вершини vvv завжди більший, ніж час виходу з усіх вершин, досяжних з неї (тобто вони були відвідані або до виклику dfs(v){\\rm dfs}(v)dfs(v), або під час нього). Таким чином, шукане топологічне сортування - це сортування у порядку зменшення часів виходу. Складність алгоритму така ж як і у пошуку в глибину - O(n+m)O(n+m)O(n+m), де nnn - кількість вершин, mmm - кількість ребер. "},{"title":"Реалізація​","type":1,"pageTitle":"Топологічне сортування","url":"/algorithms/graphs/topological_sort#реалізація","content":"Наведемо реалізацію, що припускає, що граф ациклічний, тобто шукане топологічне сортування існує. При необхідності перевірку графа на ациклічність можна здійснити додатковим пошуком в глибину, як описано у статті про пошук циклу. int n; // кількість вершин vector&lt;int&gt; g[MAXN]; // граф, список суміжності bool visited[MAXN]; vector&lt;int&gt; ans; void dfs(int v) { visited[v] = true; for (int i = 0; i &lt; g[v].size(); i++) { int to = g[v][i]; if (!visited[to]) { dfs(to); } } ans.push_back(v); } void topological_sort() { for (int i = 0; i &lt; n; i++) { visited[i] = false; } ans.clear(); for (int i = 0; i &lt; n; i++) { if (!visited[i]) { dfs(i); } } reverse(ans.begin(), ans.end()); }  Тут константа MAXN задає максимально можливу кількість вершин у графі. Основна функція розв'язку - це topological_sort. Вона ініціалізує допоміжний масив visited пошуку в глибину, запускає його, і у кінці масив ans містить шукане топологічне сортування. "},{"title":"Застосування​","type":1,"pageTitle":"Топологічне сортування","url":"/algorithms/graphs/topological_sort#застосування","content":"Є nnn змінних, значення яких нам невідомі. Відомо лише про деякі пари змінних, у яких одна змінна менша іншої. Потрібно перевірити чи не суперечливі ці нерівності, і якщо ні, видати змінні у порядку їх зростання (якщо розв'язків декілька - видати будь-який). Потрібно створити граф з nnn вершинами, де ребра ведуть з меншої змінної у більшу. Провести перевірку на ациклічність. Якщо граф містить цикл, то нерівності суперечливі, а якщо не містить циклу, то вершини у топологічному порядку відповідатимуть змінним у порядку їх зростання. "},{"title":"Задачі​","type":1,"pageTitle":"Топологічне сортування","url":"/algorithms/graphs/topological_sort#задачі","content":"e-olymp - 1948 - Топологічне сортування | Розв'язки: C++ Spoj - TOPOSORT - Topological Sorting | Розв'язки: C++ Spoj - RPLA - Answer the boss! | Розв'язки: C++ Online Judge - 124 - Following Orders Online Judge - 200 - Rare Order Online Judge - 10305 - Ordering Tasks "},{"title":"Пошук в ширину","type":0,"sectionRef":"#","url":"/algorithms/graphs/bfs","content":"","keywords":"Алгоритм Пошук Графи BFS"},{"title":"Алгоритм​","type":1,"pageTitle":"Пошук в ширину","url":"/algorithms/graphs/bfs#алгоритм","content":"На вхід алгоритму подається незважений граф і номер стартової вершини sss. Граф може бути як орієнтованим, так і неорієнтованим, для алгоритму це не важливо. Сам алгоритм можна сприймати як процес &quot;підпалювання&quot; графа: на нульовому кроці підпалюємо тільки вершину sss. На кожному наступному кроці вогонь з кожної вершини, що вже горить, поширюється на всіх її сусідів; тобто за одну ітерацію алгоритму відбувається розширення &quot;кільця вогню&quot; в ширину на одиницю (звідси і назва алгоритму). Формальний опис алгоритму. Створимо чергу qqq, в яку будуть додаватися вершини, що горять, а також заведемо булевий масив visited[]\\rm visited[]visited[], в якому для кожної вершини будемо відзначати, горить вона вже чи ні (або іншими словами, чи була вона переглянутою). Спершу в чергу додається тільки вершина sss, і visited[s]=true\\rm visited[s] = truevisited[s]=true, а для всіх інших вершин visited[]=false\\rm visited[] = falsevisited[]=false. Потім алгоритм представляє собою цикл: поки черга не порожня, дістати з її голови одну вершину, переглянути всі ребра, що виходять з цієї вершини, і якщо якісь з переглянутих вершин (на протилежних кінцях ребер) ще не горять, то підпалити їх і додати в кінець черги. В результаті, коли черга стане пустою, обхід в ширину обійде всі досяжні з sss вершини, причому до кожної дійде найкоротшим шляхом. Також можна порахувати довжини найкоротших шляхів (для чого треба завести масив довжин шляхів d[]\\rm d[]d[]), і компактно зберегти інформацію, якої достатню для відновлення всіх цих найкоротших шляхів (для цього треба завести масив &quot;предків&quot; p[]\\rm p[]p[], в якому для кожної вершини зберігати номер вершини, з якої ми потрапили в цю вершину). "},{"title":"Реалізація​","type":1,"pageTitle":"Пошук в ширину","url":"/algorithms/graphs/bfs#реалізація","content":"Реалізуємо вищеописаний алгоритм на мові C++. Вхідні дані: vector&lt;vector&lt;int&gt;&gt; g; // граф, список суміжності int n; // кількість вершин int s; // стартова вершина (вершини нумеруються з нуля) // читання графа ...  Сам обхід: queue&lt;int&gt; q; vector&lt;bool&gt; visited(n); vector&lt;int&gt; d(n), p(n); q.push(s); visited[s] = true; p[s] = -1; while (!q.empty()) { int v = q.front(); q.pop(); for (int i = 0; i &lt; g[v].size(); i++) { int to = g[v][i]; if (!visited[to]) { visited[to] = true; q.push(to); d[to] = d[v] + 1; p[to] = v; } } }  Якщо потрібно відновити і вивести найкоротший шлях до якоїсь вершини to\\rm toto, то це можна зробити наступним чином: if (!visited[to]) { cout &lt;&lt; &quot;No path!&quot;; } else { vector&lt;int&gt; path; for (int v = to; v != -1; v = p[v]) { path.push_back(v); } reverse(path.begin(), path.end()); cout &lt;&lt; &quot;Path: &quot;; for (int i = 0; i &lt; path.size(); i++) { cout &lt;&lt; path[i] + 1 &lt;&lt; &quot; &quot;; } }  "},{"title":"Застосування​","type":1,"pageTitle":"Пошук в ширину","url":"/algorithms/graphs/bfs#застосування","content":"Пошук найкоротшого шляху у незваженому графі. Описано у цій статті. Пошук компонент зв'язності у графі за O(n+m)O(n+m)O(n+m). Для цього запускаємо обхід в ширину від кожної вершини, за винятком вершин, що залишилися відвіданими (visited=true\\rm visited=truevisited=true) після попередніх запусків. Таким чином, ми виконуємо звичайний запуск в ширину від кожної вершини, але не зануляємо кожний раз масив visited[]\\rm visited[]visited[], за рахунок чого ми кожний раз будемо обходити нову компоненту зв'язності, а сумарний час роботи алгоритму буде як і раніше O(n+m)O(n+m)O(n+m) (такі декілька запусків обходу на графі без занулення масиву visited\\rm visitedvisited називається серією обходів в ширину). Знаходження розв'язку будь-якої задачі з найменшим числом ходів, якщо кожний стан системи можна уявити вершиною графа, а переходи з одного стану в інші - ребрами графа. Класичний приклад - гра, де робот рухається по полю, при цьому він може переміщати ящики, що знаходяться на цьому ж полі, і потрібно за найменше число ходів пересунути ящики в необхідні позиції. Розв'язується обходом в ширину по графу, де станом (вершиною) є набір координат: координати робота, і координати всіх коробок. Знаходження найкоротшого шляху в 0-1-графі (зважений граф, але з вагами рівними тільки 0 або 1). Достатньо трохи модифікувати пошук в ширину: якщо поточне ребро нульової ваги, і відбувається покращення відстані до якоїсь вершини, то цю вершину додаємо не в кінець, а в початок черги. Знаходження найкоротшого циклу в орієнтованому незваженому графі. Для цього запускаємо пошук в ширину з кожної вершини. Як тільки в процесі обходу ми намагаємося піти з поточної вершини по якомусь ребру до вже відвіданої вершини, то це означає, що ми знайшли найкоротший цикл, і зупиняємо обхід в ширину. Серед всіх таких знайдених циклів (по одному від кожного запуску обходу) вибираємо найкоротший. Знайти всі ребра, що лежать на будь-якому найкоротшому шляху між заданою парою вершин (a,b)(a,b)(a,b). Для цього треба запустити 2 пошуки в ширину: з aaa, і з bbb. Позначимо через da[]d_a[]da​[] масив найкоротших відстаней, отриманий в результаті першого обходу, а через db[]d_b[]db​[] - в результаті другого обходу. Тепер для будь-якого ребра (u,v)(u,v)(u,v) легко перевірити чи лежить він на будь-якому найкоротшому шляху: критерієм буде умова da[u]+1+db[v]=da[b]d_a[u] + 1 + d_b[v] = d_a[b]da​[u]+1+db​[v]=da​[b]. Знайти всі вершини, що лежать на будь-якому найкоротшому шляху між заданою парою вершин (a,b)(a,b)(a,b). Для цього треба запустити 2 пошуки в ширину: з aaa, і з bbb. Позначимо через da[]d_a[]da​[] масив найкоротших відстаней, отриманий в результаті першого обходу, а через db[]d_b[]db​[] - в результаті другого обходу. Тепер для будь-якої вершини vvv легко перевірити чи лежить вона на будь-якому найкоротшому шляху: критерієм буде умова da[v]+db[v]=da[b]d_a[v] + d_b[v] = d_a[b]da​[v]+db​[v]=da​[b]. Знайти найкоротший парний шлях в графі (тобто шлях парної довжини). Для цього треба побудувати допоміжний граф, вершинами якого будуть стани (v,c)(v,c)(v,c), де vvv - номер поточної вершини, c=0…1c = 0 \\ldots 1c=0…1 - поточна парність. Будь-яке ребро (a,b)(a,b)(a,b) вихідного графа в новому графі перетвориться в два ребра ((u,0),(v,1))((u,0),(v,1))((u,0),(v,1)) та ((u,1),(v,0))((u,1),(v,0))((u,1),(v,0)). Після цього на цьому графі треба обходом в ширину знайти найкоротший шлях з стартової вершини в кінцеву, з парністю, рівною 0. "},{"title":"Задачі​","type":1,"pageTitle":"Пошук в ширину","url":"/algorithms/graphs/bfs#задачі","content":"e-olymp - 292 - Ведмідь Міша | Розв'язки: C++ e-olymp - 1064 - Шлях коня e-olymp - 2384 - Сортуюча гра | Розв'язки: C++ e-olymp - 2621 - Шлях короля | Розв'язки: C++ "},{"title":"Література","type":0,"sectionRef":"#","url":"/books","content":"Література Thomas H. Cormen - Introduction to Algorithms","keywords":"Алгоритми Література Книги"},{"title":"Алгоритм Кнута-Морріса-Пратта","type":0,"sectionRef":"#","url":"/algorithms/strings/kmp","content":"","keywords":"Алгоритм Рядки Кнут-Морріс-Пратт Підрядок Пошук підрядка"},{"title":"Алгоритм​","type":1,"pageTitle":"Алгоритм Кнута-Морріса-Пратта","url":"/algorithms/strings/kmp#алгоритм","content":"Позначимо для зручності через nnn довжину рядка sss, а через mmm — довжину тексту ttt. Утворимо рядок s+#+ts + \\# + ts+#+t, де символ #\\## — це роздільник, який не повинен зустрічатися ніде більше. Обчислимо для цього рядка префікс-функцію. Тепер розглянемо її значення, окрім перших n+1n+1n+1 (які, як видно, належать до рядка sss і роздільника). За визначенням, значення π[i]\\pi[i]π[i] показує найдовшу довжину підрядка, що закінчується в позиції iii і збігається з префіксом. Але у нашому випадку це π[i]\\pi[i]π[i] — фактично довжина найбільшого блоку збігу з рядком sss, що закінчується в позиції iii. Більшою за nnn ця довжина бути не може — завдяки роздільнику. А от рівність π[i]=n\\pi[i] = nπ[i]=n (там, де вона досягається), означає, що в позиції iii закінчується шукане входження рядка sss (тільки не треба забувати, що всі позиції відлічуються у склеєному рядку s+#+ts+\\#+ts+#+t). Таким чином, якщо в деякій позиції iii виявилося π[i]=n\\pi[i] = nπ[i]=n, то в позиції i−2ni - 2ni−2n рядка ttt починається наступне входження рядка sss у рядок ttt. Як уже згадувалося при описі алгоритму обчислення префікс-функції, якщо відомо, що значення префікс-функції не перевищуватимуть деякої величини, то достатньо зберігати не весь рядок і префікс-функцію, а лише її початок. У нашому випадку це означає, що потрібно зберігати в пам'яті лише рядок s+#s + \\#s+# та значення префікс-функції на ньому, а потім уже зчитувати по одному символу рядок ttt і перераховувати поточне значення префікс-функції. Отже, алгоритм Кнута-Морріса-Пратта вирішує це завдання за O(n+m)O(n+m)O(n+m) часу та O(n)O(n)O(n) пам'яті. "},{"title":"Реалізація​","type":1,"pageTitle":"Алгоритм Кнута-Морріса-Пратта","url":"/algorithms/strings/kmp#реалізація","content":"TODO: add implementation. "},{"title":"Застосування​","type":1,"pageTitle":"Алгоритм Кнута-Морріса-Пратта","url":"/algorithms/strings/kmp#застосування","content":"TODO: add applications. "},{"title":"Задачі​","type":1,"pageTitle":"Алгоритм Кнута-Морріса-Пратта","url":"/algorithms/strings/kmp#задачі","content":"TODO: add problems. "},{"title":"Префікс-функція","type":0,"sectionRef":"#","url":"/algorithms/strings/prefix_function","content":"","keywords":"Алгоритм Рядки Функція Префікс"},{"title":"Визначення​","type":1,"pageTitle":"Префікс-функція","url":"/algorithms/strings/prefix_function#визначення","content":"Дано рядок s[0…n−1]s[0 \\ldots n-1]s[0…n−1], де nnn - довжина рядка. Потрібно обчислити префікс-функцію для нього, тобто масив чисел π[0…n−1]\\pi[0 \\ldots n-1]π[0…n−1], де π[i]\\pi[i]π[i] визначається наступним чином: це довжина найбільшого власного суфікса підрядка s[0…i]s[0 \\ldots i]s[0…i], який збігається з її префіксом. Власний суфікс — це такий, який не збігається з усім рядком. Зокрема, значення π[0]\\pi[0]π[0] дорівнює нулю. Визначення префікс-функції можна записати наступним чином: π[i]=max⁡(0,max⁡k=1…i { k : s[0…k−1]=s[i−k+1…i] }).\\pi[i] = \\max(0, \\max_{k=1 \\ldots i} ~ \\{ ~ k ~ : ~ s[0 \\ldots k-1] = s[i-k+1 \\ldots i] ~ \\}).π[i]=max(0,k=1…imax​ { k : s[0…k−1]=s[i−k+1…i] }). Наприклад, для рядка &quot;abcabcd&quot; префікс-функція дорівнює: [0,0,0,1,2,3,0][0, 0, 0, 1, 2, 3, 0][0,0,0,1,2,3,0], що означає: У рядку &quot;a&quot; немає префікса, який збігається з власним суфіксом.У рядку &quot;ab&quot; немає префікса, який збігається з власним суфіксом.У рядку &quot;abc&quot; немає префікса, який збігається з власним суфіксом.У рядку &quot;abca&quot; префікс довжини 111 збігається з власним суфіксом.У рядку &quot;abcab&quot; префікс довжини 222 збігається з власним суфіксом.У рядку &quot;abcabc&quot; префікс довжини 333 збігається з власним суфіксом.У рядку &quot;abcabcd&quot; немає префікса, який збігається з власним суфіксом. Наприклад, для рядка &quot;aabaaab&quot; префікс-функція дорівнює: [0,1,0,1,2,2,3][0, 1, 0, 1, 2, 2, 3][0,1,0,1,2,2,3]. "},{"title":"Алгоритм​","type":1,"pageTitle":"Префікс-функція","url":"/algorithms/strings/prefix_function#алгоритм","content":"Безпосередньо дотримуючись визначення, можна написати алгоритм обчислення префікс-функції за допомогою трьох циклів за O(n3)O(n^3)O(n3), але це є дуже повільно. Ефективний алгоритм був розроблений Кнутом (Knuth) та Праттом (Pratt), а також незалежно від них Моррісом (Morris) у 1977 році як основна частина алгоритму пошуку підрядка в рядку. "},{"title":"Перша оптимізація​","type":1,"pageTitle":"Префікс-функція","url":"/algorithms/strings/prefix_function#перша-оптимізація","content":"Перше важливе зауваження - значення π[i+1]\\pi[i+1]π[i+1] не перевищує значення π[i]\\pi[i]π[i] більше ніж на одиницю для будь-якого iii. Доведення. В іншому випадку, якщо π[i+1]&gt;π[i]+1\\pi[i+1] &gt; \\pi[i] + 1π[i+1]&gt;π[i]+1, то розглянемо суфікс, який закінчується в позиції i+1i+1i+1 і має довжину π[i+1]\\pi[i+1]π[i+1]. Видаливши з нього останній символ, ми отримаємо суфікс, який закінчується в позиції iii і має довжину π[i+1]−1\\pi[i+1]-1π[i+1]−1. Це краще, ніж π[i]\\pi[i]π[i], тому ми дійшли до протиріччя. Ілюстрація цього протиріччя (у цьому прикладі π[i−1]\\pi[i-1]π[i−1] має бути рівне 3): s0 s1⏞π[i−1]=2 s2 s3⏟π[i]=4 … si−3 si−2 si−1⏞π[i−1]=2 si⏟π[i]=4\\underbrace{ \\overbrace{s_0 \\ s_1}^{\\pi[i-1]=2} \\ s_2 \\ s_3}_{\\pi[i]=4} \\ \\ldots\\ \\underbrace{ s_{i-3}\\ \\overbrace{s_{i-2}\\ s_{i-1}}^{\\pi[i-1]=2} \\ s_i}_{\\pi[i]=4}π[i]=4s0​ s1​​π[i−1]=2​ s2​ s3​​​ … π[i]=4si−3​ si−2​ si−1​​π[i−1]=2​ si​​​ На цій схемі верхні фігурні дужки позначають два однакові підрядки довжиною 2, а нижні фігурні дужки - два однакові підрядки довжиною 4. Таким чином, при переході до наступної позиції наступний елемент префікс-функції міг або збільшитися на одиницю, або не змінитися, або зменшитися на якусь величину. Вже цей факт дозволяє нам знизити асимптотику до O(n)O(n)O(n) - оскільки за один крок значення могло зрости максимум на одиницю, то сумарно для всього рядка могло статися максимум nnn збільшень на одиницю, і, як наслідок (значення ніколи не могло стати менше нуля), максимум nnn зменшень. В результаті вийде O(n)O(n)O(n) порівнянь рядків, тобто ми вже досягли асимптотики O(n)O(n)O(n). "},{"title":"Друга оптимізація​","type":1,"pageTitle":"Префікс-функція","url":"/algorithms/strings/prefix_function#друга-оптимізація","content":"Позбавимось від очевидних порівнянь підрядків. Для цього намагатимемося максимально використовувати інформацію, обчислену на попередніх кроках. Отже, після того, як ми вирахували значення префікс-функції π[i]\\pi[i]π[i] для деякого iii, якщо s[i+1]=s[π[i]]s[i+1] = s[\\pi[i]]s[i+1]=s[π[i]], то ми можемо з упевненістю стверджувати, що π[i+1]=π[i]+1\\pi[i+1] = \\pi[i] + 1π[i+1]=π[i]+1. Це ілюструється наступною схемою: s0 s1 s2⏞π[i] s3⏞s3=si+1⏟π[i+1]=π[i]+1 … si−2 si−1 si⏞π[i] si+1⏞s3=si+1⏟π[i+1]=π[i]+1\\underbrace{ \\overbrace{s_0 \\ s_1 \\ s_2}^{\\pi[i]} \\ \\overbrace{s_3}^{s_3=s_{i+1}}}_{\\pi[i+1]=\\pi[i]+1} \\ \\ldots\\ \\underbrace{ \\overbrace{s_{i-2}\\ s_{i-1}\\ s_i}^{\\pi[i]} \\ \\overbrace{s_{i+1}}^{s_3=s_{i+1}}}_{\\pi[i+1]=\\pi[i]+1}π[i+1]=π[i]+1s0​ s1​ s2​​π[i]​ s3​​s3​=si+1​​​​ … π[i+1]=π[i]+1si−2​ si−1​ si​​π[i]​ si+1​​s3​=si+1​​​​ На цій схемі знову однакові фігурні дужки позначають однакові підрядки. Нехай тепер, навпаки, виявилося, що s[i+1]≠s[π[i]]s[i+1] \\ne s[\\pi[i]]s[i+1]=s[π[i]]. Це означає, що нам потрібно спробувати підрядок меншої довжини. З метою оптимізації бажано одразу перейти до такої найбільшої довжини j&lt;π[i]j &lt; \\pi[i]j&lt;π[i], що, як і раніше, виконується префікс-властивість в позиції iii, тобто s[0…j−1]=s[i−j+1…i]s[0 \\ldots j-1] = s[i-j+1 \\ldots i]s[0…j−1]=s[i−j+1…i]. s0 s1⏟j s2 s3⏞π[i] … si−3 si−2si−1 si⏟j⏞π[i] si+1\\overbrace{\\underbrace{s_0 \\ s_1}_{j} \\ s_2 \\ s_3}^{\\pi[i]} \\ \\ldots\\ \\overbrace{ s_{i-3}\\ s_{i-2} \\underbrace{s_{i-1}\\ s_{i}}_{j}}^{\\pi[i]} \\ s_{i+1}js0​ s1​​​ s2​ s3​​π[i]​ … si−3​ si−2​jsi−1​ si​​​​π[i]​ si+1​ Дійсно, коли ми знайдемо таку довжину jjj, то нам знову буде достатньо порівняти символи s[i+1]s[i+1]s[i+1] і s[j]s[j]s[j] - якщо вони співпадають, то можна стверджувати, що π[i+1]=j+1\\pi[i+1] = j+1π[i+1]=j+1. Інакше нам доведеться знову знайти менше (випливає з величини) значення jjj, для якого виконується префікс-властивість, і так далі. Може статися, що такі значення jjj закінчаться - це трапляється, коли j=0j=0j=0. У цьому випадку, якщо s[i+1]=s[0]s[i+1]=s[0]s[i+1]=s[0], то π[i+1]=1\\pi[i+1]=1π[i+1]=1, інакше π[i+1]=0\\pi[i+1]=0π[i+1]=0. Отже, загальна схема алгоритму у нас вже є. Нерозв'язаним залишається лише питання про ефективне знаходження таких довжин jjj. Поставимо це питання формально: для поточної довжини jjj та позиції iii (для яких виконується префікс-властивість, тобто s[0…j−1]=s[i−j+1…i]s[0 \\ldots j-1] = s[i-j+1 \\ldots i]s[0…j−1]=s[i−j+1…i]) потрібно знайти найбільше k&lt;jk &lt; jk&lt;j, для якого, як і раніше, виконується префікс-властивість s0 s1⏟k s2 s3⏞j … si−3 si−2si−1 si⏟k⏞j si+1\\overbrace{\\underbrace{s_0 \\ s_1}_{k} \\ s_2 \\ s_3}^{j} \\ \\ldots\\ \\overbrace{ s_{i-3}\\ s_{i-2} \\underbrace{s_{i-1}\\ s_{i}}_{k}}^{j} \\ s_{i+1}ks0​ s1​​​ s2​ s3​​j​ … si−3​ si−2​ksi−1​ si​​​​j​ si+1​ Значення kkk є ніщо інше, як значення префікс-функції π[j−1]\\pi[j-1]π[j−1], яке ми вже обчислювали раніше (віднімання одиниці зумовлене 0-індексацією рядка). Таким чином, ці довжини kkk можна знайти за O(1)O(1)O(1) кожну. "},{"title":"Кінцевий алгоритм​","type":1,"pageTitle":"Префікс-функція","url":"/algorithms/strings/prefix_function#кінцевий-алгоритм","content":"Отже, ми остаточно побудували алгоритм, який не містить явних порівнянь рядків і виконує O(n)O(n)O(n) операцій. Наведемо тут схему алгоритму: Значення префікс-функції π[i]\\pi[i]π[i] будемо визначати по черзі: від i=1i=1i=1 до i=n−1i=n-1i=n−1 (значення π[0]\\pi[0]π[0] дорівнює нулю). Для підрахунку поточного значення π[i]\\pi[i]π[i] ми заводимо змінну jjj, що позначає довжину поточного розглянутого зразка. Спочатку j=π[i−1]j = \\pi[i-1]j=π[i−1]. Тестуємо зразок довжини jjj, для чого порівнюємо символи s[j]s[j]s[j] та s[i]s[i]s[i]. Якщо вони співпадають, то вважаємо π[i]=j+1\\pi[i] = j+1π[i]=j+1 і переходимо до наступного індексу i+1i+1i+1. Якщо символи відрізняються, то зменшуємо довжину jjj, прирівнюючи її до π[j−1]\\pi[j-1]π[j−1], і повторюємо цей крок алгоритму з початку. Якщо ми дійшли до довжини j=0j=0j=0 і так і не знайшли збігів, то зупиняємо процес перебору зразків, вважаємо π[i]=0\\pi[i] = 0π[i]=0 і переходимо до наступного індексу i+1i+1i+1. "},{"title":"Реалізація​","type":1,"pageTitle":"Префікс-функція","url":"/algorithms/strings/prefix_function#реалізація","content":""},{"title":"Повільне обчислення за O(n3)O(n^3)O(n3)​","type":1,"pageTitle":"Префікс-функція","url":"/algorithms/strings/prefix_function#prefix-function-slow","content":"Це дуже повільна наївна реалізація, яка використовує визначення префікс-функції без будь-яких оптимізацій: vector&lt;int&gt; prefix_function(string s) { int n = (int)s.length(); vector&lt;int&gt; pi(n, 0); for (int i = 0; i &lt; n; ++i) { for (int k = 1; k &lt;= i; ++k) { if (s.substr(0, k) == s.substr(i - k + 1, k)) { pi[i] = k; } } } return pi; }  "},{"title":"Обчислення алгоритмом Кнута-Морріса-Пратта за O(n)O(n)O(n)​","type":1,"pageTitle":"Префікс-функція","url":"/algorithms/strings/prefix_function#обчислення-алгоритмом-кнута-морріса-пратта-за-on","content":"vector&lt;int&gt; prefix_function(string s) { int n = (int)s.length(); vector&lt;int&gt; pi(n); for (int i = 1; i &lt; n; ++i) { int j = pi[i - 1]; while (j &gt; 0 &amp;&amp; s[i] != s[j]) { j = pi[j - 1]; } if (s[i] == s[j]) { ++j; } pi[i] = j; } return pi; }  Зауваження Цей алгоритм є онлайн алгоритмом, тобто він обробляє дані по ходу надходження - можна, наприклад, зчитувати рядок по одному символу і зразу обробляти цей символ, знаходячи відповідь для наступної позиції. Алгоритм потребує зберігання самого рядка і попередніх обчислених значень префікс-функції, проте, якщо максимальне значення, яке може приймати префікс-функція на всьому рядку, відоме заздалегідь, то достатньо зберігати лише на одиницю більше кількості перших символів рядка і значень префікс-функції. "},{"title":"Застосування​","type":1,"pageTitle":"Префікс-функція","url":"/algorithms/strings/prefix_function#застосування","content":""},{"title":"Пошук підрядка в рядку. Алгоритм Кнута-Морріса-Пратта​","type":1,"pageTitle":"Префікс-функція","url":"/algorithms/strings/prefix_function#пошук-підрядка-в-рядку-алгоритм-кнута-морріса-пратта","content":""},{"title":"Підрахунок кількості входжень кожного префікса​","type":1,"pageTitle":"Префікс-функція","url":"/algorithms/strings/prefix_function#підрахунок-кількості-входжень-кожного-префікса","content":"Тут ми розглянемо дві задачі. Дано рядок sss довжини nnn. У першому варіанті потрібно для кожного префікса s[0…i]s[0 \\ldots i]s[0…i] порахувати, скільки разів він зустрічається у самому рядку sss. У другому варіанті задачі дано інший рядок ttt, і потрібно для кожного префікса s[0…i]s[0 \\ldots i]s[0…i] порахувати, скільки разів він зустрічається в ttt. Вирішимо спочатку першу задачу. Розглянемо будь-яку позицію iii та значення префікс-функції в ній π[i]\\pi[i]π[i]. За визначенням, воно означає, що в позиції iii закінчується входження префікса рядка sss довжини π[i]\\pi[i]π[i], і ніякий більший префікс не може закінчуватись в позиції iii. В той же час, в позиції iii могло закінчуватись входження префіксів менших довжин (і, очевидно, не обов'язково довжини π[i]−1\\pi[i]-1π[i]−1). Однак, як легко помітити, ми приходимо до того ж питання, на яке ми вже відповіли при розгляді алгоритму обчислення префікс-функції: за заданої довжини jjj потрібно знайти найбільший власний суфікс, що збігається з її префіксом. Ми вже встановили, що відповіддю на це питання буде π[j−1]\\pi[j-1]π[j−1]. Але тоді і в цій задачі, якщо в позиції iii закінчується входження підрядка довжини π[i]\\pi[i]π[i], що збігається з префіксом, то в iii також закінчується входження підрядка довжини π[π[i]−1]\\pi[\\pi[i]-1]π[π[i]−1], що збігається з префіксом, а для неї застосовні ті ж міркування, тому в iii також закінчується входження довжини π[π[π[i]−1]−1]\\pi[\\pi[\\pi[i]-1]-1]π[π[π[i]−1]−1] і так далі (поки індекс не стане нульовим). Таким чином, для обчислення відповіді ми повинні виконати такий цикл: vector&lt;int&gt; ans(n + 1); for (int i = 0; i &lt; n; ++i) { ++ans[pi[i]]; } for (int i = n - 1; i &gt; 0; --i) { ans[pi[i - 1]] += ans[i]; }  Тут ми для кожного значення префікс-функції спочатку порахували, скільки разів він зустрічався в масиві π[]\\pi[]π[], а потім порахували таку деяку динаміку: якщо ми знаємо, що префікс довжини iii зустрічався рівно ans[i]{\\rm ans}[i]ans[i] разів, то саме таку кількість треба додати до числа входжень його найдовшого власного суфікса, що збігається з його префіксом; потім вже з цього суфікса (звісно, меншої довжини, ніж iii) виконається &quot;пробрасування&quot; цієї кількості до свого суфікса, і т.д. Тепер розглянемо одну задачу. Застосуємо стандартний прийом: додамо до рядка sss рядок ttt через роздільник, тобто отримаємо рядок s#+ts\\#+ts#+t, і порахуємо для її префікс-функції. Єдина відмінність від першої задачі буде в тому, що потрібно враховувати тільки ті значення префікс-функції, які відносяться до рядка ttt, тобто всі π[i]\\pi[i]π[i] для i≥n+1i \\ge n+1i≥n+1. "},{"title":"Кількість різних підрядків у рядку​","type":1,"pageTitle":"Префікс-функція","url":"/algorithms/strings/prefix_function#кількість-різних-підрядків-у-рядку","content":"Дано рядок sss довжини nnn. Потрібно порахувати кількість різних підрядків. Будемо розв'язувати цю задачу ітеративно. Зокрема, навчимося, знаючи поточну кількість різних підрядків, перераховувати цю кількість при додаванні в кінець одного символу. Отже, нехай kkk - поточна кількість різних підрядків рядка sss, і ми додаємо в кінець символ ccc. Очевидно, в результаті можуть з'явитися деякі нові підрядки, що закінчуються на цьому новому символі ccc. А саме, додаються як нові ті підрядки, що закінчуються на символі ccc і не зустрічалися раніше. Візьмемо рядок t=s+ct = s + ct=s+c і інвертуємо його (запишемо символи в зворотньому порядку). Наше завдання - порахувати, скільки в рядку ttt таких префіксів, які не зустрічаються в ньому далі. Але якщо ми порахуємо для рядка ttt префікс-функцію і знайдемо її максимальне значення πmax\\pi_{\\rm max}πmax​, то очевидно, що в рядку ttt зустрічається (не на початку) його префікс довжини πmax\\pi_{\\rm max}πmax​, але не більшої довжини. Зрозуміло, префікси меншої довжини точно зустрічаються в ньому. Отже, ми отримали, що кількість нових підрядків, які з'являються при додаванні символу ccc, дорівнює s.length⁡()+1−πmax⁡s.\\operatorname{length}() + 1 - \\pi_{\\max}s.length()+1−πmax​. Таким чином, для кожного додаваного символу ми за O(n)O(n)O(n) можемо перерахувати кількість різних підрядків рядка. Отже, за O(n2)O(n^2)O(n2) ми можемо знайти кількість різних підрядків для будь-якого заданого рядка. Варто зазначити, що аналогічно можна перераховувати кількість різних підрядків при додаванні символу до початку, видаленні символу з кінця або з початку. "},{"title":"Стиснення рядка​","type":1,"pageTitle":"Префікс-функція","url":"/algorithms/strings/prefix_function#стиснення-рядка","content":"Дано рядок sss довжини nnn. Потрібно знайти найкоротше її &quot;стисле&quot; представлення, тобто такий рядок ttt мінімальної довжини, що sss можна уявити як конкатенацію однієї або кількох копій ttt. Зрозуміло, що проблема полягає у знаходженні довжини шуканого рядка ttt. Знаючи довжину, відповіддю на задачу буде, наприклад, префікс рядка sss цієї довжини. Порахуймо префікс-функцію для рядка sss. Розглянемо її останнє значення, тобто π[n−1]\\pi[n-1]π[n−1], і позначимо k=n−π[n−1]k = n - \\pi[n-1]k=n−π[n−1]. Доведемо, що якщо nnn ділиться на kkk, то kkk є довжиною оптимального стиснення, інакше ефективного стиснення не існує, і відповідь дорівнює nnn. Дійсно, якщо nnn ділиться на kkk, то рядок можна уявити у вигляді декількох блоків довжини kkk. За визначенням префікс-функції, префікс довжини n−kn-kn−k буде співпадати з її суфіксом. Але тоді останній блок повинен співпадати з передостаннім, передостанній - з перед-передостаннім, і так далі. У результаті всі блоки повинні співпадати, і таке kkk дійсно підходить. Покажемо, що ця відповідь є оптимальною. Дійсно, якщо б знайшлося менше kkk, то префікс-функція на кінці була б більшою, ніж n−kn-kn−k, тобто ми потрапимо у протиріччя. Російське слово &quot;префикс-функция&quot; можна замінити на &quot;передфіксна функція&quot;. Нехай тепер nnn не ділиться на kkk. Покажемо, що звідси випливає, що довжина відповіді дорівнює nnn. Доведемо це від протилежного - припустимо, що відповідь існує і має довжину ppp (ppp є дільником nnn). Зауважимо, що префікс-функція повинна бути не менше n−pn - pn−p, тобто цей суфікс повинен частково накривати перший блок. Тепер розглянемо другий блок рядка; припустимо, що префікс збігається з суфіксом, і префікс та суфікс покривають цей блок, і їх зсув на kkk не ділить довжину блоку ppp (інакше kkk ділило б nnn), тоді всі символи блоку співпадають. Але тоді рядок складається з одного й того ж символу, звідки k=1k=1k=1, і відповідь повинна існувати, тобто ми приходимо до протиріччя. s0 s1 s2 s3⏞p s4 s5 s6 s7⏞p\\overbrace{s_0\\ s_1\\ s_2\\ s_3}^{p}\\ \\overbrace{s_4\\ s_5\\ s_6\\ s_7}^{p}s0​ s1​ s2​ s3​​p​ s4​ s5​ s6​ s7​​p​ s0 s1 s2 s3 s4 s5 s6⏞p s7⏟π[7]=5s_0\\ s_1\\ s_2\\ \\underbrace{\\overbrace{s_3\\ s_4\\ s_5\\ s_6}^{p}\\ s_7}_{\\pi[7]=5}s0​ s1​ s2​ π[7]=5s3​ s4​ s5​ s6​​p​ s7​​​ s4=s3, s5=s4, s6=s5, s7=s6 ⟹ s0=s1=s2=s3s_4=s_3,\\ \\ s_5=s_4,\\ \\ s_6=s_5,\\ \\ s_7=s_6\\ \\ \\ \\ \\Longrightarrow\\ \\ \\ \\ s_0=s_1=s_2=s_3s4​=s3​, s5​=s4​, s6​=s5​, s7​=s6​ ⟹ s0​=s1​=s2​=s3​ "},{"title":"Побудова автомата за допомогою префікс-функції​","type":1,"pageTitle":"Префікс-функція","url":"/algorithms/strings/prefix_function#побудова-автомата-за-допомогою-префікс-функції","content":"Повернемося до вже неодноразово використовуваного прийому конкатенації двох рядків через роздільник, тобто для даних рядків sss і ttt обчислення префікс-функції для рядка s+#+ts+\\#+ts+#+t. Очевидно, що якщо символ #\\## є роздільником, то значення префікс-функції ніколи не перевищить s.length()s.{\\rm length}()s.length(). Звідси випливає, що, як згадувалося при описі алгоритму обчислення префікс-функції, достатньо зберігати тільки рядок s+#s+\\#s+# і значення префікс-функції для нього, а для всіх наступних символів префікс-функцію обчислювати на льоту s0 s1 … sn−1 #⏟need to savet0 t1 … tm−1⏟need not to save\\underbrace{s_0\\ s_1\\ \\ldots\\ s_{n-1}\\ \\#}_{\\rm need\\ to\\ save} \\underbrace{t_0\\ t_1\\ \\ldots\\ t_{m-1}}_{\\rm need\\ not\\ to\\ save}need to saves0​ s1​ … sn−1​ #​​need not to savet0​ t1​ … tm−1​​​ Дійсно, у такій ситуації, знаючи черговий символ c∈tc \\in tc∈t та значення префікс-функції у попередній позиції, можна обчислити нове значення префікс-функції, не використовуючи при цьому всі попередні символи рядка ttt та їхні значення префікс-функції. Іншими словами, ми можемо побудувати автомат: станом у ньому буде поточне значення префікс-функції, переходи з одного стану в інший будуть здійснюватися за допомогою символу: s0 s1 … sn−1 #…⏟π[i−1] ⟹ s0 s1 … sn−1 #…⏟π[i−1]+ti ⟹ s0 s1 … sn−1 #…ti⏟π[i]s_0\\ s_1\\ \\ldots\\ s_{n-1}\\ \\# \\underbrace{\\ldots}_{\\pi[i-1]}\\ \\ \\Longrightarrow\\ \\ s_0\\ s_1\\ \\ldots\\ s_{n-1}\\ \\# \\underbrace{\\ldots}_{\\pi[i-1]} + t_i\\ \\ \\Longrightarrow\\ \\ s_0\\ s_1\\ \\ldots\\ s_{n-1}\\ \\# \\ldots \\underbrace{t_i}_{\\pi[i]}s0​ s1​ … sn−1​ #π[i−1]…​​ ⟹ s0​ s1​ … sn−1​ #π[i−1]…​​+ti​ ⟹ s0​ s1​ … sn−1​ #…π[i]ti​​​ Таким чином, навіть якщо ми ще не маємо рядка ttt, ми можемо попередньо побудувати таблицю переходів (стара_π,c)→нова_π({\\rm стара}\\_\\pi,c) \\rightarrow {\\rm нова}\\_\\pi(стара_π,c)→нова_π за допомогою того ж алгоритму обчислення префікс-функції: вхідний рядок &quot;s&quot; константа &quot;alphabet&quot; має значення 256, що відповідає потужності алфавіту символів. Зазвичай вона менша s += '#'; int n = (int)s.length(); vector&lt;int&gt; pi = prefix_function(s); vector&lt;vector&lt;int&gt;&gt; aut(n, vector&lt;int&gt;(alphabet)); for (int i = 0; i &lt; n; ++i) { for (char c = 0; c &lt; alphabet; ++c) { int j = i; while (j &gt; 0 &amp;&amp; c != s[j]) { j = pi[j - 1]; } if (c == s[j]) { ++j; } aut[i][c] = j; } }  Правда, в такому вигляді алгоритм буде працювати за O(nk2)O(nk^2)O(nk2) (kkk - потужність алфавіту). Але зауважимо, що замість внутрішнього циклу while\\rm whilewhile, який поступово скорочує відповідь, ми можемо скористатися вже обчисленою частиною таблиці: переходячи від значення jjj до значення π[j−1]\\pi[j-1]π[j−1], ми фактично говоримо, що перехід зі стану (j,c)(j, c)(j,c) приведе в той же стан, що і перехід (π[j−1],c)(\\pi[j-1], c)(π[j−1],c), а для нього відповідь вже точно порахована (тобто π[j−1]&lt;j\\pi[j-1] &lt; jπ[j−1]&lt;j): вхідний рядок &quot;s&quot; константа &quot;alphabet&quot; має значення 256, що відповідає потужності алфавіту символів. Зазвичай це значення менше s += '#'; int n = (int)s.length(); vector&lt;int&gt; pi = prefix_function(s); vector&lt;vector&lt;int&gt;&gt; aut(n, vector&lt;int&gt;(alphabet)); for (int i = 0; i &lt; n; ++i) { for (char c = 0; c &lt; alphabet; ++c) { if (i &gt; 0 &amp;&amp; c != s[i]) { aut[i][c] = aut[pi[i - 1]][c]; } else { aut[i][c] = i + (c == s[i]); } } }  В результаті вийшла дуже проста реалізація побудови автомата, яка працює за O(nk)O(n k)O(nk). Коли може бути корисним такий автомат? На початку згадаємо, що ми припускаємо префіксну функцію для рядка s+#+ts+\\#+ts+#+t, і її значення зазвичай використовують з однією метою: знайти всі входження рядка sss в рядок ttt. Тому саме очевидна користь від побудови такого автомата - прискорення обчислення префікс-функції для рядка s+#+ts+\\#+ts+#+t. Побудувавши автомат за рядком s+#s+\\#s+#, нам вже не потрібні ні рядок sss, ні значення префікс-функції в ньому, не потрібні жодні обчислення - всі переходи (тобто те, як буде змінюватися префікс-функція) вже попередньо обраховані в таблиці. Але є й друге, менш очевидне застосування. Це випадок, коли рядок ttt є гігантським рядком, побудованим за якимось правилом. Це може бути, наприклад, рядок Грея або рядок, утворений рекурсивною комбінацією декількох коротких рядків, поданих на вхід. Нехай для конкретності ми вирішуємо таку задачу: задано номер k≤105k \\le 10^5k≤105 рядка Грея та рядок sss довжини n≤105n \\le 10^5n≤105. Потрібно порахувати кількість входжень рядка sss у kkk-й рядок Грея. Нагадаємо, рядки Грея визначаються наступним чином: g1=&quot;a&quot;g_1 = &quot;a&quot;g1​=&quot;a&quot; g2=&quot;aba&quot;g_2 = &quot;aba&quot;g2​=&quot;aba&quot; g3=&quot;abacaba&quot;g_3 = &quot;abacaba&quot;g3​=&quot;abacaba&quot; g4=&quot;abacabadabacaba&quot;g_4 = &quot;abacabadabacaba&quot;g4​=&quot;abacabadabacaba&quot; …\\ldots… У таких випадках навіть проста побудова рядка ttt буде неможливою через її астрономічну довжину (наприклад, kkk-ий рядок Грея має довжину 2k−12^k-12k−1). Тим не менше, ми зможемо порахувати значення префікс-функції в кінці цього рядка, знаючи значення префікс-функції, яке було перед початком цього рядка. Отже, крім самого автомата, також порахуємо такі величини: G[i][j]G[i][j]G[i][j] - значення автомата, досягнуте після &quot;годування&quot; йому рядка gig_igi​, якщо до цього автомат перебував у стані jjj. Друга величина - K[i][j]K[i][j]K[i][j] - кількість входжень рядка sss в рядок gig_igi​, якщо до &quot;годування&quot; цього рядка gig_igi​ автомат перебував у стані jjj. Фактично, K[i][j]K[i][j]K[i][j] - це кількість разів, коли автомат приймав значення s.length()s.{\\rm length}()s.length() під час &quot;годування&quot; рядка gig_igi​. Зрозуміло, що відповіддю на задачу буде величина K[k][0]K[k][0]K[k][0]. Як слід рахувати ці величини? По-перше, базовими значеннями є G[0][j]=jG[0][j] = jG[0][j]=j, K[0][j]=0K[0][j] = 0K[0][j]=0. А всі наступні значення можна обчислювати за попередніми значеннями, використовуючи автомат. Отже, для обчислення цих значень для деякого iii ми повинні взяти до уваги, що рядок gig_igi​ складається з gi−1g_{i-1}gi−1​ плюс iii-ий символ алфавіту плюс знову gi−1g_{i-1}gi−1​. Значить, після &quot;згодовування&quot; першого куска (gi−1g_{i-1}gi−1​) автомат перейде в стан G[i−1][j]G[i-1][j]G[i−1][j], а потім, після &quot;згодовування&quot; символу chari{\\rm char}_ichari​, він перейде в стан: mid=aut[ G[i−1][j] ][chari]{\\rm mid} = {\\rm aut}[\\ G[i-1][j]\\ ][{\\rm char}_i]mid=aut[ G[i−1][j] ][chari​] Після цього автомату &quot;подаватиметься&quot; останній шматок, тобто gi−1g_{i-1}gi−1​ G[i][j]=G[i−1][mid]G[i][j] = G[i-1][{\\rm mid}]G[i][j]=G[i−1][mid] Кількості K[i][j]K[i][j]K[i][j] легко визначаються як сума кількостей по трьох частинах gig_igi​: рядок gi−1g_{i-1}gi−1​, символ chari{\\rm char}_ichari​, і знову рядок gi−1g_{i-1}gi−1​: K[i][j]=K[i−1][j]+(mid==s.length())+K[i−1][mid]K[i][j] = K[i-1][j] + ({\\rm mid} == s.{\\rm length}()) + K[i-1][mid]K[i][j]=K[i−1][j]+(mid==s.length())+K[i−1][mid] Отже, ми вирішили задачу для стрічок Грея. Аналогічно можна розв'язати цілий клас подібних задач. Наприклад, точно таким же методом можна вирішити наступну задачу: дано рядок sss і зразки tit_iti​, кожен з яких задається наступним чином: це рядок зі звичайних символів, серед яких можуть зустрічатися рекурсивні вставки інших рядків у формі tk[cnt]t_k[\\rm cnt]tk​[cnt], яка означає, що в це місце має бути вставлено cnt\\rm cntcnt екземплярів рядка tkt_ktk​. Один з прикладів такої схеми: t1=&quot;abdeca&quot;t_1 = &quot;abdeca&quot;t1​=&quot;abdeca&quot; t2=&quot;abc&quot;+t1[30]+&quot;abd&quot;t_2 = &quot;abc&quot; + t_1[30] + &quot;abd&quot;t2​=&quot;abc&quot;+t1​[30]+&quot;abd&quot; t3=t2[50]+t1[100]t_3 = t_2[50] + t_1[100]t3​=t2​[50]+t1​[100] t4=t2[10]+t3[100]t_4 = t_2[10] + t_3[100]t4​=t2​[10]+t3​[100] Гарантується, що цей опис не містить циклічних залежностей. Обмеження полягають у тому, що якщо явно розкривати рекурсію і знаходити рядки tit_iti​, то їх довжини можуть досягати порядку 100100100^{100}100100. Потрібно знайти кількість входжень рядка sss в кожен з рядків tit_iti​. Задача вирішується шляхом побудови автомата префікс-функції, після чого потрібно обчислювати та додавати до нього переходи за цілими рядками tit_iti​. Загалом, це просто більш загальний випадок порівняно з задачею про рядки Грея. "},{"title":"Задачі​","type":1,"pageTitle":"Префікс-функція","url":"/algorithms/strings/prefix_function#задачі","content":"Список задач, які можна розв'язати, використовуючи префіксну функцію: Online Judge - 455 - &quot;Periodic Strings&quot; Online Judge - 11022 - &quot;String Factoring&quot; Online Judge - 11452 - &quot;Dancing the Cheeky-Cheeky&quot; "}]