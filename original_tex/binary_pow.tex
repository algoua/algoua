\h1{ Бинарное возведение в степень }


Бинарное (двоичное) возведение в степень --- это приём, позволяющий возводить любое число в $n$-ую степень за $O(\log n)$ умножений (вместо $n$ умножений при обычном подходе).

Более того, описываемый здесь приём применим к любой \bf{ассоциативной} операции, а не только к умножению чисел. Напомним, операция называется ассоциативной, если для любых $a, b, c$ выполняется:
$$ (a \cdot b) \cdot c = a \cdot (b \cdot c) $$

Наиболее очевидное обобщение --- на остатки по некоторому модулю (очевидно, ассоциативность сохраняется). Следующим по "популярности" является обобщение на произведение матриц (его ассоциативность общеизвестна).



\h2{ Алгоритм }

Заметим, что для любого числа $a$ и \bf{чётного} числа $n$ выполнимо очевидное тождество (следующее из ассоциативности операции умножения):
$$ a^n = (a^{n/2})^2 = a^{n/2} \cdot a^{n/2} $$
Оно и является основным в методе бинарного возведения в степень. Действительно, для чётного $n$ мы показали, как, потратив всего одну операцию умножения, можно свести задачу к вдвое меньшей степени.

Осталось понять, что делать, если степень $n$ \bf{нечётна}. Здесь мы поступаем очень просто: перейдём к степени $n-1$, которая будет уже чётной:
$$ a^n = a^{n-1} \cdot a $$

Итак, мы фактически нашли рекуррентную формулу: от степени $n$ мы переходим, если она чётна, к $n/2$, а иначе --- к $n-1$. Понятно, что всего будет не более $2 \log n$ переходов, прежде чем мы придём к $n = 0$ (базе рекуррентной формулы). Таким образом, мы получили алгоритм, работающий за $O (\log n)$ умножений.



\h2{ Реализация }

Простейшая рекурсивная реализация:

\code
int binpow (int a, int n) {
	if (n == 0)
		return 1;
	if (n % 2 == 1)
		return binpow (a, n-1) * a;
	else {
		int b = binpow (a, n/2);
		return b * b;
	}
}
\endcode

Нерекурсивная реализация, также оптимизированная (деления на 2 заменены битовыми операциями):

\code
int binpow (int a, int n) {
	int res = 1;
	while (n)
		if (n & 1) {
			res *= a;
			--n;
		}
		else {
			a *= a;
			n >>= 1;
		}
	return res;
}
\endcode

Эту реализацию можно ещё несколько упростить, заметив, что возведение $a$ в квадрат осуществляется всегда, независимо от того, сработало условие нечётности $n$ или нет:

\code
int binpow (int a, int n) {
	int res = 1;
	while (n) {
		if (n & 1)
			res *= a;
		a *= a;
		n >>= 1;
	}
	return res;
}
\endcode

Наконец, стоит отметить, что бинарное возведение в степень уже реализовано в языке Java, но только для класса длинной арифметики BigInteger (функция pow этого класса работает именно по алгоритму бинарного возведения).



\h2{ Примеры решения задач }


\h3{ Эффективное вычисление чисел Фибоначчи }

\bf{Условие}. Дано число $n$. Требуется вычислить $F_n$, где $F_i$ --- \algohref=fibonacci_numbers{последовательность чисел Фибоначчи}.

\bf{Решение}. Более подробно это решение описано в \algohref=fibonacci_numbers{статье о последовательности Фибоначчи}. Здесь же мы лишь кратко приведём суть этого решения.

Основная идея следующая. Вычисление очередного числа Фибоначчи основывается на знании двух предыдущих чисел Фибоначчи: а именно, каждое следующее число Фибоначчи получается как сумма двух предыдущих. Это означает, что мы можем построить матрицу $2 \times 2$, которая будет соответствовать этому преобразованию: как по двум числам Фибоначчи $F_i$ и $F_{i+1}$ вычислить следующее число, т.е. перейти к паре $F_{i+1}$, $F_{i+2}$. Например, применяя это преобразование $n$ раз к паре $F_0$ и $F_1$, мы получим пару $F_n$ и $F_{n+1}$. Таким образом, возведя матрицу этого преобразования в $n$-ую степень, мы тем самым найдём искомое $F_n$ за время $O (\log n)$, что нам и требовалось.


\h3{ Возведение перестановки в $k$-ую степень }

\bf{Условие}. Дана перестановка $p$ длины $n$. Требуется возвести её в $k$-ую степень, т.е. найти, что получится, если к тождественной перестановке $k$ раз применить перестановку $p$.

\bf{Решение}. Просто применим к перестановке $p$ описанный выше алгоритм бинарного возведения в степень. Никаких отличий по сравнению с возведением чисел в степень --- нет. Решение получается с асимптотикой $O (n \log k)$.

(Примечание. Данную задачу можно решить и более эффективно, \bf{за линейное время}. Для этого достаточно выделить в перестановке все циклы, после чего рассмотреть по отдельности каждый цикл и, взяв $k$ по модулю длины текущего цикла, найти ответ для этого цикла.)


\h3{ Быстрое применение набора геометрических операций к точкам }

\bf{Условие}. Даны $n$ точек $p_i$, и даны $m$ преобразований, которые надо применить к каждой из этих точек. Каждое преобразование --- это либо сдвиг на заданный вектор, либо масштабирование (умножение координат на заданные коэффициенты), либо вращение вокруг заданной оси на заданный угол. Кроме того, имеется составная операция циклического повторения: она имеет вид "повторить заданное число раз заданный список преобразований" (операции циклического повторения могут вкладываться друг в друга).

Требуется вычислить результат применения указанных операций ко всем точкам (эффективно, т.е. за время, меньшее чем $O(n \cdot length)$, где $length$ --- общее количество операций, которые необходимо сделать).

\bf{Решение}. Посмотрим на разные виды преобразований с точки зрения того, как они изменяют координаты:

\ul{

\li Операция сдвига --- она просто прибавляет ко всем координатам единицу, домноженную на некоторые константы.

\li Операция масштабирования --- она умножает каждую координату на некоторую константу.

\li Операция вращения вокруг оси --- её можно представить следующим образом: новые получаемые координаты можно записать как линейную комбинацию старых.

(Мы не будем здесь уточнять, каким образом это производится. Например, можно для простоты представить это в виде комбинации пяти двумерных поворотов: сначала в плоскостях $OXY$ и $OXZ$ так, чтобы ось вращения совпала с положительным направлением оси $OX$, затем требуемый поворот вокруг оси в плоскости $YZ$, затем обратные повороты в плоскостях $OXZ$ и $OXY$ так, чтобы ось вращения вернулась в своё исходное положение.)

}

Как легко видеть, каждое из этих преобразований --- это пересчёт координат по линейным формулам. Таким образом, любое такое преобразование можно записать в виде матрицы $4 \times 4$:

$$ \begin{pmatrix}
a_11 & a_{12} & a_{13} & a_{14} \\
a_21 & a_{22} & a_{23} & a_{24} \\
a_31 & a_{32} & a_{33} & a_{34} \\
a_41 & a_{42} & a_{43} & a_{44} \\
\end{pmatrix}, $$

которое при умножении (слева) на строку из старых координат и константы-единицы даёт строку из новых координат и константы-единицы:

$$ \begin{pmatrix} x & y & z & 1 \end{pmatrix} \cdot \begin{pmatrix}
a_{11} & a_{12} & a_{13} & a_{14} \\
a_{21} & a_{22} & a_{23} & a_{24} \\
a_{31} & a_{32} & a_{33} & a_{34} \\
a_{41} & a_{42} & a_{43} & a_{44} \\
\end{pmatrix} = \begin{pmatrix} x' & y' & z' & 1 \end{pmatrix}. $$

(Почему понадобилось вводить фиктивную четвёртую координату, всегда равную единице? Без этого не получилось бы реализовать операцию сдвига: ведь сдвиг --- это как раз прибавление к координатам единицы, домноженной на некоторые коэффициенты. Без фиктивной единицы мы бы смогли только реализовывать линейные комбинации самих координат, а прибавлять к ним заданные константы --- не смогли бы.)

Теперь решение задачи становится почти тривиальным. Раз каждая элементарная операция описывается матрицей, то последовательность операций описывается произведением этих матриц, а операция циклического повторения --- возведением этой матрицы в степень. Таким образом, мы за время $O (m \cdot \log repetition)$ можем предпосчитать матрицу $4 \times 4$, описывающую все преобразования, и затем просто умножить каждую точку $p_i$ на эту матрицу --- тем самым, мы ответим на все запросы за время $O (n)$.


\h3{ Количество путей фиксированной длины в графе }

\bf{Условие}. Дан неориентированный граф $G$ с $n$ вершинами, и дано число $k$. Требуется для каждой пары вершин $i$ и $j$ найти количество путей между ними, содержащих ровно $k$ рёбер.

\bf{Решение}. Более подробно эта задача рассматривается в \algohref=fixed_length_paths{отдельной статье}. Здесь же лишь напомним суть этого решения: мы просто возводим в $k$-ую степень матрицу смежности этого графа, и элементы этой матрицы и будут являться решениями. Итоговая асимптотика --- $O (n^3 \log k)$.

(Примечание. В \algohref=fixed_length_paths{той же статье} рассматривается и другая вариация этой задачи: когда граф взвешенный, и требуется найти путь минимального веса, содержащий ровно $k$ рёбер. Как показано в этой статье, данная задача также решается с помощью бинарного возведения в степень матрицы смежности графа, однако вместо обычной операции перемножения двух матриц следует использовать модифицированную: вместо умножений берётся сумма, а вместо суммирования --- взятие минимума.)


\h3{ Вариация бинарного возведения в степень: перемножение двух чисел по модулю }

Приведём здесь интересную вариацию бинарного возведения в степень.

Пусть перед нами стоит такая \bf{задача}: перемножить два числа $a$ и $b$ по модулю $m$:

$$ a \cdot b \pmod m $$

Предположим, что числа могут быть достаточно велики: настолько, что сами числа помещаются во встроенные типы данных, а вот их непосредственное произведение $a \cdot b$ --- уже нет (отметим, что нам также потребуется, чтобы сумма чисел помещалась во встроенный тип данных). Соответственно, задача в том, чтобы посчитать искомую величину $(a \cdot b) \pmod m$, не прибегая к помощи \algohref=big_integer{длинной арифметики}.

\bf{Решение} таково. Мы просто применяем алгоритм бинарного возведения, описанный выше, только вместо операции умножения мы будем производить сложения. Иными словами, перемножение двух чисел мы свели к $O (\log m)$ операций сложения и умножения на два (что тоже, по сути, есть сложение).

(Примечание. Данную задачу можно решить и \bf{по-другому}, прибегнув к помощи операций с числами с плавающей точкой. А именно, посчитаем в числах с плавающей точкой выражение $a \cdot b / m$, и округлим его к ближайшему целому. Так мы найдём \bf{приблизительное} частное. Отняв его от произведения $a \cdot b$ (проигнорировав переполнения), мы, скорее всего, получим относительно небольшое число, которое можно взять по модулю $m$ --- и вернуть его в качестве ответа. Это решение выглядит довольно ненадёжным, но оно весьма быстрое, и очень кратко реализуется.)



\h2{ Задачи в online judges }

Список задач, которые можно решить, используя бинарное возведение в степень:

TODO

