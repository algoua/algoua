\h1{Тернарный поиск}

\h2{Постановка задачи}

Пусть дана функция $f(x)$, \bf{унимодальная} на некотором отрезке $[l;r]$. Под унимодальностью понимается один из двух вариантов. Первый: функция сначала строго возрастает, потом достигает максимума (в одной точке или целом отрезке), потом строго убывает. Второй вариант, симметричный: функция сначала убывает убывает, достигает минимума, возрастает. В дальнейшем мы будем рассматривать первый вариант, второй будет абсолютно симметричен ему.

Требуется \bf{найти максимум} функции $f(x)$ на отрезке $[l;r]$.

\h2{Алгоритм}

Возьмём любые две точки $m_1$ и $m_2$ в этом отрезке: $l < m_1 < m_2 < r$. Посчитаем значения функции $f(m_1)$ и $f(m_2)$. Дальше у нас получается три варианта:

\ul{

\li Если окажется, что $f(m_1) < f(m_2)$, то искомый максимум не может находиться в левой части, т.е. в части $[l;m_1]$. В этом легко убедиться: если в левой точке функция меньше, чем в правой, то либо эти две точки находятся в области "подъёма" функции, либо только левая точка находится там. В любом случае, это означает, что максимум дальше имеет смысл искать только в отрезке $[m_1;r]$.

\li Если, наоборот, $f(m_1) > f(m_2)$, то ситуация аналогична предыдущей с точностью до симметрии. Теперь искомый максимум не может находиться в правой части, т.е. в части $[m_2;r]$, поэтому переходим к отрезку $[l;m_2]$.

\li Если $f(m_1) = f(m_2)$, то либо обе эти точки находятся в области максимума, либо левая точка находится в области возрастания, а правая --- в области убывания (здесь существенно используется то, что возрастание/убывание строгие). Таким образом, в дальнейшем поиск имеет смысл производить в отрезке $[m_1;m_2]$, но (в целях упрощения кода) этот случай можно отнести к любому из двух предыдущих.
}

Таким образом, по результату сравнения значений функции в двух внутренних точках мы вместо текущего отрезка поиска $[l;r]$ находим новый отрезок $[l^\prime;r^\prime]$. Повторим теперь все действия для этого нового отрезка, снова получим новый, строго меньший, отрезок, и т.д.

Рано или поздно длина отрезка станет маленькой, меньшей заранее определённой константы-точности, и процесс можно останавливать. Этот метод численный, поэтому после остановки алгоритма можно приближённо считать, что во всех точках отрезка $[l;r]$ достигается максимум; в качестве ответа можно взять, например, точку $l$.

Осталось заметить, что мы не накладывали никаких ограничений на выбор точек $m_1$ и $m_2$. От этого способа, понятно, будет зависеть скорость сходимости (но и возникающая погрешность). Наиболее распространённый способ --- выбирать точки так, чтобы отрезок $[l;r]$ делился ими на 3 равные части:
$$ m_1 = l + \frac{r-l}{3} $$
$$ m_2 = r - \frac{r-l}{3} $$

Впрочем, при другом выборе, когда $m_1$ и $m_2$ ближе друг к другу, скорость сходимости несколько увеличится.

\h3{Случай целочисленного аргумента}

Если аргумент функции $f$ целочисленный, то отрезок $[l;r]$ тоже становится дискретным, однако, поскольку мы не накладывали никаких ограничений на выбор точек $m_1$ и $m_2$, то на корректность алгоритма это никак не влияет. Можно по-прежнему выбирать $m_1$ и $m_2$ так, чтобы они делили отрезок $[l;r]$ на 3 части, но уже равные только приблизительно.

Второй отличающийся момент --- критерий остановки алгоритма. В данном случае тернарный поиск надо будет останавливать, когда станет $r-l<3$, ведь в таком случае уже невозможно будет выбрать точки $m_1$ и $m_2$ так, чтобы были различными и отличались от $l$ и $r$, и это может привести к зацикливанию. После того, как алгоритм тернарного поиска остановится и станет $r-l<3$, из оставшихся нескольких точек-кандидатов $(l,l+1,\ldots,r)$ надо выбрать точку с максимальным значением функции.

\h2{Реализация}

Реализация для непрерывного случая (т.е. функция $f$ имеет вид: $\rm double\ f\ (double\ x)$):

\code
double l = ..., r = ..., EPS = ...; // входные данные
while (r - l > EPS) {
   double m1 = l + (r - l) / 3,
      m2 = r - (r - l) / 3;
   if (f (m1) < f (m2))
      l = m1;
   else
      r = m2;
}
\endcode

Здесь $\rm EPS$ --- фактически, \bf{абсолютная погрешность} ответа (не считая погрешностей, связанных с неточным вычислением функции).

Вместо критерия "while (r - l > EPS)" можно выбрать и такой критерий останова:
\code
for (int it=0; it<iterations; ++it)
\endcode

С одной стороны, придётся подобрать константу $\rm iterations$, чтобы обеспечить требуемую точность (обычно достаточно нескольких сотен, чтобы достичь максимальной точности). Но зато, с другой стороны, число итераций перестаёт зависеть от абсолютных величин $l$ и $r$, т.е. мы фактически с помощью $\rm iterations$ задаём требуемую \bf{относительную погрешность}.