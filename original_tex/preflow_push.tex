<h1>Максимальный поток методом Проталкивания предпотока за O (N<sup>4</sup>)</h1>

<p>Пусть дан граф G, в котором выделены две вершины: исток S и сток T, а у каждого ребра определена пропускная способность C<sub>u,v</sub>. Поток F можно представить как поток вещества, которое могло бы пройти по сети от истока к стоку, если рассматривать граф как сеть труб с некоторыми пропускными способностями. Т.е. поток - функция F<sub>u, v</sub>, определённая на множестве рёбер графа.</p>
<p>&nbsp;</p>
<p>Задача заключается в нахождении максимального потока. Здесь будет рассмотрен метод Проталкивания предпотока, работающий за O (N<sup>4</sup>), или, точнее, за O (N<sup>2</sup> M). Алгоритм был предложен Гольдбергом в 1985 году.</p>
<h2>Алгоритм</h2>
<p>Общая схема алгоритма такова. На каждом шаге будем рассматривать некоторый предпоток - т.е. функцию, которая по свойствам напоминает поток, но не обязательно удовлетворяет закону сохранения потока. На каждом шаге будем пытаться применить какую-либо из двух операций: проталкивание потока или поднятие вершины. Если на каком-то шаге станет невозможно применить какую-либо из двух операций, то мы нашли требуемый поток.</p>
<p>Для каждой вершины определена её высота H<sub>u</sub>, причём H<sub>S</sub> = N, H<sub>T</sub> = 0, и для любого остаточного ребра (u, v) имеем H<sub>u</sub> &lt;= H<sub>v</sub> + 1.</p>
<p>Для каждой вершины (кроме S) можно определить её избыток: E<sub>u</sub> = F<sub>V, u</sub>. Вершина с положительным избытком называется переполненной.</p>
<p>Операция проталкивания Push (u, v) применима, если вершина u переполнена, остаточная пропускная способность Cf<sub>u, v</sub> > 0 и H<sub>u</sub> = H<sub>v</sub> + 1. Операция проталкивания заключается в максимальном увеличении потока из u в v, ограниченном избытком E<sub>u</sub> и остаточной пропускной способностью Cf<sub>u, v</sub>.</p>
<p>Операция поднятия Lift (u) поднимает переполненную вершину u на максимально допустимую высоту. Т.е. H<sub>u</sub> = 1 + min { H<sub>v</sub> }, где (u, v) - остаточное ребро.</p>
<p>Осталось только рассмотреть инициализацию потока. Нужно инициализировать только следующие значения: F<sub>S, v</sub> = C<sub>S, v</sub>, F<sub>u, S</sub> = - C<sub>u, S</sub>, остальные значения положить равными нулю.</p>
<h2>Реализация</h2>
<code>const int inf = 1000*1000*1000;


typedef vector&lt;int> graf_line;
typedef vector&lt;graf_line> graf;

typedef vector&lt;int> vint;
typedef vector&lt;vint> vvint;


void push (int u, int v, vvint & f, vint & e, const vvint & c)
{
	int d = min (e[u], c[u][v] - f[u][v]);
	f[u][v] += d;
	f[v][u] = - f[u][v];
	e[u] -= d;
	e[v] += d;
}

void lift (int u, vint & h, const vvint & f, const vvint & c)
{
	int d = inf;
	for (int i = 0; i &lt; (int)f.size(); i++)
		if (c[u][i]-f[u][i] > 0)
			d = min (d, h[i]);
	if (d == inf)
		return;
	h[u] = d + 1;
}


int main()
{
	int n;
	cin >> n;
	vvint c (n, vint(n));
	for (int i=0; i&lt;n; i++)
		for (int j=0; j&lt;n; j++)
			cin >> c[i][j];
	// исток - вершина 0, сток - вершина n-1

	vvint f (n, vint(n));
	for (int i=1; i&lt;n; i++)
	{
		f[0][i] = c[0][i];
		f[i][0] = -c[0][i];
	}

	vint h (n);
	h[0] = n;

	vint e (n);
	for (int i=1; i&lt;n; i++)
		e[i] = f[0][i];

	for ( ; ; )
	{
		int i;
		for (i=1; i&lt;n-1; i++)
			if (e[i] > 0)
				break;
		if (i == n-1)
			break;

		int j;
		for (j=0; j&lt;n; j++)
			if (c[i][j]-f[i][j] > 0 && h[i]==h[j]+1)
				break;
		if (j &lt; n)
			push (i, j, f, e, c);
		else
			lift (i, h, f, c);
	}

	int flow = 0;
	for (int i=0; i&lt;n; i++)
		if (c[0][i])
			flow += f[0][i];

	cout &lt;&lt; max(flow,0);

}</code>