\h1{Минимальное остовное дерево. Алгоритм Прима}

Дан взвешенный неориентированный граф $G$ с $n$ вершинами и $m$ рёбрами. Требуется найти такое поддерево этого графа, которое бы соединяло все его вершины, и при этом обладало наименьшим возможным весом (т.е. суммой весов рёбер). Поддерево --- это набор рёбер, соединяющих все вершины, причём из любой вершины можно добраться до любой другой ровно одним простым путём.

Такое поддерево называется минимальным остовным деревом или просто \bf{минимальным остовом}. Легко понять, что любой остов обязательно будет содержать $n-1$ ребро.

В \bf{естественной постановке} эта задача звучит следующим образом: есть $n$ городов, и для каждой пары известна стоимость соединения их дорогой (либо известно, что соединить их нельзя). Требуется соединить все города так, чтобы можно было доехать из любого города в другой, а при этом стоимость прокладки дорог была бы минимальной.


\h2{Алгоритм Прима}

Этот алгоритм назван в честь американского математика Роберта Прима (Robert Prim), который открыл этот алгоритм в 1957 г. Впрочем, ещё в 1930 г. этот алгоритм был открыт чешским математиком Войтеком Ярником (Vojtěch Jarník). Кроме того, Эдгар Дейкстра (Edsger Dijkstra) в 1959 г. также изобрёл этот алгоритм, независимо от них.


\h3{Описание алгоритма}

Сам \bf{алгоритм} имеет очень простой вид. Искомый минимальный остов строится постепенно, добавлением в него рёбер по одному. Изначально остов полагается состоящим из единственной вершины (её можно выбрать произвольно). Затем выбирается ребро минимального веса, исходящее из этой вершины, и добавляется в минимальный остов. После этого остов содержит уже две вершины, и теперь ищется и добавляется ребро минимального веса, имеющее один конец в одной из двух выбранных вершин, а другой --- наоборот, во всех остальных, кроме этих двух. И так далее, т.е. всякий раз ищется минимальное по весу ребро, один конец которого --- уже взятая в остов вершина, а другой конец --- ещё не взятая, и это ребро добавляется в остов (если таких рёбер несколько, можно взять любое). Этот процесс повторяется до тех пор, пока остов не станет содержать все вершины (или, что то же самое, $n-1$ ребро).

В итоге будет построен остов, являющийся минимальным. Если граф был изначально не связен, то остов найден не будет (количество выбранных рёбер останется меньше $n-1$).


\h3{Доказательство}

Пусть граф $G$ был связным, т.е. ответ существует. Обозначим через $T$ остов, найденный алгоритмом Прима, а через $S$ --- минимальный остов. Очевидно, что $T$ действительно является остовом (т.е. поддеревом графа $G$). Покажем, что веса $S$ и $T$ совпадают.

Рассмотрим первый момент времени, когда в $T$ происходило добавление ребра, не входящего в оптимальный остов $S$. Обозначим это ребро через $e$, концы его --- через $a$ и $b$, а множество входящих на тот момент в остов вершин --- через $V$ (согласно алгоритму, $a \in V$, $b \not\in V$, либо наоборот). В оптимальном остове $S$ вершины $a$ и $b$ соединяются каким-то путём $P$; найдём в этом пути любое ребро $g$, один конец которого лежит в $V$, а другой --- нет. Поскольку алгоритм Прима выбрал ребро $e$ вместо ребра $g$, то это значит, что вес ребра $g$ больше либо равен весу ребра $e$.

Удалим теперь из $S$ ребро $g$, и добавим ребро $e$. По только что сказанному, вес остова в результате не мог увеличиться (уменьшиться он тоже не мог, поскольку $S$ было оптимальным). Кроме того, $S$ не перестало быть остовом (в том, что связность не нарушилась, нетрудно убедиться: мы замкнули путь $P$ в цикл, и потом удалили из этого цикла одно ребро).

Итак, мы показали, что можно выбрать оптимальный остов $S$ таким образом, что он будет включать ребро $e$. Повторяя эту процедуру необходимое число раз, мы получаем, что можно выбрать оптимальный остов $S$ так, чтобы он совпадал с $T$. Следовательно, вес построенного алгоритмом Прима $T$ минимален, что и требовалось доказать.


\h2{Реализации}

Время работы алгоритма существенно зависит от того, каким образом мы производим поиск очередного минимального ребра среди подходящих рёбер. Здесь могут быть разные подходы, приводящие к разным асимптотикам и разным реализациям.


\h3{Тривиальная реализация: алгоритмы за $O(n m)$ и $O(n^2 + m \log n)$}

Если искать каждый раз ребро простым просмотром среди всех возможных вариантов, то асимптотически будет требоваться просмотр $O(m)$ рёбер, чтобы найти среди всех допустимых ребро с наименьшим весом. Суммарная асимптотика алгоритма составит в таком случае $O(nm)$, что в худшем случае есть $O(n^3)$, --- слишком медленный алгоритм.

Этот алгоритм можно улучшить, если просматривать каждый раз не все рёбра, а только по одному ребру из каждой уже выбранной вершины. Для этого, например, можно отсортировать рёбра из каждой вершины в порядке возрастания весов, и хранить указатель на первое допустимое ребро (напомним, допустимы только те рёбра, которые ведут в множество ещё не выбранных вершин). Тогда, если пересчитывать эти указатели при каждом добавлении ребра в остов, суммарная асимптотика алгоритма будет $O(n^2 + m)$, но предварительно потребуется выполнить сортировку всех рёбер за $O(m \log n)$, что в худшем случае (для плотных графов) даёт асимптотику $O(n^2 \log n)$.

Ниже мы рассмотрим два немного других алгоритма: для плотных и для разреженных графов, получив в итоге заметно лучшую асимптотику.


\h3{Случай плотных графов: алгоритм за $O(n^2)$}

Подойдём к вопросу поиска наименьшего ребра с другой стороны: для каждой ещё не выбранной будем хранить минимальное ребро, ведущее в уже выбранную вершину.

Тогда, чтобы на текущем шаге произвести выбор минимального ребра, надо просто просмотреть эти минимальные рёбра у каждой не выбранной ещё вершины --- асимптотика составит $O(n)$.

Но теперь при добавлении в остов очередного ребра и вершины эти указатели надо пересчитывать. Заметим, что эти указатели могут только уменьшаться, т.е. у каждой не просмотренной ещё вершины надо либо оставить её указатель без изменения, либо присвоить ему вес ребра в только что добавленную вершину. Следовательно, эту фазу можно сделать также за $O(n)$.

Таким образом, мы получили вариант алгоритма Прима с асимптотикой $O(n^2)$.

В частности, такая реализация особенно удобна для решения так называемой \bf{евклидовой задачи о минимальном остове}: когда даны $n$ точек на плоскости, расстояние между которыми измеряется по стандартной евклидовой метрике, и требуется найти остов минимального веса, соединяющий их все (причём добавлять новые вершины где-либо в других местах запрещается). Эта задача решается описанным здесь алгоритмом за $O(n^2)$ времени и $O(n)$ памяти, чего не получится добиться \algohref=mst_kruskal{алгоритмом Крускала}.

Реализация алгоритма Прима для графа, заданного матрицей смежности $g[][]$:

\code
// входные данные
int n;
vector < vector<int> > g;
const int INF = 1000000000; // значение "бесконечность"

// алгоритм
vector<bool> used (n);
vector<int> min_e (n, INF), sel_e (n, -1);
min_e[0] = 0;
for (int i=0; i<n; ++i) {
	int v = -1;
	for (int j=0; j<n; ++j)
		if (!used[j] && (v == -1 || min_e[j] < min_e[v]))
			v = j;
	if (min_e[v] == INF) {
		cout << "No MST!";
		exit(0);
	}

	used[v] = true;
	if (sel_e[v] != -1)
		cout << v << " " << sel_e[v] << endl;

	for (int to=0; to<n; ++to)
		if (g[v][to] < min_e[to]) {
			min_e[to] = g[v][to];
			sel_e[to] = v;
		}
}
\endcode

На вход подаются число вершин $n$ и матрица $g[][]$ размера $n \times n$, в которой отмечены веса рёбер, и стоят числа $INF$, если соответствующее ребро отсутствует. Алгоритм поддерживает три массива: флаг ${\rm used}[i] = {\rm true}$ означает, что вершина $i$ включена в остов, величина ${\rm min\_e}[i]$ хранит вес наименьшего допустимого ребра из вершины $i$, а элемент ${\rm sel\_e}[i]$ содержит конец этого наименьшего ребра (это нужно для вывода рёбер в ответе). Алгоритм делает $n$ шагов, на каждом из которых выбирает вершину $v$ с наименьшей меткой ${\rm min\_e}$, помечает её $\rm used$, и затем просматривает все рёбра из этой вершины, пересчитывая их метки.


\h3{Случай разреженных графов: алгоритм за $O(m \log n)$}

В описанном выше алгоритме можно увидеть стандартные операции нахождения минимума в множестве и изменение значений в этом множестве. Эти две операции являются классическими, и выполняются многими структурами данных, например, реализованным в языке C++ красно-чёрным деревом set.

По смыслу алгоритм остаётся точно таким же, однако теперь мы можем найти минимальное ребро за время $O(\log n)$. С другой стороны, время на пересчёт $n$ указателей теперь составит $O(n \log n)$, что хуже, чем в вышеописанном алгоритме.

Если учесть, что всего будет $O(m)$ пересчётов указателей и $O(n)$ поисков минимального ребра, то суммарная асимптотика составит $O(m \log n)$ --- для разреженных графов это лучше, чем оба вышеописанных алгоритма, но на плотных графах этот алгоритм будет медленнее предыдущего.

Реализация алгоритма Прима для графа, заданного списками смежности $g[]$:

\code
// входные данные
int n;
vector < vector < pair<int,int> > > g;
const int INF = 1000000000; // значение "бесконечность"

// алгоритм
vector<int> min_e (n, INF), sel_e (n, -1);
min_e[0] = 0;
set < pair<int,int> > q;
q.insert (make_pair (0, 0));
for (int i=0; i<n; ++i) {
	if (q.empty()) {
		cout << "No MST!";
		exit(0);
	}
	int v = q.begin()->second;
	q.erase (q.begin());

	if (sel_e[v] != -1)
		cout << v << " " << sel_e[v] << endl;

	for (size_t j=0; j<g[v].size(); ++j) {
		int to = g[v][j].first,
			cost = g[v][j].second;
		if (cost < min_e[to]) {
			q.erase (make_pair (min_e[to], to));
			min_e[to] = cost;
			sel_e[to] = v;
			q.insert (make_pair (min_e[to], to));
		}
	}
}
\endcode

На вход подаются число вершин $n$ и $n$ списков смежности: $g[i]$ --- это список всех рёбер, исходящих из вершины $i$, в виде пар (второй конец ребра, вес ребра). Алгоритм поддерживает два массива: величина ${\rm min\_e}[i]$ хранит вес наименьшего допустимого ребра из вершины $i$, а элемент ${\rm sel\_e}[i]$ содержит конец этого наименьшего ребра (это нужно для вывода рёбер в ответе). Кроме того, поддерживается очередь $q$ из всех вершин в порядке увеличения их меток ${\rm min\_e}$. Алгоритм делает $n$ шагов, на каждом из которых выбирает вершину $v$ с наименьшей меткой ${\rm min\_e}$ (просто извлекая её из начала очереди), и затем просматривает все рёбра из этой вершины, пересчитывая их метки (при пересчёте мы удаляем из очереди старую величину, и затем кладём обратно новую).


\h3{Аналогия с алгоритмом Дейкстры}

В двух описанных только что алгоритмах прослеживается вполне чёткая аналогия с \algohref=dijkstra{алгоритмом Дейкстры}: он имеет такую же структуру ($n-1$ фаза, на каждой из которых сначала выбирается оптимальное ребро, добавляется в ответ, а затем пересчитываются значения для всех не выбранных ещё вершин). Более того, алгоритм Дейкстры тоже имеет два варианта реализации: за $O(n^2)$ и $O(m \log n)$ (мы, конечно, здесь не учитываем возможность использования сложных структур данных для достижения ещё меньших асимптотик).

Если взглянуть на алгоритмы Прима и Дейкстры более формально, то получается, что они вообще идентичны друг другу, за исключением \bf{весовой функции} вершин: если в алгоритме Дейкстры у каждой вершины поддерживается длина кратчайшего пути (т.е. сумма весов некоторых рёбер), то в алгоритме Прима каждой вершине приписывается только вес минимального ребра, ведущего в множество уже взятых вершин.

На уровне реализации это означает, что после добавления очередной вершины $v$ в множество выбранных вершин, когда мы начинаем просматривать все рёбра $(v,to)$ из этой вершины, то в алгоритме Прима указатель $to$ обновляется весом ребра $(v,to)$, а в алгоритме Дейкстры --- метка расстояния $d[to]$ обновляется суммой метки $d[v]$ и веса ребра $(v,to)$. В остальном эти два алгоритма можно считать идентичными (хоть они и решают совсем разные задачи).


\h2{Свойства минимальных остовов}

\ul{

\li \bf{Максимальный} остов также можно искать алгоритмом Прима (например, заменив все веса рёбер на противоположные: алгоритм не требует неотрицательности весов рёбер).

\li Минимальный остов \bf{единственен}, если веса всех рёбер различны. В противном случае, может существовать несколько минимальных остовов (какой именно будет выбран алгоритмом Прима, зависит от порядка просмотра рёбер/вершин с одинаковыми весами/указателями)

\li Минимальный остов также является остовом, \bf{минимальным по произведению} всех рёбер (предполагается, что все веса положительны). В самом деле, если мы заменим веса всех рёбер на их логарифмы, то легко заметить, что в работе алгоритма ничего не изменится, и будут найдены те же самые рёбра.

\li Минимальный остов является остовом с минимальным весом \bf{самого тяжёлого ребра}. Яснее всего это утверждение понятно, если рассмотреть работу \algohref=mst_kruskal{алгоритма Крускала}.

\li \bf{Критерий минимальности} остова: остов является минимальным тогда и только тогда, когда для любого ребра, не принадлежащего остову, цикл, образуемый этим ребром при добавлении к остову, не содержит рёбер тяжелее этого ребра. В самом деле, если для какого-то ребра оказалось, что оно легче некоторых рёбер образуемого цикла, то можно получить остов с меньшим весом (добавив это ребро в остов, и удалив самое тяжелое ребро из цикла). Если же это условие не выполнилось ни для одного ребра, то все эти рёбра не улучшают вес остова при их добавлении.

}

