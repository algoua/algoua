<h1>Поиск в глубину</h1>

<p>Это один из основных алгоритмов на графах.</p>
<p>В результате поиска в глубину находится лексикографически первый путь в графе.</p>
<p>Алгоритм работает за <b>O (N+M)</b>.</p>
<h2>Применения алгоритма</h2>
<ul>
<li>Поиск любого пути в графе.</li>
<li>Поиск лексикографически первого пути в графе.</li>
<li>Проверка, является ли одна вершина дерева предком другой:<br>В начале и конце итерации поиска в глубину будет запоминать "время" захода и выхода в каждой вершине. Теперь за O(1) можно найти ответ: вершина i является предком вершины j тогда и только тогда, когда start<sub>i</sub> &lt; start<sub>j</sub> и end<sub>i</sub> > end<sub>j</sub>.</li>
<li><algohref=lca>Задача LCA (наименьший общий предок)</algohref>.</li>
<li><algohref=topological_sort>Топологическая сортировка</algohref>:<br>Запускаем серию поисков в глубину, чтобы обойти все вершины графа. Отсортируем вершины по времени выхода по убыванию - это и будет ответом.</li>
<li><algohref=finding_cycle>Проверка графа на ацикличность и нахождение цикла</algohref></li>
<li><algohref=strong_connected_components>Поиск компонент сильной связности</algohref>:<br>Сначала делаем топологическую сортировку, потом транспонируем граф и проводим снова серию поисков в глубину в порядке, определяемом топологической сортировкой. Каждое дерево поиска - сильносвязная компонента.</li>
<li><algohref=bridge_searching>Поиск мостов</algohref>:<br>Сначала превращаем граф в ориентированный, делая серию поисков в глубину, и ориентируя каждое ребро так, как мы пытались по нему пройти. Затем находим сильносвязные компоненты. Мостами являются те рёбра, концы которых принадлежат разным сильносвязным компонентам.</li>
</ul>
<h2>Реализация</h2>
<code>vector &lt; vector&lt;int> > g; // граф
int n; // число вершин

vector&lt;int> color; // цвет вершины (0, 1, или 2)

vector&lt;int> time_in, time_out; // "времена" захода и выхода из вершины
int dfs_timer = 0; // "таймер" для определения времён

void dfs (int v) {
	time_in[v] = dfs_timer++;
	color[v] = 1;
	for (vector&lt;int>::iterator i=g[v].begin(); i!=g[v].end(); ++i)
		if (color[*i] == 0)
			dfs (*i);
	color[v] = 2;
	time_out[v] = dfs_timer++;
}</code>
<p>Это наиболее общий код. Во многих случаях времена захода и выхода из вершины не важны, так же как и не важны цвета вершин (но тогда надо будет ввести аналогичный по смыслу булевский массив used). Вот наиболее простая реализация:</p>
<code>vector &lt; vector&lt;int> > g; // граф
int n; // число вершин

vector&lt;char> used;

void dfs (int v) {
	used[v] = true;
	for (vector&lt;int>::iterator i=g[v].begin(); i!=g[v].end(); ++i)
		if (!used[*i])
			dfs (*i);
}</code>