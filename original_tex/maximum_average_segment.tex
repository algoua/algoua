\h1{ Поиск подотрезка массива с максимальной/минимальной суммой }

Здесь мы рассмотрим задачу о поиске подотрезка массива с максимальной суммой ("maximum subarray problem" на английском), а также некоторые её вариации (в том числе алгоритм решения варианта этой задачи в режиме онлайн --- описанный автором алгоритма --- KADR (Ярослав Твердохлеб)).


\h2{ Постановка задачи }

Дан массив чисел $a[1 \ldots n]$. Требуется найти такой его подотрезок $a[l \ldots r]$, что сумма на нём \bf{максимальна}:

$$ \max_{ 1 \le l \le r \le n } \sum_{i=l}^{r} a[i]. $$

Например, если бы все числа массива $a[]$ были бы неотрицательными, то в качестве ответа можно было бы взять весь массив. Решение нетривиально, когда массив может содержать как положительные, так и отрицательные числа.

Понятно, что задача о поиске \bf{минимального} подотрезка --- по сути та же самая, достаточно лишь изменить знаки всех чисел на противоположные.


\h2{ Алгоритм 1 }

Здесь мы рассмотрим практически очевидный алгоритм. (Дальше мы рассмотрим другой алгоритм, который чуть сложнее придумать, однако его реализация получается ещё короче.)

\h3{ Описание алгоритма }

Алгоритм весьма прост.

Введём для удобства \bf{обозначение}: $s[i] = \sum_{j=1}^{i} a[j]$. Т.е. массив $s[i]$ --- это массив частичных сумм массива $a[]$. Также положим значение $s[0] = 0$.

Будем теперь \bf{перебирать} индекс $r = 1 \ldots n$, и научимся для каждого текущего значения $r$ быстро находить оптимальное $l$, при котором достигается максимальная сумма на подотрезке $[l; r]$.

Формально это означает, что нам надо для текущего $r$ найти такое $l$ (не превосходящее $r$), чтобы величина $s[r] - s[l-1]$ была максимальной. После тривиального преобразования мы получаем, что нам надо найти в массиве $s[]$ минимум на отрезке $[0;r-1]$.

Отсюда мы сразу получаем алгоритм решения: мы просто будем хранить, где в массиве $s[]$ находится текущий минимум. Используя этот минимум, мы за $O(1)$ находим текущий оптимальный индекс $l$, а при переходе от текущего индекса $r$ к следующему мы просто обновляем этот минимум.

Очевидно, этот алгоритм работает за $O(n)$ и асимптотически оптимален.

\h3{ Реализация }

Для реализации нам даже не понадобится явно хранить массив частичных сумм $s[]$ --- от него нам будет требоваться только текущий элемент.

Реализация приводится в 0-индексированных массивах, а не в 1-нумерации, как было описано выше.

Приведём сначала решение, которое находит просто численный ответ, не находя индексы искомого отрезка:

\code
int ans = a[0],
	sum = 0,
	min_sum = 0;
for (int r=0; r<n; ++r) {
	sum += a[r];
	ans = max (ans, sum - min_sum);
	min_sum = min (min_sum, sum);
}
\endcode

Теперь приведём полный вариант решения, который параллельно с числовым решением находит границы искомого отрезка:

\code
int ans = a[0],
	ans_l = 0,
	ans_r = 0,
	sum = 0,
	min_sum = 0,
	min_pos = -1;
for (int r=0; r<n; ++r) {
	sum += a[r];

	int cur = sum - min_sum;
	if (cur > ans) {
		ans = cur;
		ans_l = min_pos + 1;
		ans_r = r;
	}

	if (sum < min_sum) {
		min_sum = sum;
		min_pos = r;
	}
}
\endcode


\h2{ Алгоритм 2 }

Здесь мы рассмотрим другой алгоритм. Его чуть сложнее понять, но зато он более элегантен, чем приведённый выше, и реализуется чуть-чуть короче. Этот алгоритм был предложен Джеем Каданом (Jay Kadane) в 1984 г.

\h3{ Описание алгоритма }

Сам \bf{алгоритм} выглядит следующим образом. Будем идти по массиву и накапливать в некоторой переменной $s$ текущую частичную сумму. Если в какой-то момент $s$ окажется отрицательной, то мы просто присвоим $s=0$. Утверждается, что максимум из всех значений переменной $s$, случившихся за время работы, и будет ответом на задачу.

\bf{Докажем} этот алгоритм.

В самом деле, рассмотрим первый момент времени, когда сумма $s$ стала отрицательной. Это означает, что, стартовав с нулевой частичной суммы, мы в итоге пришли к отрицательной частичной сумме --- значит, и весь этот префикс массива, равно как и любой его суффикс имеют отрицательную сумму. Следовательно, от всего этого префикса массива в дальнейшем не может быть никакой пользы: он может дать только отрицательную прибавку к ответу.

Однако этого недостаточно для доказательства алгоритма. В алгоритме мы, фактически, ограничиваемся в поиске ответа только такими отрезками, которые начинаются непосредственно после мест, когда случалось $s<0$.

Но, в самом деле, рассмотрим произвольный отрезок $[l;r]$, причём $l$ не находится в такой "критической" позиции (т.е. $l > p+1$, где $p$ --- последняя такая позиция, в которой $s<0$). Поскольку последняя критическая позиция находится строго раньше, чем в $l-1$, то получается, что сумма $a[p+1 \ldots l-1]$ неотрицательна. Это означает, что, сдвинув $l$ в позицию $p+1$, мы увеличим ответ или, в крайнем случае, не изменим его.

Так или иначе, но получается, что действительно при поиске ответа можно ограничиться только отрезками, начинающимися сразу после позиций, в которых оказывалось $s<0$. Это доказывает правильность алгоритма.

\h3{ Реализация }

Как и в алгоритме 1, приведём сначала упрощённую реализацию, которая ищет только числовой ответ, не находя границ искомого отрезка:

\code
int ans = a[0],
	sum = 0;
for (int r=0; r<n; ++r) {
	sum += a[r];
	ans = max (ans, sum);
	sum = max (sum, 0);
}
\endcode

Полный вариант решения, с поддержанием индексов-границ искомого отрезка:

\code
int ans = a[0],
	ans_l = 0,
	ans_r = 0,
	sum = 0,
	minus_pos = -1;
for (int r=0; r<n; ++r) {
	sum += a[r];

	if (sum > ans) {
		ans = sum;
		ans_l = minus_pos + 1;
		ans_r = r;
	}

	if (sum < 0) {
		sum = 0;
		minus_pos = r;
	}
}
\endcode


\h2{ Смежные задачи }

\h3{ Поиск максимального/минимального подотрезка с ограничениями }

Если в условии задачи на искомый отрезок $[l;r]$ накладываются дополнительные ограничения (например, что длина $r-l+1$ отрезка должна находиться в заданных пределах), то описанный алгоритм скорее всего легко обобщается на эти случаи --- так или иначе, задача будет по-прежнему заключаться в поиске минимума в массиве $s[]$ при заданных дополнительных ограничениях.

\h3{ Двумерный случай задачи: поиск максимальной/минимальной подматрицы }

Описанная в данной статье задача естественно обобщается на большие размерности. Например, в двумерном случае она превращается в поиск такой подматрицы $[l_1 \ldots r_1; l_2 \ldots r_2]$ заданной матрицы, которая имеет максимальную сумму чисел в ней.

Из описанного выше решения для одномерного случая \bf{легко получить} решение за $O(n^3)$: переберём $l_1$ и $r_1$, и посчитаем массив сумм с $l_1$ по $r_1$ в каждой строке матрицы; мы пришли к одномерной задаче поиска индексов $l_2$ и $r_2$ в этом массиве, которую уже можно решать за линейное время.

\bf{Более быстрые} алгоритмы решения этой задачи хотя и известны, однако они не сильно быстрее $O(n^3)$, и при этом весьма сложны (настолько сложны, что по скрытой константе многие из них уступают тривиальному алгоритму при всех разумных ограничениях). По всей видимости, лучший из известных алгоритмов работает за $O \left( n^3 \frac{ \log^3 \log n }{ \log^2 n} \right)$ (T. Chan 2007 "More algorithms for all-pairs shortest paths in weighted graphs").

Этот алгоритм Chan, а также многие другие результаты в данной области на самом деле описывают \bf{быстрое умножение} матриц (где под умножением матриц подразумевается модифицированное умножение: вместо сложения используется минимум, а вместо умножения --- сложение). Дело в том, что задача о поиске подматрицы с наибольшей суммой сводится к задаче о поиске кратчайших путей между всеми парами вершин, а эта задача, в свою очередь --- сводится к такому умножению матриц.

\h3{ Поиск подотрезка с максимальной/минимальной средней суммой }

Эта задача заключается в том, что надо найти такой отрезок $[l;r]$, чтобы среднее значение на нём было максимальным:

$$ \max_{l \le r} \frac{ 1 }{ r-l+1 } \sum_{i=l}^{r} a[i]. $$

Конечно, если на искомый отрезок $[l;r]$ по условию не наложено других условий, то решением всегда будет являться отрезок длины $1$ в точке-максимуме массива. Задача имеет смысл, только если имеются \bf{дополнительные ограничения} (например, длина искомого отрезка ограничена снизу).

В таком случае применим \bf{стандартный приём} при работе с задачами о среднем значении: будем подбирать искомую максимальную среднюю величину \bf{двоичным поиском}.

Для этого нам надо научиться решать такую подзадачу: дано число $x$, и надо проверить, есть ли подотрезок массива $a[]$ (конечно, удовлетворяющий всем дополнительным ограничениям задачи), на котором среднее значение больше $x$.

Чтобы решить эту подзадачу, отнимем $x$ от каждого элемента массива $a[]$. Тогда наша подзадача фактически превращается в такую: есть или нет в данном массиве подотрезок положительной суммы. А эту задачу мы уже умеем решать.

Таким образом, мы получили решение за асимпотику $O (T(n) \log W)$, где $W$ --- требуемая точность, $T(n)$ --- время решения подзадачи для массива длины $n$ (которое может варьироваться в зависимости от конкретных накладываемых дополнительных ограничений).

\h3{ Решение задачи в режиме онлайн }

Условие задачи таково: дан массив из $n$ чисел, а также дано число $L$. Поступают запросы вида $(l,r)$, и в ответ на запрос требуется найти подотрезок отрезка $[l;r]$ длины не менее $L$ с максимально возможным средним арифметическим.

Алгоритм решения этой задачи достаточно сложен. Автор данного алгоритма --- KADR (Ярослав Твердохлеб) --- \href=http://e-maxx.ru/forum/viewtopic.php?id=410{описал данный алгоритм в своём сообщении на форуме}.
