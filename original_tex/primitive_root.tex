\h1{Первообразные корни}

\h2{Определение}

Первообразным корнем по модулю $n$ (primitive root modulo $n$) называется такое число $g$, что все его степени по модулю $n$ пробегают по всем числам, взаимно простым с $n$. Математически это формулируется таким образом: если $g$ является первообразным корнем по модулю $n$, то для любого целого $a$ такого, что ${\rm gcd}(a,n)=1$, найдётся такое целое $k$, что $g^k \equiv a \pmod{n}$.

В частности, для случая простого $n$ степени первообразного корня пробегают по всем числам от $1$ до $n-1$.

\h2{Существование}

Первообразный корень по модулю $n$ существует тогда и только тогда, когда $n$ является либо степенью нечётного простого, либо удвоенной степенью простого, а также в случаях $n=1$, $n=2$, $n=4$.

Эта теорема (которая была полностью доказана Гауссом в 1801 г.) приводится здесь без доказательства.

\h2{Связь с \algohref=euler_function{функцией Эйлера}}

Пусть $g$ - первообразный корень по модулю $n$. Тогда можно показать, что наименьшее число $k$, для которого $g^k \equiv 1 \pmod{n}$ (т.е. $k$ --- показатель $g$ (multiplicative order)), равно $\phi(n)$. Более того, верно и обратное, и этот факт будет использован нами ниже в алгоритме нахождения первообразного корня.

Кроме того, если по модулю $n$ есть хотя бы один первообразный корень, то всего их $\phi( \phi(n) )$ (т.к. циклическая группа с $k$ элементами имеет $\phi(k)$ генераторов).

\h2{Алгоритм нахождения первообразного корня}

Наивный алгоритм потребует для каждого тестируемого значения $g$ $O(n)$ времени, чтобы вычислить все его степени и проверить, что они все различны. Это слишком медленный алгоритм, ниже мы с помощью нескольких известных теорем из теории чисел получим более быстрый алгоритм.

Выше была приведена теорема о том, что если наименьшее число $k$, для которого $g^k \equiv 1 \pmod{n}$ (т.е. $k$ --- показатель $g$), равно $\phi(n)$, то $g$ --- первообразный корень. Так как для любого числа $a$, взаимно простого с $n$, выполняется \algohref=http://e-maxx.ru/algo/euler_function#4{теорема Эйлера} ($a^{\phi(n)} \equiv 1 \pmod{n}$), то чтобы проверить, что $g$ первообразный корень, достаточно проверить, что для всех чисел $d$, меньших $\phi(n)$, выполнялось $g^d \not\equiv 1 \pmod{n}$. Однако пока это слишком медленный алгоритм.

Из теоремы Лагранжа следует, что показатель любого числа по модулю $n$ является делителем $\phi(n)$. Таким образом, достаточно проверить, что для всех собственных делителей $d\ |\ \phi(n)$ выполняется $g^d \not\equiv 1 \pmod{n}$. Это уже значительно более быстрый алгоритм, однако можно пойти ещё дальше.

Факторизуем число $\phi(n) = p_1^{a_1} \ldots p_s^{a_s}$. Докажем, что в предыдущем алгоритме достаточно рассматривать в качестве $d$ лишь числа вида $\frac{ \phi(n) }{ p_i }$. Действительно, пусть $d$ --- произвольный собственный делитель $\phi(n)$. Тогда, очевидно, найдётся такое $j$, что $d\ |\ \frac{ \phi(n) }{ p_j }$, т.е. $d \cdot k = \frac{ \phi(n) }{ p_j }$. Однако, если бы $g^d \equiv 1 \pmod{n}$, то мы получили бы:
$$ g^{\frac{ \phi(n) }{ p_j }} \equiv g^{d \cdot k} \equiv {\left( g^d \right) }^k \equiv 1^k \equiv 1 \pmod{n}, $$
т.е. всё равно среди чисел вида $\frac{ \phi(n) }{ p_i }$ нашлось бы то, для которого условие не выполнилось, что и требовалось доказать.

Таким образом, алгоритм нахождения первообразного корня такой. Находим $\phi(n)$, факторизуем его. Теперь перебираем все числа $g = 1 \ldots n$, и для каждого считаем все величины $g^{ \frac{ \phi(n) }{ p_i } } \pmod{n}$. Если для текущего $g$ все эти числа оказались отличными от $1$, то это $g$ и является искомым первообразным корнем.

Время работы алгоритма (считая, что у числа $\phi(n)$ имеется $O \left( \log \phi(n) \right)$ делителей, а возведение в степень выполняется алгоритмом \algohref=binary_pow{Бинарного возведения в степень}, т.е. за $O(\log n)$) равно $O \left( {\rm Ans} \cdot \log \phi(n) \cdot \log n \right)$ плюс время факторизации числа $\phi(n)$, где $\rm Ans$ --- результат, т.е. значение искомого первообразного корня.

Про скорость роста первообразных корней с ростом $n$ известны лишь приблизительные оценки. Известно, что первообразные корни --- сравнительно небольшие величины. Одна из известных оценок --- оценка Шупа (Shoup), что, в предположении истинности гипотезы Римана, первообразный корень есть $O (\log^6 n)$.

\h2{Реализация}

Функция powmod() выполняет бинарное возведение в степень по модулю, а функция generator (int p) - находит первообразный корень по простому модулю $p$ (факторизация числа $\phi(n)$ здесь осуществлена простейшим алгоритмом за $O( \sqrt{ \phi(n) } )$).

Чтобы адаптировать эту функцию для произвольных $p$, достаточно добавить вычисление \algohref=euler_function{функции Эйлера} в переменной $phi$, а также отсеивать $res$, не являющиеся взаимно простыми с $n$.

\code
int powmod (int a, int b, int p) {
	int res = 1;
	while (b)
		if (b & 1)
			res = int (res * 1ll * a % p),  --b;
		else
			a = int (a * 1ll * a % p),  b >>= 1;
	return res;
}

int generator (int p) {
	vector<int> fact;
	int phi = p-1,  n = phi;
	for (int i=2; i*i<=n; ++i)
		if (n % i == 0) {
			fact.push_back (i);
			while (n % i == 0)
				n /= i;
		}
	if (n > 1)
		fact.push_back (n);

	for (int res=2; res<=p; ++res) {
		bool ok = true;
		for (size_t i=0; i<fact.size() && ok; ++i)
			ok &= powmod (res, phi / fact[i], p) != 1;
		if (ok)  return res;
	}
	return -1;
}
\endcode
