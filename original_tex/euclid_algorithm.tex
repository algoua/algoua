\h1{Алгоритм Евклида нахождения НОД (наибольшего общего делителя)}

Даны два целых неотрицательных числа $a$ и $b$. Требуется найти их наибольший общий делитель, т.е. наибольшее число, которое является делителем одновременно и $a$, и $b$. На английском языке "наибольший общий делитель" пишется "greatest common divisor", и распространённым его обозначением является ${\rm gcd}$:
$$ {\rm gcd}(a,b) = \max_{k=1 \ldots \infty \ :\  k|a \ \&\  k|b} k $$
(здесь символом "$|$" обозначена делимость, т.е. "$k|a$" обозначает "$k$ делит $a$")

Когда оно из чисел равно нулю, а другое отлично от нуля, их наибольшим общим делителем, согласно определению, будет это второе число. Когда оба числа равны нулю, результат не определён (подойдёт любое бесконечно большое число), мы положим в этом случае наибольший общий делитель равным нулю. Поэтому можно говорить о таком правиле: если одно из чисел равно нулю, то их наибольший общий делитель равен второму числу.

\bf{Алгоритм Евклида}, рассмотренный ниже, решает задачу нахождения наибольшего общего делителя двух чисел $a$ и $b$ за $O (\log \min(a,b))$.

Данный алгоритм был впервые описан в книге Евклида "Начала" (около 300 г. до н.э.), хотя, вполне возможно, этот алгоритм имеет более раннее происхождение.


\h2{Алгоритм}

Сам алгоритм чрезвычайно прост и описывается следующей формулой:

$$ {\rm gcd}(a,b) = \cases{ a, & {\rm if} b=0 \cr {\rm gcd} (b, a\ {\rm mod}\ b), & {\rm otherwise} } $$


\h2{Реализация}

\code
int gcd (int a, int b) {
	if (b == 0)
		return a;
	else
		return gcd (b, a % b);
}
\endcode

Используя тернарный условный оператор C++, алгоритм можно записать ещё короче:

\code
int gcd (int a, int b) {
	return b ? gcd (b, a % b) : a;
}
\endcode

Наконец, приведём и нерекурсивную форму алгоритма:

\code
int gcd (int a, int b) {
	while (b) {
		a %= b;
		swap (a, b);
	}
	return a;
}
\endcode


\h2{Доказательство корректности}

Сначала заметим, что при каждой итерации алгоритма Евклида его второй аргумент строго убывает, следовательно, посколько он неотрицательный, то алгоритм Евклида \bf{всегда завершается}.

Для \bf{доказательства корректности} нам необходимо показать, что ${\rm gcd}(a,b) = {\rm gcd} (b, a\ {\rm mod}\ b)$ для любых $a \ge 0, b > 0$.

Покажем, что величина, стоящая в левой части равенства, делится на настоящую в правой, а стоящая в правой --- делится на стоящую в левой. Очевидно, это будет означать, что левая и правая части совпадают, что и докажет корректность алгоритма Евклида.

Обозначим $d = {\rm gcd}(a,b)$. Тогда, по определению, $d|a$ и $d|b$.

Далее, разложим остаток от деления $a$ на $b$ через их частное:
$$ a\ {\rm mod}\ b = a - b \left\lfloor \frac{a}{b} \right\rfloor $$

Но тогда отсюда следует:
$$ d\ |\ (a\ {\rm mod}\ b) $$

Итак, вспоминая утверждение $d|b$, получаем систему:
$$ \cases{ d\ |\ b, \cr d\ |\ (a\ {\rm mod}\ b) } $$

Воспользуемся теперь следующим простым фактом: если для каких-то трёх чисел $p,q,r$ выполнено: $p|q$ и $p|r$, то выполняется и: $p\ |\ {\rm gcd}(q,r)$. В нашей ситуации получаем:
$$ d\ |\ {\rm gcd}(b, a\ {\rm mod}\ b) $$
Или, подставляя вместо $d$ его определение как ${\rm gcd}(a,b)$, получаем:
$$ {\rm gcd}(a,b)\ |\ {\rm gcd}(b, a\ {\rm mod}\ b) $$

Итак, мы провели половину доказательства: показали, что левая часть делит правую. Вторая половина доказательства производится аналогично.


\h2{Время работы}

Время работы алгоритма оценивается \bf{теоремой Ламе}, которая устанавливает удивительную связь алгоритма Евклида и последовательности Фибоначчи:

Если $a > b \ge 1$ и $b < F_n$ для некоторого $n$, то алгоритм Евклида выполнит не более $n-2$ рекурсивных вызовов.

Более того, можно показать, что верхняя граница этой теоремы --- оптимальная. При $a = F_n, b = F_{n-1}$ будет выполнено именно $n-2$ рекурсивных вызова. Иными словами, \bf{последовательные числа Фибоначчи --- наихудшие входные данные} для алгоритма Евклида.

Учитывая, что числа Фибоначчи растут экспоненциально (как константа в степени $n$), получаем, что алгоритм Евклида выполняется за $O(\log \min(a,b))$ операций умножения.

\h2{НОК (наименьшее общее кратное)}

Вычисление наименьшего общего кратного (least common multiplier, lcm) сводится к вычислению $\rm gcd$ следующим простым утверждением:

$$ {\rm lcm}(a,b) = \frac{ a \cdot b }{ {\rm gcd}(a,b) } $$

Таким образом, вычисление НОК также можно сделать с помощью алгоритма Евклида, с той же асимптотикой:

\code
int lcm (int a, int b) {
	return a / gcd (a, b) * b;
}
\endcode

(здесь выгодно сначала поделить на $\rm gcd$, а только потом домножать на $b$, поскольку это поможет избежать переполнений в некоторых случаях)


\h2{Литература}

\ul{
\li \book{Томас Кормен, Чарльз Лейзерсон, Рональд Ривест, Клиффорд Штайн}{Алгоритмы: Построение и анализ}{2005}{cormen.djvu}
}