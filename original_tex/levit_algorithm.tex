<h1>Алгоритм Левита нахождения кратчайших путей от заданной вершины до всех остальных вершин</h1>

<p>Пусть дан граф с N вершинами и M ребрами, для каждого из которых указан его вес L<sub>i</sub>. Также дана стартовая вершина V<sub>0</sub>. Требуется найти кратчайшие пути от вершины V<sub>0</sub> до всех остальных вершин.</p>
<p>Алгоритм Левита решает эту задачу весьма эффективно (по поводу асимптотики и скорости работы см. ниже).</p>
<h2>Описание</h2>
<p>Пусть массив D[1..N] будет содержать текущие кратчайшие длины путей, т.е. D<sub>i</sub> - это текущая длина кратчайшего пути от вершины V<sub>0</sub> до вершины i. Изначально массив D заполнен значениями "бесконечность", кроме D<sub>V<sub>0</sub></sub> = 0. По окончании работы алгоритма этот массив будет содержать окончательные кратчайшие расстояния.</p>
<p>Пусть массив P[1..N] содержит текущих предков, т.е. P<sub>i</sub> - это вершина, предшествующая вершине i в кратчайшем пути от вершины V<sub>0</sub> до i. Так же как и массив D, массив P изменяется постепенно по ходу алгоритма и к концу его принимает окончательные значения.</p>
<p>&nbsp;</p>
<p>Теперь собственно сам алгоритм Левита. На каждом шаге поддерживается три множества вершин:</p>
<ul>
<li>M<sub>0</sub> - вершины, расстояние до которых уже вычислено (но, возможно, не окончательно);</li>
<li>M<sub>1</sub> - вершины, расстояние до которых вычисляется;</li>
<li>M<sub>2</sub> - вершины, расстояние до которых ещё не вычислено.</li>
</ul>
<p>Вершины в множестве M<sub>1</sub> хранятся в виде двунаправленной очереди (deque).</p>
<p>&nbsp;</p>
<p>Изначально все вершины помещаются в множество M<sub>2</sub>, кроме вершины V<sub>0</sub>, которая помещается в множество M<sub>1</sub>.</p>
<p>На каждом шаге алгоритма мы берём вершину из множества M<sub>1</sub> (достаём верхний элемент из очереди). Пусть V - это выбранная вершина. Переводим эту вершину во множество M<sub>0</sub>. Затем просматриваем все рёбра, выходящие из этой вершины. Пусть T - это второй конец текущего ребра (т.е. не равный V), а L - это длина текущего ребра.</p>
<ul>
<li>Если T принадлежит M<sub>2</sub>, то T переносим во множество M<sub>1</sub> в конец очереди. D<sub>T</sub> полагаем равным D<sub>V</sub> + L.</li>
<li>Если T принадлежит M<sub>1</sub>, то пытаемся улучшить значение D<sub>T</sub>: D<sub>T</sub> = min (D<sub>T</sub>, D<sub>V</sub> + L). Сама вершина T никак не передвигается в очереди.</li>
<li>Если T принадлежит M<sub>0</sub>, и если D<sub>T</sub> можно улучшить (D<sub>T</sub> > D<sub>V</sub> + L), то улучшаем D<sub>T</sub>, а вершину T возвращаем в множество M<sub>1</sub>, помещая её в начало очереди.</li>
</ul>
<p>Разумеется, при каждом обновлении массива D следует обновлять и значение в массиве P.</p>
<h2>Подробности реализации</h2>
<p>Создадим массив ID[1..N], в котором для каждой вершины будем хранить, какому множеству она принадлежит: 0 - если M<sub>2</sub> (т.е. расстояние равно бесконечности), 1 - если M<sub>1</sub> (т.е. вершина находится в очереди), и 2 - если M<sub>0</sub> (некоторый путь уже был найден, расстояние меньше бесконечности).</p>
<p>Очередь обработки можно реализовать стандартной структурой данных deque. Однако есть более эффективный способ. Во-первых, очевидно, в очереди в любой момент времени будет храниться максимум N элементов. Но, во-вторых, мы можем добавлять элементы и в начало, и в конец очереди. Следовательно, мы можем организовать очередь на массиве размера N, однако нужно зациклить его. Т.е. делаем массив Q[1..N], указатели (int) на первый элемент QH и на элемент после последнего QT. Очередь пуста, когда QH == QT. Добавление в конец - просто запись в Q[QT] и увеличение QT на 1; если QT после этого вышел за пределы очереди (QT == N), то делаем QT = 0. Добавление в начало очереди - уменьшаем QH на 1, если она вышла за пределы очереди (QH == -1), то делаем QH = N-1.</p>
<p>Сам алгоритм реализуем в точности по описанию выше.</p>
<h2>Асимптотика</h2>
<p>Мне не известна более-менее хорошая асимптотическая оценка этого алгоритма. Я встречал только оценку O (N M) у похожего алгоритма.</p>
<p>Однако на практике алгоритма зарекомендовал себя очень хорошо: время его работы я оцениваю как <b>O (M log N)</b>, хотя, повторюсь, это исключительно <b>экспериментальная</b> оценка.</p>
<h2>Реализация</h2>
<code>typedef pair&lt;int,int> rib;
typedef vector &lt; vector&lt;rib> > graph;

const int inf = 1000*1000*1000;


int main()
{
	int n, v1, v2;
	graph g (n);

	... чтение графа ...

	vector&lt;int> d (n, inf);
	d[v1] = 0;
	vector&lt;int> id (n);
	deque&lt;int> q;
	q.push_back (v1);
	vector&lt;int> p (n, -1);

	while (!q.empty())
	{
		int v = q.front(),  q.pop_front();
		id[v] = 1;
		for (size_t i=0; i&lt;g[v].size(); ++i)
		{
			int to = g[v][i].first, len = g[v][i].second;
			if (d[to] > d[v] + len)
			{
				d[to] = d[v] + len;
				if (id[to] == 0)
					q.push_back (to);
				else if (id[to] == 1)
					q.push_front (to);
				p[to] = v;
				id[to] = 1;
			}
		}
	}

	... вывод результата ...

}</code>
