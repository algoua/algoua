<h1>Модификация метода Проталкивания предпотока для нахождения максимального потока за O (N<sup>3</sup>)</h1>

<p>Предполагается, что вы уже прочитали <algohref=preflow_push>Метод Проталкивания предпотока нахождения максимального потока за O (N<sup>4</sup>)</algohref>.</p>
<h2>Описание</h2>
<p>Модификация чрезвычайно проста: на каждой итерации среди всех переполненных вершин мы выбираем только те вершины, которые имеют <b>набольшую высоту</b>, и применяем проталкивание/поднятие только к этим вершинам. Более того, для выбора вершин с наибольшей высотой нам не понадобятся никакие структуры данных, достаточно просто хранить список вершин с наибольшей высотой и просто пересчитывать его, если все вершины из этого списка были обработаны (тогда в список добавятся вершины с уже меньшей высотой), а при появлении новой переполненной вершины с большей высотой, чем в списке, очищать список и добавлять вершину в список.</p>
<p>Несмотря на простоту, эта модификация позволяет снизить асимптотику на целый порядок. Если быть точным, асимптотика получившего алгоритма равна <b>O (N M + N<sup>2</sup> sqrt (M))</b>, что в худшем случае составляет <b>O (N<sup>3</sup>)</b>.</p>
<p>Эта модификация была предложена Черияном (Cheriyan) и Махешвари (Maheshvari) в 1989 г.</p>
<h2>Реализация</h2>
<p>Здесь приведена готовая реализация этого алгоритма.</p>
<p>Отличие от обычного алгоритма проталкивания - только в наличии массива maxh, в котором будут храниться номера переполненных вершин с максимальной высотой. Размер массива указан в переменной sz. Если на какой-то итерации оказывается, что этот массив пустой (sz==0), то мы заполняем его (просто проходя по всем вершинам); если после этого массив по-прежнему пустой, то переполненных вершин нет, и алгоритм останавливается. Иначе мы проходим по вершинам в этом списке, применяя к ним проталкивание или поднятие. После выполнения операции проталкивания текущая вершина может перестать быть переполненной, в этом случае удаляем её из списка maxh. Если после какой-то операции поднятия высота текущей вершины становится больше высоты вершин в списке maxh, то мы очищаем список (sz=0), и сразу переходим к следующей итерации алгоритма проталкивания (на которой будет построен новый список maxh).</p>
<code>const int INF = 1000*1000*1000;

int main() {

	int n;
	vector &lt; vector&lt;int> > c (n, vector&lt;int> (n));
	int s, t;
	... чтение n, c, s, t ...

	vector&lt;int> e (n);
	vector&lt;int> h (n);
	h[s] = n-1;
	vector &lt; vector&lt;int> > f (n, vector&lt;int> (n));

	for (int i=0; i&lt;n; ++i) {
		f[s][i] = c[s][i];
		f[i][s] = -f[s][i];
		e[i] = c[s][i];
	}

	vector&lt;int> maxh (n);
	int sz = 0;
	for (;;) {
		if (!sz)
			for (int i=0; i&lt;n; ++i)
				if (i != s && i != t && e[i] > 0) {
					if (sz && h[i] > h[maxh[0]])
						sz = 0;
					if (!sz || h[i] == h[maxh[0]])
						maxh[sz++] = i;
				}
		if (!sz)  break;
		while (sz) {
			int i = maxh[sz-1];
			bool pushed = false;
			for (int j=0; j&lt;n && e[i]; ++j)
				if (c[i][j]-f[i][j] > 0 && h[i] == h[j]+1) {
					pushed = true;
					int addf = min (c[i][j]-f[i][j], e[i]);
					f[i][j] += addf,  f[j][i] -= addf;
					e[i] -= addf,  e[j] += addf;
					if (e[i] == 0)  --sz;
				}
			if (!pushed) {
				h[i] = INF;
				for (int j=0; j&lt;n; ++j)
					if (c[i][j]-f[i][j] > 0 && h[j]+1 &lt; h[i])
						h[i] = h[j]+1;
				if (h[i] > h[maxh[0]]) {
					sz = 0;
					break;
				}
			}
		}
	}

	... вывод потока f ...

}</code>