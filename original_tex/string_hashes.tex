<h1>Алгоритмы хэширования в задачах на строки</h1>

<p>Алгоритмы хэширования строк помогают решить очень много задач. Но у них есть большой недостаток: что чаще всего они не 100%-ны, поскольку есть множество строк, хэши которых совпадают. Другое дело, что в большинстве задач на это можно не обращать внимания, поскольку вероятность совпадения хэшей всё-таки очень мала.</p>

<p>&nbsp;</p>

<h2>Определение хэша и его вычисление</h2>
<p>Один из лучших способов определить хэш-функцию от строки S следующий:</p>
<formula>h(S)  =  S[0]  +  S[1] * P  +  S[2] * P^2  +  S[3] * P^3  +  ...  +  S[N] * P^N</formula>
<p>где P - некоторое число.</p>
<p>Разумно выбирать для P простое число, примерно равное количеству символов во входном алфавите. Например, если строки предполаются состоящими только из маленьких латинских букв, то хорошим выбором будет P = 31. Если буквы могут быть и заглавными, и маленькими, то, например, можно P = 53.</p>
<p>Во всех кусках кода в этой статье будет использоваться P = 31.</p>
<p>Само значение хэша желательно хранить в самом большом числовом типе - int64, он же long long. Очевидно, что при длине строки порядка 20 символов уже будет происходить переполнение значение. Ключевой момент - что мы не обращаем внимание на эти переполнения, как бы беря хэш по модулю 2^64.</p>
<p>Пример вычисления хэша, если допустимы только маленькие латинские буквы:</p>
<code>const int p = 31;
long long hash = 0, p_pow = 1;
for (size_t i=0; i&lt;s.length(); ++i)
{
	// желательно отнимать 'a' от кода буквы
	// единицу прибавляем, чтобы у строки вида 'aaaaa' хэш был ненулевой
	hash += (s[i] - 'a' + 1) * p_pow;
	p_pow *= p;
}</code>
<p>В большинстве задач имеет смысл сначала вычислить все нужные степени P в каком-либо массиве.</p>

<p>&nbsp;</p>

<h2>Пример задачи. Поиск одинаковых строк</h2>
<p>Уже теперь мы в состоянии эффективно решить такую задачу. Дан список строк S[1..N], каждая длиной не более M символов. Допустим, требуется найти все повторяющиеся строки и разделить их на группы, чтобы в каждой группе были только одинаковые строки.</p>
<p>Обычной сортировкой строк мы бы получили алгоритм со сложностью O (N M log N), в то время как используя хэши, мы получим O (N M + N log N).</p>
<p>Алгоритм. Посчитаем хэш от каждой строки, и отсортируем строки по этому хэшу.</p>
<code>vector&lt;string> s (n);
// ... считывание строк ...

// считаем все степени p, допустим, до 10000 - максимальной длины строк
const int p = 31;
vector&lt;long long> p_pow (10000);
p_pow[0] = 1;
for (size_t i=1; i&lt;p_pow.size(); ++i)
	p_pow[i] = p_pow[i-1] * p;

// считаем хэши от всех строк
// в массиве храним значение хэша и номер строки в массиве s
vector &lt; pair&lt;long long, int> > hashes (n);
for (int i=0; i&lt;n; ++i)
{
	long long hash = 0;
	for (size_t j=0; j&lt;s[i].length(); ++j)
		hash += (s[i][j] - 'a' + 1) * p_pow[j];
	hashes[i] = make_pair (hash, i);
}

// сортируем по хэшам
sort (hashes.begin(), hashes.end());

// выводим ответ
for (int i=0, group=0; i&lt;n; ++i)
{
	if (i == 0 || hashes[i].first != hashes[i-1].first)
		cout &lt;&lt; "\nGroup " &lt;&lt; ++group &lt;&lt; ":";
	cout &lt;&lt; ' ' &lt;&lt; hashes[i].second;
}</code>

<p>&nbsp;</p>

<h2>Хэш подстроки и его быстрое вычисление</h2>
<p>Предположим, нам дана строка S, и даны индексы I и J. Требуется найти хэш от подстроки S[I..J].</p>
<p>По определению имеем:</p>
<formula>H[I..J]  =  S[I]  +  S[I+1] * P  +  S[I+2] * P^2  +  ...  + S[J] * P^(J-I)</formula>
<p>откуда:</p>
<formula>H[I..J] * P[I]  =  S[I] * P[I]  +  ...  +  S[J] * P[J],
H[I..J] * P[I]  =  H[0..J]  -  H[0..I-1]</formula>
<p>Полученное свойство является очень важным.</p>
<p>Действительно, получается, что, <b>зная только хэши от всех префиксов строки S, мы можем за O (1) получить хэш любой подстроки</b>.</p>
<p>Единственная возникающая проблема - это то, что нужно уметь делить на P[I]. На самом деле, это не так просто. Поскольку мы вычисляем хэш по модулю 2^64, то для деления на P[I] мы должны найти к нему обратный элемент в поле (например, с помощью <algohref=extended_Euclid_algorithm>Расширенного алгоритма Евклида</algohref>), и выполнить умножение на этот обратный элемент.</p>
<p>Впрочем, есть и более простой путь. В большинстве случаев, <b>вместо того чтобы делить хэши на степени P, можно, наоборот, умножать их на эти степени</b>.</p>
<p>Допустим, даны два хэша: один умноженный на P[I], а другой - на P[J]. Если I &lt; J, то умножим перый хэш на P[J-I], иначе же умножим второй хэш на P[I-J]. Теперь мы привели хэши к одной степени, и можем их спокойно сравнивать.</p>
<p>Например, код, который вычисляет хэши всех префиксов, а затем за O (1) сравнивает две подстроки:</p>
<code>string s;  int i1, i2, len; // входные данные

// считаем все степени p
const int p = 31;
vector&lt;long long> p_pow (s.length());
p_pow[0] = 1;
for (size_t i=1; i&lt;p_pow.size(); ++i)
	p_pow[i] = p_pow[i-1] * p;

// считаем хэши от всех префиксов
vector&lt;long long> h (s.length());
for (size_t i=0; i&lt;s.length(); ++i)
{
	h[i] = (s[i] - 'a' + 1) * p_pow[i];
	if (i)  h[i] += h[i-1];
}

// получаем хэши двух подстрок
long long h1 = h[i1+len-1];
if (i1)  h1 -= h[i1-1];
long long h2 = h[i2+len-1];
if (i2)  h2 -= h[i2-1];

// сравниваем их
if (i1 &lt; i2 && h1 * p_pow[i2-i1] == h2 ||
	i1 > i2 && h1 == h2 * p_pow[i1-i2])
	cout &lt;&lt; "equal";
else
	cout &lt;&lt; "different";</code>

<h2>Применение хэширования</h2>
<p>Вот некоторые типичные применения хэширования:</p>
<ul>
<li><algohref=rabin_karp>Алгоритм Рабина-Карпа поиска подстроки в строке за O (N)</algohref></li>
<li>Определение количества различных подстрок за O (N^2 log N) (см. ниже)</li>
<li>Определение количества палиндромов внутри строки</li>
</ul>

<h2>Определение количества различных подстрок</h2>

<p>Пусть дана строка S длиной N, состоящая только из маленьких латинских букв. Требуется найти количество различных подстрок в этой строке.</p>

<p>Для решения переберём по очереди длину подстроки: L = 1 .. N.</p>
<p>Для каждого L мы построим массив хэшей подстрок длины L, причём приведём хэши к одной степени, и отсортируем этот массив. Количество различных элементов в этом массиве прибавляем к ответу.</p>

<p>Реализация:</p>

<code>string s; // входная строка
int n = (int) s.length();

// считаем все степени p
const int p = 31;
vector&lt;long long> p_pow (s.length());
p_pow[0] = 1;
for (size_t i=1; i&lt;p_pow.size(); ++i)
	p_pow[i] = p_pow[i-1] * p;

// считаем хэши от всех префиксов
vector&lt;long long> h (s.length());
for (size_t i=0; i&lt;s.length(); ++i)
{
	h[i] = (s[i] - 'a' + 1) * p_pow[i];
	if (i)  h[i] += h[i-1];
}

int result = 0;

// перебираем длину подстроки
for (int l=1; l&lt;=n; ++l)
{
	// ищем ответ для текущей длины

	// получаем хэши для всех подстрок длины l
	vector&lt;long long> hs (n-l+1);
	for (int i=0; i&lt;n-l+1; ++i)
	{
		long long cur_h = h[i+l-1];
		if (i)  cur_h -= h[i-1];
		// приводим все хэши к одной степени
		cur_h *= p_pow[n-i-1];
		hs[i] = cur_h;
	}

	// считаем количество различных хэшей
	sort (hs.begin(), hs.end());
	hs.erase (unique (hs.begin(), hs.end()), hs.end());
	result += (int) hs.size();
}

cout &lt;&lt; result;</code>
