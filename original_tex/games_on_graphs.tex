<h1>Игры на произвольных графах</h1>

<p>Пусть игра ведётся двумя игроками на некотором графе G. Т.е. текущее состояние игры - это некоторая вершина графа, и из каждой вершины рёбра идут в те вершины, в которые можно пойти следующим ходом.</p>
<p>Мы рассматриваем самый общий случай - случай произвольного ориентированного графа с циклами. Требуется для заданной начальной позиции определить, кто выиграет при оптимальной игре обоих игроков (или определить, что результатом будет ничья).</p>
<p>Мы решим эту задачу очень эффективно - найдём ответы для всех вершин графа за линейное относительно количества рёбер время - <b>O (M)</b>.</p>
<h2>Описание алгоритма</h2>
<p>Про некоторые вершины графа заранее известно, что они являются выигрышными или проигрышными; очевидно, такие вершины не имеют исходящих рёбер.</p>
<p>Имеем следующие <b>факты</b>:</p>
<ul>
<li>если из некоторой вершины есть ребро в проигрышную вершину, то эта вершина выигрышная;</li>
<li>если из некоторой вершины все рёбра исходят в выигрышные вершины, то эта вершина проигрышная;</li>
<li>если в какой-то момент ещё остались неопределённые вершины, но ни одна из них не подходят ни под первое, ни под второе правило, то все эти вершины - ничейные.</li>
</ul>
<p>Таким образом, уже ясен алгоритм, работающий за асимптотику O (N M) - мы перебираем все вершины, пытаемся к каждой применить первое либо второе правило, и если мы произвели какие-то изменения, то повторяем всё заново.</p>
<p>Однако этот процесс поиска и обновления можно значительно ускорить, доведя асимптотику до линейной.</p>
<p>Переберём все вершины, про которые изначально известно, что они выигрышные или проигрышные. Из каждой из них пустим следующий поиск в глубину. Этот поиск в глубину будет двигаться по обратным рёбрам. Прежде всего, он не будет заходить в вершины, которые уже определены как выигрышные или проигрышные. Далее, если поиск в глубину пытается пойти из проигрышной вершины в некоторую вершину, то её он помечает как выигрышную, и идёт в неё. Если же поиск в глубину пытается пойти из выигрышной вершины в некоторую вершину, то он должен проверить, все ли рёбра ведут из этой вершины в выигрышные. Эту проверку легко осуществить за O (1), если в каждой вершине будем хранить счётчик рёбер, которые ведут в выигрышные вершины. Итак, если поиск в глубину пытается пойти из выигрышной вершины в некоторую вершину, то он увеличивает в ней счётчик, и если счётчик сравнялся с количеством рёбер, исходящих из этой вершины, то эта вершина помечается как проигрышная, и поиск в глубину идёт в эту вершину. Иначе же, если целевая вершина так и не определена как выигрышная или проигрышная, то поиск в глубину в неё не заходит.</p>
<p>Итого, мы получаем, что каждая выигрышная и каждая проигрышная вершина посещается нашим алгоритмом ровно один раз, а ничейные вершины и вовсе не посещаются. Следовательно, асимптотика действительно <b>O (M)</b>.</p>
<h2>Реализация</h2>
<p>Рассмотрим реализацию поиска в глубину, в предположении, что граф игры построен в памяти, степени исхода посчитаны и записаны в degree (это будет как раз счётчиком, он будет уменьшаться, если есть ребро в выигрышную вершину), а также изначально выигрышные или проигрышные вершины уже помечены.</p>
<code>vector&lt;int> g [100];
bool win [100];
bool loose [100];
bool used[100];
int degree[100];

void dfs (int v) {
	used[v] = true;
	for (vector&lt;int>::iterator i = g[v].begin(); i != g[v].end(); ++i)
		if (!used[*i]) {
			if (loose[v])
				win[*i] = true;
			else if (--degree[*i] == 0)
				loose[*i] = true;
			else
				continue;
			dfs (*i);
		}
}</code>
<h2>Пример задачи. "Полицейский и вор"</h2>
<p>Чтобы алгоритм стал более ясным, рассмотрим его на конкретном примере.</p>
<p><b>Условие задачи</b>. Имеется поле размером MxN клеток, в некоторые клетки заходить нельзя. Известны начальные координаты полицейского и вора. Также на карте может присутствовать выход. Если полицейский окажется в одной клетке с вором, то выиграл полицейский. Если же вор окажется в клетке с выходом (и в этой клетке не стоит полицейский), то выиграет вор. Полицейский может ходить в 8 направлениях, вор - только в 4 (вдоль осей координат). И полицейский, и вор могут пропустить свой ход. Первым ход делает полицейский.</p>
<p><b>Построение графа</b>. Построим граф игры. Мы должны формализовать правила игры. Текущее состояние игры определяется координатами полицейского P, вора T, а также булева переменная Pstep, которая определяет, кто будет делать следующий ход. Следовательно, вершина графа определена тройкой (P,T,Pstep). Граф построить легко, просто соответствуя условию.</p>
<p>Далее нужно определить, какие вершины являются выигрышными или проигрышными изначально. Здесь есть <b>тонкий момент</b>. Выигрышность/проигрышность вершины помимо координат зависит и от Pstep - чей сейчас ход. Если сейчас ход полицейского, то вершина выигрышная, если координаты полицейского и вора совпадают; вершина проигрышная, если она не выигрышная и вор находится на выходе. Если же сейчас ход вора, то вершина выигрышная, если вор находится на выходе, и проигрышная, если она не выигрышная и координаты полицейского и вора совпадают.</p>
<p>Единственный момент, которой нужно решить - строить <b>граф явно или</b> делать это "<b>на ходу</b>", прямо в поиске в глубину. С одной стороны, если строить граф предварительно, то будет меньше вероятность ошибиться. С другой стороны, это увеличит объём кода, да и время работы будет в несколько раз медленнее, чем если строить граф "на ходу".</p>
<p><b>Реализация</b> всей программы:</p>
<code>struct state {
	char p, t;
	bool pstep;
};

vector&lt;state> g [100][100][2];
// 1 = policeman coords; 2 = thief coords; 3 = 1 if policeman\'s step or 0 if thief\'s.
bool win [100][100][2];
bool loose [100][100][2];
bool used[100][100][2];
int degree[100][100][2];

void dfs (char p, char t, bool pstep) {
	used[p][t][pstep] = true;
	for (vector&lt;state>::iterator i = g[p][t][pstep].begin(); i != g[p][t][pstep].end(); ++i)
		if (!used[i->p][i->t][i->pstep]) {
			if (loose[p][t][pstep])
				win[i->p][i->t][i->pstep] = true;
			else if (--degree[i->p][i->t][i->pstep] == 0)
				loose[i->p][i->t][i->pstep] = true;
			else
				continue;
			dfs (i->p, i->t, i->pstep);
		}
}


int main() {

	int n, m;
	cin >> n >> m;
	vector&lt;string> a (n);
	for (int i=0; i&lt;n; ++i)
		cin >> a[i];

	for (int p=0; p&lt;n*m; ++p)
		for (int t=0; t&lt;n*m; ++t)
			for (char pstep=0; pstep&lt;=1; ++pstep) {
				int px = p/m, py = p%m, tx=t/m, ty=t%m;
				if (a[px][py]==\'*\' || a[tx][ty]==\'*\')  continue;
				
				bool & wwin = win[p][t][pstep];
				bool & lloose = loose[p][t][pstep];
				if (pstep)
					wwin = px==tx && py==ty,   lloose = !wwin && a[tx][ty] == \'E\';
				else
					wwin = a[tx][ty] == \'E\',   lloose = !wwin && px==tx && py==ty;
				if (wwin || lloose)  continue;

				state st = { p, t, !pstep };
				g[p][t][pstep].push_back (st);
				st.pstep = pstep != 0;
				degree[p][t][pstep] = 1;
				
				const int dx[] = { -1, 0, 1, 0,   -1, -1, 1, 1 };
				const int dy[] = { 0, 1, 0, -1,   -1, 1, -1, 1 };
				for (int d=0; d&lt;(pstep?8:4); ++d) {
					int ppx=px, ppy=py, ttx=tx, tty=ty;
					if (pstep)
						ppx += dx[d],  ppy += dy[d];
					else
						ttx += dx[d],  tty += dy[d];
					if (ppx>=0 && ppx&lt;n && ppy>=0 && ppy&lt;m && a[ppx][ppy]!=\'*\' &&
						ttx>=0 && ttx&lt;n && tty>=0 && tty&lt;m && a[ttx][tty]!=\'*\')
					{
						g[ppx*m+ppy][ttx*m+tty][!pstep].push_back (st);
						++degree[p][t][pstep];
					}
				}
			}

	for (int p=0; p&lt;n*m; ++p)
		for (int t=0; t&lt;n*m; ++t)
			for (char pstep=0; pstep&lt;=1; ++pstep)
				if ((win[p][t][pstep] || loose[p][t][pstep]) && !used[p][t][pstep])
					dfs (p, t, pstep!=0);

	int p_st, t_st;
	for (int i=0; i&lt;n; ++i)
		for (int j=0; j&lt;m; ++j)
			if (a[i][j] == \'C\')
				p_st = i*m+j;
			else if (a[i][j] == \'T\')
				t_st = i*m+j;

	cout &lt;&lt; (win[p_st][t_st][true] ? "WIN" : loose[p_st][t_st][true] ? "LOSS" : "DRAW");

}</code>