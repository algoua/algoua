<h1>Задача RMQ (Range Minimum Query - минимум на отрезке)</h1>

<p>Дан массив A[1..N]. Поступают запросы вида (L, R), на каждый запрос требуется найти минимум в массиве A, начиная с позиции L и заканчивая позицией R.</p>
<h2>Приложения</h2>
<p>Помимо непосредственного применения в самых разных задачах, можно отметить следующие:</p>
<ul>
<li><algohref=lca>Задача LCA (наименьший общий предок)</algohref></li>
</ul>
<h2>Решение</h2>
<p>Задача RMQ решается с помощью структур данных.</p>
<p>Из описанных на сайте структур данных можно выбрать:</p>
<ul>
<li><algohref=sqrt_decomposition><b>Sqrt-декомпозиция</b></algohref> - отвечает на запрос за O (sqrt (N)), препроцессинг за O (N).<br>Преимущество в том, что это очень простая структура данных. Недостаток - асимптотика.</li>
<li><algohref=segment_tree><b>Дерево отрезков</b></algohref> - отвечает на запрос за O (log N), препроцессинг за O (N).<br>Преимущество - хорошая асимптотика. Недостаток - бОльший объём кода по сравнению с другими структурами данных.</li>
<li><algohref=fenwick_tree><b>Дерево Фенвика</b></algohref> - отвечает на запрос за O (log N), препроцессинг за O (N log N)<br>Преимущество - очень быстро пишется и работает тоже очень быстро. Но значительный недостаток - дерево Фенвика может отвечать только на запросы с L = 1, что для многих приложений неприменимо.</li>
</ul>
<p>Примечание. "Препроцессинг" - это предварительная обработка массива A, фактически это построение структуры данных для данного массива.</p>
<p>Теперь предположим, что массив A <b>может изменяться</b> в процессе работы (т.е. также будут поступать запросы об изменении значения в некотором отрезке [L;R]). Тогда полученную задачу можно решить с помощью <algohref=sqrt_decomposition><b>Sqrt-декомпозиции</b></algohref> и <algohref=segment_tree><b>Дерева отрезков</b></algohref>.</p>