\h1{Нахождение кратчайших путей от заданной вершины до всех остальных вершин алгоритмом Дейкстры}

\h2{Постановка задачи}

Дан ориентированный или неориентированный взвешенный граф с $n$ вершинами и $m$ рёбрами. Веса всех рёбер неотрицательны. Указана некоторая стартовая вершина $s$. Требуется найти длины кратчайших путей из вершины $s$ во все остальные вершины, а также предоставить способ вывода самих кратчайших путей.

Эта задача называется "задачей о кратчайших путях с единственным источником" (single-source shortest paths problem).

\h2{Алгоритм}

Здесь описывается алгоритм, который предложил голландский исследователь \bf{Дейкстра} (Dijkstra) в 1959 г.

Заведём массив $d[]$, в котором для каждой вершины $v$ будем хранить текущую длину $d[v]$ кратчайшего пути из $s$ в $v$. Изначально $d[s]=0$, а для всех остальных вершин эта длина равна бесконечности (при реализации на компьютере обычно в качестве бесконечности выбирают просто достаточно большое число, заведомо большее возможной длины пути):
$$ d[v] = \infty, v \ne s $$

Кроме того, для каждой вершины $v$ будем хранить, помечена она ещё или нет, т.е. заведём булевский массив $u[]$. Изначально все вершины не помечены, т.е.
$$ u[v] = {\rm false} $$

Сам алгоритм Дейкстры состоит из $n$ \bf{итераций}. На очередной итерации выбирается вершина $v$ с наименьшей величиной $d[v]$ среди ещё не помеченных, т.е.:
$$ d[v] = \min_{p:\ u[p]={\rm false}} d[p] $$

(Понятно, что на первой итерации выбрана будет стартовая вершина $s$.)

Выбранная таким образом вершина $v$ отмечается помеченной. Далее, на текущей итерации, из вершины $v$ производятся \bf{релаксации}: просматриваются все рёбра $(v,to)$, исходящие из вершины $v$, и для каждой такой вершины $to$ алгоритм пытается улучшить значение $d[to]$. Пусть длина текущего ребра равна $\rm len$, тогда в виде кода релаксация выглядит как:
$$ d[to] = \min (d[to], d[v] + {\rm len}) $$

На этом текущая итерация заканчивается, алгоритм переходит к следующей итерации (снова выбирается вершина с наименьшей величиной $d$, из неё производятся релаксации, и т.д.). При этом в конце концов, после $n$ итераций, все вершины графа станут помеченными, и алгоритм свою работу завершает. Утверждается, что найденные значения $d[v]$ и есть искомые длины кратчайших путей из $s$ в $v$.

Стоит заметить, что, если не все вершины графа достижимы из вершины $s$, то значения $d[v]$ для них так и останутся бесконечными. Понятно, что несколько последних итераций алгоритма будут как раз выбирать эти вершины, но никакой полезной работы производить эти итерации не будут (поскольку бесконечное расстояние не сможет прорелаксировать другие, даже тоже бесконечные расстояния). Поэтому алгоритм можно сразу останавливать, как только в качестве выбранной вершины берётся вершина с бесконечным расстоянием.

\bf{Восстановление путей}. Разумеется, обычно нужно знать не только длины кратчайших путей, но и получить сами пути. Покажем, как сохранить информацию, достаточную для последующего восстановления кратчайшего пути из $s$ до любой вершины. Для этого достаточно так называемого \bf{массива предков}: массива $p[]$, в котором для каждой вершины $v \ne s$ хранится номер вершины $p[v]$, являющейся предпоследней в кратчайшем пути до вершины $v$. Здесь используется тот факт, что если мы возьмём кратчайший путь до какой-то вершины $v$, а затем удалим из этого пути последнюю вершину, то получится путь, оканчивающийся некоторой вершиной $p[v]$, и этот путь будет кратчайшим для вершины $p[v]$. Итак, если мы будем обладать этим массивом предков, то кратчайший путь можно будет восстановить по нему, просто каждый раз беря предка от текущей вершины, пока мы не придём в стартовую вершину $s$ --- так мы получим искомый кратчайший путь, но записанный в обратном порядке. Итак, кратчайший путь $P$ до вершины $v$ равен:
$$ P = (s, \ldots, p[p[p[v]]], p[p[v]], p[v], v) $$

Осталось понять, как строить этот массив предков. Однако это делается очень просто: при каждой успешной релаксации, т.е. когда из выбранной вершины $v$ происходит улучшение расстояния до некоторой вершины $to$, мы записываем, что предком вершины $to$ является вершина $v$:
$$ p[to] = v $$

\h2{Доказательство}

\bf{Основное утверждение}, на котором основана корректность алгоритма Дейкстры, следующее. Утверждается, что после того как какая-либо вершина $v$ становится помеченной, текущее расстояние до неё $d[v]$ уже является кратчайшим, и, соответственно, больше меняться не будет.

\bf{Доказательство} будем производить по индукции. Для первой итерации справедливость его очевидна --- для вершины $s$ имеем $d[s]=0$, что и является длиной кратчайшего пути до неё. Пусть теперь это утверждение выполнено для всех предыдущих итераций, т.е. всех уже помеченных вершин; докажем, что оно не нарушается после выполнения текущей итерации. Пусть $v$ --- вершина, выбранная на текущей итерации, т.е. вершина, которую алгоритм собирается пометить. Докажем, что $d[v]$ действительно равно длине кратчайшего пути до неё (обозначим эту длину через $l[v]$).

Рассмотрим кратчайший путь $P$ до вершины $v$. Понятно, этот путь можно разбить на два пути: $P_1$, состоящий только из помеченных вершин (как минимум стартовая вершина $s$ будет в этом пути), и остальная часть пути $P_2$ (она тоже может включать помеченные вершины, но начинается обязательно с непомеченной). Обозначим через $p$ первую вершину пути $P_2$, а через $q$ --- последнюю вершины пути $P_1$.

Докажем сначала наше утверждение для вершины $p$, т.е. докажем равенство $d[p] = l[p]$. Однако это практически очевидно: ведь на одной из предыдущих итераций мы выбирали вершину $q$ и выполняли релаксацию из неё. Поскольку (в силу самого выбора вершины $p$) кратчайший путь до $p$ равен кратчайшему пути до $q$ плюс ребро $(p,q)$, то при выполнении релаксации из $q$ величина $d[p]$ действительно установится в требуемое значение.

Вследствие неотрицательности стоимостей рёбер длина кратчайшего пути $l[p]$ (а она по только что доказанному равна $d[p]$) не превосходит длины $l[v]$ кратчайшего пути до вершины $v$. Учитывая, что $l[v] \le d[v]$ (ведь алгоритм Дейкстры не мог найти более короткого пути, чем это вообще возможно), в итоге получаем соотношения:
$$ d[p] = l[p] \le l[v] \le d[v] $$

С другой стороны, поскольку и $p$, и $v$ --- вершины непомеченные, то так как на текущей итерации была выбрана именно вершина $v$, а не вершина $p$, то получаем другое неравенство:
$$ d[p] \ge d[v] $$

Из этих двух неравенств заключаем равенство $d[p] = d[v]$, а тогда из найденных до этого соотношений получаем и:
$$ d[v] = l[v] $$

что и требовалось доказать.

\h2{Реализация}

Итак, алгоритм Дейкстры представляет собой $n$ итераций, на каждой из которых выбирается непомеченная вершина с наименьшей величиной $d[v]$, эта вершина помечается, и затем просматриваются все рёбра, исходящие из данной вершины, и вдоль каждого ребра делается попытка улучшить значение $d[]$ на другом конце ребра.

Время работы алгоритма складывается из:
\ul{
\li $n$ раз поиск вершины с наименьшей величиной $d[v]$ среди всех непомеченных вершин, т.е. среди $O(n)$ вершин
\li $m$ раз производится попытка релаксаций
}

При простейшей реализации этих операций на поиск вершины будет затрачиваться $O(n)$ операций, а на одну релаксацию --- $O(1)$ операций, и итоговая \bf{асимптотика} алгоритма составляет:
$$ O(n^2+m) $$

\bf{Реализация}:

\code
const int INF = 1000000000;

int main() {
	int n;
	... чтение n ...
	vector < vector < pair<int,int> > > g (n);
	... чтение графа ...
	int s = ...; // стартовая вершина

	vector<int> d (n, INF),  p (n);
	d[s] = 0;
	vector<char> u (n);
	for (int i=0; i<n; ++i) {
		int v = -1;
		for (int j=0; j<n; ++j)
			if (!u[j] && (v == -1 || d[j] < d[v]))
				v = j;
		if (d[v] == INF)
			break;
		u[v] = true;

		for (size_t j=0; j<g[v].size(); ++j) {
			int to = g[v][j].first,
				len = g[v][j].second;
			if (d[v] + len < d[to]) {
				d[to] = d[v] + len;
				p[to] = v;
			}
		}
	}
}
\endcode

Здесь граф $g$ хранится в виде списков смежности: для каждой вершины $v$ список $g[v]$ содержит список рёбер, исходящих из этой вершины, т.е. список пар $\rm pair<int,int>$, где первый элемент пары --- вершина, в которую ведёт ребро, а второй элемент --- вес ребра.

После чтения заводятся массивы расстояний $d[]$, меток $u[]$ и предков $p[]$. Затем выполняются $n$ итераций. На каждой итерации сначала находится вершина $v$, имеющая наименьшее расстояние $d[]$ среди непомеченных вершин. Если расстояние до выбранной вершины $v$ оказывается равным бесконечности, то алгоритм останавливается. Иначе вершина помечается как помеченная, и просматриваются все рёбра, исходящие из данной вершины, и вдоль каждого ребра выполняются релаксации. Если релаксация успешна (т.е. расстояние $d[to]$ меняется), то пересчитывается расстояние $d[to]$ и сохраняется предок $p[]$.

После выполнения всех итераций в массиве $d[]$ оказываются длины кратчайших путей до всех вершин, а в массиве $p[]$ --- предки всех вершин (кроме стартовой $s$). Восстановить путь до любой вершины $t$ можно следующим образом:
\code
vector<int> path;
for (int v=t; v!=s; v=p[v])
	path.push_back (v);
path.push_back (s);
reverse (path.begin(), path.end());
\endcode

\h2{Литература}

\ul{
\li \book{Томас Кормен, Чарльз Лейзерсон, Рональд Ривест, Клиффорд Штайн}{Алгоритмы: Построение и анализ}{2005}{cormen.djvu}
\li \book{Edsger Dijkstra}{A note on two problems in connexion with graphs}{1959}
}