---
id: big_integer
title: Довга арифметика
description: Алгоритми для довгих чисел
keywords:
  - Алгоритм
  - Алгебра
  - Великі числа
---

Довга арифметика - це набір програмних засобів (структур даних і алгоритмів), які дозволяють працювати з числами набагато більших величин, ніж це дозволяють стандартні типи даних.

## Види цілочисельної довгої арифметики

Взагалі кажучи, навіть тільки в олімпіадних завданнях набір засобів досить великий, тому зробимо класифікацію різних видів довгої арифметики.

### Класична довга арифметика

Основна ідея полягає в тому, що число зберігається у вигляді масиву його цифр.

Цифри можуть використовуватися у тій або іншій системі числення, зазвичай застосовується десяткова система числення і її степені (десять тисяч, мільярд), або двійкова система числення.

Операції над числами у цьому вигляді довгої арифметики виконуються за допомогою "шкільних" алгоритмів складання, віднімання, множення та ділення стовпчиком. Однак до них також застосовуються алгоритми швидкого множення: [Швидке перетворення Фур'є](fft_multiply) та Алгоритм Карацуби.

Тут описана робота тільки з не від'ємними довгими числами. Для підтримки від'ємних чисел необхідно ввести та підтримувати додатковий прапорець "від'ємності" числа, або працювати в доповнюючих кодах.

#### Структура даних

Будемо зберігати довгі числа у вигляді вектора чисел $int$, де кожен елемент - це одна цифра числа.

<!--- TODO: specify code snippet id -->
``` cpp
typedef vector<int> lnum;
```

Для підвищення ефективності будемо працювати в системі за основою мільярд, тобто кожен елемент вектора $lnum$ містить не одну, а одразу $9$ цифр:

<!--- TODO: specify code snippet id -->
``` cpp
const int base = 1000*1000*1000;
```

Цифри будуть зберігатися в векторі в такому порядку, що спочатку йдуть найменш значущі цифри (тобто одиниці, десятки, сотні, і т.д.).

Крім того, всі операції будуть реалізовані таким чином, що після виконання будь-якої з них лідируючі нулі (тобто зайві нулі в початку числа) відсутні (звісно, в припущенні, що перед кожною операцією лідируючі нулі також відсутні). Слід відзначити, що в представленій реалізації для числа нуль правильно підтримуються зразу два уявлення: порожній вектор цифр, і вектор цифр, що містить єдиний елемент - нуль.

#### Вивід

Найпростіший спосіб - це виведення довгого числа.

Спочатку ми просто виводимо самий останній елемент вектора (або $0$, якщо вектор порожній), а потім виводимо всі залишившіся елементи вектора, доповнюючи їх нулями до $9$ символів:

<!--- TODO: specify code snippet id -->
``` cpp
printf ("%d", a.empty() ? 0 : a.back());
for (int i=(int)a.size()-2; i>=0; --i)
    printf ("%09d", a[i]);
```

(тут є невеликий тонкий момент: потрібно не забути записати приведення типу $(int)$, оскільки в іншому випадку число $a.size()$ буде беззнаковим, і якщо $a.size() \le 1$, то при відніманні відбудеться переповнення)

#### Читання

Зчитуємо рядок у $string$, а потім перетворюємо його в вектор:

<!--- TODO: specify code snippet id -->
``` cpp
for (int i=(int)s.length(); i>0; i-=9)
    if (i < 9)
        a.push_back (atoi (s.substr (0, i).c_str()));
    else
        a.push_back (atoi (s.substr (i-9, 9).c_str()));
```

Якщо використати замість $string$ масив символів $char$, то код вийде ще компактніше.

<!--- TODO: specify code snippet id -->
``` cpp
for (int i=(int)strlen(s); i>0; i-=9) {
    s[i] = 0;
    a.push_back (atoi (i>=9 ? s+i-9 : s));
}
```

Якщо вхідне число може містити лідируючі нулі, то їх можна видалити після зчитування за допомогою наступного методу:

<!--- TODO: specify code snippet id -->
``` cpp
while (a.size() > 1 && a.back() == 0)
    a.pop_back();
```

#### Додавання

Додає до числа $a$ число $b$ і зберігає результат у $a$:

<!--- TODO: specify code snippet id -->
``` cpp
int carry = 0;
for (size_t i=0; i<max(a.size(),b.size()) || carry; ++i) {
    if (i == a.size())
        a.push_back (0);
    a[i] += carry + (i < b.size() ? b[i] : 0);
    carry = a[i] >= base;
    if (carry)  a[i] -= base;
}
```

#### Віднімання

Віднімає від числа $a$ число $b$ ($a \ge b$) і зберігає результат у $a$:

<!--- TODO: specify code snippet id -->
``` cpp
int carry = 0;
for (size_t i=0; i<b.size() || carry; ++i) {
    a[i] -= carry + (i < b.size() ? b[i] : 0);
    carry = a[i] < 0;
    if (carry)  a[i] += base;
}
while (a.size() > 1 && a.back() == 0)
    a.pop_back();
```

Тут після виконання обчислення видаляємо ведучі нулі, щоб підтримувати твердження про те, що вони відсутні.

#### Множення довгого на коротке

Помножити довге число $a$ на коротке $b$ ($b < {\rm base}$) і зберегти результат у $a$:

<!--- TODO: specify code snippet id -->
``` cpp
int carry = 0;
for (size_t i=0; i<a.size() || carry; ++i) {
    if (i == a.size())
        a.push_back (0);
    long long cur = carry + a[i] * 1ll * b;
    a[i] = int (cur % base);
    carry = int (cur / base);
}
while (a.size() > 1 && a.back() == 0)
    a.pop_back();
```

Тут після виконання ділення видаляємо ведучі нулі, щоб підтримувати твердження про те, що вони відсутні.

(Зауваження: якщо швидкість роботи надзвичайно важлива, можна спробувати оптимізувати код, замінивши два ділення на одне: спочатку порахувати лише цілу частину від ділення (зберігається у змінній $carry$), а потім розрахувати залишок від ділення (за допомогою одного множення). Зазвичай цей прийом дозволяє прискорити код, хоча й не дуже суттєво).

#### Множення двох довгих чисел

Помножити довге число $a$ на число $b$ і зберегти результат у $c$:

<!--- TODO: specify code snippet id -->
``` cpp
lnum c (a.size()+b.size());
for (size_t i=0; i<a.size(); ++i)
    for (int j=0, carry=0; j<(int)b.size() || carry; ++j) {
        long long cur = c[i+j] + a[i] * 1ll * (j < (int)b.size() ? b[j] : 0) + carry;
        c[i+j] = int (cur % base);
        carry = int (cur / base);
    }
while (c.size() > 1 && c.back() == 0)
    c.pop_back();
```

#### Ділення довгого на коротке

Поділити довге число $a$ на коротке $b$ ($b < {\rm base}$), зберігти результат у $a$, а залишок - у $carry$:

<!--- TODO: specify code snippet id -->
``` cpp
int carry = 0;
for (int i=(int)a.size()-1; i>=0; --i) {
    long long cur = a[i] + carry * 1ll * base;
    a[i] = int (cur / b);
    carry = int (cur % b);
}
while (a.size() > 1 && a.back() == 0)
    a.pop_back();
```

### Довга арифметика в факторизованном вигляді

Тут ідея полягає в тому, щоб зберігати не саме число, а його факторизацію, тобто степені кожного простого множника, який входить до числа.

Цей метод є дуже простим для реалізації, і в ньому дуже легко виконувати операції множення і ділення, але неможливо виконувати операції додавання і віднімання. З іншого боку, цей метод значно економить пам'ять порівняно з "класичним" підходом і дозволяє виконувати множення і ділення значно швидше (асимптотично).

Цей метод часто використовується, коли необхідно виконати ділення за непростим модулем: тоді достатньо зберігати число у вигляді степенів простих множників цього модуля та ще одного числа - залишку по цьому ж модулю.

### Довга арифметика за системою простих модулів (Китайська теорема або схема Гарнера)

Суть полягає в тому, що вибирається деяка система модулів (зазвичай невеликих, що поміщаються у стандартні типи даних), і число зберігається у вигляді вектора з залишками від його ділення на кожен з цих модулів.

За Китайською теоремою про залишки цього достатньо, щоб однозначно зберігати будь-яке число в діапазоні від 0 до добутку цих модулів мінус один. При цьому є [Алгоритм Гарнера](chinese_theorem), який дозволяє провести перетворення з модульного представлення до звичайного, "класичного", виду числа.

Таким чином, цей метод дозволяє економити пам'ять порівняно з "класичною" довгою арифметикою (хоча в деяких випадках не настільки радикально, як метод факторизації). Крім того, у модульному вигляді можна дуже швидко виконувати операції додавання, віднімання та множення, - всі вони виконуються за асимптотично однаковий час, пропорційний кількості модулів у системі.

Однак все це дається ціною вельми трудомісткого перетворення числа з модульного представлення до звичайного виду, для чого, окрім немалих часових затрат, буде потрібна також реалізація "класичної" довгої арифметики з операцією множення.

Крім того, виконання **операції ділення** чисел у цьому представленні за системою простих модулів не є можливим.

## Види дробової довгої арифметики

Операції над дробовими числами зустрічаються в олімпійських завданнях набагато рідше, а працювати з великими дробовими числами значно складніше. Тому в олімпіадах зустрічається лише специфічна підмножина дробової довгої арифметики.

### Довга арифметика у незведених дробах

Число представлене у вигляді нескоротної дробу $\frac{a}{b}$, де $a$ і $b$ - цілі числа. Отже, всі операції над дробовими числами можна звести до операцій над чисельниками та знаменниками цих дробів.

Зазвичай для зберігання чисельника та знаменника доводиться також використовувати довгу арифметику, але, однак, найпростіший її вигляд - "класична" довга арифметика, іноді виявляється достатнім вбудованого 64-бітного числового типу.

### Виділення позиції плаваючою точкою в окремий тип

Іноді в задачах потрібно виконувати обчислення з дуже великими або дуже малими числами, не допускаючи їх переповнення. Вбудований тип з плаваючою точкою $double$, як відомо, допускає значення експоненти в діапазоні від $[-308; 308]$, що іноді може бути недостатнім.

Прийом, власне, дуже простий: вводиться ще одна цілочислена змінна, яка відповідає за експоненту, і після кожної операції дробове число "нормалізується", тобто повертається до відрізку $[0.1; 1)$, шляхом збільшення або зменшення експоненти.

При множенні або діленні двох таких чисел потрібно відповідно додати або відняти їх експоненти. При додаванні або відніманні перед виконанням цієї операції числа потрібно привести до однієї експоненти, для чого одне з них домножується на $2$ в степені різниці експонент.

Нарешті, зрозуміло, що не обов'язково вибирати $10$ в якості основи експоненти. Виходячи з устрою вбудованих типів з плаваючою точкою, самим вигідним є використання основи, рівної $2$.

