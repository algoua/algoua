[{"title":"Алгоритми","type":0,"sectionRef":"#","url":"algorithms","content":"Алгоритми Метою цього розділу є надати якомога більшу кількість алгоритмічних статей та розподілити їх по категоріях. Якщо ви хочете почати вивчати алгоритми або вивчити більшу кількість алгоритмів, то варто переглянути розділ курси. Алгебра Бінарне піднесення у степіньФункція ЕйлераАлгоритм Евкліда знаходження НСДРозширений алгоритм Евкліда Геометрія Довжина об'єднання відрізків на прямій Графи Базові алгоритми Пошук в глибинуПошук в ширинуТопологічне сортуванняПошук компонент зв'язності у графі Мінімальнe каркасне дерево Алгоритм Крускала","keywords":"Алгоритми"},{"title":"Алгоритм Евкліда знаходження НСД","type":0,"sectionRef":"#","url":"algorithms/algebra/euclid_algorithm","content":"","keywords":"Алгоритм Евклід НСД НСК GCD LCM"},{"title":"Алгоритм","type":1,"pageTitle":"Алгоритм Евкліда знаходження НСД","url":"algorithms/algebra/euclid_algorithm#алгоритм","content":"Сам алгоритм надзвичайно простий і описується наступною формулою: gcd(a,b)={a,якщо b=0gcd(b,a mod b),інакше{\\rm gcd}(a,b) = \\begin{cases} a, & \\text{якщо }b=0 \\cr {\\rm gcd} (b, a\\ {\\rm mod}\\ b), & \\text{інакше} \\end{cases}gcd(a,b)={a,gcd(b,a mod b),​якщо b=0інакше​ "},{"title":"Реалізація","type":1,"pageTitle":"Алгоритм Евкліда знаходження НСД","url":"algorithms/algebra/euclid_algorithm#реалізація","content":"int gcd(int a, int b) { if (b == 0) { return a; } else { return gcd(b, a % b); }} Copy Використовуючи тернарний умовний оператор C++, алгоритм можна записати ще коротше: int gcd(int a, int b) { return b ? gcd(b, a % b) : a;} Copy Оптимальніша нерекурсивна форма алгоритму: int gcd(int a, int b) { while (b) { a %= b; swap(a, b); } return a;} Copy "},{"title":"Доведення коректності","type":1,"pageTitle":"Алгоритм Евкліда знаходження НСД","url":"algorithms/algebra/euclid_algorithm#доведення-коректності","content":"Спочатку зауважимо, що при кожній ітерації алгоритму Евкліда його другий аргумент завжди зменшується, а отже, оскільки він невід'ємний, алгоритм Евкліда завжди завершується. Для доведення коректності нам необхідно показати, що gcd(a,b)=gcd(b,a mod b){\\rm gcd}(a,b) = {\\rm gcd} (b, a\\ {\\rm mod}\\ b)gcd(a,b)=gcd(b,a mod b) для будь-яких a≥0,b>0a \\ge 0, b > 0a≥0,b>0. Покажемо, що величина, що стоїть в лівій частини рівності, ділиться на величину у правій, а та, шо стоїть у правій - ділиться на величину у лівій. Очевидно, це буде означати, що ліва і права частини збігаються, що і доведе коректність алгоритму Евкліда. Позначимо d=gcd(a,b)d = {\\rm gcd}(a,b)d=gcd(a,b). Значить, за визначенням, d∣ad|ad∣a і d∣bd|bd∣b. Далі, розкладемо залишок від ділення aaa на bbb через їх частку: a mod b=a−b⌊ab⌋a\\ {\\rm mod}\\ b = a - b \\left\\lfloor \\frac{a}{b} \\right\\rfloora mod b=a−b⌊ba​⌋ Звідси випливає: d ∣ (a mod b)d\\ |\\ (a\\ {\\rm mod}\\ b)d ∣ (a mod b) Отже, згадуючи твердження d∣bd|bd∣b, отримуємо систему: {d ∣ b,d ∣ (a mod b)\\begin{cases} d\\ |\\ b, \\cr d\\ |\\ (a\\ {\\rm mod}\\ b) \\end{cases}{d ∣ b,d ∣ (a mod b)​ Скористаємося тепер наступним простим фактом: якщо для якихось трьох чисел p,q,rp,q,rp,q,r виконуються: p∣qp|qp∣q і p∣rp|rp∣r, то виконується і: p ∣ gcd(q,r)p\\ |\\ {\\rm gcd}(q,r)p ∣ gcd(q,r). У нашій ситуації отримуємо: d ∣ gcd(b,a mod b)d\\ |\\ {\\rm gcd}(b, a\\ {\\rm mod}\\ b)d ∣ gcd(b,a mod b) Або, підставляючи замість ddd його визначення як gcd(a,b){\\rm gcd}(a,b)gcd(a,b), отримуємо: gcd(a,b) ∣ gcd(b,a mod b){\\rm gcd}(a,b)\\ |\\ {\\rm gcd}(b, a\\ {\\rm mod}\\ b)gcd(a,b) ∣ gcd(b,a mod b) Отже, ми здійснили половину доведення: показали, що ліва частина ділить праву. Друга половина доведення аналогічна. "},{"title":"Час роботи","type":1,"pageTitle":"Алгоритм Евкліда знаходження НСД","url":"algorithms/algebra/euclid_algorithm#час-роботи","content":"Час роботи алгоритму оцінюється теоремою Ламе, яка встановлює дивовижний зв'язок алгоритму Евкліда і послідовності Фібоначчі: Якщо a>b≥1a > b \\ge 1a>b≥1 і b<Fnb < F_nb<Fn​ для деякого nnn, то алгоритм Евкліда виконає не більше n−2n-2n−2 рекурсивних викликів. Більше того, можна показати, що верхня межа цієї теореми - оптимальна. При a=Fn,b=Fn−1a = F_n, b = F_{n-1}a=Fn​,b=Fn−1​ буде виконано саме n−2n-2n−2 рекурсивних викликів. Іншими словами, послідовні числа Фібоначчі - найгірші вхідні дані для алгоритму Евкліда. Враховуючи, що числа Фібоначчі ростуть експоненціально (як константа в степені nnn), отримуємо, що алгоритм Евкліда виконується за O(log⁡min⁡(a,b))O(\\log \\min(a,b))O(logmin(a,b)) операцій множення. "},{"title":"Застосування","type":1,"pageTitle":"Алгоритм Евкліда знаходження НСД","url":"algorithms/algebra/euclid_algorithm#застосування","content":""},{"title":"НСК","type":1,"pageTitle":"Алгоритм Евкліда знаходження НСД","url":"algorithms/algebra/euclid_algorithm#нск","content":"Обчислення найменшого спільного кратного (least common multiplier, lcm) зводиться до обчислення gcd\\rm gcdgcd наступним простим твердженням: lcm(a,b)=a⋅bgcd(a,b){\\rm lcm}(a,b) = \\frac{ a \\cdot b }{ {\\rm gcd}(a,b) }lcm(a,b)=gcd(a,b)a⋅b​ Таким чином, обчислення НСК також можна здійснити за допомогою алгоритму Евкліда, з тією ж асимптотикою: int lcm(int a, int b) { return a / gcd(a, b) * b;} Copy Зауваження Варто спочатку поділити на gcd\\rm gcdgcd, а тільки потім помножити на bbb, оскільки це допоможе уникнути переповнення типу у деяких випадках. "},{"title":"Задачі","type":1,"pageTitle":"Алгоритм Евкліда знаходження НСД","url":"algorithms/algebra/euclid_algorithm#задачі","content":"CodeChef - FLOW016 - GCD and LCM "},{"title":"Бінарне піднесення у степінь","type":0,"sectionRef":"#","url":"algorithms/algebra/binary_pow","content":"","keywords":"Алгоритм Бінарний Степінь"},{"title":"Алгоритм","type":1,"pageTitle":"Бінарне піднесення у степінь","url":"algorithms/algebra/binary_pow#алгоритм","content":"Зауважимо, що для будь-якого числа aaa і парного числа nnn виконується тотожність (випливає з асоціативності операції множення): an=(an/2)2=an/2⋅an/2a^n = (a^{n/2})^2 = a^{n/2} \\cdot a^{n/2}an=(an/2)2=an/2⋅an/2 Вона і є основною в методі бінарного піднесення у степінь. Дійсно, для парного nnn ми показали, як, витративши всього лиш одну операцію множення, можна звести до задачі з вдвічі меншим степенем. Залишилося зрозуміти, що робити, якщо степінь nnn непарна. Тут все дуже просто: перейдемо до степені n−1n-1n−1, яка вже буде парною: an=an−1⋅aa^n = a^{n-1} \\cdot aan=an−1⋅a Отже, ми фактично знайшли рекурентну формулу: від степені nnn ми переходимо, якщо вона парна, до n/2n/2n/2, а інакше - до n−1n-1n−1. Зрозуміло, що всього буде не більше 2log⁡n2 \\log n2logn переходів, перш ніж ми прийдемо до n=0n = 0n=0 (до бази рекурентної формули). Таким чином, ми отримали алгоритм, що працює за O(log⁡n)O(\\log n)O(logn) множень. "},{"title":"Реалізація","type":1,"pageTitle":"Бінарне піднесення у степінь","url":"algorithms/algebra/binary_pow#реалізація","content":"Рекурсивна реалізація: int binpow(int a, int n) { if (n == 0) { return 1; } else if (n % 2 == 1) { return binpow(a, n-1) * a; } else { int b = binpow(a, n/2); return b * b; }} Copy Нерекурсивна реалізація із оптимізованими діленнями на 2, які замінені бітовими операціями: int binpow(int a, int n) { int res = 1; while (n) { if (n & 1) { res *= a; --n; } else { a *= a; n >>= 1; } } return res;} Copy Цю реалізацію можна ще трішки оптимізувати, помітивши, що піднесення aaa в квадрат здійснюється завжди, незалежно від того, спрацювала умова непарності nnn чи ні: int binpow(int a, int n) { int res = 1; while (n) { if (n & 1) { res *= a; } a *= a; n >>= 1; } return res;} Copy Також, варто підмітити, що бінарне піднесення у степінь вже реалізовано у мові Java, але тільки для класу з довгою арифметикою BigInteger (функція pow цього класу працює використовуючи описаний алгоритм). "},{"title":"Застосування","type":1,"pageTitle":"Бінарне піднесення у степінь","url":"algorithms/algebra/binary_pow#застосування","content":""},{"title":"Ефективне обчислення чисел Фібоначчі","type":1,"pageTitle":"Бінарне піднесення у степінь","url":"algorithms/algebra/binary_pow#ефективне-обчислення-чисел-фібоначчі","content":"Умова. Дано число nnn. Потрібно обчислити FnF_nFn​, де FiF_iFi​ - послідовність чисел Фібоначчі. Розв'язок. Більш детально цей розв'язок описано у статті про послідовності Фібоначчі. Тут ми лише коротко наведемо його суть. Основна ідея наступна. Обчислення чергового числа Фібоначчі базується на знанні двох попередніх чисел Фібоначчі: а саме, кожне наступне число Фібоначчі обчислюється як сума двох попередніх. Це означає, що ми можемо побудувати матрицю 2×22 \\times 22×2, яка буде відповідати наступному перетворенню: як маючи два числа Фібоначчі FiF_iFi​ та Fi+1F_{i+1}Fi+1​ обчислити наступне число, тобто перейти до пари Fi+1F_{i+1}Fi+1​, Fi+2F_{i+2}Fi+2​. Застосовуючи це перетворення nnn раз до пари F0F_0F0​ та F1F_1F1​, ми отримаємо пару FnF_nFn​ і Fn+1F_{n+1}Fn+1​. Таким чином, підносячи матрицю цього перетворення в nnn-у степінь, ми знайдемо шукане FnF_nFn​ за час O(log⁡n)O(\\log n)O(logn), що нам і було потрібно. "},{"title":"Піднесення перестановки в kkk-у степінь","type":1,"pageTitle":"Бінарне піднесення у степінь","url":"algorithms/algebra/binary_pow#піднесення-перестановки-в-k-у-степінь","content":"Умова. Дано перестановку ppp довжини nnn. Потрібно піднести її в kkk-у степінь, тобто знайти, що вийде, якщо до тотожної перестановки kkk раз застосувати перестановку ppp. Розв'язок. Застосуємо до перестановки ppp описаний вище алгоритм бінарного піднесення у степінь. Жодних відмінностей із піднесенням чисел у степінь немає. Одержуємо розв'язок з асимптотикою O(nlog⁡k)O(n \\log k)O(nlogk). Зауваження Дану задачу можна розв'язати ефективніше - за лінійний час. Для цього достатньо виділити у перестановці всі цикли, після чого розглянути окремо кожний цикл і, взявши kkk за модулем довжини поточного циклу, знайти відповідь для цього циклу. "},{"title":"Швидке застосування набору геометричних операцій до точок","type":1,"pageTitle":"Бінарне піднесення у степінь","url":"algorithms/algebra/binary_pow#швидке-застосування-набору-геометричних-операцій-до-точок","content":"Умова. Дано nnn точок pip_ipi​ та mmm перетворень, які треба застосувати до кожної з цих точок. Кожне перетворення - це або переміщення на заданий вектор, або масштабування (множення координат на задані коефіцієнти), або обертання навколо заданої осі на заданий кут. Крім того, є складена операція циклічного повторення, яка має вигляд - \"повторити задане число раз заданий список перетворень\" (операції циклічного повторення можуть вкладатися один в одного). Потрібно обчислити результат застосування заданих операцій до всіх точок за час, менший ніж O(n⋅length)O(n \\cdot length)O(n⋅length), де lengthlengthlength - загальна кількість операцій, які необхідно зробити. Розв'язок. Розглянемо різні види перетворень з точки зору того, як вони змінюють координати: Операція переміщення - додає до всіх координат одиницю, помножену на деякі константи.Операція масштабування - множить кожну координату на деяку константу.Операція обертання навколо осі - нові координати можна записати у вигляді лінійної комбінації старих. Наприклад, у вигляді комбінації п'яти двовимірних поворотів: спочатку в площинах OXYOXYOXY і OXZOXZOXZ так, аби вісь обертання співпала з додатнім напрямом осі OXOXOX, потім необхідний поворот навколо осі в площині YZYZYZ, потім зворотні повороти в площинах OXZOXZOXZ і OXYOXYOXY так, аби вісь обертання повернулась у своє вихідне положення. Кожне з цих перетворень - це переобчислення координат за лінійними формулами. Таким чином, будь-яке таке перетворення можна записати у вигляді матриці 4×44 \\times 44×4: (a11a12a13a14a21a22a23a24a31a32a33a34a41a42a43a44),\\begin{pmatrix} a_{11} & a_{12} & a_{13} & a_{14} \\\\ a_{21} & a_{22} & a_{23} & a_{24} \\\\ a_{31} & a_{32} & a_{33} & a_{34} \\\\ a_{41} & a_{42} & a_{43} & a_{44} \\\\ \\end{pmatrix},⎝⎜⎜⎜⎛​a11​a21​a31​a41​​a12​a22​a32​a42​​a13​a23​a33​a43​​a14​a24​a34​a44​​⎠⎟⎟⎟⎞​, яке при множенні (ліворуч) на рядок з старими координатами і константою-одиницею дає рядок з новими координатами і теж константою-одиницею: (xyz1)⋅(a11a12a13a14a21a22a23a24a31a32a33a34a41a42a43a44)=\\begin{pmatrix} x & y & z & 1 \\end{pmatrix} \\cdot \\begin{pmatrix} a_{11} & a_{12} & a_{13} & a_{14} \\\\ a_{21} & a_{22} & a_{23} & a_{24} \\\\ a_{31} & a_{32} & a_{33} & a_{34} \\\\ a_{41} & a_{42} & a_{43} & a_{44} \\\\ \\end{pmatrix} =(x​y​z​1​)⋅⎝⎜⎜⎜⎛​a11​a21​a31​a41​​a12​a22​a32​a42​​a13​a23​a33​a43​​a14​a24​a34​a44​​⎠⎟⎟⎟⎞​= (x′y′z′1).\\begin{pmatrix} x' & y' & z' & 1 \\end{pmatrix}.(x′​y′​z′​1​). Зауваження Для чого введено фіктивну четверту координату, що завжди рівна одиниці? Без цього не вийшло б реалізувати операцію переміщення, адже переміщення - це як раз доданок до координат одиниці, що помножена на деякі коефіцієнти. Без фіктивної одиниці ми б змогли тільки реалізовувати лінійні комбінації самих координат, а додавати до них задані константи - не змогли б. Тепер розв'язок задачі стає простим. Оскільки кожна елементарна операція описується матрицею, то послідовність операцій описується добутком цих матриць, а операція циклічного повторення - піднесення цієї матриці у степінь. Таким чином, ми за час O(m⋅log⁡repetition)O(m \\cdot \\log repetition)O(m⋅logrepetition) можемо заздалегідь обчислити матрицю 4×44 \\times 44×4, що описує всі перетворення, і потім просто помножити кожну точку pip_ipi​ на цю матрицю - тим самим, ми дамо відповідь на всі запити за час O(n)O(n)O(n). "},{"title":"Кількість шляхів фіксованої довжини у графі","type":1,"pageTitle":"Бінарне піднесення у степінь","url":"algorithms/algebra/binary_pow#кількість-шляхів-фіксованої-довжини-у-графі","content":"Умова. Дано неорієнтований граф GGG з nnn вершинами, і дано число kkk. Потрібно для кожної пари вершин iii і jjj знайти кількість шляхів між ними, що містять рівно kkk ребер. Розв'язок. Більш детально цю задачу розглянуто у окремій статті. Тут лише описано суть цього розв'язку: ми підносимо в kkk-у степінь матрицю суміжності цього графа, і елементи цієї матриці будуть мати шукані значення. Асимптотика - O(n3log⁡k)O(n^3 \\log k)O(n3logk). Зауваження У згаданій статті розглядається також й інший варіант цієї задачі: коли граф зважений, і потрібно знайти шлях мінімальної ваги, що містить рівно kkk ребер. Дана задача також вирішується за допомогою бінарного піднесення у степінь матриці суміжності графа, однак замість звичайної операції перемноження двох матриць використовують модифіковану: замість множень береться сума, а замість підсумовування - взяття мінімуму. "},{"title":"Добуток двох чисел за модулем","type":1,"pageTitle":"Бінарне піднесення у степінь","url":"algorithms/algebra/binary_pow#добуток-двох-чисел-за-модулем","content":"Умова. Дано два додатних цілих числа aaa і bbb. Потрібно знайти значення їх добутку за модулем mmm: a⋅b(modm)a \\cdot b \\pmod ma⋅b(modm) Припустимо, що числа можуть бути достатньо великі: настільки, що самі числа поміщаються у базові типи даних, а ось їх добуток a⋅ba \\cdot ba⋅b - вже ні (відзначимо, що нам також буде потрібно, аби сума чисел поміщалась у базові типи даних). Відповідно, задача в тому, щоб порахувати шукану величину (a⋅b)(modm)(a \\cdot b) \\pmod m(a⋅b)(modm), не застосовуючи довгу арифметику. Розв'язок. Застосуємо алгоритм бінарного піднесення, описаний вище, тільки замість операції множення ми будемо використовувати додавання. Іншими словами, перемноження двох чисел ми звели до O(log⁡m)O(\\log m)O(logm) операцій додавання і множення на два (що теж, по суті, є додавання). f(a,b)={0якщо a=0f(a2,2b)якщо a>0 і a парнеf(a−12,2b)+bякщо a>0 і a непарнеf(a, b) = \\begin{cases} 0 &\\text{якщо }a = 0 \\\\\\\\ f(\\frac{a}{2}, 2 b) &\\text{якщо }a > 0 \\text{ і }a \\text{ парне} \\\\\\\\ f(\\frac{a-1}{2}, 2 b) + b &\\text{якщо }a > 0 \\text{ і }a \\text{ непарне} \\end{cases}f(a,b)=⎩⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎧​0f(2a​,2b)f(2a−1​,2b)+b​якщо a=0якщо a>0 і a парнеякщо a>0 і a непарне​ Реалізація: int binprod_mod(int a, int b, int m) { int res = 0; a %= m; b %= m; while (a) { if (a & 1) { res = (res + b) % m; } b = (2 * b) % m; a >>= 1; } return res;} Copy Зауваження Дану задачу можна розв'язати і по-іншому, використавши операції над числами з рухомою точкою. А саме, порахуємо в числах з рухомою точкою вираз a⋅b/ma \\cdot b / ma⋅b/m, і заокруглимо його до найближчого цілого числа. Так ми знайдемо приблизну частку. Віднявши її від добутку a⋅ba \\cdot ba⋅b (проігнорувавши переповнення), ми, швидше всього, отримаємо деяке невелике число, яке можна взяти за модулем mmm і повернути результат в якості відповіді. Цей розв'язок виглядає досить надійним та швидким і він дуже коротко реалізується. "},{"title":"Задачі","type":1,"pageTitle":"Бінарне піднесення у степінь","url":"algorithms/algebra/binary_pow#задачі","content":"Codeforces - 630 - Parking Lot Online Judge - 374 - Big Mod | Розв'язки: C++, Go, Python Spoj - LASTDIG - The last digit | Розв'язки: C++, Python "},{"title":"Розширений алгоритм Евкліда","type":0,"sectionRef":"#","url":"algorithms/algebra/extended_euclid_algorithm","content":"","keywords":"Алгоритм Евклід Коефіцієнти НСД GCD"},{"title":"Алгоритм","type":1,"pageTitle":"Розширений алгоритм Евкліда","url":"algorithms/algebra/extended_euclid_algorithm#алгоритм","content":"Введемо обчислення цих коефіцієнтів в алгоритм Евкліда. Для цього достатньо вивести формули, по яким вони змінюються при переході від пари (a,b)(a,b)(a,b) до пари (b mod a,a)(b\\ {\\rm mod}\\ a, a)(b mod a,a). Отже, нехай ми знайшли розв'язок (x1,y1)(x_1,y_1)(x1​,y1​) для задачі з новою парою (b mod a,a)(b\\ {\\rm mod}\\ a,a)(b mod a,a): (b mod a)⋅x1+a⋅y1=g,(b\\ {\\rm mod}\\ a) \\cdot x_1 + a \\cdot y_1 = g,(b mod a)⋅x1​+a⋅y1​=g, і хочемо отримати розв'язок (x,y)(x,y)(x,y) для задачі з парою (a,b)(a,b)(a,b): a⋅x+b⋅y=g.a \\cdot x + b \\cdot y = g.a⋅x+b⋅y=g. Для цього перетворимо величину b mod ab\\ {\\rm mod}\\ ab mod a наступним чином: b mod a=b−⌊ba⌋⋅a.b\\ {\\rm mod}\\ a = b - \\left\\lfloor \\frac{b}{a} \\right\\rfloor \\cdot a.b mod a=b−⌊ab​⌋⋅a. Підставимо у вираз з x1x_1x1​ та y1y_1y1​ і отримаємо: g=(b mod a)⋅x1+a⋅y1=(b−⌊ba⌋⋅a)⋅x1+a⋅y1,g = (b\\ {\\rm mod}\\ a) \\cdot x_1 + a \\cdot y_1 = \\left( b - \\left\\lfloor \\frac{b}{a} \\right\\rfloor \\cdot a \\right) \\cdot x_1 + a \\cdot y_1,g=(b mod a)⋅x1​+a⋅y1​=(b−⌊ab​⌋⋅a)⋅x1​+a⋅y1​, і, виконавши перегрупування доданків, отримуємо: g=b⋅x1+a⋅(y1−⌊ba⌋⋅x1).g = b \\cdot x_1 + a \\cdot \\left( y_1 - \\left\\lfloor \\frac{b}{a} \\right\\rfloor \\cdot x_1 \\right).g=b⋅x1​+a⋅(y1​−⌊ab​⌋⋅x1​). Порівнявши результат з початковим виразом з невідомими xxx та yyy, отримуємо необхідні рівності: {x=y1−⌊ba⌋⋅x1,y=x1.\\begin{cases} x = y_1 - \\left\\lfloor \\frac{b}{a} \\right\\rfloor \\cdot x_1, \\cr y = x_1. \\end{cases}{x=y1​−⌊ab​⌋⋅x1​,y=x1​.​ "},{"title":"Реалізація","type":1,"pageTitle":"Розширений алгоритм Евкліда","url":"algorithms/algebra/extended_euclid_algorithm#реалізація","content":"int gcd(int a, int b, int& x, int& y) { if (a == 0) { x = 0; y = 1; return b; } int x1, y1; int d = gcd(b % a, a, x1, y1); x = y1 - (b / a) * x1; y = x1; return d;} Copy Це рекурсивна функція як і раніше повертає значення НСД від чисел aaa та bbb, але крім цього також шукані коефіцієнти xxx та yyy у вигляді параметрів функції, що передаються у вигляді посилань. База рекурсії a=0a = 0a=0. Значить НСД рівний bbb, і, очевидно, необхідні коефіцієнти xxx та yyy рівні 000 та 111 відповідно. В інших випадках коефіцієнти перераховуються по вищеописаним формулами. Розширений алгоритм Евкліда у такій реалізації працює правильно навіть для від'ємних чисел. "},{"title":"Застосування","type":1,"pageTitle":"Розширений алгоритм Евкліда","url":"algorithms/algebra/extended_euclid_algorithm#застосування","content":"TODO: add applications "},{"title":"Задачі","type":1,"pageTitle":"Розширений алгоритм Евкліда","url":"algorithms/algebra/extended_euclid_algorithm#задачі","content":"Online Judge - 10104 - Euclid Problem | Розв'язки: C++, Go Online Judge - 12775 - Gift Dilemma "},{"title":"Функція Ейлера","type":0,"sectionRef":"#","url":"algorithms/algebra/euler_function","content":"","keywords":"Алгоритм Ейлер Функція"},{"title":"Визначення","type":1,"pageTitle":"Функція Ейлера","url":"algorithms/algebra/euler_function#визначення","content":"Функція Ейлера ϕ(n)\\phi (n)ϕ(n) (інколи позначається як φ(n)\\varphi(n)φ(n) або phi(n){\\it phi}(n)phi(n)) - це кількість чисел від 111 до nnn, взаємно простих з nnn. Іншими словами, це кількість таких чисел у відрізку [1;n][1; n][1;n], для яких найбільший спільний дільник з nnn рівний одиниці. Декілька перших значення цієї функції (A000010 в енциклопедії OEIS): n123456789101112131415ϕ(n)11224264641041268\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|} \\hline n & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 \\\\ \\hline \\phi(n) & 1 & 1 & 2 & 2 & 4 & 2 & 6 & 4 & 6 & 4 & 10 & 4 & 12 & 6 & 8 \\\\ \\hline \\end{array}nϕ(n)​11​21​32​42​54​62​76​84​96​104​1110​124​1312​146​158​​ "},{"title":"Властивості","type":1,"pageTitle":"Функція Ейлера","url":"algorithms/algebra/euler_function#властивості","content":"Трьох наступних властивостей функції Ейлера достатньо, щоб навчитися обчислювати її для будь-яких чисел: Якщо ppp - просте число, то ϕ(p)=p−1\\phi (p)=p-1ϕ(p)=p−1. Оскільки будь-яке число, крім самого ppp, взаємно просте з ним. Якщо ppp - просте, aaa - натуральне число, то ϕ(pa)=pa−pa−1\\phi (p^a)=p^a-p^{a-1}ϕ(pa)=pa−pa−1. Оскільки з числом pap^apa не взаємно прості тільки числа виду pkpkpk (k∈N)(k \\in \\mathcal{N})(k∈N), яких pa/p=pa−1p^a / p = p^{a-1}pa/p=pa−1 штук. Якщо aaa і bbb взаємно прості, то ϕ(ab)=ϕ(a)ϕ(b)\\phi(ab) = \\phi(a) \\phi(b)ϕ(ab)=ϕ(a)ϕ(b) (\"мультиплікативність\" функції Ейлера). Цей факт слідує з китайської теореми про остачі. Розглянемо довільне число z≤abz \\le abz≤ab. Позначимо через xxx і yyy залишки від ділення zzz на aaa і bbb відповідно. Тоді zzz взаємно просте з ababab тоді і тільки тоді, коли zzz взаємно просте з aaa і з bbb окремо, або, що означає xxx взаємно просте з aaa, та yyy взаємно просте з bbb. Застосовуючи китайську теорему про остачі, отримаємо, що будь-якій парі чисел xxx і yyy (x≤a, y≤b)(x \\le a, ~ y \\le b)(x≤a, y≤b) взаємно однозначно відповідає число zzz (z≤ab)(z \\le ab)(z≤ab), що і завершує доведення. Звідси можна отримати функцію Ейлера для будь-якого n\\it nn через його факторизацію (розкладання nnn на прості множники): якщо n=p1a1⋅p2a2⋅…⋅pkakn = p_1^{a_1} \\cdot p_2^{a_2} \\cdot \\ldots \\cdot p_k^{a_k}n=p1a1​​⋅p2a2​​⋅…⋅pkak​​ (де всі pip_ipi​ - прості), то ϕ(n)=ϕ(p1a1)⋅ϕ(p2a2)⋅…⋅ϕ(pkak)=\\phi(n) = \\phi(p_1^{a_1}) \\cdot \\phi(p_2^{a_2}) \\cdot \\ldots \\cdot \\phi(p_k^{a_k}) =ϕ(n)=ϕ(p1a1​​)⋅ϕ(p2a2​​)⋅…⋅ϕ(pkak​​)= =(p1a1−p1a1−1)⋅(p2a2−p2a2−1)⋅…⋅(pkak−pkak−1)== (p_1^{a_1} - p_1^{a_1-1}) \\cdot (p_2^{a_2} - p_2^{a_2-1}) \\cdot \\ldots \\cdot (p_k^{a_k} - p_k^{a_k-1}) ==(p1a1​​−p1a1​−1​)⋅(p2a2​​−p2a2​−1​)⋅…⋅(pkak​​−pkak​−1​)= =n⋅(1−1p1)⋅(1−1p2)⋅…⋅(1−1pk).= n \\cdot \\left( 1-{1\\over p_1} \\right) \\cdot \\left( 1-{1\\over p_2} \\right) \\cdot \\ldots \\cdot \\left( 1-{1\\over p_k} \\right).=n⋅(1−p1​1​)⋅(1−p2​1​)⋅…⋅(1−pk​1​). "},{"title":"Реалізація","type":1,"pageTitle":"Функція Ейлера","url":"algorithms/algebra/euler_function#реалізація","content":"Код, що обчислює функцію Ейлера, факторизуючи число за O(n)O(\\sqrt n)O(n​): int phi(int n) { int res = n; for (int i = 2; i*i <= n; i++) { if (n % i == 0) { while (n % i == 0) { n /= i; } res -= res / i; } } if (n > 1) { res -= res / n; } return res;} Copy Ключовим моментом при обчисленні функції Ейлера є знаходження факторизації числа nnn. Її можна знайти за час, значно менший O(n)O(\\sqrt{n})O(n​): див. Ефективні алгоритми факторизації. "},{"title":"Застосування","type":1,"pageTitle":"Функція Ейлера","url":"algorithms/algebra/euler_function#застосування","content":"Найважливіша і найвідоміша властивість функції Ейлера виражається у теоремі Ейлера: aϕ(m)≡1(modm),a^{\\phi(m)} \\equiv 1 \\pmod m,aϕ(m)≡1(modm), де a\\it aa і m\\it mm взаємно прості. Зокрема, коли m\\it mm просте, теорема Ейлера перетворюється у так звану малу теорему Ферма: am−1≡1(modm)a^{m-1} \\equiv 1 \\pmod mam−1≡1(modm) Теорема Ейлера достатньо часто зустрічається на практиці, наприклад, див. Обернений елемент в кільці за модулем. "},{"title":"Задачі","type":1,"pageTitle":"Функція Ейлера","url":"algorithms/algebra/euler_function#задачі","content":"Online Judge - 10179 - Irreducible Basic Fractions | Розв'язки: Go Online Judge - 11327 - Enumerating Rational Numbers Timus - 1673 - Admission to Exam "},{"title":"Пошук в ширину","type":0,"sectionRef":"#","url":"algorithms/graphs/bfs","content":"","keywords":"Алгоритм Пошук Графи"},{"title":"Алгоритм","type":1,"pageTitle":"Пошук в ширину","url":"algorithms/graphs/bfs#алгоритм","content":"На вхід алгоритму подається незважений граф і номер стартової вершини sss. Граф може бути як орієнтованим, так і неорієнтованим, для алгоритму це не важливо. Сам алгоритм можна сприймати як процес \"підпалювання\" графа: на нульовому кроці підпалюємо тільки вершину sss. На кожному наступному кроці вогонь з кожної вершини, що вже горить, поширюється на всіх її сусідів; тобто за одну ітерацію алгоритму відбувається розширення \"кільця вогню\" в ширину на одиницю (звідси і назва алгоритму). Формальний опис алгоритму. Створимо чергу qqq, в яку будуть додаватися вершини, що горять, а також заведемо булевий масив used[]\\rm used[]used[], в якому для кожної вершини будемо відзначати, горить вона вже чи ні (або іншими словами, чи була вона переглянутою). Спершу в чергу додається тільки вершина sss, і used[s]=true\\rm used[s] = trueused[s]=true, а для всіх інших вершин used[]=false\\rm used[] = falseused[]=false. Потім алгоритм представляє собою цикл: поки черга не порожня, дістати з її голови одну вершину, переглянути всі ребра, що виходять з цієї вершини, і якщо якісь з переглянутих вершин (на протилежних кінцях ребер) ще не горять, то підпалити їх і додати в кінець черги. В результаті, коли черга стане пустою, обхід в ширину обійде всі досяжні з sss вершини, причому до кожної дійде найкоротшим шляхом. Також можна порахувати довжини найкоротших шляхів (для чого треба завести масив довжин шляхів d[]\\rm d[]d[]), і компактно зберегти інформацію, якої достатню для відновлення всіх цих найкоротших шляхів (для цього треба завести масив \"предків\" p[]\\rm p[]p[], в якому для кожної вершини зберігати номер вершини, з якої ми потрапили в цю вершину). "},{"title":"Реалізація","type":1,"pageTitle":"Пошук в ширину","url":"algorithms/graphs/bfs#реалізація","content":"Реалізуємо вищеописаний алгоритм на мові C++. Вхідні дані: vector<vector<int>> g; // граф, список суміжностіint n; // кількість вершинint s; // стартова вершина (вершини нумеруються з нуля) // читання графа... Copy Сам обхід: queue<int> q;vector<bool> used(n);vector<int> d(n), p(n); q.push(s);used[s] = true;p[s] = -1; while (!q.empty()) { int v = q.front(); q.pop(); for (size_t i = 0; i < g[v].size(); i++) { int to = g[v][i]; if (!used[to]) { used[to] = true; q.push(to); d[to] = d[v] + 1; p[to] = v; } }} Copy Якщо потрібно відновити і вивести найкоротший шлях до якоїсь вершини to\\rm toto, то це можна зробити наступним чином: if (!used[to]) { cout << \"No path!\";} else { vector<int> path; for (int v = to; v != -1; v = p[v]) { path.push_back(v); } reverse(path.begin(), path.end()); cout << \"Path: \"; for (size_t i = 0; i < path.size(); i++) { cout << path[i] + 1 << \" \"; }} Copy "},{"title":"Застосування","type":1,"pageTitle":"Пошук в ширину","url":"algorithms/graphs/bfs#застосування","content":"Пошук найкоротшого шляху у незваженому графі. Описано у цій статті. Пошук компонент зв'язності у графі за O(n+m)O(n+m)O(n+m). Для цього запускаємо обхід в ширину від кожної вершини, за винятком вершин, що залишилися відвіданими (used=true\\rm used=trueused=true) після попередніх запусків. Таким чином, ми виконуємо звичайний запуск в ширину від кожної вершини, але не зануляємо кожний раз масив used[]\\rm used[]used[], за рахунок чого ми кожний раз будемо обходити нову компоненту зв'язності, а сумарний час роботи алгоритму буде як і раніше O(n+m)O(n+m)O(n+m) (такі декілька запусків обходу на графі без занулення масиву used\\rm usedused називається серією обходів в ширину). Знаходження розв'язку будь-якої задачі з найменшим числом ходів, якщо кожний стан системи можна уявити вершиною графа, а переходи з одного стану в інші - ребрами графа. Класичний приклад - гра, де робот рухається по полю, при цьому він може переміщати ящики, що знаходяться на цьому ж полі, і потрібно за найменше число ходів пересунути ящики в необхідні позиції. Розв'язується обходом в ширину по графу, де станом (вершиною) є набір координат: координати робота, і координати всіх коробок. Знаходження найкоротшого шляху в 0-1-графі (зважений граф, але з вагами рівними тільки 0 або 1). Достатньо трохи модифікувати пошук в ширину: якщо поточне ребро нульової ваги, і відбувається покращення відстані до якоїсь вершини, то цю вершину додаємо не в кінець, а в початок черги. Знаходження найкоротшого циклу в орієнтованому незваженому графі. Для цього запускаємо пошук в ширину з кожної вершини. Як тільки в процесі обходу ми намагаємося піти з поточної вершини по якомусь ребру до вже відвіданої вершини, то це означає, що ми знайшли найкоротший цикл, і зупиняємо обхід в ширину. Серед всіх таких знайдених циклів (по одному від кожного запуску обходу) вибираємо найкоротший. Знайти всі ребра, що лежать на будь-якому найкоротшому шляху між заданою парою вершин (a,b)(a,b)(a,b). Для цього треба запустити 2 пошуки в ширину: з aaa, і з bbb. Позначимо через da[]d_a[]da​[] масив найкоротших відстаней, отриманий в результаті першого обходу, а через db[]d_b[]db​[] - в результаті другого обходу. Тепер для будь-якого ребра (u,v)(u,v)(u,v) легко перевірити чи лежить він на будь-якому найкоротшому шляху: критерієм буде умова da[u]+1+db[v]=da[b]d_a[u] + 1 + d_b[v] = d_a[b]da​[u]+1+db​[v]=da​[b]. Знайти всі вершини, що лежать на будь-якому найкоротшому шляху між заданою парою вершин (a,b)(a,b)(a,b). Для цього треба запустити 2 пошуки в ширину: з aaa, і з bbb. Позначимо через da[]d_a[]da​[] масив найкоротших відстаней, отриманий в результаті першого обходу, а через db[]d_b[]db​[] - в результаті другого обходу. Тепер для будь-якої вершини vvv легко перевірити чи лежить вона на будь-якому найкоротшому шляху: критерієм буде умова da[v]+db[v]=da[b]d_a[v] + d_b[v] = d_a[b]da​[v]+db​[v]=da​[b]. Знайти найкоротший парний шлях в графі (тобто шлях парної довжини). Для цього треба побудувати допоміжний граф, вершинами якого будуть стани (v,c)(v,c)(v,c), де vvv - номер поточної вершини, c=0…1c = 0 \\ldots 1c=0…1 - поточна парність. Будь-яке ребро (a,b)(a,b)(a,b) вихідного графа в новому графі перетвориться в два ребра ((u,0),(v,1))((u,0),(v,1))((u,0),(v,1)) та ((u,1),(v,0))((u,1),(v,0))((u,1),(v,0)). Після цього на цьому графі треба обходом в ширину знайти найкоротший шлях з стартової вершини в кінцеву, з парністю, рівною 0. "},{"title":"Задачі","type":1,"pageTitle":"Пошук в ширину","url":"algorithms/graphs/bfs#задачі","content":"e-olymp - 292 - Ведмідь Міша | Розв'язки: C++ e-olymp - 1064 - Шлях коня e-olymp - 2384 - Сортуюча гра | Розв'язки: C++ e-olymp - 2621 - Шлях короля | Розв'язки: C++ "},{"title":"Довжина об'єднання відрізків на прямій","type":0,"sectionRef":"#","url":"algorithms/geometry/length_of_segments_union","content":"","keywords":"Алгоритм Геометрія Довжина"},{"title":"Алгоритм","type":1,"pageTitle":"Довжина об'єднання відрізків на прямій","url":"algorithms/geometry/length_of_segments_union#алгоритм","content":"Покладемо всі координати кінців відрізків в масив X і відсортуємо його по значенням координати. Додаткова умова при сортування - при рівності координат першими повинні йти ліві кінці. Крім того, для кожного елементу масиву будемо зберігати, чи відноситься він до лівого, чи до правому кінця відрузку. Тепер пройдемося по всьому масиву, маючи лічильник CCC відрізків, що перетинаються. Якщо CCC не рівний нулю, то до результату додаємо різницю Xi−Xi−1X_i - X_{i-1}Xi​−Xi−1​. Якщо поточний елемент відноситься до лівого кінця, то збільшуємо лічильник CCC, інакше зменшуємо його. "},{"title":"Реалізація","type":1,"pageTitle":"Довжина об'єднання відрізків на прямій","url":"algorithms/geometry/length_of_segments_union#реалізація","content":"int segments_union_length(const vector<pair<int, int>>& a) { size_t n = a.size(); vector<pair<int, bool>> x(n*2); for (size_t i = 0; i < n; i++) { x[i*2] = make_pair(a[i].first, false); x[i*2+1] = make_pair(a[i].second, true); } sort(x.begin(), x.end()); int result = 0; int c = 0; for (size_t i = 0; i < n*2; i++) { if (c && i) { result += x[i].first - x[i-1].first; } if (x[i].second) { ++c; } else { --c; } } return result;} Copy "},{"title":"Застосування","type":1,"pageTitle":"Довжина об'єднання відрізків на прямій","url":"algorithms/geometry/length_of_segments_union#застосування","content":"TODO: add applications "},{"title":"Задачі","type":1,"pageTitle":"Довжина об'єднання відрізків на прямій","url":"algorithms/geometry/length_of_segments_union#задачі","content":"TODO: add problems "},{"title":"Пошук компонент зв'язності у графі","type":0,"sectionRef":"#","url":"algorithms/graphs/connected_components","content":"","keywords":"Алгоритм Пошук Графи Зв'язність Компоненти зв'язності"},{"title":"Алгоритм","type":1,"pageTitle":"Пошук компонент зв'язності у графі","url":"algorithms/graphs/connected_components#алгоритм","content":"Для розв'язку можна скористатися як пошуком в глибину, так і пошуком в ширину. Фактично, ми будемо проводити серію обходів: спочатку запустимо обхід з першої вершини, і всі вершини, які він при цьому обійшов - утворюють першу компоненту зв'язності. Потім найдемо першу вершину з тих, які ще не були відвідані, і запустимо обхід з неї, знайшовши тим самим одному компоненту зв'язності. І так далі, поки всі вершини не стануть відвіданими. Підсумкова асимптотика складе O(n+m)O(n + m)O(n+m): насправді, такий алгоритм не буде запускаться від однієї і тією ж вершини двічі, а, значить, кожне ребро буде переглянуто рівне два рази (з одного кінця і з іншого кінця). "},{"title":"Реалізація","type":1,"pageTitle":"Пошук компонент зв'язності у графі","url":"algorithms/graphs/connected_components#реалізація","content":"Для реалізації трішки більш зручним є обхід в глибину: void find_connected_components_dfs(int v, const vector<vector<int>>& g, vector<bool>& used, vector<int>& component) { used[v] = true; component.push_back(v); for (size_t i = 0; i < g[v].size(); i++) { int to = g[v][i]; if (!used[to]) { find_connected_components_dfs(to, g, used, component); } }} vector<vector<int>> find_connected_components(const vector<vector<int>>& g) { size_t n = g.size(); // кількість вершин vector<bool> used(n); // відвідані вершини vector<vector<int>> components; // знайдені компоненти зв'язності for (size_t i = 0; i < n; i++) { if (!used[i]) { components.emplace_back(); // додаємо нову пусту компоненту в кінець масиву find_connected_components_dfs(i, g, used, components.back()); } } return components;} Copy "},{"title":"Застосування","type":1,"pageTitle":"Пошук компонент зв'язності у графі","url":"algorithms/graphs/connected_components#застосування","content":"TODO: add applications "},{"title":"Задачі","type":1,"pageTitle":"Пошук компонент зв'язності у графі","url":"algorithms/graphs/connected_components#задачі","content":"TODO: add problems "},{"title":"Пошук в глибину","type":0,"sectionRef":"#","url":"algorithms/graphs/dfs","content":"","keywords":"Алгоритм Пошук Графи"},{"title":"Алгоритм","type":1,"pageTitle":"Пошук в глибину","url":"algorithms/graphs/dfs#алгоритм","content":"TODO: add detailed description for DFS. "},{"title":"Реалізація","type":1,"pageTitle":"Пошук в глибину","url":"algorithms/graphs/dfs#реалізація","content":"Найпростіша реалізація: vector<vector<int>> g; // граф, список суміжностіint n; // кількість вершинvector<bool> used(n); // відвідані вершини void dfs(int v) { used[v] = true; for (size_t i = 0; i < g[v].size(); i++) { int to = g[v][i]; if (!used[to]) { dfs(to); } }} Copy Інколи необхідно знати кольори вершин (0 - не відвідана вершина; 1 - відвідана вершина, але досі у стеці; 2 - відвідана і більше немає у стеці) та \"час\" заходу та виходу з вершин. Ці допоміжні величини використовуються у декількох наведених прикладах застосування алгоритму. vector<vector<int>> g; // граф, список суміжностіint n; // кількість вершин vector<int> color; // кольори вершин (0, 1, або 2) vector<int> time_in, time_out; // \"часи\" заходу та виходу з вершинint dfs_timer = 0; // \"таймер\" для визначення \"часів\" void dfs(int v) { time_in[v] = dfs_timer++; color[v] = 1; for (size_t i = 0; i < g[v].size(); i++) { int to = g[v][i]; if (color[to] == 0) { dfs(to); } } color[v] = 2; time_out[v] = dfs_timer++;} Copy "},{"title":"Застосування","type":1,"pageTitle":"Пошук в глибину","url":"algorithms/graphs/dfs#застосування","content":"Пошук будь-якого шляху у графі. Пошук лексикографічно першого шляху в графі. Перевірка чи одна вершина дерева є предком іншої. На початку і у кінці ітерації пошуку в глибину будемо запам'ятовувати \"час\" заходу і виходу з кожної вершині. Тепер за O(1)O(1)O(1) можна знайти відповідь: вершина aaa є предком вершини bbb тоді і тільки тоді, коли time_in[a]<time_in[b]\\rm time\\_in[a] < time\\_in[b]time_in[a]<time_in[b] та time_out[a]>time_out[b]\\rm time\\_out[a] > time\\_out[b]time_out[a]>time_out[b]. Найменший спільний предок. Топологічне сортування. Запускаємо серію пошуків в глибину, щоб обійти всі вершини графа. Відсортуємо вершини по спаданню часу виходу - це і буде відповіддю. Перевірка графа на ациклічність і знаходження циклу. Пошук компонент сильної зв'язності. Спочатку проводимо топологічне сортування, а потім транспонуємо граф. Після того знову проводимо серію пошуків у глибину, але в порядку вершин, який було отримано топологічним сортуванням. Кожне дерево пошуку - сильнозв'язана компонента. Пошук мостів. Спочатку перетворюємо граф в орієнтований, роблячи серію пошуків в глибину, і орієнтуючи кожне ребро так, як ми намагалися по ньому пройти. Потім знаходимо сильнозв'язані компоненти. Мостами є ті ребра, кінці яких належать різним сильнозв'язаним компонентам. "},{"title":"Задачі","type":1,"pageTitle":"Пошук в глибину","url":"algorithms/graphs/dfs#задачі","content":"e-olymp - 122 - Маршрути в горах | Розв'язки: C++ e-olymp - 977 - Дерево? | Розв'язки: C++ e-olymp - 978 - Отримай дерево | Розв'язки: C# e-olymp - 1941 - Предок | Розв'язки: C++ e-olymp - 2270 - Пошук циклу | Розв'язки: C++ e-olymp - 2382 - Графічна маска | Розв'язки: C++ e-olymp - 2383 - Електричні провода | Розв'язки: C++ e-olymp - 3165 - Двокольоровість | Розв'язки: C++ e-olymp - 4077 - Зарплата в корпорації | Розв'язки: C++ "},{"title":"Алгоритм Крускала","type":0,"sectionRef":"#","url":"algorithms/graphs/mst/kruskal","content":"","keywords":"Алгоритм Графи Каркасне дерево"},{"title":"Властивості мінімального каркасу","type":1,"pageTitle":"Алгоритм Крускала","url":"algorithms/graphs/mst/kruskal#властивості-мінімального-каркасу","content":"Мінімальний каркас унікальний, якщо ваги всіх ребер різні. В іншому випадку, можле існувати декілька мінімальних каркасів (алгоритми зазвичай отримують один з можливих каркасів).Мінімальний каркас є також і каркасом з мінімальним добутком ваг ребер. (доводиться заміною ваг всіх ребер на їх логарифми)Мінімальний каркас є також і каркасом з мінімальною вагою найважчого ребра.Каркас максимальної ваги шукається аналогічно каркасу мінімального ваги, достатньо поміняти знаки всіх ребер на протилежні і виконати будь-який з алгоритмів пошуку мінімального каркасу. "},{"title":"Алгоритм","type":1,"pageTitle":"Алгоритм Крускала","url":"algorithms/graphs/mst/kruskal#алгоритм","content":"Даний алгоритм був описаний Крускалом (Kruskal) в 1956 р. Алгоритм Крускала спершу розташовує кожну вершину в своє незалежне дерево (розміром в одну вершину), а потім поступово об'єднує ці дерева, об'єднуючи на кожній ітерації два деяких дерева деяким ребром. Перед початком виконання алгоритму, всі ребра впорядковано по зростанню ваги. Потім починається процес з'єднання: перебираются всі ребра від першого до останнього (в порядку сортування), і якщо у поточного ребра його кінці належать різним деревам, то ці дерева об'єднуються, а ребро додається до відповіді. При закінченні перебору всіх ребер всі вершини опиняться в одному дереві, яке і є шуваним. "},{"title":"Реалізація","type":1,"pageTitle":"Алгоритм Крускала","url":"algorithms/graphs/mst/kruskal#реалізація","content":""},{"title":"Найпростіша за O(m⋅log⁡n+n2)O(m \\cdot \\log n + n^2)O(m⋅logn+n2)","type":1,"pageTitle":"Алгоритм Крускала","url":"algorithms/graphs/mst/kruskal#найпростіша-за-om-cdot-log-n--n2","content":"Дана реалізація є найпростішою і виконується за O(m⋅log⁡n+n2)O(m \\cdot \\log n + n^2)O(m⋅logn+n2). Сортування ребер займає O(m⋅log⁡n)O(m \\cdot \\log n)O(m⋅logn) операцій. Належність вершини тому чи іншому дереву зберігається за допомогою масиву tree_id - в ньому для кожної вершини зберігається номер дерева, якому вона належить. Для кожного ребра ми за O(1)O(1)O(1) визначаємо чи належать його кінці різним деревам. Нарешті, об'єднання двох дерев здійснюється за O(n)O(n)O(n) простим проходом по масиву tree_id. Враховуючи, що всього операцій з'єднання буде n−1n-1n−1, ми і отримуємо асимптотику O(m⋅log⁡n+n2)O(m \\cdot \\log n + n^2)O(m⋅logn+n2). int m;vector<pair<int, pair<int, int>>> g(m); // список ребер у форматі - {вага, {вершина 1, вершина 2}} int cost = 0;vector<pair<int, int>> res; sort(g.begin(), g.end());vector<int> tree_id(n); for (int i = 0; i < n; i++) { tree_id[i] = i;}for (int i = 0; i < m; i++) { int a = g[i].second.first, b = g[i].second.second, l = g[i].first; if (tree_id[a] != tree_id[b]) { cost += l; res.push_back(make_pair(a, b)); int old_id = tree_id[b], new_id = tree_id[a]; for (int j = 0; j < n; j++) { if (tree_id[j] == old_id) { tree_id[j] = new_id; } } }} Copy "},{"title":"Із системою множин, що не перетинаються за O(m⋅log⁡n)O(m \\cdot \\log n)O(m⋅logn)","type":1,"pageTitle":"Алгоритм Крускала","url":"algorithms/graphs/mst/kruskal#із-системою-множин-що-не-перетинаються-за-om-cdot-log-n","content":"Розглянемо реалізацію з використанням структури данних \"система множин, що не перетинаються\" (DSU), яка дозволить досягти асимптотики O(m⋅log⁡n)O(m \\cdot \\log n)O(m⋅logn). Так само, як і в простий версії алгоритму Крускала, відсортуємо всі ребра по зростанню ваги. Потім розташуємо кожну вершину в своє дерево (тобто у свою множину) - на це піде в сумі O(n)O(n)O(n). Перебираємо всі ребра (в порядку сортування) і для кожного ребра за O(1)O(1)O(1) визначаємо, чи належать його кінці різним деревам (з допомогою двох викликів dsu_get за O(1)O(1)O(1)). Нарешті, об'єднання двох дерев буде звійснюватись викликом dsu_unite - також за O(1)O(1)O(1). Разом ми отримуємо асимптотику O(m⋅log⁡n+n+m)=O(m⋅log⁡n)O(m \\cdot \\log n + n + m) = O(m \\cdot \\log n)O(m⋅logn+n+m)=O(m⋅logn). Тут представленій реалізації використовуватися рандомізована версія DSU. vector<int> p(n); int dsu_get(int v) { return (v == p[v]) ? v : (p[v] = dsu_get(p[v]));} void dsu_unite(int a, int b) { a = dsu_get(a); b = dsu_get(b); if (rand() & 1) { swap(a, b); } if (a != b) { p[a] = b; }} ... у функції main(): ... size_t m;vector<pair<int, pair<int, int>>> g; // список ребер у форматі - {вага, {вершина 1, вершина 2}}... читання графа ... int cost = 0;vector<pair<int, int>> res; sort(g.begin(), g.end());p.resize(n);for (size_t i = 0; i < n; i++) { p[i] = i;}for (size_t i = 0; i < m; i++) { int a = g[i].second.first, b = g[i].second.second, l = g[i].first; if (dsu_get(a) != dsu_get(b)) { cost += l; res.push_back(g[i].second); dsu_unite(a, b); }} Copy "},{"title":"Застосування","type":1,"pageTitle":"Алгоритм Крускала","url":"algorithms/graphs/mst/kruskal#застосування","content":"TODO: add applications "},{"title":"Задачі","type":1,"pageTitle":"Алгоритм Крускала","url":"algorithms/graphs/mst/kruskal#задачі","content":"TODO: add problems "},{"title":"Література","type":0,"sectionRef":"#","url":"books","content":"Література Thomas H. Cormen - Introduction to Algorithms","keywords":"Алгоритми Література Книги"},{"title":"Топологічне сортування","type":0,"sectionRef":"#","url":"algorithms/graphs/topological_sort","content":"","keywords":"Алгоритм Сортування Топологічний порядок Графи"},{"title":"Алгоритм","type":1,"pageTitle":"Топологічне сортування","url":"algorithms/graphs/topological_sort#алгоритм","content":"Для розв'язку скористаємось пошуком в глибину. Припустимо, що граф ациклічний, тобто розв'язок існує. Що робить пошук в глибину? При запуску з якоїсь вершини vvv він намагається запуститися уздовж всіх ребер, вихідних з vvv. Уздовж тих ребер, кінці яких вже були відвідані раніше, він не проходить, а уздовж всіх інших - проходить і викликає себе від їх кінців. Таким чином, на момент виходу з виклику dfs(v){\\rm dfs}(v)dfs(v) всі вершини, досяжні з vvv як безпосередньо (по ребру), так і дотично (по деякому шляху), вже відвідані пошуком в глибину. Отже, якщо ми будемо в момент виходу з dfs(v){\\rm dfs}(v)dfs(v) додавати нашу вершину в початок деякого списку, то у кінці алгоритму в цьому списку отримаємо топологічне сортування. Пояснити можна також за допомогою поняття \"часу виходу\" пошуку в глибину. Час виходу для кожної вершини vvv - це момент часу, в який закінчив працювати виклик dfs(v){\\rm dfs}(v)dfs(v) пошуку в глибину. Часи виходу можна пронумерувати від 111 до nnn. Легко зрозуміти, що при пошуці в глибину час виходу з будь-якої вершини vvv завжди більший, ніж час виходу з усіх вершин, досяжних з неї (тобто вони були відвідані або до виклику dfs(v){\\rm dfs}(v)dfs(v), або під час нього). Таким чином, шукане топологічне сортування - це сортування у порядку зменшення часів виходу. Складність алгоритму така ж як і у пошуку в глибину - O(n+m)O(n+m)O(n+m), де nnn - кількість вершин, mmm - кількість ребер. "},{"title":"Реалізація","type":1,"pageTitle":"Топологічне сортування","url":"algorithms/graphs/topological_sort#реалізація","content":"Наведемо реалізацію, що припускає, що граф ациклічний, тобто шукане топологічне сортування існує. При необхідності перевірку графа на ациклічність можна здійснити додатковим пошуком в глибину, як описано у статті про пошук циклу. int n; // кількість вершинvector<int> g[MAXN]; // граф, список суміжностіbool used[MAXN];vector<int> ans; void dfs(int v) { used[v] = true; for (size_t i = 0; i < g[v].size(); i++) { int to = g[v][i]; if (!used[to]) { dfs(to); } } ans.push_back(v);} void topological_sort() { for (int i = 0; i < n; i++) { used[i] = false; } ans.clear(); for (int i = 0; i < n; i++) { if (!used[i]) { dfs(i); } } reverse(ans.begin(), ans.end());} Copy Тут константа MAXN задає максимально можливу кількість вершин у графі. Основна функція розв'язку - це topological_sort. Вона ініціалізує допоміжний масив used пошуку в глибину, запускає його, і у кінці масив ans містить шукане топологічне сортування. "},{"title":"Застосування","type":1,"pageTitle":"Топологічне сортування","url":"algorithms/graphs/topological_sort#застосування","content":"Є nnn змінних, значення яких нам невідомі. Відомо лише про деякі пари змінних, у яких одна змінна менша іншої. Потрібно перевірити чи не суперечливі ці нерівності, і якщо ні, видати змінні у порядку їх зростання (якщо розв'язків декілька - видати будь-який). Потрібно створити граф з nnn вершинами, де ребра ведуть з меншої змінної у більшу. Провести перевірку на ациклічність. Якщо граф містить цикл, то нерівності суперечливі, а якщо не містить циклу, то вершини у топологічному порядку відповідатимуть змінним у порядку їх зростання. "},{"title":"Задачі","type":1,"pageTitle":"Топологічне сортування","url":"algorithms/graphs/topological_sort#задачі","content":"e-olymp - 1948 - Топологічне сортування | Розв'язки: C++ Spoj - TOPOSORT - Topological Sorting | Розв'язки: C++ Spoj - RPLA - Answer the boss! | Розв'язки: C++ Online Judge - 124 - Following Orders | Розв'язки: Go Online Judge - 200 - Rare Order | Розв'язки: Go Online Judge - 10305 - Ordering Tasks | Розв'язки: Go, Python "},{"title":"Курси","type":0,"sectionRef":"#","url":"courses","content":"Курси TODO","keywords":"Алгоритми Курси"}]