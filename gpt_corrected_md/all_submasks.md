# Перелічення всіх підмасок даної маски

## Перерахування підмасок з фіксованою маскою

Дана бітова маска $m$. Потрібно ефективно перебрати всі її підмаски, тобто такі маски $s$, в яких можуть бути включені тільки ті біти, які були включені в маску $m$.

Відразу розглянемо реалізацію цього алгоритму, що базується на трюках з бітовими операціями:

<!--- TODO: specify code snippet id -->
``` cpp
int s = m;
while (s > 0) {
... можна використовувати таке виразення: s = (s - 1) & m;
}
```

або, використовуючи більш компактний оператор $for$:

<!--- TODO: specify code snippet id -->
``` cpp
for (int s = m; s; s = (s - 1) & m)
... можна використовувати s...
```

Єдиним винятком для обох варіантів коду є підмаска, рівна нулю, яку не буде оброблено. Її обробку доведеться винести з циклу або використати менш елегантну конструкцію, наприклад:

<!--- TODO: specify code snippet id -->
``` cpp
for (int s = m;; s = (s - 1) & m) {
... можна використовувати s... якщо (s == 0) перервати;
}
```

Разберём, чому наведений вище код дійсно знаходить всі подмаскі даній маски, причому без повторений, за O (їх кількості), і в порядку зменшення.

Нехай у нас є поточна підмаска $s$, і ми хочемо перейти до наступної підмаски. Віднімемо від маски $s$ одиницю, тим самим ми знімемо самий правий одиничний біт, а всі біти правіше нього встановляться в $1$. Потім видалимо всі "зайві" одиничні біти, які не входять до маски $m$ і тому не можуть входити до підмаски. Видалення здійснюється бітовою операцією $\& m$. В результаті ми "обріжемо" маску $s-1$ до того найбільшого значення, яке вона може прийняти, тобто до наступної підмаски після $s$ в порядку зменшення.

Таким чином, цей алгоритм генерує всі підмаски даної маски в порядку строгого зменшення, витрачаючи на кожен перехід по дві елементарні операції.

Особливу увагу приділимо моменту, коли $s = 0$. Після виконання $s-1$ ми отримаємо маску, в якій всі біти включені (бітове подання числа $-1$), і після видалення зайвих бітів операцією $(s-1) \& m$ отримаємо маску $m$. Тому з маскою $s = 0` потрібно бути обережним - якщо не зупинитися на нульовій масці, то алгоритм може увійти в нескінченний цикл.

## Перерахування всіх масок з їх підмасками. Оцінка $2^n$

У багатьох завданнях, особливо при динамічному програмуванні за допомогою масок, потрібно перебирати всі маски, а для кожної маски - всі підмаски

<!--- TODO: specify code snippet id -->
``` cpp
for (int m = 0; m < (1 << n); ++m)
    for (int s = m; s; s = (s - 1) & m)
...використання "с" та "м"...
```

Доведемо, що внутрішній цикл сумарно виконає $O(2^n)$ ітерацій.

**Доведення: 1 спосіб**. Розглянемо $i$-ий біт. Для нього, загалом кажучи, є три рівних варіанти: він не входить у маску $m$ (і тому в підмаску $s$); він входить у $m$, але не входить у $s$; він входить у $m$ і в $s$. Всього бітів $n$, отже всього різних комбінацій буде $3^n$, що і потрібно довести.

**Доведення: 2 спосіб**. Зауважимо, що якщо маска $m$ має $k$ включених бітів, то вона матиме $2^k$ підмасок. Оскільки масок довжини $n$ з $k$ включеними бітами є $C_n^k$ (див. ["біноміальні коефіцієнти"](binomial_coeff)), то всього комбінацій буде:

$$
\sum_{k=0}^n C_n^k 2^k.
$$

Порахуймо цю суму. Для цього зауважимо, що вона є ніщо інше, як розкладання в біному Ньютона виразу $(1+2)^n$, тобто $3^n$, що й потрібно довести.