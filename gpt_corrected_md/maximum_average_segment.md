# Пошук найбільшого/найменшого сумарного значення підмасиву масиву

Тут ми розглянемо задачу пошуку підмасиву масиву з максимальною сумою ("максимальний підмасив" англ. "maximum subarray problem"), а також деякі її варіації (в тому числі алгоритм розв'язку варіанту цієї задачі в режимі онлайн - описаний автором алгоритму - KADR (Ярослав Твердохлеб)).

## Постановка завдання

Даний масив чисел $a[1 \ldots n]$. Потрібно знайти такий його підвідрізок $a[l \ldots r]$, на якому сума є **максимальною**:

$$
\max_{ 1 \le l \le r \le n } \sum_{i=l}^{r} a[i].
$$

Наприклад, якщо всі елементи масиву $a[]$ були б не від'ємними, то можна було б взяти весь масив як відповідь. Розв'язок стає нетривіальним, коли масив може містити як позитивні, так і від'ємні числа.

Зрозуміло, що задача про пошуку **найменшого** підвідрізку - по суті та ж сама, достатньо лише змінити знаки всіх чисел на протилежні.

## Алгоритм 1

Тут ми розглянемо практично очевидний алгоритм. (Далі ми розглянемо інший алгоритм, який трохи складніше придумати, проте його реалізація виходить ще коротшою).

### Опис алгоритму

Алгоритм дуже простий.

Введемо для зручності **позначення**: $s[i] = \sum_{j=1}^{i} a[j]$, тобто масив $s[i]$ є масивом часткових сум масиву $a[]$. Також приймемо значення $s[0] = 0$.

Будемо тепер **перебирати** індекс $r$ від $1$ до $n$, і навчимося для кожного поточного значення $r$ швидко знаходити оптимальне $l$, при якому досягається максимальна сума на підвідрізку $[l; r]$.

Формально це означає, що для поточного $r$ потрібно знайти таке $l$ (не більше $r$), щоб величина $s[r] - s[l-1]$ була максимальною. Після тривіального перетворення ми отримуємо, що потрібно знайти в масиві $s[]$ мінімум на відрізку $[0;r-1]$.

Звідси ми одразу отримуємо алгоритм розв'язку: ми просто будемо зберігати, де в масиві $s[]$ знаходиться поточний мінімум. Використовуючи цей мінімум, ми за $O(1)$ знаходимо поточний оптимальний індекс $l$, а при переході від поточного індексу $r$ до наступного ми просто оновлюємо цей мінімум.

Очевидно, цей алгоритм працює з часовою складністю $O(n)$ і є асимптотично оптимальним.

### Реалізація

Для реалізації нам навіть не знадобиться явно зберігати масив часткових сум $s[]$ - від нього нам буде потрібен тільки поточний елемент.

Реалізація проводиться в масивах, що індексуються з 0, а не з 1, як було описано вище.

Наведемо спочатку розв'язок, який знаходить просто числову відповідь, не знаходячи індекси шуканого відрізку

<!--- TODO: specify code snippet id -->
``` cpp
int ans = a[0], sum = 0, min_sum = 0;
for (int r = 0; r < n; ++r) {
    sum += a[r];
    ans = max(ans, sum - min_sum);
    min_sum = min(min_sum, sum);
}
```

Тепер наведемо повний варіант розв'язку, який разом з числовим розв'язком знаходить межі шуканого відрізку:

<!--- TODO: specify code snippet id -->
``` cpp
int ans = a[0], ans_l = 0, ans_r = 0, sum = 0, min_sum = 0, min_pos = -1;
for (int r = 0; r < n; ++r) {
    sum += a[r];

    int cur = sum - min_sum;
    if (cur > ans) {
        ans = cur;
        ans_l = min_pos + 1;
        ans_r = r;
    }

    if (sum < min_sum) {
        min_sum = sum;
        min_pos = r;
    }
}
```

## Алгоритм 2

Тут ми розглянемо інший алгоритм. Його трохи складніше зрозуміти, але зате він більш елегантний, ніж наведений вище, і реалізується трохи коротше. Цей алгоритм був запропонований Джей Каданом (Jay Kadane) в 1984 році.

### Опис алгоритму

Сам **алгоритм** виглядає наступним чином. Будемо йти по масиву і накопичувати в деякій змінній $s$ поточну часткову суму. Якщо в якийсь момент $s$ виявиться від'ємним, то ми просто даємо $s=0$. Стверджується, що максимум з усіх значень змінної $s$, які сталися за час роботи, і буде відповіддю на задачу.

Доведімо цей алгоритм.

Насправді, розглянемо перший момент часу, коли сума $s$ стала від'ємною. Це означає, що, стартуючи з нульової часткової суми, ми в підсумку досягли від'ємної часткової суми - отже, весь цей префікс масиву, так само як і будь-який його суфікс, має від'ємну суму. Отже, від всього цього префікса масиву в подальшому не можна мати жодної користі: він може тільки додати від'ємний внесок до відповіді.

Однак цього недостатньо для доведення коректності алгоритму. У алгоритмі ми, фактично, обмежуємося пошуком відповіді тільки такими відрізками, які починаються безпосередньо після місць, де $s<0$.

Але насправді розглянемо довільний відрізок $[l;r]$, при цьому $l$ не буде в такій "критичній" позиції (тобто $l > p+1$, де $p$ - остання така позиція, в якій $s<0$). Оскільки остання критична позиція знаходиться строго раніше, ніж в $l-1$, то вийде, що сума $a[p+1 \ldots l-1]$ не може бути від'ємною. Це означає, що зсунувши $l$ на позицію $p+1$, ми збільшимо відповідь або, в крайньому випадку, не змінимо її.

Так чи інакше, але виходить, що насправді при пошуку відповіді можна обмежитися лише відрізками, що починаються безпосередньо після позицій, де $s<0$. Це доводить правильність алгоритму.

### Реалізація

Як і в алгоритмі 1, спочатку наведемо спрощену реалізацію, яка знаходить тільки числову відповідь, не знаходячи меж шуканого відрізку

<!--- TODO: specify code snippet id -->
``` cpp
int ans = a[0], sum = 0;
for (int r = 0; r < n; ++r) {
    sum += a[r];
    ans = max(ans, sum);
    sum = max(sum, 0);
}
```

Повний варіант розв'язку з підтримкою індексів-меж шуканої послідовності:

<!--- TODO: specify code snippet id -->
``` cpp
int ans = a[0], ans_l = 0, ans_r = 0, sum = 0, minus_pos = -1;
for (int r = 0; r < n; ++r) {
    sum += a[r];

    if (sum > ans) {
        ans = sum;
        ans_l = minus_pos + 1;
        ans_r = r;
    }

    if (sum < 0) {
        sum = 0;
        minus_pos = r;
    }
}
```

## Суміжні задачі

### Пошук найбільшого/найменшого підрядка з обмеженнями

Якщо в умові задачі на шуканий відрізок $[l;r]$ накладаються додаткові обмеження (наприклад, що довжина $r-l+1$ відрізку повинна перебувати в заданих межах), то описаний алгоритм легко узагальнюється на такі випадки. Задача полягає в пошуку мінімуму в масиві $s[]$ при заданих додаткових обмеженнях.

### Двовимірний випадок задачі полягає в пошуку максимальної/мінімальної підматриці

Описана в даній статті задача природно узагальнюється на великі розмірності. Наприклад, у двовимірному випадку вона перетворюється на пошук такої підматриці $[l_1 \ldots r_1; l_2 \ldots r_2]$ заданої матриці, яка має максимальну суму чисел у ній.

З описаного вище розв'язку для одновимірного випадку легко отримати розв'язок за $O(n^3)$: переберемо $l_1$ і $r_1$, і порахуємо масив сум з $l_1$ по $r_1$ у кожній стрічці матриці; ми прийшли до одновимірної задачі пошуку індексів $l_2$ і $r_2$ в цьому масиві, яку вже можна розв'язати за лінійний час.

**Швидші** алгоритми розв'язку цієї задачі, хоча і відомі, проте не сильно швидші за $O(n^3)$, і при цьому дуже складні (настільки складні, що за прихованою константою багато з них поступаються тривіальному алгоритму при всіх розумних обмеженнях). За всіма ознаками, кращий з відомих алгоритмів працює за $O \left( n^3 \frac{ \log^3 \log n }{ \log^2 n} \right)$ (T. Chan 2007 "More algorithms for all-pairs shortest paths in weighted graphs").

Цей алгоритм Чана, а також багато інших результатів в цій області насправді описують **швидке множення** матриць (де під множенням матриць мається на увазі модифіковане множення: замість складання використовується мінімум, а замість множення - складання). Справа в тому, що задача про пошук підматриці з найбільшою сумою зводиться до задачі про пошук найкоротших шляхів між усіма парами вершин, а ця задача, в свою чергу, зводиться до такого множення матриць.

### Пошук підвідрізку з максимальною/мінімальною середньою сумою

Ця задача полягає в тому, що потрібно знайти такий відрізок $[l;r]$, на якому середнє значення буде максимальним

$$
\max_{l \le r} \frac{ 1 }{ r-l+1 } \sum_{i=l}^{r} a[i].
$$

Звичайно, якщо на шуканий відрізок $[l;r]$ не накладено інших умов, то розв'язком завжди буде відрізок довжини $1$ в точці максимуму масиву. Задача має сенс тільки в разі наявності **додаткових обмежень** (наприклад, довжина шуканого відрізку обмежена знизу).

У такому випадку застосуємо **стандартний підхід** при роботі з завданнями про середнє значення: будемо шукати шукану максимальну середню величину **бінарним пошуком**.

Для цього нам потрібно навчитися розв'язувати таку підзадачу: дано число $x$, і потрібно перевірити, чи існує підмасив $a[]$ (звісно, задовольняє всім додатковим обмеженням задачі), на якому середнє значення більше $x$.

Щоб вирішити цю підзадачу, потрібно відняти від кожного елемента масиву $a[]$ значення $x$. Таким чином, наша підзадача фактично зводиться до наступного: чи є в даному масиві підпослідовність з позитивною сумою. А цю задачу ми вже вміємо вирішувати.

Таким чином, ми отримали розв'язок з асимптотикою $O(T(n) \cdot \log W)$, де $W$ - потрібна точність, $T(n)$ - час розв'язку підзадачі для масиву довжини $n$ (який може змінюватися в залежності від конкретних накладених додаткових обмежень).

### Розв'язання задачі в режимі онлайн

Умова задачі така: дано масив із $n$ чисел, а також число $L$. Надходять запити у вигляді $(l,r)$, і в відповідь на запит потрібно знайти підвідрізок послідовності $[l;r]$ довжини не менше $L$ з максимально можливим середнім арифметичним.

Алгоритм розв'язку цієї задачі досить складний. Автор даного алгоритму - KADR (Ярослав Твердохлеб) - [описав цей алгоритм у своєму повідомленні на форумі](http://e-maxx.ua/forum/viewtopic.php?id=410).