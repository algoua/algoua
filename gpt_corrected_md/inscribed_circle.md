# Знаходження вписаною кола в опуклому багатокутнику методом "стиснення сторін" ("shrinking sides") за $O(n \log n)$

Даний опуклий багатокутник з $n$ вершинами. Потрібно знайти вписане в нього коло максимального радіусу: тобто знайти його радіус і координати центра. Якщо при даному радіусі можливі декілька варіантів центрів, то достатньо знайти будь-який з них.

На відміну від описаного [тут](inscribed_circle_ternary) методу подвійного тернарного пошуку, асимптотика даного алгоритму - $O(n \log n)$ - не залежить від обмежень на координати і не потребує певної точності. Тому цей алгоритм підходить для значно великих $n$ та великих обмежень на величину координат. Крім того, слід замінити русизми на українські слова: "подвійний тернарний пошук" замінити на "метод двойного тернарного пошуку".

Дякуємо **[Івану Красильникову (mf)](http://acm.uva.es/board/memberlist.php?mode=viewprofile&u=4424)** за опис цього чудового алгоритму.

## Алгоритм

Отже, дано опуклий багатокутник. Почнемо одночасно і з однаковою швидкістю **зсувати** всі його сторони паралельно самим собі всередину багатокутника:

\img{inscribed_circle_shrinking.jpg}

Нехай, для зручності, цей рух відбувається із швидкістю 1 координатна одиниця за секунду (тобто час, в якому-небудь сенсі, дорівнює відстані: після однієї одиниці часу кожна точка пройде відстань, що дорівнює одиниці).

У процесі цього руху сторони багатокутника поступово зникатимуть (перетворюватимуться на точки). Рано чи пізно весь багатокутник стиснеться до точки або відрізка, і цей момент часу $t$ стане **відповіддю на задачу** - шуканим радіусом (при цьому центр шуканого кола лежатиме на цьому відрізку). Насправді, якщо ми стиснули багатокутник на товщину $t$ у всіх напрямках, і він перетворився на точку/відрізок, то це означає, що існує точка, яка віддалена від усіх сторін багатокутника на відстані $t$, а для більших відстаней - такої точки вже не існує.

Отже, нам потрібно навчитися ефективно моделювати цей процес стиснення. Для цього навчимося для кожної сторони **визначати час**, через який вона стиснеться до точки.

Для цього розглянемо уважно процес руху сторін. Зауважимо, що вершини багатокутника завжди рухаються по бісектрисах кутів (це випливає з рівності відповідних трикутників). Але тоді питання про час, через який сторона стиснеться, зводиться до питання про визначення висоти $H$ трикутника, в якому відома довжина сторони $L$ і два прилеглі до неї кути $\alpha$ і $\beta$. Скориставшись, наприклад, теоремою синусів, отримуємо формулу:

$$
H = L \cdot \frac{ \sin \alpha \cdot \sin \beta }{ \sin (\alpha + \beta) }.
$$

Тепер ми вміємо визначати час, через який сторона стиснеться в точку за $O(1)$.

Занесемо ці часи для кожної сторони до якоїсь **структури даних для вилучення мінімуму**, наприклад, червоно-чорного дерева ($\rm set$ у мові C++).

Тепер, якщо ми виберемо сторону з **найменшим часом $H$**, то ця сторона першою стиснеться в точку - в момент часу $H$. Якщо багатокутник ще не стиснувся в точку/відрізок, то цю сторону треба **видалити** з багатокутника і продовжити алгоритм для залишених сторін. При видаленні сторони ми повинні **з'єднати** один з її лівих і правих сусідів, **продовживши** їх до точки їх перетину. При цьому необхідно буде знайти цю точку перетину, перерахувати довжини двох сторін і їх часи зникнення.

При реалізації для кожної сторони доведеться зберігати номер її правого і лівого сусіда (тим самим як у багатокутнику з двостороннім зв'язком). Це дозволяє реалізувати видалення сторони і зв'язування двох її сусідів за $O(1)$.

Якщо при видаленні сторони виявляється, що її сусідні сторони **паралельні**, то це означає, що багатокутник після цього стискання вироджується в точку або відрізок, тому ми можемо зразу зупиняти алгоритм і повертати в якості відповіді час зникнення поточної сторони (так що проблем з паралельними сторонами не виникає).

Якщо така ситуація з паралельними сторонами не виникає, то алгоритм дороблятиметься до моменту, коли в багатокутнику залишиться тільки дві сторони - і тоді відповіддю на задачу буде час видалення останньої сторони.

Очевидно, асимптотика цього алгоритму становить $O(n \log n)$, оскільки на кожному з $n$ кроків відбувається видалення однієї сторони (для цього виконується кілька операцій з $\rm set$ за час $O(n \log n)$). Російське слово "виготовляється" слід замінити на українське "виконується".

## Реалізація

Наведемо реалізацію описаного вище алгоритму. Дана реалізація повертає тільки радіус шуканого кола; проте додавання виведення центру кола не становить великої праці.

Даний алгоритм є елегантним тим, що з обчислювальної геометрії потрібно тільки знаходити кут між двома сторонами, перетин двох прямих та перевірку двох прямих на паралельність.

Зауваження. Передбачається, що поданий на вхід багатокутник є **строго опуклим**, тобто жодні три точки не лежать на одній прямій.

<!--- TODO: specify code snippet id -->
``` cpp
const double EPS = 1E-9;
const double PI = ...;

struct pt {
    double x, y;
    pt() {}
    pt(double x, double y) : x(x), y(y) {}
    pt operator-(const pt &p) const { return pt(x - p.x, y - p.y); }
};

double dist(const pt &a, const pt &b) { return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y)); }

double get_ang(const pt &a, const pt &b) {
    double ang = abs(atan2(a.y, a.x) - atan2(b.y, b.x));
    return min(ang, 2 * PI - ang);
}

struct line {
    double a, b, c;
    line(const pt &p, const pt &q) {
        a = p.y - q.y;
        b = q.x - p.x;
        c = -a * p.x - b * p.y;
        double z = sqrt(a * a + b * b);
        a /= z, b /= z, c /= z;
    }
};

double det(double a, double b, double c, double d) { return a * d - b * c; }

pt intersect(const line &n, const line &m) {
    double zn = det(n.a, n.b, m.a, m.b);
    return pt(-det(n.c, n.b, m.c, m.b) / zn, -det(n.a, n.c, m.a, m.c) / zn);
}

bool parallel(const line &n, const line &m) { return abs(det(n.a, n.b, m.a, m.b)) < EPS; }

double get_h(const pt &p1, const pt &p2, const pt &l1, const pt &l2, const pt &r1, const pt &r2) {
    pt q1 = intersect(line(p1, p2), line(l1, l2));
    pt q2 = intersect(line(p1, p2), line(r1, r2));
    double l = dist(q1, q2);
    double alpha = get_ang(l2 - l1, p2 - p1) / 2;
    double beta = get_ang(r2 - r1, p1 - p2) / 2;
    return l * sin(alpha) * sin(beta) / sin(alpha + beta);
}

struct cmp {
    bool operator()(const pair<double, int> &a, const pair<double, int> &b) const {
        if (abs(a.first - b.first) > EPS)
            return a.first < b.first;
        return a.second < b.second;
    }
};

int main() {
    int n;
    vector<pt> p;
...читання $n$ і $p$...

        vector<int>
            next(n), prev(n);
    for (int i = 0; i < n; ++i) {
        next[i] = (i + 1) % n;
        prev[i] = (i - 1 + n) % n;
    }

    set<pair<double, int>, cmp> q;
    vector<double> h(n);
    for (int i = 0; i < n; ++i) {
        h[i] = get_h(p[i], p[next[i]], p[i], p[prev[i]], p[next[i]], p[next[next[i]]]);
        q.insert(make_pair(h[i], i));
    }

    double last_time;
    while (q.size() > 2) {
        last_time = q.begin()->first;
        int i = q.begin()->second;
        q.erase(q.begin());

        next[prev[i]] = next[i];
        prev[next[i]] = prev[i];
        int nxt = next[i], nxt1 = (nxt + 1) % n, prv = prev[i], prv1 = (prv + 1) % n;
        if (parallel(line(p[nxt], p[nxt1]), line(p[prv], p[prv1])))
            break;

        q.erase(make_pair(h[nxt], nxt));
        q.erase(make_pair(h[prv], prv));

        h[nxt] = get_h(p[nxt], p[nxt1], p[prv1], p[prv], p[next[nxt]], p[(next[nxt] + 1) % n]);
        h[prv] = get_h(p[prv], p[prv1], p[(prev[prv] + 1) % n], p[prev[prv]], p[nxt], p[nxt1]);

        q.insert(make_pair(h[nxt], nxt));
        q.insert(make_pair(h[prv], prv));
    }

    cout << last_time << endl;
}
```

Основна функція тут - це $get\_h()$, яка за допомогою лівого і правого сусідів обчислює час зникнення цієї сторони. Для цього знаходиться точка перетину цієї сторони з сусідами, і за допомогою формули, наведеної вище, обчислюється шуканий час.