# Алгоритми хешування в завданнях на рядки

Алгоритми хешування рядків допомагають вирішити багато задач. Однак, у них є великий недолік: дуже часто вони не є 100% точними, оскільки існує множина рядків, хеші яких збігаються. Інша справа, що в більшості задач на це можна не звертати увагу, оскільки ймовірність збігу хешів все ж дуже мала.

&nbsp;

## Визначення хеша і його обчислення

Один із кращих способів визначення хеш-функції для рядка S полягає в наступному:

$$
h(S)  =  S[0]  +  S[1] * P  +  S[2] * P^2  +  S[3] * P^3  +  ...  +  S[N] * P^N
$$

де $P$ - деяке число.

Розумно обирати для P просте число, що приблизно дорівнює кількості символів у вхідному алфавіті. Наприклад, якщо передбачається, що рядки складаються тільки з малих латинських літер, то хорошим вибором буде P = 31. Якщо літери можуть бути як малими, так і великими, то, наприклад, можна вибрати P = 53.

У всіх частинах коду в цій статті буде використовуватися значення P = 31.

Саме значення хешу бажано зберігати у найбільшому числовому типі - int64, він же long long. Очевидно, що при довжині рядка біля 20 символів вже буде відбуватися переповнення значення. Ключовий момент полягає в тому, що ми не звертаємо увагу на ці переповнення, беручи хеш за модулем 2^64.

Приклад обчислення хешу, якщо допустимі тільки малі латинські літери:

<!--- TODO: specify code snippet id -->
``` cpp
const int p = 31;
long long hash = 0, p_pow = 1;
for (size_t i = 0; i < s.length(); ++i) {
Бажано віднімати код літери 'a' від коду поточної букви
// Додаємо одиницю, щоб у рядку "aaaaa" хеш був ненульовим
    hash += (s[i] - 'a' + 1) * p_pow;
    p_pow *= p;
}
```
У більшості задач має сенс спочатку обчислити всі необхідні степені P у якомусь масиві.

&nbsp;

## Приклад задачі. Пошук однакових рядків

Вже зараз ми здатні ефективно вирішити таку задачу. Маємо список рядків S[1..N], кожен з яких має довжину не більше M символів. Припустимо, що потрібно знайти всі повторювані рядки та розділити їх на групи, таким чином, щоб у кожній групі були лише однакові рядки.

За допомогою звичайного сортування рядків ми отримаємо алгоритм із складністю O(NM log N), тоді як використовуючи хеші, ми отримаємо O(NM + N log N).  (виправлено русизми та помилки в написанні)

Алгоритм. Порахуємо хеш від кожної рядка, і відсортуємо рядки за цим хешем.

<!--- TODO: specify code snippet id -->
``` cpp
vector<string> s(n);
// ... зчитування рядків ...

Припустимо всі показники $p$, допустимі до 10000 - максимальної довжини рядка
const int p = 31;
vector<long long> p_pow(10000);
p_pow[0] = 1;
for (size_t i = 1; i < p_pow.size(); ++i)
    p_pow[i] = p_pow[i - 1] * p;

Припустимо хеші від усіх рядків
У масиві зберігаємо значення хешу та номер рядка в масиві s
vector<pair<long long, int>> hashes(n);
for (int i = 0; i < n; ++i) {
    long long hash = 0;
    for (size_t j = 0; j < s[i].length(); ++j)
        hash += (s[i][j] - 'a' + 1) * p_pow[j];
    hashes[i] = make_pair(hash, i);
}

Сортуємо за хешами
sort(hashes.begin(), hashes.end());

Виводимо відповідь
for (int i = 0, group = 0; i < n; ++i) {
    if (i == 0 || hashes[i].first != hashes[i - 1].first)
        cout << "\nGroup " << ++group << ":";
    cout << ' ' << hashes[i].second;
}
```

&nbsp;

## Хеш підрядка і його швидке обчислення

Припустимо, що нам дано рядок S, а також індекси I та J. Необхідно знайти хеш від підрядка S[I..J].

Згідно з визначенням, маємо:

$$
H[I..J]  =  S[I]  +  S[I+1] * P  +  S[I+2] * P^2  +  ...  + S[J] * P^(J-I)
$$

звідки:

$$
H[I..J] * P[I]  =  S[I] * P[I]  +  ...  +  S[J] * P[J],
H[I..J] * P[I]  =  H[0..J]  -  H[0..I-1]
$$

Отримана властивість є дуже важливою.

Дійсно, виходить, що **знаючи лише хеші всіх префіксів рядка S, ми можемо отримати хеш будь-якої підрядки за O(1)**.

Єдине, що виникає проблема - це те, що потрібно вміти ділити на P[I]. Насправді, це не так просто. Оскільки ми обчислюємо хеш за модулем $2^{64}$, то для ділення на P[I] ми повинні знайти до нього зворотний елемент у полі (наприклад, за допомогою [Розширеного алгоритму Евкліда](https://uk.wikipedia.org/wiki/Розширений_алгоритм_Евкліда)), і виконати множення на цей зворотний елемент.

Втім, існує більш простий шлях. У більшості випадків, замість того, щоб ділити хеші на степені P, можна, навпаки, помножити їх на ці степені.

Припустимо, є два хеші: один помножений на P[I], а інший - на P[J]. Якщо I < J, то помножимо перший хеш на P[J-I], інакше - другий хеш помножимо на P[I-J]. Тепер ми привели хеші до однакової степені і можемо спокійно порівнювати їх.

Наприклад, код, який обчислює хеші всіх префіксів, а потім за $O(1)$ порівнює дві підрядки:

<!--- TODO: specify code snippet id -->
``` cpp
string s;
int i1, i2, length; // вхідні дані

Припустимо всі степені $p$
const int p = 31;
vector<long long> p_pow(s.length());
p_pow[0] = 1;
for (size_t i = 1; i < p_pow.size(); ++i)
    p_pow[i] = p_pow[i - 1] * p;

Припустимо хеші всіх префіксів
vector<long long> h(s.length());
for (size_t i = 0; i < s.length(); ++i) {
    h[i] = (s[i] - 'a' + 1) * p_pow[i];
    if (i)
        h[i] += h[i - 1];
}

Отримуємо хеші двох підрядків
long long h1 = h[i1 + len - 1];
if (i1)
    h1 -= h[i1 - 1];
long long h2 = h[i2 + len - 1];
if (i2)
    h2 -= h[i2 - 1];

Порівнюємо їх
if (i1 < i2 && h1 * p_pow[i2 - i1] == h2 || i1 > i2 && h1 == h2 * p_pow[i1 - i2])
    cout << "equal";
else
    cout << "different";
```

## Застосування хешування

Ось деякі типові застосування хешування:

* Алгоритм Рабіна-Карпа для пошуку підрядки в рядку за O(N)
* Визначення кількості різних підрядків за $O(N^2 \log N)$ (див. нижче)
* Визначення кількості паліндромів всередині рядка

## Визначення кількості різних підрядків

Нехай дано рядок $S$ довжиною $N$, що складається тільки з малих латинських букв. Потрібно знайти кількість різних підрядків в цій рядку.

Для розв'язання переберемо послідовно довжину підрядки: L = 1..N.

Для кожного L ми побудуємо масив хешів підрядків довжини L, причому приведемо хеші до однієї степені та відсортуємо цей масив. Кількість різних елементів у цьому масиві додаємо до відповіді.

Реалізація:

<!--- TODO: specify code snippet id -->
``` cpp
рядок s; // вхідний рядок
int n = (int)s.length();

Припустімо всі степені $p$
const int p = 31;
vector<long long> p_pow(s.length());
p_pow[0] = 1;
for (size_t i = 1; i < p_pow.size(); ++i)
    p_pow[i] = p_pow[i - 1] * p;

Припустимо хеші від усіх префіксів
vector<long long> h(s.length());
for (size_t i = 0; i < s.length(); ++i) {
    h[i] = (s[i] - 'a' + 1) * p_pow[i];
    if (i)
        h[i] += h[i - 1];
}

int result = 0;

Перебираємо довжину підрядка
for (int l = 1; l <= n; ++l) {
// Шукаємо відповідь для поточної довжини

Отримуємо хеші для всіх підрядків довжини $l$
    vector<long long> hs(n - l + 1);
    for (int i = 0; i < n - l + 1; ++i) {
        long long cur_h = h[i + l - 1];
        if (i)
            cur_h -= h[i - 1];
Наводимо всі хеші до однієї степені
        cur_h *= p_pow[n - i - 1];
        hs[i] = cur_h;
    }

Припустімо, що кількість різних хешів
    sort(hs.begin(), hs.end());
    hs.erase(unique(hs.begin(), hs.end()), hs.end());
    result += (int)hs.size();
}

cout << result;
```