# Максимальний потік методом Протікання предпотоку за O(N^4)

Нехай дано граф G, в якому виділені дві вершини: джерело S і стік T, а кожному ребру визначена пропускна здатність C<sub>u,v</sub>. Потік F можна уявити як потік речовини, який міг би пройти по мережі від джерела до стоку, якщо розглядати граф як мережу труб з деякими пропускними здібностями. Тобто, потік - це функція F<sub>u, v</sub>, визначена на множині ребер графа.

&nbsp;

Задача полягає у знаходженні максимального потоку. Тут буде розглянуто метод Протікання предпотоку, що працює за O(N<sup>4</sup>), або, точніше, за O(N<sup>2</sup> M). Алгоритм був запропонований Голдбергом у 1985 році.

## Алгоритм

Загальна схема алгоритму така: на кожному кроці розглядається деякий препотік - тобто функція, яка за своїми властивостями нагадує потік, але не обов'язково задовольняє закону збереження потоку. На кожному кроці намагаємося застосувати одну з двох операцій: проштовхування потоку або підняття вершини. Якщо на якомусь кроці стає неможливо застосувати одну з цих операцій, то знайдено необхідний потік.

Для кожної вершини визначена її висота H<sub>u</sub>, причому H<sub>S</sub> дорівнює N, H<sub>T</sub> дорівнює 0, а для будь-якого листового ребра (u, v) маємо H<sub>u</sub> ≤ H<sub>v</sub> + 1.

Для кожної вершини (окрім S) можна визначити її надлишок: E<sub>u</sub> = F<sub>V, u</sub>. Вершина з додатнім надлишком називається переповненою.

Операцію проштовхування Push (u, v) можна застосувати, якщо вершина u переповнена, залишкова пропускна здатність Cf<sub>u, v</sub> більше 0 і H<sub>u</sub> = H<sub>v</sub> + 1. Операція проштовхування полягає в максимальному збільшенні потоку з u в v, обмеженому залишковим витоком E<sub>u</sub> та залишковою пропускною здатністю Cf<sub>u, v</sub>.

Операція підняття Lift (u) піднімає переповнену вершину u на максимально допустиму висоту, тобто H<sub>u</sub> = 1 + min { H<sub>v</sub> }, де (u, v) - остаточне ребро.

Залишилося лише розглянути ініціалізацію потоку. Потрібно ініціалізувати лише наступні значення: F<sub>S, v</sub> = C<sub>S, v</sub>, F<sub>u, S</sub> = - C<sub>u, S</sub>, інші значення встановити рівними нулю.

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
const int inf = 1000 * 1000 * 1000;

typedef vector<int> graf_line;
typedef vector<graf_line> graf;

typedef vector<int> vint;
typedef vector<vint> vvint;

void push(int u, int v, vvint &f, vint &e, const vvint &c) {
    int d = min(e[u], c[u][v] - f[u][v]);
    f[u][v] += d;
    f[v][u] = -f[u][v];
    e[u] -= d;
    e[v] += d;
}

void lift(int u, vint &h, const vvint &f, const vvint &c) {
    int d = inf;
    for (int i = 0; i < (int)f.size(); i++)
        if (c[u][i] - f[u][i] > 0)
            d = min(d, h[i]);
    if (d == inf)
        return;
    h[u] = d + 1;
}

int main() {
    int n;
    cin >> n;
    vvint c(n, vint(n));
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            cin >> c[i][j];
Джерело - вершина 0, стік - вершина n-1

    vvint f(n, vint(n));
    for (int i = 1; i < n; i++) {
        f[0][i] = c[0][i];
        f[i][0] = -c[0][i];
    }

    vint h(n);
    h[0] = n;

    vint e(n);
    for (int i = 1; i < n; i++)
        e[i] = f[0][i];

    for (;;) {
        int i;
        for (i = 1; i < n - 1; i++)
            if (e[i] > 0)
                break;
        if (i == n - 1)
            break;

        int j;
        for (j = 0; j < n; j++)
            if (c[i][j] - f[i][j] > 0 && h[i] == h[j] + 1)
                break;
        if (j < n)
            push(i, j, f, e, c);
        else
            lift(i, h, f, c);
    }

    int flow = 0;
    for (int i = 0; i < n; i++)
        if (c[0][i])
            flow += f[0][i];

    cout << max(flow, 0);
}
```