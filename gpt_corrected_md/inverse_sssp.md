# Зворотня задача найкоротших шляхів з однієї вершини (inverse-SSSP)

Є зважений неорієнтований мультиграф G з N вершинами і M ребрами. Даний масив P[1..N] і вказана деяка початкова вершина S. Потрібно змінити ваги ребер так, щоб для всіх I P[I] було рівне довжині найкоротшого шляху з S в I, причому сума всіх змін (сума модулів змін ваг ребер) була найменшою. Якщо цього зробити неможливо, то алгоритм повинен видати "No solution". Зробити вагу ребра від'ємною заборонено.

## Опис розв'язання

Ми вирішимо цю задачу за лінійний час, просто перебравши всі ребра (тобто за один прохід).

Нехай на поточному кроці ми розглядаємо ребро з вершини A до вершини B довжиною R. Ми припускаємо, що для вершини A вже виконані всі умови (тобто відстань від S до A дійсно дорівнює P[A]), і будемо перевіряти виконання умов для вершини B. Маємо кілька варіантів ситуацій:

* 1. **P[A] + R < P[B]**
Це означає, що ми знайшли шлях, який є коротшим, ніж він повинен бути. Оскільки ми не можемо змінювати P[A] і P[B], то ми зобов'язані подовжити поточне ребро (незалежно від інших ребер), а саме виконати:
R += P[B] - P[A] - R.
Крім того, це означає, що ми вже знайшли шлях до вершини B з S, довжина якого дорівнює значенню P[B], тому на наступних кроках нам не доведеться скорочувати будь-які ребра (див. варіант 2).
* 2. **P[A] + R >= P[B]**
Це означає, що ми знайшли шлях, який є більш довгим, ніж необхідно. Оскільки може бути декілька таких шляхів, ми повинні вибрати серед них той, який потребує найменшої зміни. Зазначимо, що якщо ми збільшили довжину якоїсь ребра, що веде до вершини B (різновид 1), то ми фактично побудували найкоротший шлях до вершини B, тому вже не потрібно скорочувати жодне ребро. Таким чином, для кожної вершини ми повинні зберігати ребро, яке ми збираємося скоротити, тобто ребро з найменшою вагою зміни.

Таким чином, просто перебравши всі ребра і розглянувши для кожного ребра ситуацію (за O(1)), ми вирішимо зворотню задачу SSSP за лінійний час.

Якщо в якийсь момент ми намагаємося змінити вже змінене ребро, то, очевидно, цього робити не можна, і випливає видати "Немає рішення". Крім того, у деяких вершинах може бути так і не досягнута необхідна оцінка найкоротшого шляху, тоді відповідь також буде "Немає рішення". У всіх інших випадках (крім, звісно, явно некоректних значень в масиві P, тобто P[S] ≠ 0 або негативних значень) відповідь буде існувати.

## Реалізація

Програма виводить "Немає розв'язку", якщо розв'язку немає, інакше виводить у першому рядку мінімальну суму змін ваг ребер, а в наступних M рядках - нові ваги ребер.

<!--- TODO: specify code snippet id -->
``` cpp
const int INF = 1000 * 1000 * 1000;
int n, m;
vector<int> p(n);

bool ok = true;
vector<int> cost(m), cost_ch(m), decrease(n, INF), decrease_id(n, -1);
decrease[0] = 0;
for (int i = 0; i < m; ++i) {
int a, b, c; // Поточне ребро (a,b) із вартістю c
    cost[i] = c;

    for (int j = 0; j <= 1; ++j) {
        int diff = p[b] - p[a] - c;
        if (diff > 0) {
            ok &= cost_ch[i] == 0 || cost_ch[i] == diff;
            cost_ch[i] = diff;
            decrease[b] = 0;
        } else if (-diff <= c && -diff < decrease[b]) {
            decrease[b] = -diff;
            decrease_id[b] = i;
        }
        swap(a, b);
    }
}

for (int i = 0; i < n; ++i) {
    ok &= decrease[i] != INF;
    int r_id = decrease_id[i];
    if (r_id != -1) {
        ok &= cost_ch[r_id] == 0 || cost_ch[r_id] == -decrease[i];
        cost_ch[r_id] = -decrease[i];
    }
}

if (!ok)
    cout << "No solution";
else {
    long long sum = 0;
    for (int i = 0; i < m; ++i)
        sum += abs(cost_ch[i]);
    cout << sum << \'\n\'; for (int i = 0; i < m; ++i) printf("%d ", cost[i] + cost_ch[i]);
}
```