# Бінарне піднесення до степеня

Бінарне (двійкове) піднесення до ступеня - це прийом, який дозволяє підносити будь-яке число до $n$-ої ступені за $O(\log n)$ множень (замість $n$ множень при звичайному підході).

Більше того, описаний тут прийом застосовується до будь-якої **асоціативної** операції, а не тільки до множення чисел. Нагадаємо, операція називається асоціативною, якщо для будь-яких $a, b, c$ виконується:

$$
(a \cdot b) \cdot c = a \cdot (b \cdot c)
$$

Найбільш очевидне узагальнення - на залишки по певному модулю (очевидно, що асоціативність зберігається). Наступним за "популярністю" є узагальнення на множення матриць (його асоціативність загальновідома).

## Алгоритм

Зауважимо, що для будь-якого числа $a$ і **парного** числа $n$ виконується очевидна тотожність (випливає з асоціативності операції множення):

$$
a^n = (a^{n/2})^2 = a^{n/2} \cdot a^{n/2}
$$

Це є основним у методі бінарного піднесення до степеня. Дійсно, для парного $n$ ми показали, як, використовуючи всього одну операцію множення, можна звести задачу до степеня, що вдвічі менше.

Залишилося зрозуміти, що робити, якщо ступінь $n$ **непарний**. Тут ми чинимо дуже просто: перейдемо до степені $n-1$, яка буде вже парною

$$
a^n = a^{n-1} \cdot a
$$

Отже, ми фактично знайшли рекурентну формулу: від степені $n$ ми переходимо, якщо вона парна, до $n/2$, а інакше - до $n-1$. Зрозуміло, що всього буде не більше $2 \log n$ переходів, перш ніж ми прийдемо до $n = 0$ (база рекурентної формули). Таким чином, ми отримали алгоритм, що працює за $O(\log n)$ множень.

## Реалізація

Найпростіша рекурсивна реалізація:

<!--- TODO: specify code snippet id -->
``` cpp
int binpow(int a, int n) {
    if (n == 0)
        return 1;
    if (n % 2 == 1)
        return binpow(a, n - 1) * a;
    else {
        int b = binpow(a, n / 2);
        return b * b;
    }
}
```

Нерекурсивна реалізація, також оптимізована (ділення на 2 замінені бітовими операціями):

<!--- TODO: specify code snippet id -->
``` cpp
int binpow(int a, int n) {
    int res = 1;
    while (n)
        if (n & 1) {
            res *= a;
            --n;
        } else {
            a *= a;
            n >>= 1;
        }
    return res;
}
```

Цю реалізацію можна ще спростити, помітивши, що піднесення $a$ до квадрату здійснюється завжди, незалежно від того, чи виконалася умова непарності $n$ чи ні

<!--- TODO: specify code snippet id -->
``` cpp
int binpow(int a, int n) {
    int res = 1;
    while (n) {
        if (n & 1)
            res *= a;
        a *= a;
        n >>= 1;
    }
    return res;
}
```

Нарешті, варто відзначити, що бінарне піднесення до степеня вже реалізовано в мові Java, проте лише для класу довгої арифметики BigInteger (функція pow цього класу працює саме за алгоритмом бінарного піднесення).

## Приклади розв'язання задач

### Эффективное обчислення чисел Фібоначчі

Умова. Дано число $n$. Потрібно обчислити $F_n$, де $F_i$ - послідовність чисел Фібоначчі.

Розв'язок. Більш детально цей розв'язок описано в [статті про послідовності Фібоначчі](https://uk.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%B0_%D0%A4%D1%96%D0%B1%D0%BE%D0%BD%D0%B0%D1%87%D1%87%D1%96). Тут ми лише коротко наведемо суть цього розв'язку.

Основна ідея полягає в наступному. Обчислення наступного числа Фібоначчі базується на знанні двох попередніх чисел Фібоначчі. Кожне число Фібоначчі виходить як сума двох попередніх. Це означає, що можна побудувати матрицю $2 \times 2$, яка буде відповідати цьому перетворенню. З двох чисел Фібоначчі $F_i$ і $F_{i+1}$ можна обчислити наступне число, перейшовши до пари $F_{i+1}$, $F_{i+2}$. Наприклад, застосовуючи це перетворення $n$ разів до пари $F_0$ і $F_1$, отримаємо пару $F_n$ і $F_{n+1}$. Таким чином, піднімаючи матрицю цього перетворення до $n$-ої ступені, можна знайти $F_n$ за час $O(\log n)$.

### Піднесення перестановки до $k$-го степеня

**Умова**. Дано перестановку $p$ довжини $n$. Потрібно піднести її до $k$-ої степені, тобто знайти, що вийде, якщо до тотожньої перестановки $k$ разів застосувати перестановку $p$.

**Розв'язок**. Просто застосуємо до перестановки $p$ описаний вище алгоритм бінарного піднесення до степеня. Жодних відмінностей порівняно з піднесенням чисел до степеня немає. Розв'язок має асимптотику $O(n \log k)$.

(Зауваження. Дану задачу можна розв'язати і більш ефективно, **за лінійний час**. Для цього достатньо виділити в перестановки всі цикли, після чого розглянути по окремо кожний цикл і, взявши $k$ за модулем довжини поточного циклу, знайти відповідь для цього циклу).

### Швидке застосування набору геометричних операцій до точок

**Умова**. Дано $n$ точок $p_i$ і $m$ перетворень, які потрібно застосувати до кожної з цих точок. Кожне перетворення - це або зсув на заданий вектор, або масштабування (множення координат на задані коефіцієнти), або обертання навколо заданої осі на заданий кут. Крім того, є складна операція циклічного повторення: вона має вигляд "повторити задану кількість разів заданий список перетворень" (операції циклічного повторення можуть вкладатися один в одного).

Потрібно обчислити результат застосування вказаних операцій до всіх точок (ефективно, тобто за час, менший ніж $O(n \cdot length)$, де $length$ - загальна кількість операцій, які необхідно виконати).

Розв'язок. Подивимося на різні види перетворень з точки зору того, як вони змінюють координати:

* Операція зсуву полягає у додаванні до всіх координат одиниці, помноженої на певні константи.

* Операція масштабування полягає у множенні кожної координати на певну константу.

* Операцію обертання навколо осі можна уявити наступним чином: нові координати можна отримати як лінійну комбінацію старих.

(Ми не будемо тут уточняти, як це виготовляється. Наприклад, можна для простоти уявити це у вигляді комбінації п'яти двовимірних поворотів: спочатку в площинах $OXY$ і $OXZ$ так, щоб вісь обертання співпала з позитивним напрямком осі $OX$, потім необхідний поворот навколо осі в площині $YZ$, потім зворотні повороти в площинах $OXZ$ і $OXY$ так, щоб вісь обертання повернулася в своє вихідне положення).

Як легко бачити, кожне з цих перетворень - це перерахунок координат за допомогою лінійних формул. Таким чином, будь-яке таке перетворення можна записати у вигляді матриці $4 \times 4$:

$$
\begin{pmatrix}
a_11 & a_{12} & a_{13} & a_{14} \\
a_21 & a_{22} & a_{23} & a_{24} \\
a_31 & a_{32} & a_{33} & a_{34} \\
a_41 & a_{42} & a_{43} & a_{44} \\
\end{pmatrix},
$$

при множенні (ліворуч) на рядок зі старими координатами і константами-одиницями отримуємо рядок з новими координатами і константами-одиницями:

$$
\begin{pmatrix} x & y & z & 1 \end{pmatrix} \cdot \begin{pmatrix}
a_{11} & a_{12} & a_{13} & a_{14} \\
a_{21} & a_{22} & a_{23} & a_{24} \\
a_{31} & a_{32} & a_{33} & a_{34} \\
a_{41} & a_{42} & a_{43} & a_{44} \\
\end{pmatrix} = \begin{pmatrix} x' & y' & z' & 1 \end{pmatrix}.
$$

Чому потрібно вводити фіктивну четверту координату, завжди рівну одиниці? Без цього не вийшло б реалізувати операцію зсуву: адже зсув - це саме додавання до координат одиниці, помноженої на деякі коефіцієнти. Без фіктивної одиниці ми могли б реалізувати тільки лінійні комбінації координат, але не могли б додавати до них задані константи.

Тепер розв'язок задачі стає майже тривіальним. Оскільки кожна елементарна операція описується матрицею, то послідовність операцій описується добутком цих матриць, а операція циклічного повторення - піднесенням цієї матриці до степеня. Таким чином, ми за час $O(m \cdot \log repetition)$ можемо попередньо порахувати матрицю $4 \times 4$, яка описує всі перетворення, і потім просто множимо кожну точку $p_i$ на цю матрицю - тим самим, ми відповідаємо на всі запити за час $O(n)$.

### Кількість шляхів фіксованої довжини в графі

**Умова**. Дано неорієнтований граф $G$ з $n$ вершинами та число $k$. Потрібно знайти кількість шляхів довжини $k$ між кожною парою вершин $i$ та $j$.

Розв'язок. Більш детально ця задача розглядається в [окремій статті](fixed_length_paths). Тут лише нагадаємо суть цього розв'язку: ми просто підносимо до $k$-ої степені матрицю суміжності цього графа, і елементи цієї матриці і будуть розв'язками. Підсумкова асимптотика - $O(n^3 \log k)$.

(Зауваження. У [цій же статті](fixed_length_paths) розглядається інша варіація цієї задачі: коли граф зважений і потрібно знайти шлях мінімальної ваги, що містить рівно $k$ ребер. Як показано в цій статті, дана задача також вирішується за допомогою бінарного піднесення до степеня матриці суміжності графа, однак замість звичайної операції множення двох матриць використовується модифікована: замість множення береться сума, а замість підсумовування - взяття мінімуму).

### Варіант бінарного піднесення до степеня: множення двох чисел за модулем

Наведемо тут цікаву варіацію піднесення числа до степеня.

Нехай перед нами стоїть така **задача**: перемножити два числа $a$ і $b$ за модулем $m$:

$$
a \cdot b \pmod m
$$

Припустимо, що числа можуть бути достатньо великі: настільки, що самі числа не поміщаються у вбудовані типи даних, а от їх безпосередній добуток $a \cdot b$ - вже ні (відзначимо, що нам також буде потрібно, щоб сума чисел поміщалася у вбудований тип даних). Відповідно, задача полягає в тому, щоб порахувати шукану величину $(a \cdot b) \pmod m$, не вдаючись до допомоги [довгої арифметики](https://uk.wikipedia.org/wiki/Довга_арифметика).

**Розв'язок** такий. Ми просто застосовуємо алгоритм бінарного піднесення, описаний вище, тільки замість операції множення ми будемо виконувати операцію додавання. Іншими словами, множення двох чисел ми звели до $O(\log m)$ операцій додавання і множення на два (що також, по суті, є додаванням).

(Зауваження. Дану задачу можна розв'язати **інакше**, скориставшись операціями з числами з плаваючою точкою. Зокрема, можна обчислити вираз $a \cdot b / m$ в числах з плаваючою точкою та округлити його до найближчого цілого. Таким чином можна знайти **приблизне** значення приватного ключа. Віднімаючи його від добутку $a \cdot b$ (ігноруючи переповнення), ми отримаємо невелике число, яке можна взяти за залишок від ділення на $m$. Цей підхід може бути ненадійним, але він дуже швидкий та легко реалізовується).

## Завдання в онлайн-суддях

Список задач, які можна вирішити, використовуючи бінарне піднесення до ступеня:

TODO