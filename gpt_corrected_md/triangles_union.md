# Знаходження площі перетину трикутників. Метод вертикальної декомпозиції

Дано N трикутники. Потрібно знайти площу їх перетину.

## Розв'язок

Тут ми розглянемо метод **вертикальної декомпозиції**, який у завданнях з геометрії часто виявляється дуже важливим.

Отже, у нас є N трикутників, які можуть перетинатися між собою будь-яким чином. Позбавимося від цих перетинів за допомогою вертикальної декомпозиції: знайдемо всі точки перетину всіх відрізків (утворені трикутниками) та відсортуємо їх за їх абсцисою. Нехай ми отримали масив B. Рухатимемося по цьому масиві. На i-му кроці розглядаємо елементи B[i] і B[i+1]. Маємо вертикальну смугу між прямими X = B[i] і X = B[i+1], причому, згідно з побудовою масиву B, всередині цієї смуги відрізки не перетинаються між собою. Отже, всередині цієї смуги трикутники перетворюються на трапеції, причому їх сторони всередині смуги не перетинаються взагалі. Рухатимемося по сторонах цих трапецій знизу вгору та додаватимемо їх площі, слідкуючи, щоб кожен шматок був зарахований рівно один раз. Фактично, цей процес дуже нагадує обробку вкладених дужок. Додавши площі трапецій всередині кожної смуги та результати для всіх смуг, ми отримаємо відповідь - площу перетину трикутників.

Розглянемо ще раз процес складання площ трапецій з точки зору реалізації. Ми перебираємо всі сторони всіх трикутників, і якщо якась сторона (не вертикальна, оскільки нам вертикальні сторони не потрібні, і навіть навпаки, вони будуть заважати) потрапляє в цю вертикальну полосу (повністю або частково), то ми додаємо цю сторону до деякого вектора, зручніше всього це робити в такому вигляді: координати Y в точках перетину сторони з кордонами вертикальної смуги, і номер трикутника. Після того, як ми побудували цей вектор, що містить куски сторін, сортуємо його за значеннями Y: спочатку за лівою Y, потім за правою Y. В результаті перший елемент в векторі буде містити нижню сторону самої нижньої трапеції. Тепер ми просто йдемо по отриманому вектору. Нехай i - поточний елемент; це означає, що i-ий шматок - це нижня сторона деякої трапеції, деякого блоку (який може містити декілька трапецій), площу якого ми хочемо зразу додати до відповіді. Тому ми встановлюємо лічильник трикутників рівним 1, і піднімаємося по відрізках вгору, і збільшуємо лічильник, якщо ми зустрічаємо сторону якогось трикутника вперше, і зменшуємо лічильник, якщо ми зустрічаємо трикутник у другий раз. Якщо на якомусь відрізку j лічильник став рівним нулю, то ми знаходимо верхній кордон блоку - на цьому ми зупиняємося, додаємо площу трапеції, обмеженої відрізками i і j, і i присвоюємо j+1, і повторюємо весь процес заново.

Отже, завдяки методу вертикальної декомпозиції ми вирішили цю задачу, використовуючи геометричні примітиви та лише операцію перетину двох відрізків.

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
struct segment {
    int x1, y1, x2, y2;
};

struct point {
    double x, y;
};

struct item {
    double y1, y2;
    int triangle_id;
};

struct line {
    int a, b, c;
};

const double EPS = 1E-7;

void intersect(segment s1, segment s2, vector<point> &res) {
    line l1 = {s1.y1 - s1.y2, s1.x2 - s1.x1, l1.a * s1.x1 + l1.b * s1.y1}, l2 = {s2.y1 - s2.y2, s2.x2 - s2.x1, l2.a * s2.x1 + l2.b * s2.y1};
    double det1 = l1.a * l2.b - l1.b * l2.a;
    if (abs(det1) < EPS)
        return;
    point p = {(l1.c * 1.0 * l2.b - l1.b * 1.0 * l2.c) / det1, (l1.a * 1.0 * l2.c - l1.c * 1.0 * l2.a) / det1};
    if (p.x >= s1.x1 - EPS && p.x <= s1.x2 + EPS && p.x >= s2.x1 - EPS && p.x <= s2.x2 + EPS)
        res.push_back(p);
}

double segment_y(segment s, double x) { return s.y1 + (s.y2 - s.y1) * (x - s.x1) / (s.x2 - s.x1); }

bool eq(double a, double b) { return abs(a - b) < EPS; }

vector<item> c;

bool cmp_y1_y2(int i, int j) {
    const item &a = c[i];
    const item &b = c[j];
    return a.y1 < b.y1 - EPS || abs(a.y1 - b.y1) < EPS && a.y2 < b.y2 - EPS;
}

int main() {
    int n;
    cin >> n;
    vector<segment> a(n * 3);
    for (int i = 0; i < n; ++i) {
        int x1, y1, x2, y2, x3, y3;
        scanf("%d%d%d%d%d%d", &x1, &y1, &x2, &y2, &x3, &y3);
        segment s1 = {x1, y1, x2, y2};
        segment s2 = {x1, y1, x3, y3};
        segment s3 = {x2, y2, x3, y3};
        a[i * 3] = s1;
        a[i * 3 + 1] = s2;
        a[i * 3 + 2] = s3;
    }

    for (size_t i = 0; i < a.size(); ++i)
        if (a[i].x1 > a[i].x2)
            swap(a[i].x1, a[i].x2), swap(a[i].y1, a[i].y2);

    vector<point> b;
    b.reserve(n * n * 3);
    for (size_t i = 0; i < a.size(); ++i)
        for (size_t j = i + 1; j < a.size(); ++j)
            intersect(a[i], a[j], b);

    vector<double> xs(b.size());
    for (size_t i = 0; i < b.size(); ++i)
        xs[i] = b[i].x;
    sort(xs.begin(), xs.end());
    xs.erase(unique(xs.begin(), xs.end(), &eq), xs.end());

    double res = 0;
    vector<char> used(n);
    vector<int> cc(n * 3);
    c.resize(n * 3);
    for (size_t i = 0; i + 1 < xs.size(); ++i) {
        double x1 = xs[i], x2 = xs[i + 1];
        size_t csz = 0;
        for (size_t j = 0; j < a.size(); ++j)
            if (a[j].x1 != a[j].x2)
                if (a[j].x1 <= x1 + EPS && a[j].x2 >= x2 - EPS) {
                    item it = {segment_y(a[j], x1), segment_y(a[j], x2), (int)j / 3};
                    cc[csz] = (int)csz;
                    c[csz++] = it;
                }
        sort(cc.begin(), cc.begin() + csz, &cmp_y1_y2);
        double add_res = 0;
        for (size_t j = 0; j < csz;) {
            item lower = c[cc[j++]];
            used[lower.triangle_id] = true;
            int cnt = 1;
            while (cnt && j < csz) {
                char &cur = used[c[cc[j++]].triangle_id];
                cur = !cur;
                if (cur)
                    ++cnt;
                else
                    --cnt;
            }
            item upper = c[cc[j - 1]];
            add_res += upper.y1 - lower.y1 + upper.y2 - lower.y2;
        }
        res += add_res * (x2 - x1) / 2;
    }

    cout.precision(8);
    cout << fixed << res;
}
```