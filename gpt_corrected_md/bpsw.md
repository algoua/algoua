# Тест БПШ на простоту чисел

## Введение

Алгоритм BPSW є тестом на простоту числа. Цей алгоритм отримав свою назву на честь його винахідників: Роберта Бейлі (Bailey), Карла Померанса (Pomerance), Джона Селфріджа (Selfridge), Семюеля Вагстаффа (Wagstaff). Алгоритм був запропонований у 1980 році. До цього часу не було знайдено жодного контрприкладу до алгоритму, але також не було доведено його правильність.

Алгоритм BPSW був перевірений на всіх числах до $10^{15}$. Крім того, контрприклад намагалися знайти за допомогою програми PRIMO (див. [[6]](#6)), заснованої на тесті на простоту з використанням еліптичних кривих. Програма, яка працювала три роки, не знайшла жодного контрприкладу, на підставі чого Мартін припустив, що не існує жодного BPSW-псевдопростого числа, меншого за $10^{10000}$ (псевдопросте число - складене число, на якому алгоритм дає результат "просте"). У той же час, Карл Померанс в 1984 році представив евристичне доведення того, що існує нескінченна множина BPSW-псевдопростих чисел.

Складність алгоритму BPSW становить O(log<sup>3</sup>(N)) бітових операцій. Якщо порівнювати його з іншими тестами, наприклад, з тестом Міллера-Рабіна, то алгоритм BPSW зазвичай працює 3-7 разів повільніше. Російське слово "бітових" краще замінити на "бітних".

Алгоритм часто застосовується на практиці. Здається, що багато комерційні математичні пакети, повністю або частково, використовують алгоритм BPSW для перевірки чисел на простоту.

## Короткий опис

Алгоритм має кілька різних реалізацій, що відрізняються одна від одної лише деталями. У нашому випадку алгоритм має наступний вигляд:

Виконати тест Міллера-Рабіна за основою 2.

Виконати сильний тест Люкаса-Селфріджа, використовуючи послідовності Люкаса з параметрами Селфріджа.

Повернути "просте" лише у тому випадку, якщо обидва тести повернули "просте".

Крім того, на початку алгоритму можна додати перевірку на тривіальні дільники, наприклад, до 1000. Це дозволить збільшити швидкість роботи на складених числах, хоча дещо збільшить час виконання на простих числах.

Отже, алгоритм БПШ базується на наступному:

1. (Факт) Тест Міллера-Рабіна та тест Лукаса-Селфрідж, якщо й помиляються, то тільки в одну сторону: деякі складові числа цими алгоритмами визнаються як прості. У зворотному напрямку ці алгоритми ніколи не помиляються.

(Припущення) Тест Міллера-Рабіна та тест Лукаса-Селфріджа, якщо й помиляються, то ніколи не помиляються на одному числі одночасно.

Насправді, друге припущення, здається, невірне - евристичне доведення-опроверження Померанса наведено нижче. Тим не менш, на практиці досі не знайшли жодного псевдопростого числа, тому умовно можна вважати друге припущення вірним.

## Реалізація алгоритмів у цій статті

Усі алгоритми в цій статті будуть реалізовані на мові C++. Усі програми тестувалися лише на компіляторі Microsoft C++ 8.0 SP1 (2005), але також повинні компілюватися на g++.

Алгоритми реалізовані з використанням шаблонів, що дозволяє застосовувати їх як до вбудованих числових типів, так і до власних класів, що реалізують довгу арифметику. [ Поки довга арифметика не входить до статті - TODO ]

У самій статті будуть наведені тільки суттєві функції, а текст допоміжних функцій можна завантажити в додатку до статті. Тут будуть наведені тільки заголовки цих функцій разом з коментарями:

<!--- TODO: specify code snippet id -->
``` cpp
//! Модуль 64-битного числа
long long **abs **(long long n);
unsigned long long abs(unsigned long long n);

Повертається true, якщо n є парним
template <class T> bool **even **(const T &n);

Ділить число на 2
template <class T> void **bisect **(T &n);

Помножує число на 2
template <class T> void **redouble **(T &n);

Повертає true, якщо n є точним квадратом простого числа
template <class T> bool **perfect_square **(const T &n);

Обчислює корінь з числа, округлюючи його вниз
template <class T> T **sq_root **(const T &n);

Повертає кількість біт у числі
template <class T> unsigned **bits_in_number **(T n);

Повертає значення k-го біту числа (біти нумеруються з нуля)
template <class T> bool **test_bit **(const T &n, unsigned k);

//! Примножує a *= b (mod n)
template <class T> void **mulmod **(T &a, T b, const T &n);

//! Обчислює a^k (mod n)
template <class T, class T2> T **powmod **(T a, T2 k, const T &n);

Перетворює число $n$ до форми $q\cdot2^p$
template <class T> void **transform_num **(T n, T &p, T &q);

Алгоритм Євкліда
template <class T, class T2> T **gcd **(const T &a, const T2 &b);

//! Обчислює jacobi(a,b) - символ Якобі
template <class T>
T **jacobi **(T a, T b)

Обчислює перші pi(b) простих чисел і повертає вектор з цими числами та значенням pi - pi(b)
    template <class T, class T2>
    const std::vector<T> &**get_primes **(const T &b, T2 &pi);

Тривіальна перевірка простоти числа n полягає у переборі всіх його дільників до кореня квадратного з n.
// Результат: 1 - якщо n точно просте, p - його знайдений дільник, 0 - якщо не відомо
template <class T, class T2> T2 **prime_div_trivial **(const T &n, T2 m);
```

## Тест Міллера-Рабіна

Я не буду звертати увагу на тест Міллера-Рабіна, оскільки він описаний у багатьох джерелах, в тому числі й на українській мові (див. наприклад [[5]](#5)).

Зазначу лише, що швидкість його роботи становить O(log<sup>3</sup>(N)) бітових операцій, і наведу готову реалізацію цього алгоритму:

<!--- TODO: specify code snippet id -->
``` cpp
template <class T, class T2> bool miller_rabin(T n, T2 b) {
Спочатку перевіряємо тривіальні випадки
    if (n == 2)
        return true;
    if (n < 2 || even(n))
        return false;

// перевіряємо, що n і b є взаємно простими (інакше це призведе до помилки)
Якщо вони не є взаємно простими, то або n не є простим, або потрібно збільшити b
    if (b < 2)
        b = 2;
    for (T g; (g = gcd(n, b)) != 1; ++b)
        if (n > g)
            return false;

    // розкладаємо n-1 = q*2^p
    T n_1 = n;
    --n_1;
    T p, q;
    transform_num(n_1, p, q);

// Обчислюємо b^q mod n. Якщо воно дорівнює 1 або n-1, то n є простим (або псевдопростим)
    T rem = powmod(T(b), q, n);
    if (rem == 1 || rem == n_1)
        return true;

Тепер обчислюємо $b^{2q}$, $b^{4q}$, ..., $b^{\frac{n-1}{2}}$
Якщо будь-яке з них дорівнює $n-1$, то $n$ є простим (або псевдопростим)
    for (T i = 1; i < p; i++) {
        mulmod(rem, rem, n);
        if (rem == n_1)
            return true;
    }

    return false;
}
```

## Сильний тест Люкаса-Селфріджа

Сильний тест Люкаса-Селфріджа складається з двох частин: алгоритму Селфріджа для обчислення деякого параметра та сильного алгоритму Люкаса, що виконується з цим параметром.

### Алгоритм Селфріджа

Серед послідовності 5, -7, 9, -11, 13, ... потрібно знайти перше число D, для якого J(D,N)=-1 і gcd(D,N)=1, де J(x,y) - символ Якобі.

Параметрами Селфріджа будуть P = 1 і Q = (1 - D) / 4.

Слід зауважити, що параметр Селфріджа не застосовується до чисел, які є точними квадратами. Якщо число є точним квадратом, то перебір D досягне значення sqrt(N), на якому буде виявлено, що gcd(D, N) > 1, тобто число N є складеним.

Крім того, параметри Селфріджа будуть обчислені неправильно для парних чисел і для одиниці; проте перевірка цих випадків не складе проблем.

Таким чином, **перед початком алгоритму** випливає перевірити, що число N є непарним, більшим за 2, і не є точним квадратом, інакше (при невиконанні хоча б однієї умови) потрібно зразу вийти з алгоритму з результатом "складене".

Нарешті, зауважимо, що якщо D для деякого числа N виявиться занадто великим, то алгоритм з обчислювальної точки зору виявиться непридатним. Хоча на практиці такого не спостерігалося (достатньо було 4-байтного числа), проте ймовірність цієї події не варто виключати. Наприклад, на відрізку [1; 10<sup>6</sup>] максимальне значення D = 47, а на відрізку [10<sup>19</sup>; 10<sup>19</sup>+10<sup>6</sup>] максимальне значення D = 67. Крім того, Бейлі та Вагстаф в 1980 році аналітично довели це спостереження (див. Рібенбойм, 1995/96, стор. 142).

### Сильний алгоритм Лукаса

Параметрами алгоритму Лукаса є числа D, P і Q такі, що D = P² - 4Q ≠ 0, і P > 0.

(Легко помітити, що параметри, обчислені за алгоритмом Селфріджа, задовольняють цим умовам)

**Послідовності Люкаса** - це послідовності U<sub>k</sub> та V<sub>k</sub>, визначені наступним чином:

$$
U<sub>0</sub> = 0
U<sub>1</sub> = 1
**U<sub>k</sub> = P U<sub>k-1</sub> - Q U<sub>k-2</sub>**
V<sub>0</sub> = 2
V<sub>1</sub> = P
**V<sub>k</sub> = P V<sub>k-1</sub> - Q V<sub>k-2</sub>**
$$

Далі нехай M = N - J(D, N).

Якщо $N$ є простим, і $\gcd(N, Q) = 1$, то маємо:

$$
**U<sub>M</sub> = 0 (mod N)**
$$

Зокрема, коли параметри D, P, Q обчислені за алгоритмом Селфріджа, маємо:

$$
U<sub>N+1</sub> = 0 (mod N)**
$$

Зворотне, загалом кажучи, неправильно. Тим не менш, псевдопрості числа за даного алгоритму виявляються не дуже часто, на чому, власне, і базується алгоритм Лукаса.

Отже, алгоритм Лукаса полягає в обчисленні Uₘ і порівнянні його з нулем.

Далі необхідно знайти спосіб прискорення обчислення U<sub>K</sub>. Інакше, зрозуміло, цей алгоритм не матиме практичного застосування.

Маємо:

$$
U<sub>k</sub> = (a<sup>k</sup> - b<sup>k</sup>) / (a - b),
V<sub>k</sub> = a<sup>k</sup> + b<sup>k</sup>,
$$

де $a$ і $b$ - різні корені квадратного рівняння $x^2 - Px + Q = 0$.

Тепер наступні рівності можна довести просто:

$$
U<sub>2k</sub> = U<sub>k</sub> V<sub>k</sub> (mod N)
V<sub>2k</sub> = V<sub>k</sub><sup>2</sup> - 2 Q<sup>k</sup> (mod N)
$$

Тепер, якщо уявити M = E 2<sup>T</sup>, де E - непарне число, то легко отримати:

$$
**U<sub>M</sub> = U<sub>E</sub> V<sub>E</sub> V<sub>2E</sub> V<sub>4E</sub> ... V<sub>2<sup>T-2</sup>E</sub> V<sub>2<sup>T-1</sup>E</sub> = 0 (mod N)**,
$$

хоча б один з множників дорівнює нулю за модулем N.

Зрозуміло, що **достатньо обчислити U<sub>E</sub> та V<sub>E</sub>**, а всі наступні добутки V<sub>2E</sub>, V<sub>4E</sub>, ..., V<sub>2<sup>T-2</sup>E</sub>, V<sub>2<sup>T-1</sup>E</sub> можна **отримати з них**.

Таким чином, залишилося навчитися швидко обчислювати U<sub>Е</sub> та V<sub>Е</sub> для непарного Е.

Спочатку розглянемо наступні формули для обчислення членів послідовності Люкаса:

$$
U<sub>i+j</sub> = (U<sub>i</sub> V<sub>j</sub> + U<sub>j</sub> V<sub>i</sub>) / 2 (mod N)
V<sub>i+j</sub> = (V<sub>i</sub> V<sub>j</sub> + D U<sub>i</sub> U<sub>j</sub>) / 2 (mod N)
$$

Слід звернути увагу, що ділення виконується за модулем N.

Ці формули доводяться дуже просто, але їх доведення тут опущено.

Тепер, маючи формули для додавання та подвоєння членів послідовності Люкаса, є зрозумілим спосіб прискорення обчислення U<sub>E</sub> та V<sub>E</sub>.

Дійсно, розглянемо двійкову запис числа Е. Покладемо спочатку результат - U<sub>E</sub> і V<sub>E</sub> - рівними, відповідно, U<sub>1</sub> і V<sub>1</sub>. Пройдемося по всім бітам числа Е від менш значущих до більш значущих, пропустивши тільки самий перший біт (початковий член послідовності). Для кожного i-го біта будемо обчислювати U<sub>2<sup>i</sup></sub> і V<sub>2<sup>i</sup></sub> з попередніх членів з допомогою формул подвоєння. Крім того, якщо поточний i-ий біт рівний одиниці, то до відповіді будемо додавати поточні U<sub>2<sup>i</sup></sub> і V<sub>2<sup>i</sup></sub> з допомогою формул додавання. Після закінчення алгоритму, що виконується за O(log(E)), ми **отримаємо шукані U<sub>E</sub> і V<sub>E</sub>**.

Якщо $U_{E}$ або $V_{E}$ виявилися рівними нулю (mod N), то число N є простим (або псевдопростим). Якщо вони обидва відмінні від нуля, то обчислюємо $V_{2E}$, $V_{4E}$, ..., $V_{2^{T-2}E}$, $V_{2^{T-1}E}$. Якщо хоча б один з них буде дорівнювати нулю за модулем N, то число N є простим (або псевдопростим). В іншому випадку число N є складеним.

### Обговорення алгоритму Селфріджа

Тепер, коли ми розглянули алгоритм Люкаса, можна більш детально зупинитися на його параметрах $D$, $P$, $Q$, одним з способів отримання яких є алгоритм Селфріджа.

Нагадаємо базові вимоги до параметрів:

$$
**P > 0**,
**D = P<sup>2</sup> - 4*Q ? 0**.
$$

Тепер продовжимо вивчення цих параметрів.

D не повинно бути точним квадратом (за модулем N).

Дійсно, інакше ми отримаємо:

D = b², звідси J(D,N) = 1, P = b + 2, Q = b + 1, звідси U<sub>n-1</sub> = (Q<sup>n-1</sup> - 1) / (Q - 1).

отже, якщо $D$ є точним квадратом, то алгоритм Лукаса стає практично звичайним ймовірнісним тестом.

Один з кращих способів уникнути подібного - **вимагати, щоб J(D,N) = -1**.

Наприклад, можна вибрати перше число D з послідовності 5, -7, 9, -11, 13, ..., для якого J(D,N) = -1. Також нехай P = 1. Отже, Q = (1 - D) / 4. Цей спосіб був запропонований Селфріджем.

Втім, є інші способи вибору D. Можна вибирати його з послідовності 5, 9, 13, 17, 21 тощо. Також нехай P - найменше непарне число, що перевищує sqrt(D). Тоді Q = (P<sup>2</sup> - D) / 4.

Зрозуміло, що від вибору конкретного способу обчислення параметрів Лукаса залежить його результат - псевдопрості можуть відрізнятися при різних способах вибору параметра. Як показала практика, алгоритм, запропонований Селфріджем, виявився дуже успішним: всі псевдопрості Лукаса-Селфрідж не є псевдопростими Міллера-Рабіна, принаймні, жодного контрприкладу не знайдено.

### Реалізація потужного алгоритму Лукаса-Селфріджа

Тепер залишилося лише реалізувати алгоритм:

<!--- TODO: specify code snippet id -->
``` cpp
template <class T, class T2> bool lucas_selfridge(const T &n, T2 unused) {
// Спочатку перевіряємо тривіальні випадки
    if (n == 2)
        return true;
    if (n < 2 || even(n))
        return false;

// Перевіряємо, що n не є точним квадратом. Інакше алгоритм дасть помилку
    if (perfect_square(n))
        return false;

// алгоритм Селфріджа: знаходимо перше число d таке, що:
jacobi(d,n)=-1, і воно належить до послідовності { 5,-7,9,-11,13,... }
    T2 dd;
    for (T2 d_abs = 5, d_sign = 1;; d_sign = -d_sign, ++ ++d_abs) {
        dd = d_abs * d_sign;
        T g = gcd(n, d_abs);
        if (1 < g && g < n)
// знайшли дільник - d\_abs
            return false;
        if (jacobi(T(dd), n) == -1)
            break;
    }

// Параметри Селфріджа
    T2 p = 1, q = (p * p - dd) / 4;

    // розкладаємо n+1 = d*2^s
    T n_1 = n;
    ++n_1;
    T s, d;
    transform_num(n_1, s, d);

Алгоритм Люкаса
    T u = 1, v = p, u2m = 1, v2m = p, qm = q, qm2 = q * 2, qkd = q;
    for (unsigned bit = 1, bits = bits_in_number(d); bit < bits; bit++) {
        mulmod(u2m, v2m, n);
        mulmod(v2m, v2m, n);
        while (v2m < qm2)
            v2m += n;
        v2m -= qm2;
        mulmod(qm, qm, n);
        qm2 = qm;
        redouble(qm2);
        if (test_bit(d, bit)) {
            T t1, t2;
            t1 = u2m;
            mulmod(t1, v, n);
            t2 = v2m;
            mulmod(t2, u, n);

            T t3, t4;
            t3 = v2m;
            mulmod(t3, v, n);
            t4 = u2m;
            mulmod(t4, u, n);
            mulmod(t4, (T)dd, n);

            u = t1 + t2;
            if (!even(u))
                u += n;
            bisect(u);
            u %= n;

            v = t3 + t4;
            if (!even(v))
                v += n;
            bisect(v);
            v %= n;
            mulmod(qkd, qm, n);
        }
    }

Точно просте (або псевдопросте)
    if (u == 0 || v == 0)
        return true;

// Довираховуємо залишився члени
    T qkd2 = qkd;
    redouble(qkd2);
    for (T2 r = 1; r < s; ++r) {
        mulmod(v, v, n);
        v -= qkd2;
        if (v < 0)
            v += n;
        if (v < 0)
            v += n;
        if (v >= n)
            v -= n;
        if (v >= n)
            v -= n;
        if (v == 0)
            return true;
        if (r < s - 1) {
            mulmod(qkd, qkd, n);
            qkd2 = qkd;
            redouble(qkd2);
        }
    }

    return false;
}
```

## Код BPSW

Тепер залишилося просто скомбінувати результати всіх трьох тестів: перевірка на невеликі тривіальні дільники, тест Міллера-Рабіна, сильний тест Лукаса-Селфріджа.

<!--- TODO: specify code snippet id -->
``` cpp
template <class T> bool baillie_pomerance_selfridge_wagstaff(T n) {
// Спочатку перевіряємо на тривіальні дільники - наприклад, до 29
    int div = prime_div_trivial(n, 29);
    if (div == 1)
        return true;
    if (div > 1)
        return false;

// Тест Міллера-Рабіна з основою 2
    if (!miller_rabin(n, 2))
        return false;

Сильний тест Люкаса-Селфріджа
    return lucas_selfridge(n, 0);
}
```
<a href="BPSW_main.zip">Звідси</a> можна завантажити програму, яка містить повну реалізацію тесту BPSW (код + exe). [77 КБ]

## Коротка реалізація

Довжину коду можна значно зменшити, відмовившись від шаблонів та різних допоміжних функцій, але це зменшить універсальність.

<!--- TODO: specify code snippet id -->
``` cpp
const int trivial_limit = 50;
int p[1000];

int gcd(int a, int b) { return a ? gcd(b % a, a) : b; }

int powmod(int a, int b, int m) {
    int res = 1;
    while (b)
        if (b & 1)
            res = (res * 1ll * a) % m, --b;
        else
            a = (a * 1ll * a) % m, b >>= 1;
    return res;
}

bool miller_rabin(int n) {
    int b = 2;
    for (int g; (g = gcd(n, b)) != 1; ++b)
        if (n > g)
            return false;
    int p = 0, q = n - 1;
    while ((q & 1) == 0)
        ++p, q >>= 1;
    int rem = powmod(b, q, n);
    if (rem == 1 || rem == n - 1)
        return true;
    for (int i = 1; i < p; ++i) {
        rem = (rem * 1ll * rem) % n;
        if (rem == n - 1)
            return true;
    }
    return false;
}

int jacobi(int a, int b) {
    if (a == 0)
        return 0;
    if (a == 1)
        return 1;
    if (a < 0)
        if ((b & 2) == 0)
            return jacobi(-a, b);
        else
            return -jacobi(-a, b);
    int a1 = a, e = 0;
    while ((a1 & 1) == 0)
        a1 >>= 1, ++e;
    int s;
    if ((e & 1) == 0 || (b & 7) == 1 || (b & 7) == 7)
        s = 1;
    else
        s = -1;
    if ((b & 3) == 3 && (a1 & 3) == 3)
        s = -s;
    if (a1 == 1)
        return s;
    return s * jacobi(b % a1, a1);
}

bool bpsw(int n) {
    if ((int)sqrt(n + 0.0) * (int)sqrt(n + 0.0) == n)
        return false;
    int dd = 5;
    for (;;) {
        int g = gcd(n, abs(dd));
        if (1 < g && g < n)
            return false;
        if (jacobi(dd, n) == -1)
            break;
        dd = dd < 0 ? -dd + 2 : -dd - 2;
    }
    int p = 1, q = (p * p - dd) / 4;
    int d = n + 1, s = 0;
    while ((d & 1) == 0)
        ++s, d >>= 1;
    long long u = 1, v = p, u2m = 1, v2m = p, qm = q, qm2 = q * 2, qkd = q;
    for (int mask = 2; mask <= d; mask <<= 1) {
        u2m = (u2m * v2m) % n;
        v2m = (v2m * v2m) % n;
        while (v2m < qm2)
            v2m += n;
        v2m -= qm2;
        qm = (qm * qm) % n;
        qm2 = qm * 2;
        if (d & mask) {
            long long t1 = (u2m * v) % n, t2 = (v2m * u) % n, t3 = (v2m * v) % n, t4 = (((u2m * u) % n) * dd) % n;
            u = t1 + t2;
            if (u & 1)
                u += n;
            u = (u >> 1) % n;
            v = t3 + t4;
            if (v & 1)
                v += n;
            v = (v >> 1) % n;
            qkd = (qkd * qm) % n;
        }
    }
    if (u == 0 || v == 0)
        return true;
    long long qkd2 = qkd * 2;
    for (int r = 1; r < s; ++r) {
        v = (v * v) % n - qkd2;
        if (v < 0)
            v += n;
        if (v < 0)
            v += n;
        if (v >= n)
            v -= n;
        if (v >= n)
            v -= n;
        if (v == 0)
            return true;
        if (r < s - 1) {
            qkd = (qkd * 1ll * qkd) % n;
            qkd2 = qkd * 2;
        }
    }
    return false;
}

функція для перевірки простоти числа має наступний вигляд:

bool is_prime(int n) {
    for (int i = 0; i < trivial_limit && p[i] < n; ++i)
        if (n % p[i] == 0)
            return false;
    if (p[trivial_limit - 1] * p[trivial_limit - 1] >= n)
        return true;
    if (!miller_rabin(n))
        return false;
    return bpsw(n);
}

void prime_init() { // слід викликати перед першим викликом prime()!
    for (int i = 2, j = 0; j < trivial_limit; ++i) {
        bool pr = true;
        for (int k = 2; k * k <= i; ++k)
            if (i % k == 0)
                pr = false;
        if (pr)
            p[j++] = i;
    }
}
```

## Евристичне доведення-опроверження Померанса

Померанс у 1984 році запропонував евристичне доведення.

Утвердження: **Кількість BPSW-псевдопростих від 1 до X менше X<sup>1-a</sup> для будь-якого a > 0**.

Доведення.

Нехай $k > 4$ - довільне, але фіксоване число. Нехай $T$ - деяке велике число.

Нехай P<sub>k</sub>(T) - множина таких простих чисел p в інтервалі [T; T<sup>k</sup>], для яких:

(1) p = 3 (mod 8), J(5,p) = -1

(2) Число $(p-1)/2$ не є точним квадратом

Число $(p-1)/2$ складене виключно з простих $q<T$
Число $(p-1)/2$ складено виключно з простих чисел $q$, для яких $q \equiv 1 \pmod 4$

Число $(p+1)/4$ не є точним квадратом

(6) Число $(p+1)/4$ складено виключно з простих $d < T$

(7) Число $(p+1)/4$ складено виключно з таких простих $d$, що $q \equiv 3 \pmod{4}$

Зрозуміло, що близько 1/8 усіх простих в інтервалі [T; T<sup>k</sup>] задовольняють умову (1). Також можна показати, що частина чисел задовольняє умови (2) і (5). Евристично можна припустити, що умови (3) і (6) також залишають деяку частину чисел з відрізку (T; T<sup>k</sup>). Нарешті, ймовірність события (4) така ж, як і события (7) і дорівнює c (log T)<sup>-1/2</sup>. Таким чином, потужність множини P<sub>k</sub>(T) приблизно дорівнює при T -> нескінченність

<img src=BPSW_formula1.jpg>

де $c$ - деяка позитивна константа, залежна від вибору $k$.

Тепер ми **можемо побудувати число n**, яке не є точним квадратом, складене з l простих чисел P<sub>k</sub>(T), де l є непарне і менше T<sup>2</sup> / log(T<sup>k</sup>). Кількість способів вибрати таке число n приблизно дорівнює

<img src=BPSW_formula2.jpg>

для великого T та фіксованого k. Крім того, кожне таке число n менше e<sup>T<sup>2</sup></sup>.

Позначимо через Q<sub>1</sub> добуток простих q < T, для яких q ≡ 1 (mod 4), а через Q<sub>3</sub> - добуток простих q < T, для яких q ≡ 3 (mod 4). Отже, gcd (Q<sub>1</sub>, Q<sub>3</sub>) = 1 і Q<sub>1</sub> Q<sub>3</sub> ≈ e<sup>T</sup>. Таким чином, кількість способів вибрати n **з додатковими умовами**

$$
n = 1 (mod Q<sub>1</sub>), n = -1 (mod Q<sub>3</sub>)
$$

має бути, евристично, принаймні

$$
e<sup>T<sup> 2</sup> (1 - 3 / k)</sup> / e<sup> 2T</sup> > **e<sup>T<sup> 2</sup> (1 - 4 / k)</sup>**
$$

для великої літери T.

Але **кожне таке $n$ є контрприкладом до тесту BPSW**. Дійсно, $n$ буде числом Кармайкла (тобто числом, на якому тест Міллера-Рабіна буде помилятися при будь-якому основі), тому воно автоматично буде псевдопростим за основою 2. Оскільки $n \equiv 3 \pmod{8}$ і кожне $p | n$ рівне $3 \pmod{8}$, очевидно, що $n$ також буде сильним псевдопростим за основою 2. Оскільки $J(5,n) = -1$, то кожне просте $p | n$ задовольняє $J(5,p) = -1$, і так як $p+1 | n+1$ для будь-якого простого $p | n$, звідси випливає, що $n$ - псевдопросте Люкаса для будь-якого тесту Люкаса з дискримінантом 5.

Таким чином, ми показали, що для будь-якого фіксованого k і всіх великих T, буде як мінімум e<sup>T<sup>2</sup> (1 - 4 / k)</sup> контрприкладів до тесту BPSW серед чисел, менших e<sup>T<sup>2</sup></sup>. Тепер, якщо ми покладемо x = e<sup>T<sup>2</sup></sup>, буде як мінімум x<sup>1 - 4 / k</sup> контрприкладів, менших x. Оскільки k - випадкове число, то наше доведення означає, що кількість контрприкладів, менших x, є число, більше x<sup>1-a</sup> для будь-якого a > 0.

## Практичні випробування тесту BPSW

У цьому розділі будуть розглянуті результати, отримані мною в результаті тестування моєї реалізації тесту BPSW. Усі випробування проводилися на вбудованому типі - 64-бітному числі long long. Довга арифметика не тестувалася.

Тестування проводилися на комп'ютері з процесором Celeron 1.3 ГГц.

Усі часи дані в **мікросекундах** (10<sup>-6</sup> сек).

### Середній час роботи на відрізку чисел у залежності від межі тривіального перебору

Є на увазі параметр, який передається функції prime_div_trivial(), і який у коді вище дорівнює 29.

Завантажити тестову програму (код та exe-файл) можна за [посиланням](BPSW_test_1.zip). [83 КБ]

Якщо запускати тест **на всіх непарних числах** з відповідного набору, то результати виходять наступні:

<table class=table2 cellspacing=0>
<tr><th>початок
відрузку</th><th>кінець
відрузку</th><th>межа >
перебору ></th><th width=13%>0</th><th width=13%>10<sup>2</sup></th><th width=13%>10<sup>3</sup></th><th width=13%>10<sup>4</sup></th><th width=13%>10<sup>5</sup></th></tr>
<tr><td>1</td><td>10<sup>5</sup></td><td></td><td>8.1</td><td>4.5</td><td>0.7</td><td>0.7</td><td>0.9</td></tr>
<tr><td>10<sup>6</sup></td><td>10<sup>6</sup>+10<sup>5</sup></td><td></td><td>12.8</td><td>6.8</td><td>7.0</td><td>1.6</td><td>1.6</td>
<tr><td>10<sup>9</sup></td><td>10<sup>9</sup>+10<sup>5</sup></td><td></td><td>28.4</td><td>12.6</td><td>12.1</td><td>17.0</td><td>17.1</td></tr>
<tr><td>10<sup>12</sup></td><td>10<sup>12</sup>+10<sup>5</sup></td><td></td><td>41.5</td><td>16.5</td><td>15.3</td><td>19.4</td><td>54.4</td></tr>
<tr><td>10<sup>15</sup></td><td>10<sup>15</sup>+10<sup>5</sup></td><td></td><td>66.7</td><td>24.4</td><td>21.1</td><td>24.8</td><td>58.9</td></tr>
</table>
Якщо запустити тест **лише на простих числах** з відповідного діапазону, то швидкість роботи буде наступною:

<table class=table2 cellspacing=0>
<tr><th>початок
відрузку</th><th>кінець
відрузку</th><th>межа >
перебору ></th><th width=13%>0</th><th width=13%>10<sup>2</sup></th><th width=13%>10<sup>3</sup></th><th width=13%>10<sup>4</sup></th><th width=13%>10<sup>5</sup></th></tr>
<tr><td>1</td><td>10<sup>5</sup></td><td></td><td>42.9</td><td>40.8</td><td>3.1</td><td>4.2</td><td>4.2</td></tr>
<tr><td>10<sup>6</sup></td><td>10<sup>6</sup>+10<sup>5</sup></td><td></td><td>75.0</td><td>76.4</td><td>88.8</td><td>13.9</td><td>15.2</td>
<tr><td>10<sup>9</sup></td><td>10<sup>9</sup>+10<sup>5</sup></td><td></td><td>186.5</td><td>188.5</td><td>201.0</td><td>294.3</td><td>283.9</td></tr>
<tr><td>10<sup>12</sup></td><td>10<sup>12</sup>+10<sup>5</sup></td><td></td><td>288.3</td><td>288.3</td><td>302.2</td><td>387.9</td><td>1069.5</td></tr>
<tr><td>10<sup>15</sup></td><td>10<sup>15</sup>+10<sup>5</sup></td><td></td><td>485.6</td><td>489.1</td><td>496.3</td><td>585.4</td><td>1267.4</td></tr>
</table>
Таким чином, оптимально вибирати межу тривіального перебору рівною 100 або 1000.

Для всіх наступних тестів я вибрав межу 1000.

### Середній час роботи на відрізку чисел

Тепер, коли ми визначили межу для тривіального перебору, можна більш точно протестувати швидкість роботи на різних відрізках.

<a href="BPSW_test2.zip">Завантажити</a> тестову програму (код і виконуваний файл). [83 КБ]

<table class=table1 cellspacing=0>
<tr><th width=100>початок
відрузку</th><th width=100>кінець
відстань</th><th width=200>Час роботи</th>
на непарних числах</th><th width=200>час роботи</th>
<tr><th>Про прості числа</th></tr>
<tr><td>1</td><td>10<sup>5</sup></td><td>1.2</td><td>4.2</td></tr>
<tr><td>10<sup>6</sup></td><td>10<sup>6</sup>+10<sup>5</sup></td><td>13.8</td><td>88.8</td></tr>
<tr><td>10<sup>7</sup></td><td>10<sup>7</sup>+10<sup>5</sup></td><td>16.8</td><td>115.5</td></tr>
<tr><td>10<sup>8</sup></td><td>10<sup>8</sup>+10<sup>5</sup></td><td>21.2</td><td>164.8</td></tr>
<tr><td>10<sup>9</sup></td><td>10<sup>9</sup>+10<sup>5</sup></td><td>24.0</td><td>201.0</td></tr>
<tr><td>10<sup>10</sup></td><td>10<sup>10</sup>+10<sup>5</sup></td><td>25.2</td><td>225.5</td></tr>
<tr><td>10<sup>11</sup></td><td>10<sup>11</sup>+10<sup>5</sup></td><td>28.4</td><td>266.5</td></tr>
<tr><td>10<sup>12</sup></td><td>10<sup>12</sup>+10<sup>5</sup></td><td>30.4</td><td>302.2</td></tr>
<tr><td>10<sup>13</sup></td><td>10<sup>13</sup>+10<sup>5</sup></td><td>33.0</td><td>352.2</td></tr>
<tr><td>10<sup>14</sup></td><td>10<sup>14</sup>+10<sup>5</sup></td><td>37.5</td><td>424.3</td></tr>
<tr><td>10<sup>15</sup></td><td>10<sup>15</sup>+10<sup>5</sup></td><td>42.3</td><td>499.8</td></tr>
<tr><td>10<sup>16</sup></td><td>10<sup>15</sup>+10<sup>5</sup></td><td>46.5</td><td>553.6</td></tr>
<tr><td>10<sup>17</sup></td><td>10<sup>15</sup>+10<sup>5</sup></td><td>48.9</td><td>621.1</td></tr>
</table>
Або у вигляді графіка, приблизний час виконання тесту BPSW для одного числа:

<img src=BPSW_graph1.gif>

Ми отримали те, що на практиці, при малих числах (до 10<sup>17</sup>), **алгоритм працює зі складністю O(log N)**. Це пояснюється тим, що для вбудованого типу int64 операція ділення виконується зі складністю O(1), тобто складність ділення не залежить від кількості бітів у числі.

Якщо застосувати тест BPSW до довгої арифметики, очікується, що він буде працювати за час O(log<sup>3</sup>(N)). [TODO]

## Додаток. Усі програми

<a href="BPSW_all.zip">Скачати</a> всі програми з цієї статті. [242 КБ]

## Література

Використана мною література, повністю доступна в Інтернеті:

<ol>
* Robert Baillie; Samuel S. Wagstaff
**Lucas pseudoprimes**
Math. Comp. 35 (1980) 1391-1417
[mpqs.free.fr/LucasPseudoprimes.pdf](http://mpqs.free.fr/LucasPseudoprimes.pdf)
&nbsp;
* Daniel J. Bernstein
**Distinguishing prime numbers from composite numbers: the state of the art in 2004**
Math. Comp. (2004)
[cr.yp.to/primetests/prime2004-20041223.pdf](http://cr.yp.to/primetests/prime2004-20041223.pdf)
&nbsp;
* Richard P. Brent
**Primality Testing and Integer Factorisation**
The Role of Mathematics in Science (1990)
[wwwmaths.anu.edu.au/~brent/pd/rpb120.pdf](http://wwwmaths.anu.edu.au/~brent/pd/rpb120.pdf)
&nbsp;
* H. Cohen; H. W. Lenstra
**Primality Testing and Jacobi Sums**
Amsterdam (1984)
[www.openaccess.leidenuniv.nl/bitstream/1887/2136/1/346_065.pdf](https://www.openaccess.leidenuniv.nl/bitstream/1887/2136/1/346_065.pdf)
&nbsp;
* <a name=5></a>Thomas H. Cormen; Charles E. Leiserson; Ronald L. Rivest
**Introduction to Algorithms**
[Без посилання]
The MIT Press (2001)
&nbsp;
* <a name=6></a>M. Martin
**PRIMO - Primality Proving**
[www.ellipsa.net](http://www.ellipsa.net/)
&nbsp;
* F. Morain
**Elliptic curves and primality proving**
Math. Comp. 61(203) (1993)
[citeseer.ist.psu.edu/rd/43190198%2C72628%2C1%2C0.25%2CDownload/ftp%3AqSqqSqftp.inria.frqSqINRIAqSqpublicationqSqpubli-ps-gzqSqRRqSqRR-1256.ps.gz](http://citeseer.ist.psu.edu/rd/43190198%2C72628%2C1%2C0.25%2CDownload/ftp%3AqSqqSqftp.inria.frqSqINRIAqSqpublicationqSqpubli-ps-gzqSqRRqSqRR-1256.ps.gz)
&nbsp;
* Carl Pomerance
**Are there counter-examples to the Baillie-PSW primality test?**
Math. Comp. (1984)
[www.pseudoprime.com/dopo.pdf](http://www.pseudoprime.com/dopo.pdf)
&nbsp;
* Eric W. Weisstein
**Baillie-PSW primality test**
MathWorld (2005)
[mathworld.wolfram.com/Baillie-PSWPrimalityTest.html](http://mathworld.wolfram.com/Baillie-PSWPrimalityTest.html)
&nbsp;
* Eric W. Weisstein
**Strong Lucas pseudoprime**
MathWorld (2005)
[mathworld.wolfram.com/StrongLucasPseudoprime.html](http://mathworld.wolfram.com/StrongLucasPseudoprime.html)
&nbsp;
* Paulo Ribenboim
**The Book of Prime Number Records**
Springer-Verlag (1989)
[ без посилання ]
&nbsp;
</ol>
Список інших рекомендованих книг, яких мені не вдалося знайти в Інтернеті:

<ol start=12>
* Zhaiyu Mo; James P. Jones
**A new primality test using Lucas sequences**
Preprint (1997)
&nbsp;
* Hans Riesel
**Prime numbers and computer methods for factorization**
Boston: Birkhauser (1994)
&nbsp;
</ol>