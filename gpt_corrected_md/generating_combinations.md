# Генерація комбінацій з N елементів

## Сочетання з $N$ елементів по $K$ в лексикографічному порядку

Постановка задачі. Задано натуральні числа $N$ і $K$. Розглянемо множину чисел від 1 до $N$. Потрібно вивести всі різні її підмножини потужності $K$, причому в лексикографічному порядку.

Алгоритм дуже простий. Першим поєднанням, очевидно, буде поєднання (1,2,...,K). Навчимося для поточного поєднання знаходити лексикографічно наступне. Для цього в поточному поєднанні знайдемо найправіший елемент, який ще не досяг свого найбільшого значення; тоді збільшимо його на одиницю, а всім наступним елементам дамо найменші значення.

<!--- TODO: specify code snippet id -->
``` cpp
bool next_combination(vector<int> &a, int n) {
    int k = (int)a.size();
    for (int i = k - 1; i >= 0; --i)
        if (a[i] < n - k + i + 1) {
            ++a[i];
            for (int j = i + 1; j < k; ++j)
                a[j] = a[j - 1] + 1;
            return true;
        }
    return false;
}
```
З точки зору продуктивності, цей алгоритм є повільним (у середньому), якщо K далеко від N (тобто якщо не виконується, що K = N - o(N)). Для цього достатньо довести, що порівняння "a[i] < n-k+i+1" виконуються в сумі C<sub>n+1</sub><sup>k</sup> раз, тобто в (N+1) / (N-K+1) раз більше, ніж всього є комбінацій з N елементів по K.

## Сполучення з N елементів по K зі змінами дорівнює одному елементу

Потрібно виписати всі комбінації з N елементів по K, такі що будь-які дві сусідні комбінації відрізняються лише одним елементом.

Інтуїтивно можна відразу помітити, що ця задача подібна до задачі генерації всіх підмножин даної множини у такому порядку, коли два сусідні підмножини відрізняються лише одним елементом. Цю задачу можна вирішити з використанням [коду Грея](https://uk.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4_%D0%93%D1%80%D0%B5%D1%8F): якщо кожному підмножині ставити у відповідність бітову маску, то генеруючи за допомогою кодів Грея ці бітові маски, отримаємо відповідь.

Може здатися дивним, але задачу генерації поєднань також можна вирішити з використанням **коду Грея**. Згенеруємо коди Грея для чисел від 0 до 2<sup>N</sup>-1 і залишимо лише ті коди, які містять рівно K одиниць. Цікаво, що будь-які дві сусідні маски (а також перша і остання маски) в отриманій послідовності будуть відрізнятися рівно двома бітами, що дозволяє досягти потрібного результату. 

**Доведемо** це.

Для доведення згадаємо факт, що послідовність G(N) кодів Грея можна отримати наступним чином:

$$
G(N) = 0G(N-1) &cup; 1G(N-1)<sup>R</sup>
$$

тобто беремо послідовність кодів Грея для $N-1$, дописуємо в початок кожної маски 0, додаємо до відповіді. Потім знову беремо послідовність кодів Грея для $N-1$, інвертуємо її, дописуємо в початок кожної маски 1 і додаємо до відповіді.

Тепер ми можемо провести доказ.

Спочатку доведемо, що перша і остання маски будуть відрізнятися у двох бітах. Для цього достатньо замітити, що перша маска матиме вигляд N-K нулів і K одиниць, а остання маска матиме вигляд: одиниця, потім N-K-1 нуль, потім K-1 одиниця. Довести це легко за допомогою індукції по N, використовуючи наведену вище формулу для послідовності кодів Грея.

Тепер доведемо, що будь-які два сусідні коди будуть відрізнятися рівно в двох бітах. Для цього знову звернемося до формули для послідовності кодів Грея. Нехай всередині кожної з половинок (утворених з G(N-1)) твердження є вірним, доведемо, що воно вірне для всієї послідовності. Для цього досить довести, що воно вірне в місці "склеювання" двох половинок G(N-1), а це легко показати, ґрунтуючись на тому, що ми знаємо перший і останній елементи цих половинок.

Наведемо тепер наївну реалізацію, яка працює за 2<sup>N</sup>:

<!--- TODO: specify code snippet id -->
``` cpp
int gray_code(int n) { return n ^ (n >> 1); }

int count_bits(int n) {
    int res = 0;
    for (; n; n >>= 1)
        res += n & 1;
    return res;
}

void all_combinations(int n, int k) {
    for (int i = 0; i < (1 << n); ++i) {
        int cur = gray_code(i);
        if (count_bits(cur) == k) {
            for (int j = 0; j < n; ++j)
                if (cur & (1 << j))
                    printf("%d ", j + 1);
            puts("");
        }
    }
}
```
Варто зазначити, що можлива, і до певної міри більш ефективна реалізація, яка будує всі можливі комбінації на льоту, тим самим працюючи за O(C<sub>n</sub><sup>k</sup> n). З іншого боку, ця реалізація є рекурсивною функцією, тому для невеликих n вона, ймовірно, має велику приховану константу порівняно з попереднім рішенням.

Власне, сама реалізація полягає у безпосередньому дотриманні формули:

$$
G(N,K) = 0G(N-1,K) &cup; 1G(N-1,K-1)<sup>R</sup>
$$

Ця формула легко випливає з наведеної вище формули для послідовності Грея - ми просто обираємо підпослідовність з відповідних нам елементів.

<!--- TODO: specify code snippet id -->
``` cpp
bool ans[MAXN];

void gen(int n, int k, int l, int r, bool rev, int old_n) {
    if (k > n || k < 0)
        return;
    if (!n) {
        for (int i = 0; i < old_n; ++i)
            printf("%d", (int)ans[i]);
        puts("");
        return;
    }
    ans[rev ? r : l] = false;
    gen(n - 1, k, !rev ? l + 1 : l, !rev ? r : r - 1, rev, old_n);
    ans[rev ? r : l] = true;
    gen(n - 1, k - 1, !rev ? l + 1 : l, !rev ? r : r - 1, !rev, old_n);
}

void all_combinations(int n, int k) { gen(n, k, 0, n - 1, false, n); }
```