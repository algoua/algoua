# Heavy-light декомпозиція

"Heavy-light декомпозиція" - це досить загальний прийом, який дозволяє ефективно розв'язувати багато задач, що сводяться до "запитів на дереві".

Найпростіший **приклад** задачі такого типу - це наступне завдання. Дано дерево, кожній вершині якого приписано деяке число. Надходять запити типу $(a,b)$, де $a$ і $b$ - номери вершин дерева, і потрібно дізнатися максимальне число на шляху між вершинами $a$ і $b$.

## Опис алгоритму

Отже, нехай дано дерево $G$ з $n$ вершинами, підвішене за деякий корінь.

Суть цієї декомпозиції полягає в тому, щоб **розбити дерево на кілька шляхів** таким чином, щоб для будь-якої вершини $v$ виконувалося, що якщо ми будемо подніматися від $v$ до кореня, то по шляхах змінимо не більше, ніж $\log n$ шляхів. Крім того, всі шляхи повинні не перетинатися один з іншим по ребрах.

Зрозуміло, що якщо ми навчимося шукати таку декомпозицію для будь-якого дерева, це дозволить звести будь-який запит типу "дізнатися що-то на шляху з $a$ в $b$" до кількох запитів типу "дізнатися що-то на відрізку $[l;r]$ $k$-го шляху".

### Побудова декомпозиції "важких-легких"

Порахуємо для кожної вершини $v$ розмір її піддерева $s(v)$ (тобто кількість вершин в піддереві вершини $v$, включаючи саму вершину).

Далі, розглянемо всі ребра, що виходять з вершини $v$. Назвемо ребро $(v,c)$ **важким**, якщо воно веде в вершину $c$ таку, що:

$$
s(c) \ge \frac{ s(v) }{ 2 } \Leftrightarrow {\rm edge} ~ (v,c) ~ {\rm is ~ heavy}.
$$

Усі інші ребра назвемо **легкими**. Очевидно, що з однієї вершини $v$ вниз можливо виходить максимум одне тяжке ребро (тобто в іншому випадку у вершини $v$ було б два сини розміру $s(v)/2$, що з урахуванням самої вершини $v$ дає розмір $2 \cdot s(v) / 2 + 1 > s(v)$, отже, ми прийшли до протиріччя).

Тепер побудуємо саму **декомпозицію** дерева на неперетинні шляхи. Розглянемо всі вершини, з яких не виходить вниз жодного важкого ребра, і будемо йти від кожної з них вгору, поки не дійдемо до кореня дерева або не пройдемо легке ребро. В результаті ми отримаємо декілька шляхів - покажемо, що це і є шукані шляхи heavy-light декомпозиції.

### Доведення коректності алгоритму

По-перше, зауважимо, що отримані алгоритмом шляхи будуть **неперетинними**. Насправді, якщо б два якихось шляхи мали б загальне ребро, це б означало, що з якоїсь вершини вниз іде два тяжкі ребра, що є неможливим.

По-друге, покажемо, що спускаючись від кореня дерева до довільної вершини, ми **змінимо не більше $\log n$ шляхів**. Насправді, прохід вниз по легкому ребру зменшує розмір поточного піддерева більше ніж вдвічі:

$$
s(c) < \frac{ s(v) }{ 2 } \Leftrightarrow {\rm edge} ~ (v,c) ~ {\rm is ~ light}.
$$

Таким чином, ми не могли пройти більше ніж $\log n$ легких ребер. Однак переходити з одного шляху на інший ми можемо тільки через легке ребро (тобто кожний шлях, крім того, що закінчується в корені, містить легке ребро в кінці; а потрапити зразу посередині шляху ми не можемо).

Отже, ми не можемо змінити більше, ніж $\log n$ шляхів від кореня до будь-якої вершини, що потрібно довести.

## Застосування при розв'язанні задач

При рішенні задач іноді зручніше розглядати heavy-light як набір **вершинно-неперетинаючихся** шляхів (а не реберно-неперетинаючихся). Для цього достатньо з кожного шляху виключити останнє ребро, якщо воно є легким ребром - тоді жодні властивості не порушаться, але тепер кожна вершина буде належати рівно одному шляху.

Нижче ми розглянемо кілька типових задач, які можна розв'язувати за допомогою декомпозиції heavy-light.

Окремо варто звернути увагу на задачу **сума чисел на шляхах**, оскільки це приклад завдання, яке можна вирішити і більш простими техніками.

### Максимальна кількість шляхів між двома вершинами

Дано дерево, до кожної вершини якого приписано певне число. Надходять запити виду $(a,b)$, де $a$ і $b$ - номери вершин дерева, і необхідно знайти максимальне число на шляху між вершинами $a$ і $b$.

Побудуємо напередодні декомпозицію heavy-light. Над кожним отриманим шляхом побудуємо [дерево відрізків для максимуму](https://uk.wikipedia.org/wiki/Дерево_відрізків), що дозволить знаходити вершину з максимальним числом, приписаним до неї, в зазначеному сегменті зазначеного шляху за $O(\log n)$. Хоча кількість шляхів у декомпозиції heavy-light може досягати $n-1$, сумарний розмір усіх шляхів є $O(n)$, тому і сумарний розмір дерев відрізків також буде лінійним.

Тепер, щоб відповісти на отриманий запит $(a,b)$, знайдемо найменший загальний предок $l$ цих вершин (наприклад, за допомогою методу двійкового підйому). Тепер задача зводиться до двох запитів: $(a,l)$ і $(b,l)$, на кожен з яких ми можемо відповісти таким чином: знайдемо, в якому шляху знаходиться нижня вершина, зробимо запит до цього шляху, перейдемо в кінцеву вершину цього шляху, знову визначимо, в якому шляху ми знаходимося і зробимо запит до нього, і так далі, доки не дійдемо до шляху, що містить $l$.

Акуратно випливає, що може статися випадок, коли, наприклад, $a$ і $l$ виявляться на одному шляху - тоді запит максимуму до цього шляху потрібно робити не на суфіксі, а на внутрішньому підрізку.

Таким чином, під час відповіді на один підзапит ми пройдемо по $O(\log n)$ шляхах, в кожному з них зробивши запит максимуму на суфіксі або на префіксі/підрядку (запит на префікс/підрядок міг бути тільки один раз).

Так, ми отримали розв'язок для одного запиту за $O(\log^2 n)$.

Якщо ще додатково попередньо порахувати на кожному шляху максимуми на всіх суфіксах, то вийде розв'язок за $O(n \log n)$ - тобто, запит максимуму не на суфікс відбувається тільки один раз, коли ми доходимо до вершини $l$.

### Сума чисел на шляху між двома вершинами

Дано дерево, кожній вершині якого приписано яке-небудь число. Надходять запити у вигляді $(a,b)$, де $a$ і $b$ - номери вершин дерева, і потрібно дізнатися суму чисел на шляху між вершинами $a$ і $b$. Можливий різновид цієї задачі, коли додатково можуть надходити запити на зміну числа, приписаного тій чи іншій вершині.

Хоча цю задачу можна розв'язувати з допомогою техніки heavy-light декомпозиції, побудувавши над кожним шляхом дерево відрізків для суми (або просто попередньо підрахувавши часткові суми, якщо в задачі відсутні запити зміни), цю задачу можна вирішити **більш простими техніками**.

Якщо запити на модифікацію відсутні, то можна дізнатися суму на шляху між двома вершинами паралельно з пошуком LCA двох вершин у [алгоритмі бінарного підйому](lca_simpler) - для цього необхідно у час препроцесінгу для LCA підраховувати не лише $2^k$-ті предки кожної вершини, але й суму чисел на шляхах до цього предка.

Є принципово інший підхід до цієї задачі - розглянути Ейлерів обхід дерева і побудувати дерево відрізків над ним. Цей алгоритм розглядається в [статті з розв'язком подібної задачі](tree_painting). Якщо запити модифікації відсутні, то достатньо обійтися попереднім обрахуванням часткових сум, без дерева відрізків.

Обидва ці способи дають прості розв'язки з асимптотикою $O(\log n)$ на один запит.

### Перефарбування ребер шляху між двома вершинами

Дано дерево. Кожне ребро спочатку пофарбовано в білий колір. Надходять запити у вигляді $(a,b,c)$, де $a$ і $b$ - номери вершин, $c$ - колір, що означає, що всі ребра на шляху з $a$ в $b$ треба перефарбувати в колір $c$. Потрібно після всіх перефарбувань повідомити, скільки в підсумку вийшло ребер кожного кольору.

Розв'язок - просто створити [дерево відрізків з покраскою на відрізку](дерево відрізків) над набором шляхів декомпозиції heavy-light.

Кожен запит на перекраску шляху $(a,b)$ повинен бути розбитий на два подзапити $(a,l)$ і $(b,l)$, де $l$ - найменший загальний предок вершин $a$ і $b$ (знайдений, наприклад, [за допомогою алгоритму двійкового підйому](lca_simpler)). Кожен з цих подзапитів можна обробити за допомогою $O(\log n)$ запитів до дерев відрізків, що відповідають шляхам.

Разом виходить розв'язок з асимптотикою $O(\log^2 n)$ на кожен запит.

## Завдання в онлайн-суддях

Список задач, які можна розв'язати, використовуючи heavy-light декомпозицію:

* [TIMUS #1553 **"Caves and Tunnels"** [складність: середня]](http://acm.timus.ru/problem.aspx?space=1&num=1553)

* [IPSC 2009 L **"Let there be rainbows!"** [складність: середня]](http://ipsc.ksp.sk/contests/ipsc2009/real/problems/l.php)

* [SPOJ #2798 **"Query on a tree again!"** [складність: середня]](http://www.spoj.pl/problems/QTREE3/)

* [Codeforces Beta Round #88 E **"Дерево або не дерево"** [складність: висока]](http://codeforces.com/contest/117/problem/E)