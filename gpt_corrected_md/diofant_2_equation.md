# Лінійні діофантові рівняння з двома змінними

Діофантове рівняння з двома невідомими має вигляд:

$$
a \cdot x + b \cdot y = c,
$$

де $a$, $b$, $c$ - задані цілі числа, $x$ і $y$ - невідомі цілі числа.

Нижче розглядаються декілька класичних задач на ці рівняння: знаходження будь-якого розв'язку, отримання всіх розв'язків, знаходження кількості розв'язків і самі розв'язки в певному відрізку, знаходження розв'язку з найменшою сумою невідомих.

## Випадок дегенерувався

Один з вироджених випадків ми зразу виключимо з розгляду: коли $a = b = 0$. У цьому випадку, зрозуміло, рівняння має або нескінченно багато довільних розв'язків, або ж не має розв'язків зовсім (в залежності від того, чи $c = 0$).

## Знаходження одного розв'язку

Знайти одне рішення діофантового рівняння з двома невідомими можна за допомогою [Розширеного алгоритму Евкліда](https://uk.wikipedia.org/wiki/Розширений_алгоритм_Евкліда). Припустимо спочатку, що числа $a$ і $b$ не від'ємні.

Розширений алгоритм Євкліда по заданим не від'ємним числам $a$ і $b$ знаходить їх найбільший спільний дільник $g$, а також такі коефіцієнти $x_g$ і $y_g$, що:

$$
a \cdot x_g + b \cdot y_g = g.
$$

Стверджується, що якщо $c$ ділиться на $g = {\rm НСД} (a,b)$, то діофантове рівняння $a \cdot x + b \cdot y = c$ має розв'язок; в іншому випадку діофантове рівняння розв'язків не має. Доведення випливає з очевидного факту, що лінійна комбінація двох чисел також повинна ділитися на їхній загальний дільник.

Припустимо, що $c$ ділиться на $g$. Тоді очевидно виконується:

$$
a \cdot x_g \cdot (c/g) + b \cdot y_g \cdot (c/g) = c,
$$

отже, одним із розв'язків діофантового рівняння є числа:

$$
\cases{
x_0 = x_g \cdot (c / g), \cr
y_0 = y_g \cdot (c / g).
}
$$

Ми описали розв'язок у випадку, коли числа $a$ і $b$ не менше нуля. Якщо ж одне з них або обидва є від'ємними, то можна діяти наступним чином: взяти їх за модулем і застосувати до них алгоритм Євкліда, як описано вище, а потім змінити знак знайдених $x_0$ і $y_0$ відповідно залежно від знаку вихідних чисел $a$ і $b$.

Реалізація (нагадаємо, що тут ми припускаємо, що вхідні дані $a=b=0$ є недопустимими):

<!--- TODO: specify code snippet id -->
``` cpp
int gcd(int a, int b, int &x, int &y) {
    if (a == 0) {
        x = 0;
        y = 1;
        return b;
    }
    int x1, y1;
    int d = gcd(b % a, a, x1, y1);
    x = y1 - (b / a) * x1;
    y = x1;
    return d;
}

bool find_any_solution(int a, int b, int c, int &x0, int &y0, int &g) {
    g = gcd(abs(a), abs(b), x0, y0);
    if (c % g != 0)
        return false;
    x0 *= c / g;
    y0 *= c / g;
    if (a < 0)
        x0 *= -1;
    if (b < 0)
        y0 *= -1;
    return true;
}
```

## Отримання всіх рішень

Покажемо, як отримати всі інші розв'язки (іх нескінченну множину) діофантового рівняння, знаючи один з розв'язків $(x_0,y_0)$.

Отже, нехай $g = \gcd(a,b)$, а числа $x_0$ та $y_0$ задовольняють умову:

$$
a \cdot x_0 + b \cdot y_0 = c.
$$

Зауважимо, що додавши до $x_0$ число $b/d$ і віднявши $a/d$ від $y_0$, ми не порушимо рівності:

$$
a \cdot (x_0 + b/g) + b \cdot (y_0 - a/g) = a \cdot x_0 + b \cdot y_0 + a \cdot b/g - b \cdot a/g = c.
$$

Очевидно, що цей процес можна повторювати скільки завгодно, тобто всі числа увазі:

$$
\cases{
x = x_0 + k \cdot b/g, \cr
y = y_0 - k \cdot a/g,
} ~~~~k \in Z
$$

є розв'язками діофантового рівняння.

Більше того, лише числа такого виду є розв'язками, тобто ми описали множину всіх розв'язків діофантового рівняння (воно виявилося нескінченним, якщо не накладено додаткових умов).

## Знаходження кількості розв'язків та самих розв'язків у заданому відрізку

Нехай дані дві відрізки $[min_x;max_x]$ і $[min_y;max_y]$, і потрібно знайти кількість розв'язків $(x,y)$ діофантового рівняння, що лежать в даних відрізках відповідно.

Зауважимо, що якщо одне з чисел $a, b$ дорівнює нулю, то задача має не більше одного розв'язку, тому ці випадки ми в даному розділі виключаємо з розгляду.

Спочатку знайдемо розв'язок з мінімальним можливим $x$, тобто $x \ge \min_x$. Для цього спочатку знайдемо будь-який розв'язок діофантового рівняння (див. пункт 1). Потім отримаємо з нього розв'язок з найменшим $x \ge \min_x$ - для цього скористаємося процедурою, описаною в попередньому пункті, і будемо зменшувати/збільшувати $x$, поки воно не стане $\ge \min_x$, і при цьому мінімальним. Це можна зробити за $O(1)$, вважаючи, з яким коефіцієнтом потрібно застосувати це перетворення, щоб отримати мінімальне число, більше або рівне $\min_x$. Позначимо знайдений $x$ через $l_{x1}$.

Аналогічним чином можна знайти розв'язок з максимальним підходящим значенням $x=rx1$, тобто $x \le \max_x$.

Далі перейдемо до задоволення обмежень на $y$, тобто до розгляду відрізку $[min_y;max_y]$. Способом, описаним вище, знайдемо розв'язок з мінімальним $y \ge min_y$, а також розв'язок з максимальним $y \le max_y$. Позначимо $x$-коефіцієнти цих рішень через $l_x$ і $r_x$ відповідно.

Перетнемо відрізки $[lx1;rx1]$ і $[lx2;rx2]$; позначимо отриманий відрізок через $[lx;rx]$. Твердиться, що будь-який розв'язок, у якого $x$-коефіцієнт лежить в $[lx;rx]$ - будь-який такий розв'язок є відповідним. (Це вірно у зв'язку з побудовою цього відрізку: спочатку ми окремо задовольнили обмеження на $x$ і $y$, отримавши два відрізки, а потім перетнули їх, отримавши область, в якій задовольняються обидва умови).

Таким чином, кількість рішень буде дорівнювати довжині цього відрізку, поділеній на $|b|$ (оскільки $x$-коефіцієнт можна змінювати тільки на $\pm b$), і додано одиницю.

Наведемо реалізацію. Вона вийшла досить складною, оскільки потрібно аккуратно розглядати випадки додатних і від'ємних коефіцієнтів $a$ і $b$

<!--- TODO: specify code snippet id -->
``` cpp
void shift_solution(int &x, int &y, int a, int b, int cnt) {
    x += cnt * b;
    y -= cnt * a;
}

int find_all_solutions(int a, int b, int c, int minx, int maxx, int miny, int maxy) {
    int x, y, g;
    if (!find_any_solution(a, b, c, x, y, g))
        return 0;
    a /= g;
    b /= g;

    int sign_a = a > 0 ? +1 : -1;
    int sign_b = b > 0 ? +1 : -1;

    shift_solution(x, y, a, b, (minx - x) / b);
    if (x < minx)
        shift_solution(x, y, a, b, sign_b);
    if (x > maxx)
        return 0;
    int lx1 = x;

    shift_solution(x, y, a, b, (maxx - x) / b);
    if (x > maxx)
        shift_solution(x, y, a, b, -sign_b);
    int rx1 = x;

    shift_solution(x, y, a, b, -(miny - y) / a);
    if (y < miny)
        shift_solution(x, y, a, b, -sign_a);
    if (y > maxy)
        return 0;
    int lx2 = x;

    shift_solution(x, y, a, b, -(maxy - y) / a);
    if (y > maxy)
        shift_solution(x, y, a, b, sign_a);
    int rx2 = x;

    if (lx2 > rx2)
        swap(lx2, rx2);
    int lx = max(lx1, lx2);
    int rx = min(rx1, rx2);

    return (rx - lx) / abs(b) + 1;
}
```

Також нескладно додати до цієї реалізації висновок усіх знайдених рішень: для цього достатньо перебрати $x$ в відрізку $[lx;rx]$ з кроком $|b|$, знаходячи для кожного з них відповідний $y$ безпосередньо з рівняння $ax+by=c$.

## Знаходження розв'язку в заданому відрізку з найменшою сумою $x+y$

Тут на $x$ і на $y$ також повинні бути накладені які-небудь обмеження, інакше відповіддю практично завжди буде від'ємна нескінченність.

Ідея розв'язку така сама, як і в попередньому пункті: спочатку знаходимо будь-який розв'язок діофантового рівняння, а потім, застосовуючи описану в попередньому пункті процедуру, приходимо до найкращого розв'язку.

Дійсно, ми маємо право виконати випливаючі перетворення (див. попередній пункт):

$$
\cases{
x^\prime = x + k \cdot (b/g), \cr
y^\prime = y - k \cdot (a/g),
} ~~~~k \in Z.
$$

Зауважимо, що при цьому сума $x+y$ змінюється наступним чином:

$$
x^\prime + y^\prime = x + y + k \cdot (b/g - a/g) = x + y + k \cdot (b - a) / g.
$$

тобто, якщо $a < b$, то потрібно вибрати якнайменше значення $k$, а якщо $a > b$, то потрібно вибрати якнайбільше значення $k$.

Якщо $a = b$, то ми ніяк не зможемо покращити розв'язок, - всі розв'язки будуть мати однакову суму.

## Завдання на online-суддях

Список завдань, які можна здати на тему діофантових рівнянь з двома невідомими:

TODO