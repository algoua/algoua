# Решітка Ератосфена з лінійним часом роботи

Дано число $n$. Потрібно знайти **усі прості числа** на відрізку $[2; n]$.

Класичний спосіб розв'язання цієї задачі - **[решітка Єратосфена](https://uk.wikipedia.org/wiki/Решітка_Єратосфена)**. Цей алгоритм дуже простий, але працює за час $O(n \log \log n)$.

Хоча наразі відомо достатньо багато алгоритмів, що працюють за сублінійний час (тобто за $o(n)$), описаний нижче алгоритм є цікавим своєю **простотою** - він практично не складніший за класичне решето Ератосфена.

Крім того, наведений тут алгоритм як "побічний ефект" фактично обчислює **розклад всіх чисел** в інтервалі $[2; n]$, що може бути корисним у багатьох практичних застосуваннях.

Недоліком приведеного алгоритму є те, що він використовує **більше пам'яті**, ніж класичне решето Ератосфена: потрібно створювати масив з $n$ чисел, тоді як класичному решету Ератосфена достатньо лише $n$ біт пам'яті (що виходить в $32$ рази менше).

Таким чином, описаний алгоритм має сенс застосовувати тільки до чисел порядку $10^7$, не більше.

Авторство алгоритму, з усієї видимості, належить Грайсу та Місрі (Gries, Misra, 1978 р. - див. список літератури в кінці). (І, власне кажучи, називати даний алгоритм "решетом Ератосфена" некоректно: занадто відрізняються ці два алгоритми).

## Опис алгоритму

Нашою метою є порахувати для кожного числа $i$ від $2$ до $n$ його **найменший простий дільник** $lp[i]$.

Крім того, нам буде потрібно зберігати список усіх знайдених простих чисел - назвемо його масивом $пр[]$.

Спочатку всі значення $lp[i]$ заповнимо нулями, що означає, що ми поки що припускаємо, що всі числа є простими. Під час роботи алгоритму цей масив буде поступово заповнюватись.

Будемо тепер перебирати поточне число $i$ від $2$ до $n$. У нас може бути два випадки:

* $lp[i] = 0$ означає, що число $i$ є простим, тобто для нього не було знайдено жодного іншого дільника.

Отже, потрібно присвоїти $lp[i] = i$ та додати $i$ в кінець списку $пр[]$.

* $lp[i] \ne 0$ - це означає, що поточне число $i$ є складениим, і його мінімальним простим дільником є $lp[i]$.

У обох випадках починається процес **встановлення значень** в масиві $lp[]$: ми будемо брати числа, **що кратні** $i$, і оновлювати їх значення $lp[]$. Однак наша мета - навчитися робити це таким чином, щоб в підсумку кожне число мало значення $lp[]$, встановлене не більше одного разу.

Стверджується, що це можна зробити наступним чином. Розглянемо числа уважно:

$$
x_j = i \cdot p_j,
$$

де послідовність $p_j$ - це всі прості числа, які не перевищують $lp[i]$ (для цього ми зберігали список всіх простих чисел).

У всіх числах такого масиву проставимо нове значення $lp[x_j]$ - очевидно, воно буде дорівнювати $p_j$.

Чому такий алгоритм є коректним, і чому він працює за лінійний час - дивись нижче, поки ж наведемо його реалізацію.

## Реалізація

Решітка виконується до зазначеного в константі числа $N$.

<!--- TODO: specify code snippet id -->
``` cpp
const int N = 10000000;
int lp[N + 1];
vector<int> pr;

for (int i = 2; i <= N; ++i) {
    if (lp[i] == 0) {
        lp[i] = i;
        pr.push_back(i);
    }
    for (int j = 0; j < (int)pr.size() && pr[j] <= lp[i] && i * pr[j] <= N; ++j)
        lp[i * pr[j]] = pr[j];
}
```

Цю реалізацію можна трохи прискорити, позбувшись від вектора $pr$ (замінивши його на звичайний масив з лічильником), а також позбувшись від повторюваного множення у вкладеному циклі $for$ (для чого результат потрібно просто запам'ятати в якій-небудь змінній).

## Доведення коректності

Доведемо **коректність** алгоритму, тобто те, що він правильно розставляє всі значення $lp[]$, причому кожне з них буде встановлено рівне один раз. Звідси буде випливати, що алгоритм працює за лінійний час, оскільки всі інші дії алгоритму, очевидно, працюють за $O(n)$.

Для цього зауважимо, що у будь-якого числа $i$ **єдине уявлення** такого значення:

$$
i = lp[i] \cdot x,
$$

де $lp[i]$ - (як і раніше) найменший простий дільник числа $i$, а число $x$ не має дільників, менших $lp[i]$, тобто:

$$
lp[i] \le lp[x].
$$

Тепер порівняємо це з тим, що робить наш алгоритм - він фактично для кожного $x$ перебирає всі прості числа, на які його можна домножити, тобто прості числа до $lp[x]$ включно, щоб отримати числа вище згаданого подання.

Отже, алгоритм дійсно пройде по кожному складеному числу рівно один раз, встановивши у нього правильне значення $lp[]$.

Це означає коректність алгоритму і те, що він працює за лінійний час.

## Час роботи та необхідний обсяг пам'яті

Хоча асимптотика $O(n)$ краща за асимптотику $O(n \log \log n)$ класичного решета Ератосфена, різниця між ними невелика. На практиці це означає лише двукратну різницю в швидкості, а оптимізовані варіанти решета Ератосфена навіть не поступаються приведеному тут алгоритму.

Враховуючи витрати пам'яті, які потрібні для цього алгоритму - масив чисел $lp[]$ довжиною $n$ та масив всіх простих $pr[]$ довжиною приблизно $n / \ln n$ - цей алгоритм здається гіршим за класичне решітко у всіх аспектах. (Українською мовою "уступающий" відповідає слово "гірший", а "статья" - "аспект").

Однак його врятувала можливість шукати факторизацію будь-якого числа в інтервалі $[2;n]$ за час порядку розміру цієї факторизації завдяки масиву $lp[]$, який обчислюється цим алгоритмом. Більше того, за допомогою ще одного додаткового масиву можна зробити так, щоб в цій факторизації не потрібні були операції ділення.

Знання факторизації всіх чисел є дуже корисною інформацією для деяких задач, а цей алгоритм є одним з небагатьох, які дозволяють знаходити її за лінійний час.

## Література

* David Gries, Jayadev Misra. **A Linear Sieve Algorithm for Finding Prime Numbers** [1978]