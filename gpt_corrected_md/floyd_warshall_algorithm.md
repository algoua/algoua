# Алгоритм Флойда-Уоршелла знаходження найкоротших шляхів між усіма парами вершин

Даний орієнтований або неорієнтований зважений граф $G$ з $n$ вершинами. Потрібно знайти значення всіх величин $d_{ij}$ - довжини найкоротшого шляху з вершини $i$ до вершини $j$.

Передбачається, що граф не містить від'ємних циклів ваги (тоді відповіді між деякими парами вершин можуть просто не існувати - граф буде нескінченно малим).

Цей алгоритм був одночасно опублікований у статтях Роберта Флойда (Robert Floyd) та Стівена Воршелла (Stephen Warshall) у 1962 році, за іменами яких він і називається до цього часу. Однак, вже у 1959 році Бернар Рой (Bernard Roy) опублікував практично такий самий алгоритм, але його публікація залишилась непоміченою.

## Опис алгоритму

Ключова ідея алгоритму - розбиття процесу пошуку найкоротших шляхів на **етапи**.

Перед $k$-ою фазою ($k = 1 \ldots n$) вважається, що в матриці відстаней $d[][]$ збережені довжини таких найкоротших шляхів, які містять в якості внутрішніх вершин тільки вершини з множини $\{ 1, 2, \ldots, k-1 \}$ (вершини графа ми нумеруємо, починаючи з одиниці).

Іншими словами, перед $k$-ою фазою величина $d[i][j]$ дорівнює довжині найкоротшого шляху з вершини $i$ до вершини $j$, якщо при проходженні шляху можна відвідати лише вершини з номерами меншими за $k$ (початок та кінець шляху не враховуються). Російське слово "фаза" можна замінити на "етап".

Легко переконатися, що щоб ця властивість виконалася для першої фази, достатньо в матрицю відстаней $d[][]$ записати матрицю суміжності графа: $d[i][j] = g[i][j]$ - вартість ребра з вершини $i$ до вершини $j$. При цьому, якщо між якимись вершинами немає ребра, то записується величина "нескінченність" $\infty$. З вершини в саму себе завжди випливає записувати величину $0$, це критично для алгоритму.

Нехай зараз ми знаходимося на $k$-ій фазі і хочемо **перерахувати** матрицю $d[][]$ таким чином, щоб вона відповідала вимогам для $k+1$-ої фази. Зафіксуємо деякі вершини $i$ і $j$. У нас виникає два принципово різних випадки:

* Найкоротший шлях з вершини $i$ до вершини $j$, якому дозволено проходити через вершини $\{ 1, 2, \ldots, k \}$, **співпадає** з найкоротшим шляхом, якому дозволено проходити через вершини множини $\{ 1, 2, \ldots, k-1 \}$.

У цьому випадку величина $d[i][j]$ не зміниться під час переходу з $k$-ої на $k+1$-у фазу.

* "Новий" найкоротший шлях став **кращим** за "старий" шлях.

Це означає, що "новий" найкоротший шлях проходить через вершину $k$. Відразу зауважимо, що ми не втратимо загальності, розглядаючи далі лише прості шляхи (тобто шляхи, які не проходять через будь-яку вершину двічі).

Зауважимо, що якщо ми розіб'ємо цей "новий" шлях вершиною $k$ на дві половинки (одна йде з $i$ до $k$, а інша - з $k$ до $j$), то кожна з цих половинок вже не проходить через вершину $k$. Але тоді виходить, що довжина кожної з цих половинок була порахована ще на $k-1$-ій фазі або ще раніше, і нам достатньо взяти просто суму $d[i][k] + d[k][j]$, вона і дасть довжину "нового" найкоротшого шляху.

Об'єднуючи ці два випадки, отримуємо, що на $k$-ій фазі потрібно перерахувати довжини найкоротших шляхів між усіма парами вершин $i$ та $j$ наступним чином:

<!--- TODO: specify code snippet id -->
``` cpp
new_d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
```

Таким чином, вся робота, яку потрібно провести на $k$-ій фазі, полягає у переборі всіх пар вершин і перерахуванні довжини найкоротшого шляху між ними. В результаті після виконання $n$-ої фази у матриці відстаней $d[i][j]$ буде записана довжина найкоротшого шляху між $i$ та $j$, або $\infty$, якщо шляху між цими вершинами не існує.

Останнє зауваження, що потрібно зробити, полягає в тому, що можна **не створювати окрему матрицю** $\rm new\_d[][]$ для тимчасової матриці найкоротших шляхів на $k$-ій фазі: всі зміни можна зробити одразу в матриці $d[][]$. Насправді, якщо ми поліпшили (зменшили) яке-небудь значення в матриці відстаней, то не могли погіршити тим самим довжину найкоротшого шляху для деяких інших пар вершин, що обробляться пізніше.

Асимптотика алгоритму, очевидно, становить $O(n^3)$.

## Реалізація

На вхід програмі подається граф у вигляді матриці суміжності - двовимірного масиву $d[][]$ розміру $n \times n$, в якому кожен елемент задає довжину ребра між відповідними вершинами.

Потрібно, щоб виконувалося $d[i][i] = 0$ для будь-якого $i$.

<!--- TODO: specify code snippet id -->
``` cpp
for (int k = 0; k < n; ++k)
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
```

Передбачається, що якщо між двома якимись вершинами **немає ребра**, то в матриці суміжності було записано якесь велике число (достатньо велике, щоб воно було більше довжини будь-якого шляху в цьому графі); тоді це ребро завжди буде не вигідно брати, і алгоритм працюватиме правильно.

Правда, якщо не прийняти спеціальних заходів, то при наявності в графі ребер з **від'ємним вагою**, у результуючій матриці можуть з'явитися числа у вигляді $\infty-1$, $\infty-2$ і т.д., які, звісно, як і раніше означають, що між відповідними вершинами взагалі немає шляху. Тому при наявності в графі ребер з від'ємним вагою алгоритм Флойда краще написати так, щоб він не робив переходів з тих станів, в яких вже "немає шляху"

<!--- TODO: specify code snippet id -->
``` cpp
for (int k = 0; k < n; ++k)
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            if (d[i][k] < INF && d[k][j] < INF)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
```

## Відновлення самого дороги

Легко підтримувати додаткову інформацію - так звані "попередники", за допомогою яких можна буде відновлювати найкоротший шлях між будь-якими двома заданими вершинами **у вигляді послідовності вершин**.

Для цього достатньо, окрім матриці відстаней $d[][]$, підтримувати також **матрицю предків** $p[][]$, яка для кожної пари вершин буде містити номер фази, на якій було отримано найкоротший шлях між ними. Зрозуміло, що цей номер фази є нічим іншим, як "середньою" вершиною шуканого найкоротшого шляху, і тепер нам просто треба знайти найкоротший шлях між вершинами $i$ і $p[i][j]$, а також між $p[i][j]$ і $j$. Звідси випливає простий рекурсивний алгоритм відновлення найкоротшого шляху.

## Випадок речовинних ваг

Якщо ваги ребер графа не цілочисельні, а дійсні, то потрібно враховувати похибки, які неминуче виникають при роботі з типами з плаваючою точкою.

Применивши алгоритм Флойда, можна стикнутися з неприємним ефектом помилок, які можуть призвести до того, що знайдені алгоритмом відстані можуть бути дуже від'ємними через **накопичення помилок**. Насправді, якщо на першій фазі сталася помилка $\Delta$, то на другій ітерації ця помилка може перетворитися в $2 \Delta$, на третій - в $4 \Delta$, і так далі.

Щоб цього не траплялося, порівняння в алгоритмі Флойда потрібно робити з урахуванням похибки:

<!--- TODO: specify code snippet id -->
``` cpp
if (d[i][k] + d[k][j] < d[i][j] - EPS)
    d[i][j] = d[i][k] + d[k][j];
```

## Випадок негативних циклів

Якщо в графі є цикли з від'ємною вагою, то формально алгоритм Флойда-Уоршелла не можна застосовувати до такого графу.

Насправді, для тих пар вершин $i$ і $j$, між якими неможливо утворити цикл з від'ємною вагою, алгоритм працюватиме правильно.

Для тих пар вершин, для яких не існує відповіді (через наявність негативного циклу на шляху між ними), алгоритм Флойда знайде як відповідь деяке число (можливо, дуже від'ємне, але не обов'язково). Тим не менш, можна покращити алгоритм Флойда, щоб він точно обробляв такі пари вершин і виводив для них, наприклад, $-\infty$.

Для цього можна зробити, наприклад, наступний **критерій** "невідсутності шляху". Отже, нехай на даному графі був використаний звичайний алгоритм Флойда. Значить, між вершинами $i$ і $j$ не існує найкоротшого шляху тоді і тільки тоді, коли знайдеться така вершина $t$, досяжна з $i$ і з якої досяжна $j$, для якої виконується $d[t][t] < 0$.

Крім того, при використанні алгоритму Флойда для графів з від'ємними циклами виникає необхідність пам'ятати, що в процесі роботи відстані можуть дуже сильно ставати від'ємними, зменшуючись експоненційно з кожною ітерацією. Тому потрібно прийняти заходи проти переповнення цілих чисел, обмеживши всі відстані знизу якоюсь величиною (наприклад, $- {\rm INF}$).

Більш детально про цю задачу можна дізнатися з окремої статті "Знаходження від'ємного циклу в графі" (negative_cycle).