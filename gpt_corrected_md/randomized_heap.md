# Рандомізованих куп****

Рандомізована купа (randomized heap) - це купа, яка за допомогою генератора випадкових чисел дозволяє виконувати всі необхідні операції за логарифмічний очікуваний час.

**Купою** називається бінарне дерево, для будь-якої вершини якого справедливо, що значення в цій вершині менше або рівне значенням у всіх її нащадків (це купа для мінімуму; звісно, симетрично можна визначити купу для максимуму). Таким чином, в корені купи завжди знаходиться мінімум.

Стандартний набір операцій, визначений для купи, наступний:

* Додавання елемента
* Знаходження мінімуму
* Вилучення мінімуму (видалення його з дерева та повернення його значення)
* Злиття двох куп (повертається купа, що містить елементи обох куп; дублікати не видаляються)
* Видалення будь-якого елементу (з відомою позицією в дереві)

Рандомізована купа дозволяє виконувати всі ці операції за очікуваний час $O(\log n)$ при дуже простій реалізації.

## Структура даних

Відразу опишемо структуру даних, що описує бінарну купу:
<!--- TODO: specify code snippet id -->
``` cpp
struct tree {
    T value;
    tree *l, *r;
};
```
У вершині дерева зберігається значення типу $\rm T$ під назвою $\rm value$, для якого визначений оператор порівняння ($\rm operator\ <$). Крім того, зберігаються вказівники на лівого і правого синів (які дорівнюють 0, якщо відповідний син відсутній).

## Виконання операцій

Не складно зрозуміти, що всі операції над купою зводяться до однієї операції: **злиття** двох куп у одну. Дійсно, додавання елементу до купи еквівалентно злиттю цієї купи з купою, що складається з єдиного додаваного елементу. Знаходження мінімуму взагалі не потребує ніяких дій - мінімумом є корінь купи. Вилучення мінімуму еквівалентно заміні купи результатом злиття лівого і правого піддерева кореня. Нарешті, видалення довільного елементу аналогічне видаленню мінімуму: все піддерево з коренем в цій вершині замінюється результатом злиття двох піддерев-синів цієї вершини.

Отже, насправді нам потрібно реалізувати лише операцію злиття двох куп, всі інші операції можна легко звести до цієї операції.

Нехай є дві купи $T_1$ і $T_2$, потрібно об'єднати їх. Очевидно, що в корені кожної купи знаходиться її мінімум. Тому в корені результуючої купи буде мінімум з цих двох значень. Ми порівнюємо значення в коренях куп і поміщаємо менше з них в корінь результату. Потім ми повинні об'єднати синів обраної вершини з іншою купою. Якщо ми виберемо одного з двох синів за якимось критерієм, то ми просто об'єднаємо піддерево кореня з цим сином з іншою купою. Таким чином, ми знову приходимо до операції злиття. Рано або пізно цей процес зупиниться (на це знадобиться, зрозуміло, не більше, ніж сума висот куп).

Таким чином, щоб досягти логарифмічної асимптотики в середньому, нам потрібно вказати спосіб вибору одного з двох синів так, щоб в середньому довжина проходимого шляху становила порядок логарифма від кількості елементів у купі. Не складно здогадатися, що ми будемо **випадково** вибирати цей вибір, тому реалізація операції злиття буде наступною:

<!--- TODO: specify code snippet id -->
``` cpp
tree *merge(tree *t1, tree *t2) {
    if (!t1 || !t2)
        return t1 ? t1 : t2;
    if (t2->value < t1->value)
        swap(t1, t2);
    if (rand() & 1)
        swap(t1->l, t1->r);
    t1->l = merge(t1->l, t2);
    return t1;
}
```

Тут спочатку перевіряється, якщо хоча б одна з куп порожня, то ніяких дій по злиттю виробляти не потрібно. Інакше, ми робимо так, щоб купа $\rm t1$ була купою з меншим значенням в корені (для чого обмінюємо $\rm t1$ і $\rm t2$, якщо потрібно). Нарешті, ми припускаємо, що одному купу $\rm t2$ будемо злити з лівим сином кореня купи $\rm t1$, тому ми випадковим чином обмінюємо лівого і правого синів, а потім виконуємо злиття лівого сина і другої купи.

## Асимптотика

Введемо випадкову величину $h(T)$, яка позначає **довжину випадкового шляху** від кореня до листа (довжина в числі ребер). Зрозуміло, що алгоритм $\rm merge$ виконується за $O(h(T_1)+h(T_2))$ операцій. Тому для дослідження асимптотики алгоритму потрібно дослідити випадкову величину $h(T)$.

### Математичне очікування

Стверджується, що математичне очікування $h(T)$ оцінюється зверху логарифмом від числа $n$ вершин у цій купі:

$$
Eh(T) \le \log(n+1)
$$

Доводиться це легко за допомогою індукції. Нехай $L$ та $R$ є, відповідно, лівим та правим піддеревами кореня купи $T$, а $n_L$ та $n_R$ - кількості вершин у них (зрозуміло, що $n = n_L+n_R+1$).

Значить, правильно:

$$
Eh(T) = 1 + \frac{1}{2}(Eh(L) + Eh(R)) \le 1 + \frac{1}{2}(\log(n_L+1) + \log(n_R+1)) =
$$

$$
= 1 + \log \sqrt{ (n_L+1)(n_R+1) } = \log 2 \sqrt{ (n_L+1)(n_R+1) } \le
$$

$$
\le \log \frac{ 2 ((n_L+1) + (n_R+1)) }{ 2 } = \log (n_L + n_R + 2) = \log(n+1)
$$

що потрібно довести?

### Перевищення очікуваної оцінки

Доведемо, що ймовірність перевищення отриманої вище оцінки була мала:

$$
P\{ h(T) > (c+1) \log n \} < \frac{1}{n^c}
$$

для будь-якої позитивної константи $c$.

Позначимо через $P$ множину шляхів від кореня купи до листя, довжина яких перевищує $(c+1) \log n$. Зауважимо, що для будь-якого шляху $p$ довжини $|p|$ ймовірність того, що саме він буде обраний як випадковий шлях, дорівнює $2^{-|p|}$. Отже, отримуємо:

$$
P\{ h(T) > (c+1) \log n \} = \sum_{p \in P} 2^{-|p|} < \sum_{p \in P} 2^{-(c+1) \log n} = |P| n^{-(c+1)} \le n^{-c}
$$

що потрібно довести?

### Асимптотика алгоритму

Таким чином, алгоритм $\mathrm{merge}$, а отже, і всі інші, що виражені через нього операції, виконуються за $O(\log n)$ у середньому.

Більше того, для будь-якої позитивної константи $\epsilon$ знайдеться така позитивна константа $c$, що ймовірність того, що операція займе більше ніж $c \log n$ операцій, менше $n^{-\epsilon}$ (це в деякому сенсі описує найгірше поведінку алгоритму).