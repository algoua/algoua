# Декомпозиція Ліндона. Алгоритм Дюваля. Знаходження найменшого циклічного зсуву

## Поняття декомпозиції Ліндона

Визначимо поняття **декомпозиції Ліндона** (розкладу Ліндона, англ. Lyndon decomposition).

Рядок називається **простим**, якщо він є строго **меншим**, ніж будь-який з його власних **суфіксів**. Приклади простих рядків: $a$, $b$, $ab$, $aab$, $abb$, $ababb$, $abcd$. Можна показати, що рядок є простим тоді і тільки тоді, коли він є строго **меншим** за всі його нетривіальні **циклічні зсуви**.

Далі, нехай задано рядок $s$. Декомпозиція Ліндона рядка $s$ - це його розкладання на добуток $s = w_1 w_2 \ldots w_k$, де рядки $w_i$ є простими, і при цьому $w_1 \ge w_2 \ge \ldots \ge w_k$.

Можна показати, що для будь-якої стрічки $s$ це розкладання існує і єдине.

## Алгоритм Дівала

Алгоритм Дювала (Duval's algorithm) знаходить для заданої стрічки довжини $n$ декомпозицію Ліндона за час $O(n)$ з використанням $O(1)$ додаткової пам'яті.

Працюватимемо з рядками у 0-індексації.

Введемо допоміжне поняття простої стрічки. Стрічка $t$ називається **простою**, якщо вона має вигляд $t = w w w \ldots w \overline{w}$, де $w$ - деяка проста стрічка, а $\overline{w}$ - деякий префікс стрічки $w$.

Алгоритм Дюваля є жадібним. У будь-який момент його роботи стрічка S фактично розділена на три стрічки $s = s_1 s_2 s_3$, де в стрічці $s_1$ декомпозицію Ліндона вже знайдено і $s_1$ більше не використовується алгоритмом; стрічка $s_2$ - це проста стрічка (причому довжину простих стрічок всередині її ми також запам'ятовуємо); стрічка $s_3$ - це ще не оброблена частина стрічки $s$. Кожен раз алгоритм Дюваля бере перший символ стрічки $s_3$ і намагається додати його до стрічки $s_2$. При цьому, можливо, для якогось префікса стрічки $s_2$ декомпозиція Ліндона стає відомою, і ця частина переходить до стрічки $s_1$.

Опишемо тепер алгоритм **формально**. По-перше, буде підтримуватися вказівник $i$ на початок стрічки $s_2$. Зовнішній цикл алгоритму буде виконуватися, доки $i < n$, тобто поки вся стрічка $s$ не перейде в стрічку $s_1$. Усередині цього циклу створюються два покажчика: вказівник $j$ на початок стрічки $s_3$ (фактично вказівник на наступний символ-кандидат) і вказівник $k$ на поточний символ у стрічці $s_2$, з яким буде проводитися порівняння. Потім будемо в циклі намагатися додати символ $s[j]$ до стрічки $s_2$, для чого необхідно провести порівняння з символом $s[k]$. Тут у нас виникають три різних випадки:

* Якщо $s[j] = s[k]$, то ми можемо додати символ $s[j]$ до рядка $s_2$, не порушуючи його "простоти". Отже, у цьому випадку ми просто збільшуємо вказівники $j$ і $k$ на одиницю.

* Якщо $s[j] > s[k]$, то очевидно, що рядок $s_2 + s[j]$ стане простішим. Тому ми збільшуємо $j$ на одиницю, а $k$ передвигаємо назад на $i$, щоб наступний символ порівнювався з першим символом $s_2$.

* Якщо $s[j] < s[k]$, то рядок $s_2+s[j]$ вже не може бути простим. Тому ми розбиваємо простий рядок $s_2$ на прості рядки плюс "залишок" (префікс простого рядка, можливо, порожній); прості рядки додаємо до відповіді (тобто виводимо їх позиції, попутно пересуваючи вказівник $i$), а "залишок" разом з символом $s[j]$ переводимо назад в рядок $s_3$, і зупиняємо виконання внутрішнього циклу. Тим самим ми наступної ітерації зовнішнього циклу знову опрацюємо залишок, знаючи, що він не міг утворити простий рядок з попередніми простими рядками. Залишилося тільки зазначити, що при виведенні позицій простих рядків нам потрібно знати їх довжину; але вона, очевидно, дорівнює $j-k$.

### Реалізація

Наведемо реалізацію алгоритму Дюваля, яка виводитиме шукану декомпозицію Ліндона рядка $s$:

<!--- TODO: specify code snippet id -->
``` cpp
рядок s; // вхідний рядок
int n = (int)s.length();
int i = 0;
while (i < n) {
    int j = i + 1, k = i;
    while (j < n && s[k] <= s[j]) {
        if (s[k] < s[j])
            k = i;
        else
            ++k;
        ++j;
    }
    while (i <= k) {
        cout << s.substr(i, j - k) << ' ';
        i += j - k;
    }
}
```

### Асимптотика

Відразу зауважимо, що для алгоритму Дюваля потрібно **$O(1)$ пам'яті**, а саме три вказівники $i$, $j$, $k$.

Оцінимо тепер **час виконання** алгоритму.

Внешній цикл while робить не більше $n$ ітерацій, оскільки в кінці кожної його ітерації виводиться принаймні один символ (а загалом символів виводиться, очевидно, рівно $n$).

Оцінимо тепер кількість ітерацій **першого вкладеного циклу while**. Для цього розглянемо другий вкладений цикл while - він при кожному своєму запуску виводить деяку кількість $r \ge 1$ копій однієї і тієї ж простої стрічки деякої довжини $p = j-k$. Зауважимо, що стрічка $s_2$ є простою, причому її прості стрічки мають довжину якраз $p$, тобто її довжина не перевищує $r p + p - 1$. Оскільки довжина стрічки $s_2$ дорівнює $j-i$, а вказівник $j$ збільшується на одиницю при кожній ітерації першого вкладеного циклу while, то цей цикл виконає не більше $r p + p - 2$ ітерацій. Найгіршим випадком є випадок $r = 1$, і ми отримуємо, що перший вкладений цикл while виконує не більше $2 p - 2$ ітерацій. Згадуючи, що всього виводиться $n$ символів, отримуємо, що для виведення $n$ символів потрібно не більше $2 n - 2$ ітерацій першого вкладеного while-а.

Отже, алгоритм Дюваля виконується за $O(n)$.

Легко оцінити кількість порівнянь символів, що виконує алгоритм Дюваля. Оскільки кожна ітерація першого вкладеного циклу while виконує два порівняння символів, а також одне порівняння виконується після останньої ітерації циклу (щоб зрозуміти, що цикл повинен зупинитися), то загальна **кількість порівнянь символів** не перевищує $4 n - 3$.

## Знаходження найменшого циклічного зсуву

Нехай дана стрічка $s$. Побудуємо для стрічки $s+s$ декомпозицію Ліндона (ми можемо це зробити за $O(n)$ часу і $O(1)$ пам'яті (якщо не використовувати конкатенацію в явному вигляді)). Знайдемо передпростий блок, який починається в позиції, меншій $n$ (тобто в першому екземплярі стрічки $s$), і закінчується в позиції, більшій або рівній $n$ (тобто в іншому екземплярі). Стверджується, що **позиція початку** цього блоку і буде початком шуканого циклічного зсуву (в цьому легко переконатися, скориставшись визначенням декомпозиції Ліндона).

Початок простого блоку знайти просто - достатньо помітити, що вказівник $i$ на початку кожної ітерації зовнішнього циклу while вказує на початок поточного простого блоку.

Разом ми отримуємо таку **реалізацію** (для спрощення коду вона використовує $O(n)$ пам'яті, явно дописуючи стрічку до себе):

<!--- TODO: specify code snippet id -->
``` cpp
string min_cyclic_shift(string s) {
    s += s;
    int n = (int)s.length();
    int i = 0, ans = 0;
    while (i < n / 2) {
        ans = i;
        int j = i + 1, k = i;
        while (j < n && s[k] <= s[j]) {
            if (s[k] < s[j])
                k = i;
            else
                ++k;
            ++j;
        }
        while (i <= k)
            i += j - k;
    }
    return s.substr(ans, n / 2);
}
```

## Завдання в онлайн-суддях

Список задач, які можна вирішити, використовуючи алгоритм Дейкстри:

* [UVA #719 **"Glass Beads"** [складність: низька]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=660)