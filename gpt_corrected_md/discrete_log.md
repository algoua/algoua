# Дискретне логарифмування

Задача дискретного логарифмування полягає в тому, щоб за даними цілими числами $a$, $b$ та $m$ знайти таке ціле число $x$, для якого виконується рівність:

$$
a^x = b \pmod m,
$$

де $a$ і $m$ - **взаємно прості** (зауваження: якщо вони не є взаємно простими, то описаний нижче алгоритм є некоректним; хоча, передбачувано, його можна модифікувати, щоб він як і раніше працював).

Тут описаний алгоритм, відомий як **"алгоритм маленьких кроків - великих кроків"**, запропонований **Шенксом (Shenks)** в 1971 році, працюючий за час $O(\sqrt{m} \log m)$. Часто цей алгоритм просто називають алгоритмом **"зустріч-в-середині"** (тому що це одне з класичних застосувань техніки "зустріч-в-середині": "поділ задачі навпіл").

## Алгоритм

Отже, маємо рівняння:

$$
a^x = b \pmod m,
$$

де $a$ і $m$ є взаємно простими.

Перетворимо рівняння, поклавши

$$
x = np - q,
$$

де $n$ - це заздалегідь обрана константа (як її вибрати в залежності від $m$, ми зрозуміємо трохи пізніше). Іноді $p$ називають "великим кроком" (оскільки збільшення його на одиницю збільшує $x$ зразу на $n$), а в протилежність йому $q$ - "малим кроком".

Очевидно, що будь-яке $x$ (з проміжку $[0;m)$ - зрозуміло, що такого діапазону значень буде достатньо) можна подати у такій формі, причому для цього буде достатньо значень:

$$
p \in \left[ 1; \left\lceil \frac{m}{n} \right\rceil \right], ~~~~~ q \in [0;n].
$$

Отже, рівняння має наступний вигляд:

$$
a^{np-q} = b \pmod m,
$$

звідки, використовуючи той факт, що $a$ і $m$ взаємно прості, отримуємо:

$$
a^{np} = b a^q \pmod m.
$$

Щоб розв'язати вихідне рівняння, потрібно знайти відповідні значення $p$ та $q$, щоб значення лівої та правої частин співпали. Іншими словами, потрібно розв'язати рівняння:

$$
f_1(p) = f_2(q).
$$

Ця задача вирішується за допомогою методу meet-in-the-middle наступним чином. Перша фаза алгоритму: порахуємо значення функції $f_1$ для всіх значень аргументу $p$, і відсортуємо ці значення. Друга фаза алгоритму: будемо перебирати значення другої змінної $q$, обчислювати функцію $f_2$, і шукати це значення серед попередньо обчислених значень першої функції з допомогою бінарного пошуку.

## Асимптотика

Спочатку оцінимо час обчислення кожної з функцій $f_1(p)$ і $f_2(q)$. Обидві функції містять піднесення до ступеня, які можна виконувати з допомогою [алгоритму швидкого піднесення до степеня](https://uk.wikipedia.org/wiki/Алгоритм_швидкого_піднесення_в_ступінь). Значить, обидві ці функції ми можемо обчислювати за час $O(\log m)$.

Сам алгоритм у першій фазі містить обчислення функції $f_1(p)$ для кожного можливого значення $p$ і подальше сортування значень, що дає нам асимптотику:

$$
O\left( \left\lceil \frac{m}{n} \right\rceil \left( \log m + \log \left\lceil \frac{m}{n} \right\rceil \right) \right) = O\left( \left\lceil \frac{m}{n} \right\rceil \log m \right).
$$

У другій фазі алгоритму відбувається обчислення функції $f_2(q)$ для кожного можливого значення $q$, а також проводиться бінарний пошук по масиву значень $f_2$, що дає нам асимптотику:

$$
O\left( n \left( \log m + \log \left\lceil \frac{m}{n} \right\rceil \right) \right) = O\left( n \log m \right).
$$

Тепер, коли ми додамо ці дві асимптотики, отримаємо $\log m$, помножене на суму $n$ і $m/n$. Практично очевидно, що мінімум досягається, коли $n \approx \sqrt{m}$, тобто для оптимальної роботи алгоритму константу $n$ потрібно обирати так:

$$
n \approx \sqrt{m}.
$$

Значить, асимптотика алгоритму має наступний вигляд:

$$
O\left( \sqrt{m} ~ \log m \right).
$$

Зауваження. Ми могли б обміняти ролями $f_1$ і $f_2$ (тобто на першій фазі обчислювати значення функції $f_2$, а на другій - $f_1$), проте легко зрозуміти, що результат від цього не зміниться, і асимптотику цим ми ніяк не покращимо.

## Реалізація

### Найпростіша реалізація

Функція $\mathrm{powmod}$ виконує бінарне піднесення числа $a$ в ступінь $b$ за модулем $m$, див. [Бінарне піднесення в ступінь](https://uk.wikipedia.org/wiki/Бінарне_піднесення_в_ступінь).

Функція $\rm solve$ виробляє розв'язок задачі. Ця функція повертає відповідь (число в проміжку $[0;m)$), точніше кажучи, один з розв'язків. Функція поверне $-1$, якщо розв'язку не існує.

<!--- TODO: specify code snippet id -->
``` cpp
int powmod(int a, int b, int m) {
    int res = 1;
    while (b > 0)
        if (b & 1) {
            res = (res * a) % m;
            --b;
        } else {
            a = (a * a) % m;
            b >>= 1;
        }
    return res % m;
}

int solve(int a, int b, int m) {
    int n = (int)sqrt(m + .0) + 1;
    map<int, int> vals;
    for (int i = n; i >= 1; --i)
        vals[powmod(a, i * n, m)] = i;
    for (int i = 0; i <= n; ++i) {
        int cur = (powmod(a, i, m) * b) % m;
        if (vals.count(cur)) {
            int ans = vals[cur] * n - i;
            if (ans < m)
                return ans;
        }
    }
    return -1;
}
```

Тут ми для зручності при реалізації першої фази алгоритму скористалися структурою даних "відображення" (червоно-чорним деревом), яка для кожного значення функції $f_1(i)$ зберігає аргумент $i$, при якому це значення досягалося. При цьому, якщо одне і те ж значення досягалося декілька разів, записується найменший з усіх аргументів. Це зроблено для того, щоб згодом, на другій фазі алгоритму, знайшлася відповідь в проміжку $[0;m)$.

Враховуючи, що аргумент функції $f_1()$ на першій фазі перебирався від одиниці до $n$, а аргумент функції $f_2()$ на другій фазі перебирається від нуля до $n$, то в підсумку ми охоплюємо всю множину можливих відповідей. Таким чином, відрізок $[0; n^2]$ містить у собі проміжок $[0;m)$. При цьому негативна відповідь не могла виникнути, а відповіді, що більші або рівні $m$, можна ігнорувати - всі рівні відповіді повинні бути з проміжку $[0;m)$.

Цю функцію можна змінити на випадок, коли потрібно знайти **усі розв'язки** задачі дискретного логарифма. Для цього потрібно замінити "map" на яку-небудь іншу структуру даних, що дозволяє зберігати для одного аргументу кілька значень (наприклад, "multimap"), і відповідно змінити код другої фази.

### Покращена реалізація

При **оптимізації швидкості** можна вступити наступним чином.

По-перше, зразу біється в очі непотрібність бінарного піднесення в ступінь на другій фазі алгоритму. Замість цього можна просто створити змінну і множити її кожен раз на $a$.

По-друге, таким же чином можна позбутися від бінарного піднесення до степеня на першій фазі: насправді, достатньо один раз порахувати величину $a^n$, і потім просто домножувати її на себе.

Таким чином, логарифм у асимптотиці залишається, але це буде лише логарифм, пов'язаний із структурою даних $map<>$ (тобто, у термінах алгоритму, із сортуванням та бінарним пошуком значень) - іншими словами, це буде логарифм від $\sqrt{m}$, що на практиці дає помітне прискорення.

<!--- TODO: specify code snippet id -->
``` cpp
int solve(int a, int b, int m) {
    int n = (int)sqrt(m + .0) + 1;

    int an = 1;
    for (int i = 0; i < n; ++i)
        an = (an * a) % m;

    map<int, int> vals;
    for (int i = 1, cur = an; i <= n; ++i) {
        if (!vals.count(cur))
            vals[cur] = i;
        cur = (cur * an) % m;
    }

    for (int i = 0, cur = b; i <= n; ++i) {
        if (vals.count(cur)) {
            int ans = vals[cur] * n - i;
            if (ans < m)
                return ans;
        }
        cur = (cur * a) % m;
    }
    return -1;
}
```

Нарешті, якщо модуль $m$ досить малий, то можна зовсім позбутися логарифма в асимптотиці - просто використати замість $map<>$ звичайний масив.

Також можна згадати про хеш-таблиці: в середньому вони працюють також за $O(1)$, що в цілому дає асимптотику $O(\sqrt{m})$.