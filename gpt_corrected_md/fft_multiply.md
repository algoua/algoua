# Швидке перетворення Фур'є за O(N log N). Застосування до множення двох поліномів або довгих чисел

Тут ми розглянемо алгоритм, який дозволяє перемножити два поліноми довжиною $n$ за час $O(n \log n)$, що значно краще, ніж час $O(n^2)$, досягнутий тривіальним алгоритмом множення. Очевидно, що множення двох довгих чисел можна звести до множення поліномів, тому два довгі числа також можна перемножити за час $O(n \log n)$.

Ізобретення Швидкого перетворення Фур'є приписують Кулі (Cooley) і Такі (Tukey) - 1965 р. Насправді, ШПФ неодноразово винаходилося до цього, але важливість його повністю не усвідомлювалась до появи сучасних комп'ютерів. Деякі дослідники приписують відкриття ШПФ Рунге (Runge) і Кенігу (König) в 1924 р. Нарешті, відкриття цього методу приписують ще Гауссу (Gauss) в 1805 р.

## Дискретне перетворення Фур'є (ДПФ)

Нехай є поліном $n$-го ступеня:

$$
A(x) = a_0 x^0 + a_1 x^1 + \ldots + a_{n-1} x^{n-1}.
$$

Чи не втрачаючи цілісності, можна вважати, що $n$ є степенем двійки. Якщо насправді $n$ не є степенем двійки, то ми просто додамо недостаючі коефіцієнти, положивши їх рівними нулю.

З теорії функцій комплексної змінної відомо, що кількість комплексних коренів $n$-ої степені з одиниці дорівнює $n$. Позначимо ці корені як $w_{n,k}, k = 0 \ldots {n-1}$. Тоді відомо, що $w_{n,k} = e^{ i \frac{ 2 \pi k }{ n } }$. Крім того, один з цих коренів $w_n = w_{n,1} = e^{ i \frac{ 2 \pi }{ n } }$ (званий головним значенням кореня $n$-ої степені з одиниці) такий, що всі інші корені є його степенями: $w_{n,k} = (w_n)^k$.

Значить **дискретним перетворенням Фур'є (ДПФ)** (discrete Fourier transform, DFT) вектора коефіцієнтів $(a_0, a_1, \dots, a_{n-1})$ багаточлена $A(x)$ називаються значення цього багаточлена в точках $x = w_{n,k}$, тобто це вектор:

$$
{\rm DFT}(a_0, a_1, \ldots, a_{n-1}) = (y_0, y_1, \ldots, y_{n-1}) = (A(w_{n,0}), A(w_{n,1}), \ldots, A(w_{n,n-1})) =
$$

$$
= (A(w_n^0), A(w_n^1), \ldots, A(w_n^{n-1})).
$$

Аналогічно визначається і **зворотне дискретне перетворення Фур'є** (Зворотне ДПФ). Зворотне ДПФ для вектора значень полінома $(y_0, y_1, \ldots, y_{n-1})$ - це вектор коефіцієнтів полінома $(a_0, a_1, \ldots, a_{n-1})$:

$$
{\rm InverseDFT}(y_0, y_1, \ldots, y_{n-1}) = (a_0, a_1, \ldots, a_{n-1}).
$$

Таким чином, якщо здійснювати пряме ДПФ, переходячи від коефіцієнтів многочлена до його значень у комплексних коренях $n$-го степеня з одиниці, то зворотне ДПФ, навпаки, за значеннями многочлена відновлює його коефіцієнти.

## Застосування Дискретного перетворення Фур'є для швидкого множення поліномів

Нехай дані два багаточлени $A$ і $B$. Порахуємо ДФТ для кожного з них: ${\rm DFT}(A)$ і ${\rm DFT}(B)$ - це два вектори-значення багаточленів.

Тепер, що відбувається під час множення багаточленів? Очевидно, що в кожній точці їх значення просто перемножуються, тобто

$$
(A \times B)(x) = A(x) \times B(x).
$$

Але це означає, що якщо ми перемножимо вектори ${\rm DFT}(A)$ і ${\rm DFT}(B)$, просто помноживши кожен елемент одного вектора на відповідний йому елемент іншого вектора, то ми отримаємо не що інше, як ДФТ від багаточлена $A \times B$:

$$
{\rm DFT} (A \times B) = {\rm DFT} (A) \times {\rm DFT} (B).
$$

Нарешті, застосовуючи обернену ДПФ, отримуємо:

$$
A \times B = {\rm InverseDFT}( {\rm DFT} (A) \times {\rm DFT} (B) ),
$$

де, як ми вже говорили, під твором двох ДПФ розуміється попарний добуток елементів векторів. Такий добуток вимагає тільки $O(n)$ операцій для обчислення. Отже, якщо ми зможемо обчислити ДПФ і зворотнє ДПФ за час $O(n \log n)$, то ми зможемо знайти добуток двох поліномів (і, відповідно, двох довгих чисел) за ту ж асимптотику.

Слід зазначити, що спочатку необхідно привести до однакового степеня два багаточлени (додавши до одного з них коефіцієнти нульовими). Крім того, результат множення двох багаточленів степеня $n$ буде багаточлен степеня $2n-2$, тому перед множенням необхідно подвоїти степені обох багаточленів (додавши до них нульові коефіцієнти). Таким чином, отримаємо коректний результат.

## Швидке перетворення Фур'є

"Швидке перетворення Фур'є" (швидкий Fourier transform) - це метод, який дозволяє обчислювати ДПФ за час $O(n \log n)$. Цей метод базується на властивостях комплексних коренів з одиниці (зокрема, на тому, що степені одних коренів дають інші корені).

Основна ідея ШФП полягає в розділенні вектора коефіцієнтів на два вектори, рекурсивному обчисленні ДФП для них та об'єднанні результатів в одну ШФП.

Отже, нехай є багаточлен $A(x)$ степені $n$, де $n$ є ступенем двійки, і $n>1$:

$$
A(x) = a_0 x^0 + a_1 x^1 + \ldots + a_{n-1} x^{n-1}.
$$

Розділимо його на два багаточлени: один - з парними коефіцієнтами, а інший - з непарними

$$
A_0(x) = a_0 x^0 + a_2 x^1 + \ldots + a_{n-2} x^{n/2-1},
$$

$$
A_1(x) = a_1 x^0 + a_3 x^1 + \ldots + a_{n-1} x^{n/2-1}.
$$

Не складно переконатися, що:

$$
A(x) = A_0(x^2) + x A_1(x^2). ~~~~~~~(1)
$$

Многочлени $A_0$ і $A_1$ мають вдвічі меншу ступінь, ніж багаточлен $A$. Якщо ми зможемо за лінійний час по обчисленим ${\rm DFT}(A_0)$ і ${\rm DFT}(A_1)$ обчислити ${\rm DFT}(A)$, то ми отримаємо шуканий алгоритм швидкого перетворення Фур'є. Це стандартна схема алгоритму "розділяй і володарюй", для якої відома асимптотична оцінка $O(n \log n)$.

Отже, маємо обчислені вектори $\{ y_k^0 \}_{k=0}^{n/2-1} = {\rm FFT}(A_0)$ і $\{ y_k^1 \}_{k=0}^{n/2-1} = {\rm FFT}(A_1)$. Знайдемо вираз для $\{ y_k \}_{k=0}^{n-1} = {\rm FFT}(A)$.

По-перше, згадуючи (1), ми зразу отримуємо значення для першої половини коефіцієнтів:

$$
y_k = y_k^0 + w_n^k y_k^1, ~~~~k = 0 \ldots n/2-1.
$$

Для другої половини коефіцієнтів після перетворень також отримуємо просту формулу:

$$
y_{k+n/2} = A(w_n^{k+n/2}) = A_0(w_n^{2k+n}) + w_n^{k+n/2} A_1(w_n^{2k+n}) = A_0(w_n^{2k} w_n^n) + w_n^k w_n^{n/2} A_1(w_n^{2k} w_n^n) =
$$

$$
= A_0(w_n^{2k}) - w_n^k A_1(w_n^{2k}) = y_k^0 - w_n^k y_k^1.
$$

Тут ми скористалися формулою (1), а також тотожностями $w_n^n = 1$, $w_n^{n/2} = -1$.

Отже, ми отримали формули для обчислення вектора $\{ y_k \}$:

$$
y_k = y_k^0 + w_n^k y_k^1, \ \ \ \ k = 0 \ldots n/2-1,
$$

$$
y_{k+n/2} = y_k^0 - w_n^k y_k^1, \ \ \ \ k = 0 \ldots n/2-1.
$$

Ці формули, тобто дві формули у вигляді $a+bc$ і $a-bc$, іноді називають "операцією метелика" ("баттерфляй-операція")

Тим самим, ми остаточно побудували алгоритм ШПФ.

## Зворотній ДВПФ

Отже, нехай заданий вектор $(y_0, y_1, \ldots, y_{n-1})$ - значення полінома $A$ степеня $n$ в точках $x = w_n^k$. Потрібно відновити коефіцієнти $(a_0, a_1, \ldots, a_{n-1})$ полінома. Ця відома задача називається **інтерполяцією**, для цієї задачі є загальні алгоритми розв'язку, однак в даному випадку буде отриманий дуже простий алгоритм (простий тим, що він практично не відрізняється від прямого DFT).

Дискретне перетворення Фур'є ми можемо записати, згідно його визначення, у матричному вигляді:

$$
\begin{pmatrix}w_n^0 & w_n^0 & w_n^0 & w_n^0 & \cdots & w_n^0 \cr w_n^0 & w_n^1 & w_n^2 & w_n^3 & \cdots & w_n^{n-1} \cr w_n^0 & w_n^2 & w_n^4 & w_n^6 & \cdots & w_n^{2(n-1)} \cr w_n^0 & w_n^3 & w_n^6 & w_n^9 & \cdots & w_n^{3(n-1)} \cr \vdots & \vdots & \vdots & \vdots & \ddots & \vdots \cr w_n^0 & w_n^{n-1} & w_n^{2(n-1)} & w_n^{3(n-1)} & \cdots & w_n^{(n-1)(n-1)}\end{pmatrix} \begin{pmatrix}a_0 \cr a_1 \cr a_2 \cr a_3 \cr \vdots \cr a_{n-1}\end{pmatrix} =  \begin{pmatrix}y_0 \cr y_1 \cr y_2 \cr y_3 \cr \vdots \cr y_{n-1}\end{pmatrix}.
$$

Отже, вектор $(a_0, a_1, \ldots, a_{n-1})$ можна знайти, помноживши вектор $(y_0, y_1, \ldots, y_{n-1})$ на обернену матрицю до матриці, що стоїть ліворуч (яка, до речі, називається матрицею Вандермонда):

$$
\begin{pmatrix}a_0 \cr a_1 \cr a_2 \cr a_3 \cr \vdots \cr a_{n-1}\end{pmatrix} = \begin{pmatrix}w_n^0 & w_n^0 & w_n^0 & w_n^0 & \cdots & w_n^0 \cr w_n^0 & w_n^1 & w_n^2 & w_n^3 & \cdots & w_n^{n-1} \cr w_n^0 & w_n^2 & w_n^4 & w_n^6 & \cdots & w_n^{2(n-1)} \cr w_n^0 & w_n^3 & w_n^6 & w_n^9 & \cdots & w_n^{3(n-1)} \cr \vdots & \vdots & \vdots & \vdots & \ddots & \vdots \cr w_n^0 & w_n^{n-1} & w_n^{2(n-1)} & w_n^{3(n-1)} & \cdots & w_n^{(n-1)(n-1)}\end{pmatrix}^{-1} \begin{pmatrix}y_0 \cr y_1 \cr y_2 \cr y_3 \cr \vdots \cr y_{n-1}\end{pmatrix}.
$$

Непосредственною перевіркою можна переконатися в тому, що ця обернена матриця така:

$$
\frac{1}{n} \begin{pmatrix}w_n^0 & w_n^0 & w_n^0 & w_n^0 & \cdots & w_n^0 \cr w_n^0 & w_n^{-1} & w_n^{-2} & w_n^{-3} & \cdots & w_n^{-(n-1)} \cr w_n^0 & w_n^{-2} & w_n^{-4} & w_n^{-6} & \cdots & w_n^{-2(n-1)} \cr w_n^0 & w_n^{-3} & w_n^{-6} & w_n^{-9} & \cdots & w_n^{-3(n-1)} \cr \vdots & \vdots & \vdots & \vdots & \ddots & \vdots \cr w_n^0 & w_n^{-(n-1)} & w_n^{-2(n-1)} & w_n^{-3(n-1)} & \cdots & w_n^{-(n-1)(n-1)}\end{pmatrix}.
$$

Отже, отримуємо формулу:

$$
a_k = \frac{1}{n} \sum_{j=0}^{n-1} y_j w_n^{-kj}.
$$

Порівнюючи її з формулою для $y_k$:

$$
y_k = \sum_{j=0}^{n-1} a_j w_n^{kj},
$$

ми помічаємо, що ці дві задачі майже нічим не відрізняються, тому коефіцієнти $a_k$ можна знайти таким же алгоритмом "розділяй і володарюй", як і для прямого ШПФ. Треба замість $w_n^k$ всюди використовувати $w_n^{-k}$, а кожний елемент результату потрібно розділити на $n$. Крім того, слід уникати використання російських слів та русизмів.

Таким чином, обчислення зворотної ДВП майже не відрізняється від обчислення прямої ДВП, і його також можна виконувати за час $O(n \log n)$.

## Реалізація

Розглянемо просту рекурсивну реалізацію ДПФ і зворотного ДПФ, реалізуємо їх у вигляді однієї функції, оскільки відмінності між прямим і зворотним ДПФ мінімальні. Для зберігання комплексних чисел скористаємось стандартним у C++ STL типом complex (визначеним у заголовочному файлі <complex>).

<!--- TODO: specify code snippet id -->
``` cpp
typedef complex<double> base;

void fft(vector<base> &a, bool invert) {
    int n = (int)a.size();
    if (n == 1)
        return;

    vector<base> a0(n / 2), a1(n / 2);
    for (int i = 0, j = 0; i < n; i += 2, ++j) {
        a0[j] = a[i];
        a1[j] = a[i + 1];
    }
    fft(a0, invert);
    fft(a1, invert);

    double ang = 2 * PI / n * (invert ? -1 : 1);
    base w(1), wn(cos(ang), sin(ang));
    for (int i = 0; i < n / 2; ++i) {
        a[i] = a0[i] + w * a1[i];
        a[i + n / 2] = a0[i] - w * a1[i];
        if (invert)
            a[i] /= 2, a[i + n / 2] /= 2;
        w *= wn;
    }
}
```

У аргумент $\rm a$ функції передається вхідний вектор коефіцієнтів, в якому буде міститися результат. Аргумент $\rm invert$ показує, чи потрібно обчислити пряме або зворотне ДПФ. Усередині функції спочатку перевіряється, чи довжина вектора $\rm a$ дорівнює одиниці. Якщо так, то нічого робити не потрібно, оскільки він сам є відповіддю. Інакше вектор $\rm a$ розділяється на два вектори $\rm a0$ і $\rm a1$, для яких рекурсивно обчислюється ДПФ. Потім обчислюється величина $w_n$, і створюється змінна $w$, що містить поточну ступінь $w_n$. Потім обчислюються елементи результативного ДПФ за вищезгаданими формулами.

Якщо задано прапорець $\rm invert = true$, то $w_n$ замінюється на $w_n^{-1}$, а кожен елемент результату ділиться на 2 (враховуючи, що ці ділення на 2 відбудуться в кожному рівні рекурсії, то в підсумку вийде, що всі елементи поділяться на $n$).

Отже, функція для **множення двох многочленів** буде виглядати наступним чином:

<!--- TODO: specify code snippet id -->
``` cpp
void multiply(const vector<int> &a, const vector<int> &b, vector<int> &res) {
    vector<base> fa(a.begin(), a.end()), fb(b.begin(), b.end());
    size_t n = 1;
    while (n < max(a.size(), b.size()))
        n <<= 1;
    n <<= 1;
    fa.resize(n), fb.resize(n);

    fft(fa, false), fft(fb, false);
    for (size_t i = 0; i < n; ++i)
        fa[i] *= fb[i];
    fft(fa, true);

    res.resize(n);
    for (size_t i = 0; i < n; ++i)
        res[i] = int(fa[i].real() + 0.5);
}
```

Ця функція працює з многочленами із цілими коефіцієнтами (хоча, зрозуміло, теоретично нічого не заважає їй працювати із дробовими коефіцієнтами). Однак тут проявляється проблема великої похибки при обчисленні ДПФ: похибка може виявитися значною, тому округлювати числа краще самостійно надійним способом - додатком 0.5 і наступним округленням вниз (**увага**: це буде працювати неправильно для від'ємних чисел, якщо такі можуть з'явитися у вашому застосуванні).

Нарешті, функція для **множення двох довгих чисел** практично нічим не відрізняється від функції для множення поліномів. Єдина особливість - після виконання множення чисел як поліномів потрібно нормалізувати результат, тобто виконати всі переноси розрядів:

<!--- TODO: specify code snippet id -->
``` cpp
int carry = 0;
for (size_t i = 0; i < n; ++i) {
    res[i] += carry;
    carry = res[i] / 10;
    res[i] %= 10;
}
```

(Оскільки довжина двох чисел ніколи не перевищує сумарної довжини чисел, то розміру вектора $\rm res$ достатньо для виконання всіх переносів).

## Покращена реалізація: обчислення "на місці" без додаткової пам'яті

Для підвищення ефективності відмовимось від рекурсії у явному вигляді. У наведеній вище рекурсивній реалізації ми явно розділяли вектор $\rm a$ на два підвектори - елементи на парних позиціях ми заносили до одного тимчасового вектора, а на непарних - до іншого. Однак, якщо б ми переупорядкували елементи певним чином, то необхідність у створенні тимчасових векторів відпала б (тобто всі обчислення ми могли б виконувати "на місці", безпосередньо в самому векторі $a$).

Зауважимо, що на першому рівні рекурсії елементи, молодші (перші) біти позицій яких дорівнюють нулю, належать до вектору $a_0$, а молодші біти позицій, які дорівнюють одиниці, - до вектору $a_1$. На іншому рівні рекурсії виконується те саме, але вже для других бітів і т.д. Тому якщо ми в позиції $i$ кожного елементу $a[i]$ інвертуємо порядок бітів і переупорядкуємо елементи масиву $a$ відповідно до нових індексів, то ми отримаємо шуканий порядок (він називається **порозрядно зворотною перестановкою** (bit-reversal permutation)).

Наприклад, для $n=8$ цей порядок має вигляд:

$$
a = \biggl\{ \Bigl[ (a_0,a_4), (a_2, a_6) \Bigr] , \Bigl[ (a_1, a_5), (a_3, a_7) \Bigr] \biggr\}.
$$

Дійсно, на першому рівні рекурсії (оточено фігурними дужками) звичайного рекурсивного алгоритму відбувається поділ вектора на дві частини: $[a_0,a_2,a_4,a_6]$ і $[a_1,a_3,a_5,a_7]$. Як ми бачимо, в розрядному зворотньому перестановуванні цьому відповідає просто поділ вектора на дві половинки: перші $n/2$ елементів і останні $n/2$ елементів. Потім відбувається рекурсивний виклик від кожної половинки; нехай результуюче ДПФ від кожної з них було повернуто на місце самі елементи (тобто в першій і другій половинах вектора $a$ відповідно):

$$
a = \biggl\{ \Bigl[ y_0^0,\ y_1^0,\ y_2^0,\ y_3^0 \Bigr], \Bigl[ y_0^1,\ y_1^1,\ y_2^1,\ y_3^1 \Bigr] \biggr\}.
$$

Тепер нам потрібно виконати об'єднання двох ДФТ в одну для всього вектора. Але елементи розташувалися так вдало, що об'єднання можна виконати прямо в цьому масиві. Дійсно, візьмемо елементи $y_0^0$ і $y_0^1$, застосуємо до них перетворення метелика і результат поставимо на їх місце - і це місце виявиться тим самим, що й мало б вийти

$$
a = \biggl\{ \Bigl[ y_0^0+w_n^0y_0^1,\ y_1^0,\ y_2^0,\ y_3^0 \Bigr], \Bigl[ y_0^0-w_n^0y_0^1,\ y_1^1,\ y_2^1,\ y_3^1 \Bigr] \biggr\}.
$$

Аналогічно застосовуємо перетворення метелики до $y_1^0$ та $y_1^1$ і результат ставимо на їх місце, і т.д. В результаті отримуємо:

$$
a = \biggl\{ \Bigl[ y_0^0+w_n^0y_0^1,\ y_1^0+w_n^1y_1^1,\ y_2^0+w_n^2y_2^1,\ y_3^0+w_n^3y_3^1 \Bigr],
$$

$$
~~~~~~~~ \Bigl[ y_0^0-w_n^0y_0^1,\ y_1^0-w_n^1y_1^1,\ y_2^0-w_n^2y_2^1,\ y_3^0-w_n^3y_3^1 \Bigr] \biggr\}.
$$

тобто, ми отримали саме шукану ДФТ від вектора $a$.

Ми описали процес обчислення ДПФ на першому рівні рекурсії. Однак зрозуміло, що ті ж самі міркування вірні і для всіх інших рівнів рекурсії. Таким чином, **після застосування порозрядної зворотної перестановки ДПФ можна обчислити на місці**, без залучення додаткових масивів.

Але тепер можна **позбутися рекурсії** в явному вигляді. Отже, ми застосували порозрядну зворотню перестановку елементів. Тепер виконаємо всю роботу, яку виконує нижній рівень рекурсії: вектор $a$ розділимо на пари елементів, для кожної застосуємо перетворення метелики, в результаті в векторі $a$ будуть результати роботи нижнього рівня рекурсії. На наступному кроці розділимо вектор $a$ на четвірки елементів, до кожної застосуємо перетворення метелики, в результаті отримаємо ДПФ для кожної четвірки. І так далі, нарешті, на останньому кроці ми, отримавши результати ДПФ для двох половинок вектора $a$, застосуємо до них перетворення метелики і отримаємо ДПФ для всього вектора $a$.

Отже, реалізація:

<!--- TODO: specify code snippet id -->
``` cpp
typedef complex<double> base;

int rev(int num, int lg_n) {
    int res = 0;
    for (int i = 0; i < lg_n; ++i)
        if (num & (1 << i))
            res |= 1 << (lg_n - 1 - i);
    return res;
}

void fft(vector<base> &a, bool invert) {
    int n = (int)a.size();
    int lg_n = 0;
    while ((1 << lg_n) < n)
        ++lg_n;

    for (int i = 0; i < n; ++i)
        if (i < rev(i, lg_n))
            swap(a[i], a[rev(i, lg_n)]);

    for (int len = 2; len <= n; len <<= 1) {
        double ang = 2 * PI / len * (invert ? -1 : 1);
        base wlen(cos(ang), sin(ang));
        for (int i = 0; i < n; i += len) {
            base w(1);
            for (int j = 0; j < len / 2; ++j) {
                base u = a[i + j], v = a[i + j + len / 2] * w;
                a[i + j] = u + v;
                a[i + j + len / 2] = u - v;
                w *= wlen;
            }
        }
    }
    if (invert)
        for (int i = 0; i < n; ++i)
            a[i] /= n;
}
```

На початку до вектора $a$ застосовується порозрядна зворотна перестановка. Для цього обчислюється кількість значущих бітів ($\rm lg\_n$) у числі $n$, і для кожної позиції $i$ знаходиться відповідна їй позиція, бітовий запис якої є бітовим записом числа $i$, записаного у зворотному порядку. Якщо отримана позиція виявляється більшою за $i$, то елементи в цих двох позиціях потрібно обміняти. Якщо ця умова не виконується, то кожна пара обмінюється двічі, і в результаті нічого не відбувається.

Потім виконується $\log n - 1$ стадій алгоритму, на $k$-й з яких ($k=2 \ldots \log n$) обчислюються ДПФ для блоків довжини $2^k$. Для всіх цих блоків буде одне й те ж значення первісного кореня $w_{2^k}$, яке запам'ятовується в змінній $\rm wlen$. Цикл по $i$ ітерується по блоках, а вкладений в нього цикл по $j$ застосовує перетворення метелика до всіх елементів блоку.

Можна виконати подальшу **оптимізацію реверсу бітів**. У попередній реалізації ми явно проходили по всім бітам числа, попутно будуючи поразрядно інвертоване число. Однак реверс бітів можна виконувати інакше.

Наприклад, нехай $j$ - вже підраховане число, рівне зворотній перестановці бітів числа $i$. Означає, що при переході до наступного числа $i+1$ ми повинні додати до числа $j$ одиницю, але додати її в такій "інвертованій" системі числення. У звичайній двійковій системі числення додавання одиниці означає видалення всіх одиниць, що стоять в кінці числа (тобто групу молодших одиниць), і перед ними поставити одиницю. Відповідно, в "інвертованій" системі ми повинні йти по бітах числа, починаючи зі старших, і поки там стоять одиниці, видаляти їх і переходити до наступного біту; коли ж зустріне перший нульовий біт, поставити в нього одиницю і зупинитися.

Отже, отримуємо таку реалізацію:

<!--- TODO: specify code snippet id -->
``` cpp
typedef complex<double> base;

void fft(vector<base> &a, bool invert) {
    int n = (int)a.size();

    for (int i = 1, j = 0; i < n; ++i) {
        int bit = n >> 1;
        for (; j >= bit; bit >>= 1)
            j -= bit;
        j += bit;
        if (i < j)
            swap(a[i], a[j]);
    }

    for (int len = 2; len <= n; len <<= 1) {
        double ang = 2 * PI / len * (invert ? -1 : 1);
        base wlen(cos(ang), sin(ang));
        for (int i = 0; i < n; i += len) {
            base w(1);
            for (int j = 0; j < len / 2; ++j) {
                base u = a[i + j], v = a[i + j + len / 2] * w;
                a[i + j] = u + v;
                a[i + j + len / 2] = u - v;
                w *= wlen;
            }
        }
    }
    if (invert)
        for (int i = 0; i < n; ++i)
            a[i] /= n;
}
```

## Додаткові оптимізації

Наведемо список інших оптимізацій, які в сукупності дозволяють помітно прискорити наведену вище "покращену" реалізацію:

* Предподсчитать реверс битов для всіх чисел у деякій глобальній таблиці. Особливо легко це робити, коли розмір $n$ при всіх викликах є однаковим.

Ця оптимізація стає помітною при великій кількості викликів $fft()$. Однак її ефект можна помітити навіть при трьох викликах (три виклики - найбільш поширена ситуація, коли потрібно один раз перемножити два поліноми).

* Відмовитися від використання $\rm vector$ (**перейти на звичайні масиви**).

Ефект від цього залежить від конкретного компілятора, проте зазвичай він присутній і становить приблизно 10%-20%.

* Підрахувати **всі степені** числа $wlen$. Насправді, в цьому циклі алгоритму раз за разом проходиться по всіх степенях числа $wlen$ від $0$ до $len/2-1$:

<!--- TODO: specify code snippet id -->
``` cpp
for (int i = 0; i < n; i += len) {
    base w(1);
    for (int j = 0; j < len / 2; ++j) {
        [...] w *= wlen;
    }
}
```

Відповідно, перед цим циклом ми можемо передпідрахувати в деякому масиві всі необхідні степені і таким чином позбутися зайвих множень у вкладеному циклі.

Орієнтоване прискорення - 5-10%.

* Позбутися **звернень до масивів за індексами**, використовувати замість цього вказівники на поточні елементи масивів, продвигаючи їх на 1 вправо на кожній ітерації.

На перший погляд, оптимізуючі компілятори повинні бути здатні самостійно справитися з цим завданням, проте на практиці виявляється, що заміна обробки масивів $a[i+j]$ і $a[i+j+len/2]$ на вказівники прискорює програму в поширених компіляторах. Виграш становить 5-10%.

* Відмовитися від стандартного типу комплексних чисел $\rm complex$, переписавши його на власну реалізацію.

Знову ж, це може здатися дивним, але навіть у сучасних компіляторах вигода від такого переписування може складати до декількох десятків відсотків! Це косвенно підтверджує розповсюджене твердження, що компілятори гірше справляються з шаблонними типами даних, оптимізуючи роботу з ними набагато гірше, ніж з нешаблонними типами.

* Інша корисна оптимізація полягає у **відсіченні за довжиною**: коли довжина робочого блоку стає маленькою (скажімо, 4), обчислювати ДПФ для нього "вручну". Якщо розписати ці випадки у вигляді явних формул при довжині, рівній $4/2$, то значення синусів-косинусів прийматимуть цілочисельні значення, завдяки чому можна отримати приріст швидкості ще на декілька десятків відсотків.

Наведемо тут реалізацію з описаними покращеннями (за винятком двох останніх пунктів, які призводять до надмірного зростання коду):

<!--- TODO: specify code snippet id -->
``` cpp
int rev[MAXN];
base wlen_pw[MAXN];

void fft(base a[], int n, bool invert) {
    for (int i = 0; i < n; ++i)
        if (i < rev[i])
            swap(a[i], a[rev[i]]);

    for (int len = 2; len <= n; len <<= 1) {
        double ang = 2 * PI / len * (invert ? -1 : +1);
        int len2 = len >> 1;

        base wlen(cos(ang), sin(ang));
        wlen_pw[0] = base(1, 0);
        for (int i = 1; i < len2; ++i)
            wlen_pw[i] = wlen_pw[i - 1] * wlen;

        for (int i = 0; i < n; i += len) {
            base t, *pu = a + i, *pv = a + i + len2, *pu_end = a + i + len2, *pw = wlen_pw;
            for (; pu != pu_end; ++pu, ++pv, ++pw) {
                t = *pv * *pw;
                *pv = *pu - t;
                *pu += t;
            }
        }
    }

    if (invert)
        for (int i = 0; i < n; ++i)
            a[i] /= n;
}

void calc_rev(int n, int log_n) {
    for (int i = 0; i < n; ++i) {
        rev[i] = 0;
        for (int j = 0; j < log_n; ++j)
            if (i & (1 << j))
                rev[i] |= 1 << (log_n - 1 - j);
    }
}
```

На поширених компіляторах ця реалізація працює швидше, ніж попередня "вдосконалена" версія, у 2-3 рази.

## Дискретне перетворення Фур'є в модульній арифметиці

В основі дискретного перетворення Фур'є лежать комплексні числа - корені $n$-ої степені з одиниці. Для ефективного обчислення використовуються такі особливості коренів, як існування $n$ різних коренів, які утворюють групу (тобто ступінь одного кореня завжди дає інший корінь; серед них є один елемент - генератор групи, званий примітивним коренем).

Але це ж саме вірно і щодо коренів $n$-го степеня з одиниці в модульній арифметиці. Точніше, не для будь-якого модуля $p$ знайдеться $n$ різних коренів з одиниці, проте такі модулі все ж існують. Як і раніше, нам важливо знайти серед них примітивний корінь

$$
(w_n)^n = 1 \pmod p,
$$

$$
(w_n)^k \ne 1 {\pmod p}, ~~~~~1 \le k < n.
$$

Усі інші $n-1$ корені $n$-го степеня з одиниці за модулем $p$ можна отримати як степені примітивного кореня $w_n$ (як і в комплексному випадку).

Для застосування в алгоритмі Швидкого перетворення Фур'є нам потрібно, щоб примітивний корінь існував для деякого $n$, який є степенем двійки, а також для всіх менших степенів. І, якщо в комплексному випадку примітивний корінь існує для будь-якого $n$, то в випадку модульної арифметики це, загалом кажучи, не так. Однак, зауважимо, що якщо $n=2^k$, тобто $n$ є $k$-тою степенем двійки, то за модулем $m=2^{k-1}$ маємо:

$$
(w_n^2)^m = (w_n)^n = 1 \pmod p,
$$

$$
(w_n^2)^k = w_n^{2k} \ne 1 {\pmod p}, ~~~~~1 \le k < m.
$$

Таким чином, якщо $w_n$ є примітивним коренем $n=2^k$-ої степені з одиниці, то $w_n^2$ є примітивним коренем $2^{k-1}$-ої степені з одиниці. Отже, для всіх степенів двійки, менших за $n$, примітивні корені потрібної степені також існують і можуть бути обчислені як відповідні степені $w_n$.

Останній штрих - для зворотнього ДПФ ми використовували замість $w_n$ його зворотний елемент: $w_n^{-1}$. Але при модулю $p$ зворотний елемент також завжди існує.

Таким чином, всі необхідні нам властивості зберігаються в випадку модульної арифметики, за умови, що ми вибрали достатньо великий модуль $p$ та знайшли в ньому примітивний корінь $n$-го степеня з одиниці.

Наприклад, можна взяти такі значення: модуль $p = 7340033$, $w_{2^{20}} = 5$. Якщо цього модуля буде недостатньо, для знаходження іншої пари можна скористатися тим фактом, що для модулів у вигляді $c 2^k + 1$ (але як і раніше обов'язково простих) завжди знайдеться примітивний корінь степені $2^k$ з одиниці.

<!--- TODO: specify code snippet id -->
``` cpp
const int mod = 7340033;
const int root = 5;
const int root_1 = 4404020;
const int root_pw = 1 << 20;

void fft(vector<int> &a, bool invert) {
    int n = (int)a.size();

    for (int i = 1, j = 0; i < n; ++i) {
        int bit = n >> 1;
        for (; j >= bit; bit >>= 1)
            j -= bit;
        j += bit;
        if (i < j)
            swap(a[i], a[j]);
    }

    for (int len = 2; len <= n; len <<= 1) {
        int wlen = invert ? root_1 : root;
        for (int i = len; i < root_pw; i <<= 1)
            wlen = int(wlen * 1ll * wlen % mod);
        for (int i = 0; i < n; i += len) {
            int w = 1;
            for (int j = 0; j < len / 2; ++j) {
                int u = a[i + j], v = int(a[i + j + len / 2] * 1ll * w % mod);
                a[i + j] = u + v < mod ? u + v : u + v - mod;
                a[i + j + len / 2] = u - v >= 0 ? u - v : u - v + mod;
                w = int(w * 1ll * wlen % mod);
            }
        }
    }
    if (invert) {
        int nrev = reverse(n, mod);
        for (int i = 0; i < n; ++i)
            a[i] = int(a[i] * 1ll * nrev % mod);
    }
}
```

Тут функція $\rm reverse$ знаходить зворотний елемент до $n$ за модулем $\rm mod$ (див. [Обернений елемент в полі за модулем](reverse_element)). Константи $\rm mod$, $\rm root$ та $\rm root\_pw$ визначають модуль і примітивний корінь, а $\rm root\_1$ - зворотний до $\rm root$ елемент за модулем $\rm mod$.

Як показує практика, реалізація цілочисельного ДПФ працює навіть повільніше, ніж реалізація з комплексними числами (через велику кількість операцій взяття за модулем), проте вона має такі переваги, як менше використання пам'яті та відсутність похибок округлення.

## Деякі застосування

Крім безпосереднього застосування для множення многочленів або довгих чисел, опишемо тут деякі інші застосування дискретного перетворення Фур'є.

### Усі можливі суми

Задача: дані два масиви $a[]$ і $b[]$. Потрібно знайти всі числа виду $a[i]+b[j]$, і для кожного такого числа вивести кількість способів його отримання.

Наприклад, для $a = (1,2,3)$ та $b = (2,4)$ отримуємо: число 3 можна отримати 1 способом, 4 - також одним, 5 - 2, 6 - 1, 7 - 1.

Побудуємо за масивами $a$ і $b$ два багаточлени $A$ і $B$. В якості степенів у многочлені будуть виступати самі числа, тобто значення $a[i]$ ($b[i]$), а в якості коефіцієнтів при них - скільки разів це число зустрічається в масиві $a$ ($b$).

Значить, помноживши ці два поліноми за $O(n \log n)$, ми отримаємо поліном $C$, де в якості степенів будуть різні числа у вигляді $a[i]+b[j]$, а коефіцієнти при них будуть шуканими кількостями

### Усі можливі скалярні добутки

Дано два масиви $a[]$ і $b[]$ однакової довжини $n$. Потрібно вивести значення кожного скалярного добутку вектора $a$ на черговий циклічний зсув вектора $b$.

Інвертуємо масив $a$ і додаємо до нього в кінець $n$ нулів, а до масиву $b$ - просто додаємо самого себе. Потім перемножуємо їх як многочлени. Тепер розглядаємо коефіцієнти творів $c[n \ldots 2n-1]$ (як завжди, всі індекси в 0-індексації). Маємо:

$$
c[k] = \sum_{i+j=k} a[i] b[j].
$$

Оскільки всі елементи $a[i]=0$ для $i=n \ldots 2n-1$, то ми отримуємо:

$$
c[k] = \sum_{i=0}^{n-1} a[i] b[k-i].
$$

Неважко побачити в цій сумі, що це саме скалярний добуток вектора $a$ на $k-n-1$-ий циклічний зсув. Таким чином, ці коефіцієнти (починаючи з $n-1$-го і закінчуючи $2n-2$-м) - є відповіддю на задачу.

Розв'язок має складність $O(n \log n)$.

### Две смужки

Дано дві стрічки, задані як два булевих (тобто числових зі значеннями 0 або 1) масиви $a[]$ і $b[]$. Потрібно знайти всі такі позиції на першій стрічці, що якщо прикласти, починаючи з цієї позиції, одну стрічку, то ні в якому місці не вийде значення $\rm true$ на обох стрічках. Цю задачу можна переформулювати таким чином: дана карта стрічки, в вигляді 0/1 - можна вставляти в цю клітинку або ні, і дана деяка фігурка в вигляді шаблону (в вигляді масиву, в якому 0 - немає клітини, 1 - є), потрібно знайти всі позиції в стрічці, до яких можна прикласти фігурку.

Ця задача фактично нічим не відрізняється від попередньої задачі про скалярний добуток. Дійсно, скалярний добуток двох 0/1 масивів - це кількість елементів, в яких одночасно виявилися одиниці. Наша задача полягає в тому, щоб знайти всі циклічні зрушення другого масиву так, щоб не знайшлося жодного елемента, в якому б в обох масивах одночасно виявилися одиниці. Тобто ми повинні знайти всі циклічні зрушення іншого масиву, при яких скалярний добуток дорівнює нулю.

Таким чином, ми вирішили цю задачу за $O(n \log n)$.