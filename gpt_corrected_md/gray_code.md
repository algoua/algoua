# Код Грея

## Визначення

Кодом Грея називається система нумерації невід'ємних чисел, у якій коди двох сусідніх чисел відрізняються у рівно одному біті.

Наприклад, для чисел довжини 3 біти маємо таку послідовність кодів Грея: $000$, $001$, $011$, $010$, $110$, $111$, $101$, $100$. Наприклад, $G(3)=6$.

Цей код був винайдений Френком Греєм (Frank Gray) у 1953 році.

## Знаходження коду Грея

Розглянемо біти числа $n$ та біти числа $G(n)$. Зауважимо, що $i$-ий біт $G(n)$ дорівнює одиниці тільки тоді, коли $i$-ий біт $n$ дорівнює одиниці, а $i+1$-ий біт дорівнює нулю, або навпаки ($i$-ий біт дорівнює нулю, а $i+1$-ий біт дорівнює одиниці). Таким чином, маємо: $G(n) = n \oplus (n>>1)$

<!--- TODO: specify code snippet id -->
``` cpp
int g(int n) { return n ^ (n >> 1); }
```

## Знаходження зворотнього коду Грея

Потрібно відновити вихідне число $n$ за кодом Грея $g$.

Будемо йти від старших бітів до молодших (нехай самий молодший біт має номер 1, а самий старший - $k$). Отримуємо такі співвідношення між бітами $n_i$ числа $n$ і бітами $g_i$ числа $g$:

$$
n_k = g_k,
$$

$$
n_{k-1} = g_{k-1} \oplus n_k = g_k \oplus g_{k-1},
$$

$$
n_{k-2} = g_{k-2} \oplus n_{k-1} = g_k \oplus g_{k-1} \oplus g_{k-2},
$$

$$
n_{k-3} = g_{k-3} \oplus n_{k-2} = g_k \oplus g_{k-1} \oplus g_{k-2} \oplus g_{k-3},
$$

$$
\ldots
$$

У вигляді програмного коду це найпростіше записати так:

<!--- TODO: specify code snippet id -->
``` cpp
int rev_g(int g) {
    int n = 0;
    for (; g; g >>= 1)
        n ^= g;
    return n;
}
```

## Застосування

Коди Грея мають кілька застосувань у різних областях, іноді досить неочікуваних:

* $n$-бітний код Грея відповідає гамільтоновому циклу по $n$-вимірному кубу.

* У техніці коди Грея використовуються для **мінімізації помилок** при перетворенні аналогових сигналів в цифрові (наприклад, у датчиках). Зокрема, коди Грея були розроблені саме для цього застосування.

* Коди Грея використовуються для вирішення задачі про **Ханойські вежі**.

Нехай $n$ - кількість дисків. Почнемо з коду Грея довжини $n$, що складається з одиниць (тобто $G(0)$), і будемо рухатися по кодах Грея (від $G(i)$ переходити до $G(i+1)$). Поставимо в відповідність кожному $i$-му біту поточного коду Грея $i$-й диск (причому самому молодшому біту відповідає найменший за розміром диск, а самому старшому біту - найбільший). Оскільки на кожному кроці змінюється рівно один біт, то ми можемо розуміти зміну біту $i$ як переміщення $i$-го диска. Зауважимо, що для всіх дисків, крім найменшого, на кожному кроці є рівно один варіант ходу (за винятком стартової і кінцевої позицій). Для найменшого диска завжди є два варіанти ходу, але є стратегія вибору ходу, що завжди приводить до правильної відповіді: якщо $n$ непарне, то послідовність переміщень найменшого диска має вигляд $f \rightarrow t \rightarrow r \rightarrow f \rightarrow t \rightarrow r \rightarrow \ldots$ (де $f$ - стартовий стовпчик, $t$ - кінцевий стовпчик, $r$ - залишився стовпчик), а якщо $n$ парне, то $f \rightarrow r \rightarrow t \rightarrow f \rightarrow r \rightarrow t \rightarrow \ldots$.

* Коди Грея також знаходять застосування в теорії **генетичних алгоритмів**.

## Завдання в онлайн-суддях

Список задач, які можна здати, використовуючи коди Грея:

TODO