# Найменший загальний предок. Знаходження за O(log N) (метод двійкового піднесення)

Нехай задано дерево G. На вхід надходять запити уваги (V1, V2). Для кожного запиту потрібно знайти їх найменшого загального предка, тобто вершину V, яка лежить на шляху від кореня до V1, на шляху від кореня до V2, і з усіх таких вершин потрібно вибирати найнижчу. Іншими словами, шукана вершина V - предок і V1, і V2, і серед усіх таких загальних предків потрібно вибрати найнижчу. Очевидно, що найменший загальний предок вершин V1 і V2 - це їх загальний предок, що лежить на найкоротшому шляху з V1 до V2. Зокрема, якщо V1 є предком V2, то V1 є їх найменшим загальним предком.

На англійській ця задача називається задачею LCA - Lowest Common Ancestor.

Тут буде розглянуто алгоритм, який пишеться набагато швидше, ніж описаний [тут](lca).

Асимптотика отриманого алгоритму буде такою: попереднє оброблення за **O(N log N)** і відповідь на кожен запит за **O(log N)**.

## Алгоритм

Підрахуємо для кожної вершини її першого предка, другого предка, четвертого і так далі. Позначимо цей масив як P, тобто P[i][j] - це 2<sup>j</sup>-й предок вершини i, де i = 1..N, j = 0..&lceil;logN&rceil;. Для кожної вершини також знайдемо час заходу та виходу під час пошуку в глибину (див. ["Пошук в глибину"](dfs)). Це нам знадобиться, щоб визначати за O(1), чи є одна вершина предком іншої (не обов'язково безпосередньою). Такий попередній обрахунок можна виконати за **O(N log N)**.

Нехай зараз надійшов черговий запит - пара вершин (A,B). Відразу перевіримо, чи одна вершина не є предком іншої - у такому випадку вона і є результатом. Якщо A не є предком B, і B не є предком A, то будемо підніматися по предкам A, поки не знайдемо найвищу вершину (тобто найбільш близьку до кореня), яка ще не є предком (не обов'язково безпосередньо) B (тобто таку вершину X, що X не є предком B, а P[X][0] - предок B). При цьому знаходити цю вершину X будемо за O(log N), використовуючи масив P.

Опишемо цей процес детальніше. Нехай L = &lceil;logN&rceil;. Спочатку нехай I = L. Якщо P[A][I] не є батьківською вершиною B, то присвоюємо A = P[A][I] і зменшуємо I. Якщо ж P[A][I] є батьківською вершиною B, то просто зменшуємо I. Очевидно, що коли I стане менше за нуль, вершина A буде шуканою вершиною - тобто такою, що A не є батьківською вершиною B, але P[A][0] - батьківська вершина B.

Тепер, очевидно, відповіддю на LCA буде P[A][0] - тобто найменша вершина серед предків вихідної вершини A, яка є також предком B.

Асимптотика. Весь алгоритм відповіді на запит складається зі зміни I від L = &lceil;logN&rceil; до 0, а також перевірки на кожному кроці, чи є одна вершина предка іншої, за O(1). Отже, на кожний запит буде знайдена відповідь за O(log N).

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
int n, l;
vector<vector<int>> g;
vector<int> tin, tout;
int timer;
vector<vector<int>> up;

void dfs(int v, int p = 0) {
    tin[v] = ++timer;
    up[v][0] = p;
    for (int i = 1; i <= l; ++i)
        up[v][i] = up[up[v][i - 1]][i - 1];
    for (size_t i = 0; i < g[v].size(); ++i) {
        int to = g[v][i];
        if (to != p)
            dfs(to, v);
    }
    tout[v] = ++timer;
}

bool upper(int a, int b) { return tin[a] <= tin[b] && tout[a] >= tout[b]; }

int lca(int a, int b) {
    if (upper(a, b))
        return a;
    if (upper(b, a))
        return b;
    for (int i = l; i >= 0; --i)
        if (!upper(up[a][i], b))
            a = up[a][i];
    return up[a][0];
}

int main() {
...читання "ен" і "ґе"...

        tin.resize(n),
        tout.resize(n), up.resize(n);
    l = 1;
    while ((1 << l) <= n)
        ++l;
    for (int i = 0; i < n; ++i)
        up[i].resize(l + 1);
    dfs(0);

    for (;;) {
int a, b; // Поточний запит
int res = знайдено_спільного_предка(a, b); // відповідь на запит
    }
}
```