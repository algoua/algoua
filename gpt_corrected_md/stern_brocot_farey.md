# Дерево Штерна-Броко. Ряд Фарея

## Дерево Штерна-Броко

Дерево Штерна-Броко - це витончена конструкція, що дозволяє побудувати множину всіх додатних дробів. Вона була незалежно відкрита німецьким математиком Моріцем Штерном (Moritz Stern) у 1858 році та французьким годинниковим майстром Ахіллом Броко (Achille Brocot) у 1861 році. Однак, за деякими даними, ця конструкція була відкрита ще давньогрецьким вченим Ератосфеном (Eratosthenes).

На **нульовій** ітерації у нас є дві дроби:

$$
\frac{0}{1}, \frac{1}{0}
$$

Друга величина, строго кажучи, не є дробом; її можна розуміти як нескінченність, що не можна скоротити до дробу

Далі, на кожній **наступній** ітерації береться цей список дробів і між кожними двома сусідніми дробами $\frac{a}{b}$ і $\frac{c}{d}$ вставляється їх **медіана**, тобто дріб $\frac{a+c}{b+d}$.

Так, на першій ітерації поточний множину буде таким:

$$
\frac{0}{1}, \frac{1}{1}, \frac{1}{0}
$$

На другий день:

$$
\frac{0}{1}, \frac{1}{2}, \frac{1}{1}, \frac{2}{1}, \frac{1}{0}
$$

На третій:

$$
\frac{0}{1}, \frac{1}{3}, \frac{1}{2}, \frac{2}{3}, \frac{1}{1}, \frac{3}{2}, \frac{2}{1}, \frac{3}{1}, \frac{1}{0}
$$

Продовжуючи цей процес до **нескінченності**, затверджується, що можна отримати множину **всіх** невід'ємних дробів. Більше того, всі отримані дроби будуть **різними** (тобто в поточній множині кожна дріб зустрічається не більше одного разу), **нескорочуваними** (чисельники і знаменники будуть взаємно простими). Нарешті, всі дроби будуть автоматично **упорядковані** за зростанням. Доведення всіх цих чудових властивостей дерева Штерна-Броко буде наведено трохи нижче.

Залишилося лише намалювати зображення дерева Штерна-Броко (поки ми описували його з допомогою змінюваної множини). У корені цього нескінченного дерева знаходиться дріб $\frac{1}{1}$, а ліворуч і праворуч від дерева знаходяться дроби $\frac{0}{1}$ і $\frac{1}{0}$. Будь-яка вершина дерева має двох синів, кожний з яких є медіантою свого лівого предка і правого предка:

\img{stern_brocot.jpg}

### Доведення

Упорядкованість. Вона доводиться дуже просто: зауважимо, що медіани двох дробів завжди знаходяться між ними, тобто:

$$
\frac{a}{b} \le \frac{a+c}{b+d} \le \frac{c}{d}
$$

за умови, що

$$
\frac{a}{b} \le \frac{c}{d}
$$

Доводиться це просто приведенням трьох дробів до загального знаменника.

Оскільки на нульовій ітерації мала місце упорядкованість, вона буде зберігатися на кожній наступній ітерації.

**Нескорочуваність**. Для цього покажемо, що на будь-якій ітерації для будь-яких двох сусідніх у списку дробів $\frac{a}{b}$ і $\frac{c}{d}$ виконується:

$$
bc-ad=1
$$

Дійсно, згадуючи [Діофантові рівняння з двома невідомими ($ax+by=c$)](diofant_2_equation), отримуємо з цього твердження, що ${\rm НСД}(a,b) = {\rm НСД}(c,d) = 1$, що нам і потрібно.

Отже, нам потрібно довести істинність твердження $bc-ad=1$ на будь-якій ітерації. Доведемо його також за допомогою індукції. На нульовій ітерації ця властивість виконувалася (в чому нескладно переконатися). Тепер нехай вона виконується на попередній ітерації, покажемо, що вона виконується на поточній ітерації. Для цього потрібно розглянути трійку дробів-сусідів у новому списку:

$$
\frac{a}{b}, \frac{a+c}{b+d}, \frac{c}{d}
$$

Для них умови мають вигляд:

$$
b(a+c) - a(b+d) = 1,
$$

$$
c(b+d) - d(a+c) = 1
$$

Однак, правильність цих умов очевидна за умови правильності $bc-ad=1$. Таким чином, дійсно, ця властивість виконується на поточній ітерації, що і потрібно довести.

Наявність всіх дробів. Доведення цієї властивості тісно пов'язане з алгоритмом знаходження дробу в дереві Штерна-Броко. З урахуванням того, що в дереві Штерна-Броко всі дроби впорядковані, отримуємо, що для будь-якої вершини дерева в її лівому піддереві знаходяться дроби, менші за неї, а в правому - більші за неї. Звідси отримуємо і очевидний алгоритм пошуку якого-небудь дробу в дереві Штерна-Броко: на початку ми знаходимося в корені; порівнюємо наш дріб з дробом, записаним в поточній вершині: якщо наш дріб менший, то переходимо в ліве піддерево, якщо наш дріб більший - переходимо в праве, а якщо збігається - знайшли дріб, пошук завершено.

Щоб довести, що нескінченне дерево Штерна-Броко містить всі дроби, достатньо показати, що цей алгоритм пошуку дроби завершиться за кінцеву кількість кроків для будь-якої заданої дробі. Цей алгоритм можна розуміти так: у нас є поточний відрізок $\left[ \frac{a}{b}; \frac{c}{d} \right]$, в якому ми шукаємо нашу дріб $\frac{x}{y}$. Спочатку $\frac{a}{b}=\frac{0}{1}$, $\frac{c}{d}=\frac{1}{0}$. На кожному кроці дріб $\frac{x}{y}$ порівнюється з медіаною кінців відрізку, тобто з $\frac{a+c}{b+d}$, і в залежності від цього ми або зупиняємо пошук, або переходимо в ліву або праву частину відрізку. Якщо б алгоритм пошуку дробі працював нескінченно довго, то наступні умови були б виконані на кожній ітерації:

$$
\frac{a}{b} < \frac{x}{y} < \frac{c}{d}
$$

Але їх можна переписати у такому вигляді:

$$
bx-ay \ge 1,
$$

$$
cy-dx \ge 1
$$

(Тут використовується те, що вони цілочисельні, тому з $>0$ випливає $\ge 1$)

Значить, множачи перший на $c+d$, а другий - на $a+b$, і додаючи їх, отримуємо:

$$
(c+d)(bx-ay) + (a+b)(cy-dx) \ge a+b+c+d
$$

Розкриваючи дужки ліворуч і враховуючи, що $bс-аd=1$ (див. доведення попередньої властивості), отримуємо:

$$
x+y \ge a+b+c+d
$$

І оскільки на кожній ітерації хоча б одна змінна $a, b, c, d$ строго зростає, то процес пошуку дробу $\frac{x}{y}$ буде містити не більше $x+y$ ітерацій, що і потрібно довести.

### Алгоритм побудови дерева

Щоб побудувати будь-яке піддерево дерева Штерна-Броко, достатньо знати тільки лівого і правого батьків. Спочатку, на першому рівні, лівим батьком є $\frac{0}{1}$, а правим - $\frac{1}{0}$. За ним можна обчислити дріб у поточній вершині, а потім запуститися від лівого і правого синів (лівому сину передається собі в якості правого батька, а правому сину - в якості лівого батька).

Псевдокод цій процедуры, пытающийся побудувати усе нескінченне дерево:

<!--- TODO: specify code snippet id -->
``` cpp
void build(int a = 0, int b = 1, int c = 1, int d = 0, int level = 1) {
    int x = a + c, y = b + d;
...висновок поточної дробу x/y на рівні дерева level: build(a, b, x, y, level+1);
    build(x, y, c, d, level + 1);
}
```

### Алгоритм пошуку дроби

Алгоритм пошуку дробу вже був описаний при доведенні того, що дерево Штерна-Броко містить всі дроби. Повторимо його тут. Цей алгоритм фактично є алгоритмом бінарного пошуку або пошуку заданого значення в бінарному дереві пошуку. Спочатку ми стоїмо в корені дерева. Стоячи в поточній вершині, порівнюємо наш дріб з дробом у поточній вершині. Якщо вони збігаються, то процес зупиняється, оскільки ми знайшли дріб у дереві. Інакше, якщо наш дріб менший за дріб у поточній вершині, ми переходимо до лівого сина, інакше - до правого.

Як було доведено в твердженні про те, що дерево Штерна-Броко містить всі невід'ємні дроби, під час пошуку дробу $\frac{x}{y}$ алгоритм здійснить не більше $x+y$ ітерацій.

Наведемо реалізацію, яка повертає шлях до вершини, що містить задану дріб $\frac{x}{y}$, у вигляді послідовності символів 'L'/'R': якщо поточний символ дорівнює 'L', то це позначає перехід в дереві до лівого сина, а інакше - до правого (спочатку ми стоїмо в корені дерева, тобто в вершині з дробом $\frac{1}{1}$). Насправді, така послідовність символів, яка існує і однозначно визначає будь-яку не від'ємну дріб, називається **системою числення Штерна-Броко**.

<!--- TODO: specify code snippet id -->
``` cpp
string find(int x, int y, int a = 0, int b = 1, int c = 1, int d = 0) {
    int m = a + c, n = b + d;
    if (x == m && y == n)
        return "";
    if (x * n < y * m)
        return 'L' + find(x, y, a, b, m, n);
    else
        return 'R' + find(x, y, m, n, c, d);
}
```

Ірраціональні числа в системі числення Штерна-Броко будуть відповідати нескінченним послідовностям символів; якщо відома якась наперед задана точність, то можна обмежитися деяким префіксом цієї нескінченної послідовності. Під час цього нескінченного пошуку ірраціональної дробу в дереві Штерна-Броко алгоритм кожного разу знаходитиме просту дріб (з поступово зростаючими знаменниками), що забезпечить краще наближення цього ірраціонального числа (це застосування саме те, що важливо в годинній техніці, і тому Ахілл Броко відкрив це дерево).

## Послідовність Фарея

Послідовністю Фарея порядку $n$ називається множина всіх нескорочуваних дробів між 0 і 1, знаменники яких не перевищують $n$, причому дроби впорядковані в порядку зростання.

Ця послідовність названа на честь англійського геолога Джона Фарея (John Farey), який у 1816 році намагався довести, що в ряді Фарея будь-який дріб є медіаною двох сусідніх. Наскільки відомо, його доведення було невірним, а правильне доведення запропонував декілька пізніше Коші (Cauchy). Однак ще у 1802 році математик Харос (Haros) у одній зі своїх робіт прийшов практично до тих самих результатів.

Послідовності Фарея мають безліч цікавих властивостей, однак найбільш очевидний їх зв'язок з деревом Штерна-Броко: фактично, послідовність Фарея можна отримати, видаливши деякі гілки з дерева. Або можна сказати, що для отримання послідовності Фарея потрібно взяти множину дробів, що отримується при будівництві дерева Штерна-Броко за нескінченної ітерації, і залишити в цій множині лише дроби зі знаменниками, не перевищуючими $n$, і чисельниками, не перевищуючими знаменників.

З алгоритму побудови дерева Штерна-Броко випливає і аналогічний алгоритм для послідовностей Фарея. На нульовій ітерації включаємо до множини тільки дроби $\frac{0}{1}$ і $\frac{1}{1}$. На кожній наступній ітерації ми між кожними двома сусідніми дробами вставляємо їх медіанту, якщо її знаменник не перевищує $n$. Рано або пізно в множині перестануть відбуватися які-небудь зміни, і процес можна зупинити - ми знайшли шукану послідовність Фарея.

Обчислимо довжину послідовності Фарея. Послідовність Фарея порядку $n$ містить всі елементи послідовності Фарея порядку $n-1$, а також всі нескорочувані дроби зі знаменниками, рівними $n$, але ця кількість, як відомо, дорівнює $\phi(n)$. Таким чином, довжина $L_n$ послідовності Фарея порядку $n$ виражається за формулою:

$$
L_n = L_{n-1} + \phi(n)
$$

або, розгортаючи рекурсію:

$$
L_n = 1 + \sum_{k=1}^n \phi(k)
$$

## Література

* \book{Рональд Греєм, Дональд Кнут, Орен Паташник}{Конкретна математика. Основа інформатики}{1998}{graham.djvu}