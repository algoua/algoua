# Задача про призначення. Розв'язок з допомогою мінімального потоку з мінімальною вартістю

Задача має дві еквівалентні постановки:

* Дана квадратна матриця $A[1..N,1..N]$. Потрібно вибрати в ній $N$ елементів так, щоб в кожній стрічці та стовпці був обраний рівно один елемент, а сума значень цих елементів була найменшою.
* Є $N$ замовлень і $N$ верстатів. Про кожне замовлення відома вартість його виготовлення на кожному верстаті. На кожному верстаті можна виконувати тільки одне замовлення. Потрібно розподілити всі замовлення по верстатах так, щоб мінімізувати загальну вартість.

Тут ми розглянемо розв'язок задачі про призначення на основі алгоритму [знаходження потоку мінімальної вартості (min-cost-flow)](min_cost_flow) за **O(N^5)**.

## Опис

Побудуємо двудольну мережу: є джерело S, стік T, в першій частині знаходяться N вершин (відповідні рядкам матриці або замовленням), у другій - також N вершин (відповідні стовпцям матриці або станкам). Між кожною вершиною i першої частини і кожною вершиною j другої частини проведемо ребро з пропускною здатністю 1 і вартістю A<sub>ij</sub>. Від джерела S проведемо ребра до всіх вершин i першої частини з пропускною здатністю 1 і вартістю 0. Від кожної вершини другої частини j до стоку T проведемо ребро з пропускною здатністю 1 і вартістю 0.

Знайдемо в отриманій мережі максимальний потік мінімальної вартості. Очевидно, що величина потоку буде дорівнювати N. Далі, для кожної вершини i з першої частини знайдеться рівно одна вершина j з другої частини, така, що потік F<sub>ij</sub> = 1. Нарешті, ця взаємно однозначна відповідність між вершинами першої частини і вершинами другої частини є розв'язком задачі (оскільки знайдений потік має мінімальну вартість, то сума вартостей обраних ребер буде найменшою з можливих, що і є критерієм оптимальності).

Асимптотика цього розв'язку задачі про призначення залежить від того, яким алгоритмом виконується пошук максимального потоку мінімальної вартості. Асимптотика складе **O(N<sup>3</sup>)** при використанні алгоритму Флойда-Уоршелла або **O(N<sup>4</sup>)** при використанні алгоритму Форда-Фалкерсона. Русизми були виправлені на українські слова.

## Реалізація

Наведена тут реалізація довга, можливо, її можна значно скоротити.

<!--- TODO: specify code snippet id -->
``` cpp
typedef vector<int> vint;
typedef vector<vint> vvint;

const int INF = 1000 * 1000 * 1000;

int main() {
    int n;
    vvint a(n, vint(n));
    ... читання a...

        int m = n * 2 + 2;
    vvint f(m, vint(m));
    int s = m - 2, t = m - 1;
    int cost = 0;
    for (;;) {
        vector<int> dist(m, INF);
        vector<int> p(m);
        vector<int> type(m, 2);
        deque<int> q;
        dist[s] = 0;
        p[s] = -1;
        type[s] = 1;
        q.push_back(s);
        for (; !q.empty();) {
            int v = q.front();
            q.pop_front();
            type[v] = 0;
            if (v == s) {
                for (int i = 0; i < n; ++i)
                    if (f[s][i] == 0) {
                        dist[i] = 0;
                        p[i] = s;
                        type[i] = 1;
                        q.push_back(i);
                    }
            } else {
                if (v < n) {
                    for (int j = n; j < n + n; ++j)
                        if (f[v][j] < 1 && dist[j] > dist[v] + a[v][j - n]) {
                            dist[j] = dist[v] + a[v][j - n];
                            p[j] = v;
                            if (type[j] == 0)
                                q.push_front(j);
                            else if (type[j] == 2)
                                q.push_back(j);
                            type[j] = 1;
                        }
                } else {
                    for (int j = 0; j < n; ++j)
                        if (f[v][j] < 0 && dist[j] > dist[v] - a[j][v - n]) {
                            dist[j] = dist[v] - a[j][v - n];
                            p[j] = v;
                            if (type[j] == 0)
                                q.push_front(j);
                            else if (type[j] == 2)
                                q.push_back(j);
                            type[j] = 1;
                        }
                }
            }
        }

        int curcost = INF;
        for (int i = n; i < n + n; ++i)
            if (f[i][t] == 0 && dist[i] < curcost) {
                curcost = dist[i];
                p[t] = i;
            }
        if (curcost == INF)
            break;
        cost += curcost;
        for (int cur = t; cur != -1; cur = p[cur]) {
            int prev = p[cur];
            if (prev != -1)
                f[cur][prev] = -(f[prev][cur] = 1);
        }
    }

    printf("%d\n", cost);
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            if (f[i][j + n] == 1)
                printf("%d ", j + 1);
}
```