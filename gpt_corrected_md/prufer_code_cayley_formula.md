# Код Прюфера. Формула Келі. Кількість способів зробити граф зв'язним

У даній статті ми розглянемо так званий **код Прюфера**, який є способом однозначного кодування позначеного дерева за допомогою послідовності чисел.

За допомогою кодів Прюфера демонструється доведення **формули Келі**, яка задає кількість остовних дерев у повному графі. Також розв'язується задача про кількість способів додати ребра до заданого графа, щоб перетворити його на зв'язний.

Зауваження. Ми не будемо розглядати дерева, які складаються з єдиної вершини, - це особливий випадок, на якому багато тверджень вироджуються.

## Код Прюфера

Код Прюфера - це спосіб взаємно однозначного кодування помічених дерев з $n$ вершинами за допомогою послідовності $n-2$ цілих чисел у відрізку $[1;n]$ . Іншими словами, код Прюфера - це **взаємно однозначне відображення** між усіма остовними деревами повного графа та числовими послідовностями. Також слід замінити "остовные деревья" на "остовні дерева".

Хоча використання коду Прюфера для зберігання та операцій з деревами є недоцільним через специфічність представлення, коди Прюфера знаходять застосування у розв'язанні комбінаторних задач.

Автор - Гайнц Прюфер - запропонував цей код у 1918 році як доведення формули Келі (див. нижче).

### Побудова коду Прюфера для даного дерева

Код Прюфера будується наступним чином. Будемо $n-2$ рази проводити процедуру: вибираємо лист дерева з найменшим номером, видаляємо його з дерева та додаємо до коду Прюфера номер вершини, яка була пов'язана з цим листком. В кінці в дереві залишиться тільки $2$ вершини, і алгоритм на цьому завершується (номери цих вершин явним чином в коді не записуються).

Таким чином, код Прюфера для заданого дерева є послідовністю з $n-2$ чисел, де кожне число є номером вершини, пов'язаної з найменшим на той момент листком. Іншими словами, це число знаходиться в інтервалі $[1;n]$. Треба уникати використання російських слів та русизмів українській мові.

Алгоритм обчислення коду Прюфера легко реалізувати з асимптотикою $O(n \log n)$, просто підтримуючи структуру даних для вилучення мінімуму (наприклад, $\rm set<>$ або $\rm priority\_queue<>$ в мові C++), що містить у собі список всіх поточних листків

<!--- TODO: specify code snippet id -->
``` cpp
const int MAXN = ...;
int n;
vector<int> g[MAXN];
int degree[MAXN];
bool killed[MAXN];

vector<int> prufer_code() {
    set<int> leaves;
    for (int i = 0; i < n; ++i) {
        degree[i] = (int)g[i].size();
        if (degree[i] == 1)
            leaves.insert(i);
        killed[i] = false;
    }

    vector<int> result(n - 2);
    for (int iter = 0; iter < n - 2; ++iter) {
        int leaf = *leaves.begin();
        leaves.erase(leaves.begin());
        killed[leaf] = true;

        int v;
        for (size_t i = 0; i < g[leaf].size(); ++i)
            if (!killed[g[leaf][i]])
                v = g[leaf][i];

        result[iter] = v;
        if (--degree[v] == 1)
            leaves.insert(v);
    }
    return result;
}
```

Втім, побудову коду Прюфера можна реалізувати за лінійний час, що описується в наступному розділі.

### Побудова коду Прюфера для даного дерева за лінійний час

Наведемо тут простий алгоритм з асимптотикою $O(n)$.

Суть алгоритму полягає в зберіганні **рухомого вказівника** $ptr$, який завжди буде продвигатися тільки в напрямку збільшення номерів вершин.

На перший погляд, таке неможливо, адже в процесі побудови коду Прюфера номера листків можуть як збільшуватися, так і **зменшуватися**. Однак легко замітити, що зменшення відбуваються тільки у випадку, коли при видаленні поточного листка його предок має менший номер (цей предок стане мінімальним листком і видалиться з дерева на наступному кроці побудови коду Прюфера). Таким чином, випадки зменшення можна обробити за час $O(1)$, і нічого не заважає побудові алгоритму з **лінійною асимптотикою**

<!--- TODO: specify code snippet id -->
``` cpp
const int MAXN = ...;
int n;
vector<int> g[MAXN];
int parent[MAXN], degree[MAXN];

void dfs(int v) {
    for (size_t i = 0; i < g[v].size(); ++i) {
        int to = g[v][i];
        if (to != parent[v]) {
            parent[to] = v;
            dfs(to);
        }
    }
}

vector<int> prufer_code() {
    parent[n - 1] = -1;
    dfs(n - 1);

    int ptr = -1;
    for (int i = 0; i < n; ++i) {
        degree[i] = (int)g[i].size();
        if (degree[i] == 1 && ptr == -1)
            ptr = i;
    }

    vector<int> result;
    int leaf = ptr;
    for (int iter = 0; iter < n - 2; ++iter) {
        int next = parent[leaf];
        result.push_back(next);
        --degree[next];
        if (degree[next] == 1 && next < ptr)
            leaf = next;
        else {
            ++ptr;
            while (ptr < n && degree[ptr] != 1)
                ++ptr;
            leaf = ptr;
        }
    }
    return result;
}
```

Прокоментуємо цей код. Основна функція тут - $\rm prufer\_code()$, яка повертає код Прюфера для дерева, заданого в глобальних змінних $n$ (кількість вершин) і $g$ (список суміжності, що задає граф). На початку ми знаходимо для кожної вершини її предка ${\rm parent}[i]$ - тобто того предка, якого ця вершина матиме в момент видалення з дерева (усе це ми можемо знайти заздалегідь, користуючись тим, що максимальна вершина $n-1$ ніколи не видалиться з дерева). Також ми знаходимо для кожної вершини її ступінь ${\rm degree}[i]$. Змінна $\rm ptr$ - це двіжний вказівник ("кандидат" на мінімальний лист), який змінюється завжди тільки в сторону збільшення. Змінна $\rm leaf$ - це поточний лист з мінімальним номером. Таким чином, кожна ітерація коду Прюфера полягає в додаванні $\rm leaf$ в відповідь, а також перевірці, чи не виявилось, що $\rm parent[leaf]$ менше поточного кандидата $\rm ptr$: якщо виявилося менше, то ми просто присвоюємо $\rm leaf = parent[leaf]$, а в іншому випадку - рухаємо вказівник $\rm ptr$ до наступного листа.

Як легко бачити з коду, асимптотика алгоритму дійсно становить $O(n)$: вказівник $\rm ptr$ змінюється лише $O(n)$ разів, а всі інші частини алгоритму очевидно працюють за лінійний час.

### Деякі властивості кодів Прюфера

* Після побудови коду Прюфера в дереві залишаться невидаленими дві вершини.

Одна з них точно буде вершина з максимальним номером — $n$, а от про іншу вершину нічого конкретного сказати не можна.

* Кожна вершина зустрічається в коді Прюфера певну кількість разів, рівну її ступеню мінус один.

Це легко зрозуміти, якщо помітити, що вершина видаляється з дерева в той момент, коли її ступінь дорівнює одиниці - тобто до цього моменту всі сусідні з нею ребра, окрім одного, були видалені. (Для двох залишилися після побудови коду вершин це твердження також є вірним).

### Відновлення дерева за його кодом Прюфера

Для відновлення дерева достатньо замітити з попереднього пункту, що степені всіх вершин в шуканому дереві ми вже знаємо (і можемо порахувати і зберегти в деякому масиві $degree[]$). Отже, ми можемо знайти всі листки, і, відповідно, номер найменшого листка - який був видалений на першому кроці. Цей листок був з'єднаний з вершиною, номер якої записаний в першому елементі коду Прюфера.

Таким чином, ми знайшли перше ребро, віддалене кодом Прюфера. Додамо це ребро до відповіді, а потім зменшимо ступені вершин, до яких під'єднане це ребро, у масиві $degree[]$.

Будемо повторювати цю операцію, доки не переглянемо весь код Прюфера: шукати мінімальну вершину з $degree = 1$, з'єднувати її з черговою вершиною коду Прюфера, зменшувати $degree[]$ на обох кінцях.

В кінці кінців у нас залишиться лише дві вершини з $degree = 1$ - це ті вершини, які алгоритм Прюфера залишив невидаленими. З'єднаємо їх ребром.

Алгоритм завершено, побудовано шукане дерево.

**Реалізувати** цей алгоритм легко за час $O(n \log n)$: підтримуючи в структурі даних для вилучення мінімуму (наприклад, $\rm set<>$ або $\rm priority\_queue<>$ в C++) номери всіх вершин з $degree=1$, і вилучаючи з нього кожний раз мінімум.

Наведемо відповідну реалізацію, де функція $\text{prufer\_decode()}$ повертає список ребер шуканого дерева:

<!--- TODO: specify code snippet id -->
``` cpp
vector<pair<int, int>> prufer_decode(const vector<int> &prufer_code) {
    int n = (int)prufer_code.size() + 2;
    vector<int> degree(n, 1);
    for (int i = 0; i < n - 2; ++i)
        ++degree[prufer_code[i]];

    set<int> leaves;
    for (int i = 0; i < n; ++i)
        if (degree[i] == 1)
            leaves.insert(i);

    vector<pair<int, int>> result;
    for (int i = 0; i < n - 2; ++i) {
        int leaf = *leaves.begin();
        leaves.erase(leaves.begin());

        int v = prufer_code[i];
        result.push_back(make_pair(leaf, v));
        if (--degree[v] == 1)
            leaves.insert(v);
    }
    result.push_back(make_pair(*leaves.begin(), *--leaves.end()));
    return result;
}
```

### Відновлення дерева за кодом Прюфера можна здійснити за лінійний час

Для отримання алгоритму з лінійною асимптотикою можна застосувати той самий прийом, що використовувався для отримання лінійного алгоритму обчислення коду Прюфера.

Насправді, для знаходження листа з найменшим номером не потрібно створювати структуру даних для вилучення мінімуму. Замість цього можна помітити, що після обробки поточного листа, він додає до розгляду лише один новий лист. Тому можна використовувати один рухливий вказівник разом зі змінною, яка містить поточний мінімальний лист

<!--- TODO: specify code snippet id -->
``` cpp
vector<pair<int, int>> prufer_decode_linear(const vector<int> &prufer_code) {
    int n = (int)prufer_code.size() + 2;
    vector<int> degree(n, 1);
    for (int i = 0; i < n - 2; ++i)
        ++degree[prufer_code[i]];

    int ptr = 0;
    while (ptr < n && degree[ptr] != 1)
        ++ptr;
    int leaf = ptr;

    vector<pair<int, int>> result;
    for (int i = 0; i < n - 2; ++i) {
        int v = prufer_code[i];
        result.push_back(make_pair(leaf, v));

        --degree[leaf];
        if (--degree[v] == 1 && v < ptr)
            leaf = v;
        else {
            ++ptr;
            while (ptr < n && degree[ptr] != 1)
                ++ptr;
            leaf = ptr;
        }
    }
    for (int v = 0; v < n - 1; ++v)
        if (degree[v] == 1)
            result.push_back(make_pair(v, n - 1));
    return result;
}
```

### Взаємна однозначність відповідності між деревами і кодами Прюфера

З одного боку, для кожного дерева існує лише один код Прюфера, що відповідає йому (це випливає з визначення коду Прюфера).

З іншого боку, з правильності алгоритму відновлення дерева за кодом Прюфера випливає, що будь-якій послідовності з $n-2$ чисел, де кожне число належить відрізку $[1;n]$, відповідає певне дерево. Також слід уникати використання російських слів "код Прюфера", краще вживати український варіант - "послідовність Прюфера".

Таким чином, всі дерева та всі коди Прюфера утворюють **взаємно однозначну відповідність**.

## Формула Келі

Формула Келі свідчить, що **кількість остовних дерев у повному позначеному графі** з $n$ вершин дорівнює:

$$
n^{n-2}.
$$

Є багато доказів цієї формули, але доведення з використанням кодів Прюфера є найбільш наочним та конструктивним.

Насправді, будь-якому набору з $n-2$ чисел з множини $[1;n]$ однозначно відповідає деяке дерево з $n$ вершин. Всього різних кодів Прюфера $n^{n-2}$. Оскільки в випадку повного графа з $n$ вершинами в якості острову підходить будь-яке дерево, то кількість остовних дерев дорівнює $n^{n-2}$, що потрібно довести.

## Кількість способів зробити граф зв'язним:

Міць кодів Прюфера полягає в тому, що вони дозволяють отримати більш загальну формулу, ніж формула Келі.

Отже, дано граф з $n$ вершинами і $m$ ребрами; нехай $k$ - кількість компонент зв'язності в цьому графі. Потрібно знайти кількість способів додати $k-1$ ребер, щоб граф став зв'язним (очевидно, $k-1$ ребро - мінімальна кількість ребер, необхідних для того, щоб зробити граф зв'язним).

Виведемо готову формулу для вирішення цієї задачі.

Позначимо через $s_1, \ldots, s_k$ розміри компонент зв'язності цього графу. Оскільки додавати ребра всередині компонент зв'язності заборонено, то виходить, що задача дуже схожа на пошук кількості остовних дерев у повному графі з $k$ вершин: але відмінність тут у тому, що кожна вершина має свою "вагу" $s_i$: кожне ребро, суміжне з $i$-тою вершиною, множить відповідь на $s_i$.

Отже, для підрахунку кількості способів виявляється важливим, які степені мають всі $k$ вершин у остові. Для отримання формули для задачі потрібно підсумувати відповіді по всім можливим степеням.

Нехай $d_1, \ldots, d_k$ - степені вершин у остові. Сума степенів вершин дорівнює кількості ребер удвоє, тому:

$$
\sum_{i=1}^k d_i = 2k-2.
$$

Якщо $i$-та вершина має ступінь $d_i$, то в код Прюфера вона повинна входити $d_i-1$ рази. Код Прюфера для дерева з $k$ вершинами має довжину $k-2$. Кількість способів вибрати набір $k-2$ чисел, де число $i$ зустрічається рівно $d_i-1$ раз, дорівнює **мультиноміальному коефіцієнту** (за аналогією з [біноміальним коефіцієнтом](binomial_coeff)):

$$
\binom{ k-2 }{ d_1-1, ~ d_2-1, ~ \ldots ~ , d_k-1 } = \frac{ (k-2)! }{ (d_1-1)! ~ (d_2-1)! ~ \ldots ~ (d_k-1)! }.
$$

З урахуванням того, що кожне ребро, що межує з $i$-ою вершиною, множить відповідь на $s_i$, отримуємо, що відповідь при умові, що степені вершин дорівнюють $d_1, \ldots, d_k$, дорівнює:

$$
s_1^{d_1} \cdot s_2^{d_2} \cdot \ldots \cdot s_k^{d_k} \cdot \frac{ (k-2)! }{ (d_1-1)! ~ (d_2-1)! ~ \ldots ~ (d_k-1)! }.
$$

Для отримання відповіді на задачу потрібно підсумувати цю формулу по всіх допустимих наборах $\{ d_i \}_{i=1}^{k}$

$$
\sum_{ \substack{ d_i \ge 1, \\ \sum_{i=1}^k d_i = 2k-2 } } s_1^{d_1} \cdot s_2^{d_2} \cdot \ldots \cdot s_k^{d_k} \cdot \frac{ (k-2)! }{ (d_1-1)! ~ (d_2-1)! ~ \ldots ~ (d_k-1)! }.
$$

Для скорочення цієї формули скористаємось визначенням мультиноміального коефіцієнта:

$$
(x_1 + \ldots x_m)^p = \sum_{ \substack{ c_i \ge 0, \\ \sum_{i=1}^{m} c_i = p } } x_1^{c_1} \cdot x_2^{c_2} \cdot \ldots \cdot x_m^{c_m} \cdot \binom{ m }{ c_1, ~ c_2, ~ \ldots ~ , c_k }.
$$

Порівнюючи цю формулу з попередньою, ми отримуємо, що якщо ввести позначення $e_i = d_i-1$:

$$
\sum_{ \substack{ e_i \ge 0, \\ \sum_{i=1}^k e_i = k-2 } } s_1^{e_1+1} \cdot s_2^{e_2+1} \cdot \ldots \cdot s_k^{e_k+1} \cdot \frac{ (k-2)! }{ e_1! ~ e_2! ~ \ldots ~ e_k! },
$$

так після скорочення **відповіді на задачу** рівний:

$$
s_1 \cdot s_2 \cdot \ldots \cdot s_k \cdot (s_1 + s_2 + \ldots + s_k)^{k-2} = s_1 \cdot s_2 \cdot \ldots \cdot s_k \cdot n^{k-2}.
$$

(Ця формула є вірною навіть при $k=1$, хоча формально цього не було доведено).

## Завдання на онлайн-суддях

Задачі в онлайн-суддях, в яких використовуються коди Прюфера:

* [ UVA #10843 **"Anne's game"** ~~~~~~ [складність: низька] ](http://acm.uva.es/p/v108/10843.html)

* [Задача #1069 **"Код Прюфера"** ~~~~~~ [складність: низька] ](http://acm.timus.ru/problem.aspx?space=1&num=1069)

* [ CODEFORCES 110D **"Улики"** ~~~~~~ [складність: середня] ](http://codeforces.ru/contest/156/problem/D)

* [ TopCoder SRM 460 **"TheCitiesAndRoadsDivTwo"** ~~~~~~ [складність: середня] ](http://community.topcoder.com/stat?c=problem_statement&pm=10774&rd=14146)