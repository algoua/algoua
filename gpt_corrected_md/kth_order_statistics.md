# K-та порядкова статистика за O(N)

Нехай дано масив A довжиною N і число K. Задача полягає у знаходженні K-ої порядкової статистики в цьому масиві, тобто K-го за величиною елементу.

&nbsp;

Основна ідея полягає в тому, щоб використовувати ідеї алгоритму швидкого сортування. Власне, алгоритм не є складним, складніше довести, що він працює в середньому за O(N), на відміну від швидкого сортування.

&nbsp;

Реалізація у вигляді нерекурсивної функції:

<!--- TODO: specify code snippet id -->
``` cpp
template <class T> T order_statistics(std::vector<T> a, unsigned n, unsigned k) {
    using std::swap;
    for (unsigned l = 1, r = n;;) {
        if (r <= l + 1) {
// Поточна частина складається з одного або двох елементів -
Легко можемо знайти відповідь
            if (r == l + 1 && a[r] < a[l])
                swap(a[l], a[r]);
            return a[k];
        }

        // упорядочиваем a[l], a[l+1], a[r]
        unsigned mid = (l + r) >> 1;
        swap(a[mid], a[l + 1]);
        if (a[l] > a[r])
            swap(a[l], a[r]);
        if (a[l + 1] > a[r])
            swap(a[l + 1], a[r]);
        if (a[l] > a[l + 1])
            swap(a[l], a[l + 1]);

// Виконуємо ділення
// Бар'єром є a[l+1], тобто медіана серед a[l], a[l+1], a[r]
        unsigned i = l + 1, j = r;
        const T cur = a[l + 1];
        for (;;) {
            while (a[++i] < cur)
                ;
            while (a[--j] > cur)
                ;
            if (i > j)
                break;
            swap(a[i], a[j]);
        }

// Вставляємо бар'єр
        a[l + 1] = a[j];
        a[j] = cur;

// продовжуємо працювати в тій частині,
Який елемент потрібно знайти та який він має бути
        if (j >= k)
            r = j - 1;
        if (j <= k)
            l = i;
    }
}
```
&nbsp;

Слід зазначити, що в стандартній бібліотеці C++ цей алгоритм вже реалізований - він називається nth_element.