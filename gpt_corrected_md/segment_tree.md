# Дерево відрізків

Дерево відрізків - це структура даних, яка дозволяє ефективно (тобто за асимптотику $O(\log n)$) реалізувати операції наступного змісту: знаходження суми/мінімуму елементів масиву в заданому відрізку ($a[l \ldots r]$, де $l$ і $r$ надходять на вхід алгоритму). При цьому додатково можливо змінювати елементи масиву: як зміна значення одного елементу, так і зміна елементів на цілому підвідрізку масиву (тобто дозволяється присвоювати всім елементам $a[l \ldots r]$ яке-небудь значення або додавати до всіх елементів масиву яке-небудь число).

Загалом, дерево відрізків є дуже гнучкою структурою, і число задач, які можна розв'язати за її допомогою, теоретично необмежене. Окрім вищезгаданих операцій з деревами відрізків, можливі і значно більш складні операції (див. розділ "Ускладнені версії дерева відрізків"). Зокрема, дерево відрізків легко узагальнюється на великі розмірності: наприклад, для розв'язання задачі про знаходження суми/мінімуму в деякому підпрямокутнику даної матриці (правда, вже тільки за час $O(\log^2 n)$).

Важною особливістю дерев відрізків є те, що вони використовують лінійний обсяг пам'яті: стандартному дереву відрізків потрібно близько $4n$ елементів пам'яті для роботи з масивом розміру $n$.

## Опис дерева відрізків в базовом варіанті

Для початку розглянемо найпростіший випадок дерева відрізків - дерево відрізків для суми. Якщо ставити задачу формально, то у нас є масив $a[0..n-1]$, і наше дерево відрізків має вміти знаходити суму елементів з $l$-го по $r$-ий (це запит на суму), а також обробляти зміну значення одного зазначеного елементу масиву, тобто фактично реагувати на присвоєння $a[i]=x$ (це запит модифікації). Ще раз повторимось, дерево відрізків має обробляти обидва ці запити за час $O(\log n)$.

### Структура дерева відрізків

Отже, що представляє собою дерево відрізків?

Порахуймо і запам'ятаймо десь суму елементів усього масиву, тобто відрізку $a[0 \ldots n-1]$. Також порахуймо суму на двох половинах цього масиву: $a[0 \ldots n/2]$ і $a[n/2+1 \ldots n-1]$. Кожну з цих двох половинок в свою чергу розіб'ємо навпіл, порахуємо і збережемо суму на них, потім знову розіб'ємо навпіл, і так далі, поки поточний відрізок не досягне довжини $1$. Іншими словами, ми стартуємо з відрізку $[0;n-1]$ і кожного разу ділимо поточний відрізок надвоє (якщо він ще не став відрізком одиничної довжини), викликаючи потім цю ж процедуру від обох половинок; для кожного такого відрізку ми зберігаємо суму чисел на ньому.

Можна сказати, що ці відрізки, на яких ми рахували суму, утворюють дерево: корінь цього дерева - відрізок $[0 \ldots n-1]$, а кожен вузол має рівно двох синів (крім листків, у яких відрізок має довжину $1$). Звідси й назва - "дерево відрізків" (хоча при реалізації зазвичай ніяке дерево явно не будується, але про це нижче в розділі реалізації).

Отже, ми описали структуру дерева відрізків. Відразу зауважимо, що воно має **лінійний розмір**, а саме, містить не більше $2n$ вершин. Розуміння цього можна пояснити наступним чином: перший рівень дерева відрізків містить одну вершину (відрізок $[0 \ldots n-1]$), другий рівень - в гіршому випадку дві вершини, на третьому рівні в гіршому випадку буде чотири вершини, і так далі, поки кількість вершин не досягне $n$. Таким чином, кількість вершин в гіршому випадку можна оцінити сумою $n + n/2 + n/4 + n/8 + \ldots + 1$, що менше за $2n$.

Варто відзначити, що при $n$, відмінних від степенів двійки, не всі рівні дерева відрізків будуть повністю заповнені. Наприклад, при $n=3$ лівий син кореня є відрізок $[0 \ldots 1]$, має двох нащадків, тоді як правий син кореня - відрізок $[2 \ldots 2]$, є листком. Ніяких особливих складнощів при реалізації цього не виникає, але все ж таки це потрібно мати на увазі.

Висота дерева відрізків є величина $O(\log n)$ - наприклад, тому що довжина відрізку в корені дерева дорівнює $n$, а при переході на один рівень вниз довжина відрізків зменшується приблизно вдвічі.

### Побудова

Процес побудови дерева відрізків за заданим масивом $a$ можна здійснювати ефективно наступним чином, знизу вгору: спочатку запишемо значення елементів $a[i]$ в відповідні листки дерева, потім на основі них порахуємо значення для вершин попереднього рівня як суму значень у двох листках, потім аналогічним чином порахуємо значення для наступного рівня і т.д. Зручно описувати цю операцію рекурсивно: ми запускаємо процедуру побудови від кореня дерева відрізків, а сама процедура побудови, якщо її викликали не від листка, викликає собі від кожного з двох синів і сумує обчислені значення, а якщо її викликали від листка - то просто записує в собі значення цього елемента масиву.

Асимптотика побудови дерева відрізків становить $O(n)$.

### Запит на суму

Розглянемо тепер запит суми. На вхід надходять два числа $l$ та $r$, і ми повинні за час $O(\log n)$ порахувати суму чисел на відрізку $a[l \dots r]$.

Для цього ми будемо спускатися по побудованому дереву відрізків, використовуючи для підрахунку відповіді підраховані раніше суми в кожній вершині дерева. Спочатку ми стаємо в корінь дерева відрізків. Подивимося, в якого з двох його синів потрапляє відрізок запиту $[l \ldots r]$ (нагадаємо, що сини кореня дерева відрізків - це відрізки $[0 \ldots n/2]$ і $[n/2+1 \ldots n-1]$). Можливі два варіанти: що відрізок $[l \ldots r]$ потрапляє тільки в одного сина кореня, і що, навпаки, відрізок перетинається з обома синами.

Перший випадок є простим: необхідно перейти до того сина, в якому міститься наш відрізок-запит, і застосувати описаний алгоритм до поточної вершини.

У іншому випадку нам не залишається інших варіантів, окрім як перейти спочатку до лівого сина і порахувати відповідь на запит в ньому, а потім - перейти до правого сина, порахувати в ньому відповідь і додати до нашої відповіді. Іншими словами, якщо лівий син представляє відрізок $[l_1 \ldots r_1]$, а правий - відрізок $[l_2 \ldots r_2]$ (зауважимо, що $l_2 = r_1 + 1$), то ми перейдемо до лівого сина з запитом $[l \ldots r_1]$, а до правого - з запитом $[l_2 \ldots r]$.

Отже, обробка запиту суми представляє собою **рекурсивну функцію**, яка кожного разу викликається або від лівого сина, або від правого (не змінюючи межі запиту в обох випадках), або від обох одразу (при цьому ділячи наш запит на два відповідні підзапити). Однак рекурсивні виклики будемо робити не завжди: якщо поточний запит збігається з кордонами відрізку в поточній вершині дерева відрізків, то в якості відповіді повертатимемо попередньо обчислене значення суми на цьому відрізку, записане в дереві відрізків.

Іншими словами, обчислення запиту полягає у спуску по дереву відрізків, який розповсюджується по всіх потрібних гілках дерева і для швидкої роботи використовує вже пораховані суми по кожному відрізку в дереві відрізків.

Чому ж **асимптотика** цього алгоритму буде $O(\log n)$? Для цього подивимося на кожному рівні дерева відрізків, скільки максимум відрізків могла відвідати наша рекурсивна функція при обробці якогось запиту. Стверджується, що таких відрізків не могло бути більше ніж чотири; тоді, враховуючи оцінку $O(\log n)$ для висоти дерева, ми отримуємо потрібну асимптотику часу роботи алгоритму.

Покажемо, що ця оцінка для чотирьох відрізків є вірною. На нульовому рівні дерева запитом затрагується лише одна вершина - корінь дерева. На першому рівні рекурсивний виклик у гіршому випадку розбивається на два рекурсивних виклики, але важливо тут, що запити в цих двох викликах будуть сусідніми, тобто номер запиту $l^{\prime\prime}$ у другому рекурсивному виклику буде на одиницю більше номера запиту $r^\prime$ у першому рекурсивному виклику. Звідси випливає, що на наступному рівні кожен з цих двох викликів може породити ще по два рекурсивних виклики, але в такому випадку половина цих запитів відпрацює нерекурсивно, взявши потрібне значення з вершини дерева відрізків. Таким чином, кожного разу у нас буде не більше двох реально працюючих гілок рекурсії (можна сказати, що одна гілка приближається до лівого краю запиту, а інша гілка - до правого), а всього число затронутих відрізків не може перевищувати висоту дерева відрізків, помножену на чотири, тобто воно є числом $O(\log n)$.

В завершення можна навести таке розуміння роботи запиту суми: вхідний відрізок $[l \ldots r]$ розбивається на кілька підвідрізків, відповідь на кожному з яких вже підрахована і збережена в дереві. Якщо зробити це розбиття правильним чином, то завдяки структурі дерева відрізків кількість необхідних підвідрізків завжди буде $O(\log n)$, що дає ефективність роботи дерева відрізків.

### Запит на поновлення

Нагадаємо, що запит на поновлення отримує на вхід індекс $i$ та значення $x$, і перебудовує дерево відрізків таким чином, щоб воно відповідало новим значенням $a[i]=x$. Цей запит також повинен виконуватися за час $O(\log n)$.

Це менш складний запит порівняно з запитом підрахунку суми. Справа в тому, що елемент $a[i]$ бере участь тільки в дуже обмеженій кількості вершин дерева відрізків: а саме, в $O(\log n)$ вершинах - по одній з кожного рівня.

Значить, зрозуміло, що запит на поновлення можна реалізувати як рекурсивну функцію: їй передається поточна вершина дерева відрізків, і ця функція виконує рекурсивний виклик від одного з двох своїх синів (від того, який містить позицію $i$ у своєму відрізку), а після цього - перераховує значення суми в поточній вершині точно таким же чином, як ми це робили при побудові дерева відрізків (тобто як суму значень по обом синам поточної вершини).

### Реалізація

Основний момент реалізації полягає у тому, як **зберігати** дерево відрізків в пам'яті. З метою спрощення ми не будемо зберігати дерево у явному вигляді, а скористаємося таким трюком: скажімо, що корінь дерева має номер $1$, його сини - номери $2$ і $3$, їх сини - номери від $4$ до $7$, і так далі. Легко зрозуміти коректність наступної формули: якщо вершина має номер $i$, то нехай її лівий син - це вершина з номером $2i$, а правий - з номером $2i+1$.

Такий прийом значно спрощує програмування дерева відрізків, - тепер нам не потрібно зберігати в пам'яті структуру дерева відрізків, а лише завести масив для сум на кожному відрізку дерева відрізків.

Варто лише відзначити, що розмір цього масиву при такій нумерації потрібно ставити не $2n$, а $4n$. Справа в тому, що така нумерація не ідеально працює у випадку, коли $n$ не є степенем двійки - тоді з'являються пропущені номери, яким не відповідають жодні вершини дерева (фактично, нумерація веде себе подібно до того, якби $n$ округлили вгору до найближчої степені двійки). Це не створює жодних складнощів при реалізації, проте призводить до того, що розмір масиву потрібно збільшувати до $4n$.

Отже, дерево відрізків ми зберігаємо просто у вигляді масиву $t[]$, розміру вчетверо більшого за розмір $n$ вхідних даних:

<!--- TODO: specify code snippet id -->
``` cpp
int n, t[4 * MAXN];
```

Процедура **побудови дерева відрізків** по заданому масиву $a[]$ виглядає наступним чином: це рекурсивна функція, якій передається сам масив $a[]$, номер $v$ поточної вершини дерева, і межі $tl$ і $tr$ відрізку, відповідного поточній вершині дерева. З основної програми викликати цю функцію слід з параметрами $v=1$, $tl=0$, $tr=n-1$.

<!--- TODO: specify code snippet id -->
``` cpp
void build(int a[], int v, int tl, int tr) {
    if (tl == tr)
        t[v] = a[tl];
    else {
        int tm = (tl + tr) / 2;
        build(a, v * 2, tl, tm);
        build(a, v * 2 + 1, tm + 1, tr);
        t[v] = t[v * 2] + t[v * 2 + 1];
    }
}
```

Далі, функція для **запиту на суму** представляє собою також рекурсивну функцію, якій таким же чином передається інформація про поточну вершину дерева (тобто числа $v$, $tl$, $tr$, які в основній програмі випливає передавати значення $1$, $0$, $n-1$ відповідно), а крім того - також межі $l$ і $r$ поточного запиту. В цілях спрощення коду ця функція завжди робить по два рекурсивних виклики, навіть якщо насправді потрібен лише один - просто лишньому рекурсивному виклику передається запит, у якому $l > r$, що легко відсікається додатковою перевіркою в самому початку функції.

<!--- TODO: specify code snippet id -->
``` cpp
int sum(int v, int tl, int tr, int l, int r) {
    if (l > r)
        return 0;
    if (l == tl && r == tr)
        return t[v];
    int tm = (tl + tr) / 2;
    return sum(v * 2, tl, tm, l, min(r, tm)) + sum(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r);
}
```

Нарешті, **запит на модифікацію**. Йому точно так само передається інформація про поточну вершину дерева відрізків, а додатково вказується індекс змінюваного елемента, а також його нове значення.

<!--- TODO: specify code snippet id -->
``` cpp
void update(int v, int tl, int tr, int pos, int new_val) {
    if (tl == tr)
        t[v] = new_val;
    else {
        int tm = (tl + tr) / 2;
        if (pos <= tm)
            update(v * 2, tl, tm, pos, new_val);
        else
            update(v * 2 + 1, tm + 1, tr, pos, new_val);
        t[v] = t[v * 2] + t[v * 2 + 1];
    }
}
```

Варто відзначити, що функцію $\rm update$ легко можна зробити нерекурсивною, оскільки рекурсія в ній є хвостовою, тобто розгалуження ніколи не відбувається: один виклик може породити тільки один рекурсивний виклик. При нерекурсивній реалізації швидкість роботи може зрости в декілька разів.

З інших **оптимізацій** варто зазначити, що множення і ділення на два слід замінити бітовими операціями - це також трохи покращує продуктивність дерева відрізків.

## Ускладнені версії дерева відрізків

Дерево відрізків - дуже гнучка структура і дозволяє робити узагальнення у багатьох різних напрямках. Спробуємо нижче класифікувати їх.

### Більш складні функції та запити

Покращення дерева відрізків в цьому напрямку можуть бути як досить очевидними (наприклад, у випадку мінімуму/максимуму замість суми), так і дуже нетривіальними.

#### Пошук мінімуму/максимуму

Трохи змінимо умову задачі, описаної вище: замість запиту суми будемо тепер виробляти запит мінімуму/максимуму на відрізку.

Значить, дерево відрізків для цієї задачі практично нічим не відрізняється від дерева відрізків, описаного вище. Просто потрібно змінити спосіб обчислення $t[v]$ у функціях $\rm build$ і $\rm update$, а також обчислення поверненої відповіді в функції $\rm sum$ (замінити сумування на мінімум/максимум).

#### Пошук мінімума/максимума та кількості його входжень

Задача аналогічна попередній, але тепер потрібно повертати не лише максимум, а й кількість його входжень. Ця задача виникає при розв'язуванні задачі з допомогою дерева відрізків, наприклад, знайти кількість найдовших зростаючих підпослідовностей в заданому масиві.

Для розв'язання цієї задачі в кожній вершині дерева відрізків будемо зберігати пару чисел: крім максимуму - кількість його входжень на відповідному відрізку. Отже, при побудові дерева ми повинні просто з двох таких пар, отриманих від синів поточної вершини, отримувати пару для поточної вершини.

Об'єднання двох таких пар в одну слід виділити в окрему функцію, оскільки цю операцію потрібно буде виконувати як у запиті модифікації, так і у запиті пошуку максимуму.

<!--- TODO: specify code snippet id -->
``` cpp
pair<int, int> t[4 * MAXN];

pair<int, int> combine(pair<int, int> a, pair<int, int> b) {
    if (a.first > b.first)
        return a;
    if (b.first > a.first)
        return b;
    return make_pair(a.first, a.second + b.second);
}

void build(int a[], int v, int tl, int tr) {
    if (tl == tr)
        t[v] = make_pair(a[tl], 1);
    else {
        int tm = (tl + tr) / 2;
        build(a, v * 2, tl, tm);
        build(a, v * 2 + 1, tm + 1, tr);
        t[v] = combine(t[v * 2], t[v * 2 + 1]);
    }
}

pair<int, int> get_max(int v, int tl, int tr, int l, int r) {
    if (l > r)
        return make_pair(-INF, 0);
    if (l == tl && r == tr)
        return t[v];
    int tm = (tl + tr) / 2;
    return combine(get_max(v * 2, tl, tm, l, min(r, tm)), get_max(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r));
}

void update(int v, int tl, int tr, int pos, int new_val) {
    if (tl == tr)
        t[v] = make_pair(new_val, 1);
    else {
        int tm = (tl + tr) / 2;
        if (pos <= tm)
            update(v * 2, tl, tm, pos, new_val);
        else
            update(v * 2 + 1, tm + 1, tr, pos, new_val);
        t[v] = combine(t[v * 2], t[v * 2 + 1]);
    }
}
```

#### Пошук найбільшого спільного дільника / найменшого спільного кратного

тобто, ми хочемо навчитися знаходити НСД/НСК всіх чисел в заданому відрізку масиву.

Це досить цікаве узагальнення дерева відрізків, виходить абсолютно таким же шляхом, як і дерева відрізків для суми/мінімуму/максимуму: достатньо просто зберігати в кожній вершині дерева НСД/НСК всіх чисел у відповідному відрізку масиву.

#### Підрахунок кількості нулів, пошук $k$-го нуля

У цій задачі ми хочемо навчитися відповідати на запит щодо кількості нулів у заданому відрізку масиву, а також на запит щодо знаходження $k$-го нульового елементу.

Знову трохи змінимо дані, що зберігаються в дереві відрізків: тепер у масиві $t[]$ буде зберігатися кількість нулів, які зустрічаються в відповідних відрізках масиву. Зрозуміло, як підтримувати та використовувати ці дані в функціях $\rm build$, $\rm sum$, $\rm update$, - тим самим ми вирішили задачу про кількість нулів у заданому відрізку масиву.

Тепер навчимося розв'язувати задачу про пошук позиції $k$-го входження нуля в масиві. Для цього будемо спускатися по дереву відрізків, починаючи з кореня і переходячи кожен раз у лівого або правого сина в залежності від того, в якому з відрізків знаходиться шуканий $k$-ий нуль. Насправді, щоб зрозуміти, в якого сина нам треба переходити, достатньо подивитися на значення, записане в лівому сині: якщо воно більше або рівне $k$, то переходити треба в лівого сина (тому що в його відрізку є як мінімум $k$ нулів), а інакше - переходити в правого сина.

При реалізації можна відсікти випадок, коли $k$-й нуль не існує. Також можна повернути в якості відповіді, наприклад, $-1$, якщо такий нуль не знайдений.

<!--- TODO: specify code snippet id -->
``` cpp
int find_kth(int v, int tl, int tr, int k) {
    if (k > t[v])
        return -1;
    if (tl == tr)
        return tl;
    int tm = (tl + tr) / 2;
    if (t[v * 2] >= k)
        return find_kth(v * 2, tl, tm, k);
    else
        return find_kth(v * 2 + 1, tm + 1, tr, k - t[v * 2]);
}
```

#### Пошук префіксу масиву з заданою сумою

Задача полягає в тому, щоб швидко знайти таке $i$, для якого сума перших $i$ елементів масиву $a[]$ буде більша або дорівнювати заданому значенню $x$. При цьому вважається, що масив $a[]$ складається тільки з не від'ємних чисел.

Цю задачу можна розв'язувати бінарним пошуком, обчислюючи кожного разу всередині нього суму на тому або іншому префіксі масиву, але це приведе до розв'язку за час $O(\log^2 n)$.

Замість цього можна скористатися тією самою ідеєю, що й у попередньому пункті, і шукати шукану позицію одним спуском по дереву: переходячи кожен раз в лівого або правого сина в залежності від величини суми в лівому сина. Отже, відповідь на запит пошуку буде представляти собою один такий спуск по дереву, тому буде виконуватися за $O(\log n)$.

#### Пошук підрядка з максимальною сумою

Зараз на вхід надається масив $a[0 \ldots n-1]$, і надходять запити $(l,r)$, які означають: знайти такий підвідрізок $a[l^\prime \ldots r^\prime]$, що $l \le l^\prime$, $r^\prime \le r$, і сума цього підвідрізку $a[l^\prime \ldots r^\prime]$ максимальна. Дозволяються запити модифікації окремих елементів масиву. Елементи масиву можуть бути від'ємними (і, наприклад, якщо всі числа від'ємні, то оптимальним підвідрізком буде порожній - на ньому сума дорівнює нулю).

Це дуже нетривіальне узагальнення дерева відрізків. Будемо зберігати в кожній вершині дерева відрізків чотири значення: суму на цьому відрізку, максимальну суму серед всіх префіксів цього відрізку, максимальну суму серед всіх суфіксів та максимальну суму підвідрізку на ньому. Іншими словами, для кожного відрізку дерева відрізків відповідь на ньому вже попередньо обчислена, а також додатково обчислена відповідь серед всіх відрізків, що межують з лівим краєм відрізку, а також серед всіх відрізків, що межують з правим краєм. Крім того, текст може містити LaTeX вставки між $ символом, які не повинні бути змінені.

Як побудувати дерево відрізків з такими даними? Знову підійдемо до цього з рекурсивної точки зору: нехай для поточної вершини всі чотири значення в лівому сині та в правому сині вже підраховані, порахуємо їх тепер для самої вершини. Зауважимо, що відповідь в самій вершині дорівнює:

* Або відповіді в лівому підрядку, що означає, що кращий підвідрізок в поточній вершині повністю поміщається в підрядок лівого сина
* Або відповідь в правому сині, що означає, що кращий підвідрізок в поточній вершині повністю поміщається в відрізок правого сина
* Або сума максимального суфікса в лівому сині та максимального префікса в правому сині, що означає, що кращий підвідрізок починається в лівому сині та закінчується в правому.

Отже, відповідь в поточній вершині дорівнює максимуму з цих трьох величин. Перерахування максимальної суми на префіксах і суфіксах ще простіше. Наведемо реалізацію функції $\rm combine$, якій передаватимуться дві структури $\rm data$, що містять дані про лівого і правого синів, і яка повертатиме дані в поточній вершині.

<!--- TODO: specify code snippet id -->
``` cpp
struct data {
    int sum, pref, suff, ans;
};

data combine(data l, data r) {
    data res;
    res.sum = l.sum + r.sum;
    res.pref = max(l.pref, l.sum + r.pref);
    res.suff = max(r.suff, r.sum + l.suff);
    res.ans = max(max(l.ans, r.ans), l.suff + r.pref);
    return res;
}
```

Таким чином, ми навчилися будувати дерево відрізків. Звідси легко отримати і реалізацію запиту модифікації: як і в самому простому дереві відрізків, ми виконуємо перерахунок значень у всіх змінившихся вершинах дерева відрізків, для чого використовуємо ту саму функцію $\rm combine$. Для обчислення значень дерева в листях також є допоміжна функція $\rm make\_data$, яка повертає структуру $\rm data$, обчислену за одним числом $\rm val$.

<!--- TODO: specify code snippet id -->
``` cpp
data make_data(int val) {
    data res;
    res.sum = val;
    res.pref = res.suff = res.ans = max(0, val);
    return res;
}

void build(int a[], int v, int tl, int tr) {
    if (tl == tr)
        t[v] = make_data(a[tl]);
    else {
        int tm = (tl + tr) / 2;
        build(a, v * 2, tl, tm);
        build(a, v * 2 + 1, tm + 1, tr);
        t[v] = combine(t[v * 2], t[v * 2 + 1]);
    }
}

void update(int v, int tl, int tr, int pos, int new_val) {
    if (tl == tr)
        t[v] = make_data(new_val);
    else {
        int tm = (tl + tr) / 2;
        if (pos <= tm)
            update(v * 2, tl, tm, pos, new_val);
        else
            update(v * 2 + 1, tm + 1, tr, pos, new_val);
        t[v] = combine(t[v * 2], t[v * 2 + 1]);
    }
}
```

Залишилося розібратися з відповіддю на запит. Для цього ми так само, як і раніше, спускаємося по дереву, розбиваючи тим самим відрізок запиту $[l \ldots r]$ на декілька підвідрізків, співпадаючих з відрізками дерева відрізків, і об'єднуємо відповіді в них в єдину відповідь на всю задачу. Значить зрозуміло, що робота нічим не відрізняється від роботи звичайного дерева відрізків, тільки потрібно замість простого підсумовування/мінімуму/максимуму значень використовувати функцію $\rm combine$. Наведена нижче реалізація трохи відрізняється від реалізації запиту $\rm sum$: вона не допускає випадків, коли ліва межа $l$ запиту перевищує правий кордон $r$ (інакше виникають неприємні випадки - яку структуру $\rm data$ повертати, коли відрізок запиту порожній?)...

<!--- TODO: specify code snippet id -->
``` cpp
data query(int v, int tl, int tr, int l, int r) {
    if (l == tl && tr == r)
        return t[v];
    int tm = (tl + tr) / 2;
    if (r <= tm)
        return query(v * 2, tl, tm, l, r);
    if (l > tm)
        return query(v * 2 + 1, tm + 1, tr, l, r);
    return combine(query(v * 2, tl, tm, l, tm), query(v * 2 + 1, tm + 1, tr, tm + 1, r));
}
```

### Збереження всього підмасиву в кожній вершині дерева відрізків

Це окремий підрозділ, що стоїть окремо від інших, оскільки в кожній вершині дерева відрізків ми будемо зберігати не якусь стислу інформацію про цей підвідрізок (суму, мінімум, максимум і т.п.), а **всі** елементи масиву, що лежать в цьому підвідрізку. Таким чином, корінь дерева відрізків буде зберігати всі елементи масиву, лівий син кореня - першу половину масиву, правий син кореня - другу половину, і так далі.

Самий простий спосіб застосування цієї техніки - коли в кожній вершині дерева відрізків зберігається відсортований список всіх чисел, які зустрічаються в відповідному відрізку. У більш складних варіантах зберігаються не списки, а якісь структури даних, побудовані над цими списками ($\rm set$, $\rm map$ і т.д.). Але всі ці методи об'єднує те, що в кожній вершині дерева відрізків зберігається якась структура даних, яка має в пам'яті розмір, порядку довжини відповідного відрізку.

Перше природне питання, що виникає при розгляді дерев відрізків цього класу, - це **обсяг використаної пам'яті**. Стверджується, що якщо в кожній вершині дерева відрізків зберігатиметься список всіх чисел, які зустрічаються на цьому відрізку, або будь-яка інша структура даних розміру того ж порядку, то в сумі все дерево відрізків займатиме $O(n \log n)$ осередків пам'яті. Чому це так? Тому що кожне число $a[i]$ потрапляє в $O(\log n)$ відрізків дерева відрізків (принаймні тому, що висота дерева відрізків дорівнює $O(\log n)$).

Отже, незважаючи на казалось би розкішність такого дерева відрізків, воно використовує пам'ять не значно більше, ніж звичайне дерево відрізків.

Нижче описано декілька типових застосувань такої структури даних. Варто зразу відзначити явну аналогію дерев відрізків цього типу з **двовимірними структурами даних** (власне, в якому-то сенсі це і є двовимірна структура даних, але з досить обмеженими можливостями).

#### Пошук найменшого числа, що більше або дорівнює заданому, в зазначеному відрізку. Запитів модифікації немає

Потрібно відповідати на запити наступного вигляду: $(l,r,x)$, що означає знайти найменше число в діапазоні $a[l \ldots r]$, яке більше або дорівнює $x$.

Побудуємо дерево відрізків, в якому в кожній вершині будемо зберігати відсортований список всіх чисел, що зустрічаються на відповідному відрізку. Наприклад, корінь буде містити масив $a[]$ у відсортованому вигляді. Як побудувати таке дерево відрізків максимально ефективно? Для цього підійдемо до задачі, як зазвичай, з точки зору рекурсії: нехай для лівого і правого синів поточної вершини ці списки вже побудовані, і нам потрібно побудувати цей список для поточної вершини. При такій постановці питання стає майже очевидно, що це можна зробити за лінійний час: нам потрібно просто об'єднати два відсортованих списки в один, що робиться одним проходом по ним з двома вказівниками. Користувачам C++ ще простіше, оскільки цей алгоритм злиття вже включений у стандартну бібліотеку STL:

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> t[4 * MAXN];

void build(int a[], int v, int tl, int tr) {
    if (tl == tr)
        t[v] = vector<int>(1, a[tl]);
    else {
        int tm = (tl + tr) / 2;
        build(a, v * 2, tl, tm);
        build(a, v * 2 + 1, tm + 1, tr);
        merge(t[v * 2].begin(), t[v * 2].end(), t[v * 2 + 1].begin(), t[v * 2 + 1].end(), back_inserter(t[v]));
    }
}
```

Ми вже знаємо, що побудоване таким чином дерево відрізків займатиме $O(n \log n)$ пам'яті. Завдяки такій реалізації час його побудови також є величиною $O(n \log n)$ - адже кожен список будується за лінійний щодо його розміру час. До речі, тут прослідковується очевидна аналогія з алгоритмом **сортування злиттям**: тільки тут ми зберігаємо інформацію з усіх етапів роботи алгоритму, а не тільки підсумок.

Тепер розглянемо **відповідь на запит**. Будемо спускатися по дереву, як це робить стандартний алгоритм в дереві відрізків, розбиваючи наш відрізок $a[l \ldots r]$ на декілька підвідрізків (порядку $O(\log n)$ штук). Зрозуміло, що відповідь на всю задачу дорівнює мінімуму серед відповідей на кожному з цих підвідрізків. Зрозуміймо тепер, як відповісти на запит на одному такому підвідрізку, що збігається з деякою вершиною дерева.

Отже, ми прийшли до якоїсь вершини дерева відрізків і хочемо порахувати відповідь на ній, тобто знайти мінімальне число, більше або рівне даному $x$. Для цього нам потрібно виконати **пошук з бінарним розділом** по списку, посортованому в цій вершині дерева, і повернути перше число з цього списку, більше або рівне $x$.

Таким чином, відповідь на запит в одному підвідрізку відбувається за $O(\log n)$, а весь запит обробляється за час $O(\log^{2} n)$.

<!--- TODO: specify code snippet id -->
``` cpp
int query(int v, int tl, int tr, int l, int r, int x) {
    if (l > r)
        return INF;
    if (l == tl && tr == r) {
        vector<int>::iterator pos = lower_bound(t[v].begin(), t[v].end(), x);
        if (pos != t[v].end())
            return *pos;
        return INF;
    }
    int tm = (tl + tr) / 2;
    return min(query(v * 2, tl, tm, l, min(r, tm), x), query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, x));
}
```

Константа $\rm INF$ дорівнює деякому великому числу, свідомо більшому, ніж будь-яке число в масиві. Вона має сенс "відповіді в заданому відрізку не існує".

#### Пошук найменшого числа, що більше або дорівнює заданому, в зазначеному відрізку. Дозволені запити на модифікацію

Задача аналогічна попередній, тільки тепер дозволені запити модифікації: змінити значення $a_i$ на $y$.

Розв'язок також аналогічний розв'язку попередньої задачі, тільки замість простих списків в кожній вершині дерева відрізків ми будемо зберігати збалансований список, який дозволяє швидко шукати необхідне число, видаляти його, а також вставляти нове число. Зважаючи на те, що взагалі кажучи число у вхідному масиві можуть повторюватися, оптимальним вибором є структура даних STL $\rm multiset$.

Побудова такого дерева відрізків відбувається приблизно так само, як і в попередній задачі, тільки тепер треба об'єднувати не відсортовані списки, а $\rm multiset$, що призведе до того, що асимптотика побудови погіршиться до $n \log^2 n$ (хоча, мабуть, червоно-чорні дерева дозволяють виконати злиття двох дерев за лінійний час, однак бібліотека STL цього не гарантує).

Відповідь на запит пошуку взагалі практично еквівалентна приведеному вище коду, тільки тепер $\rm lower\_bound$ треба викликати від $t[v]$.

Нарешті, **запит на модифікацію**. Для його обробки ми повинні спуститися по дереву, внести зміни у всі $O(\log n)$ списків, що містять затрагнений елемент. Ми просто видаляємо старе значення цього елементу (не забуваючи, що нам не потрібно вилучати разом з ним всі повтори цього числа) і вставляємо його нове значення.

<!--- TODO: specify code snippet id -->
``` cpp
void update(int v, int tl, int tr, int pos, int new_val) {
    t[v].erase(t[v].find(a[pos]));
    t[v].insert(new_val);
    if (tl != tr) {
        int tm = (tl + tr) / 2;
        if (pos <= tm)
            update(v * 2, tl, tm, pos, new_val);
        else
            update(v * 2 + 1, tm + 1, tr, pos, new_val);
    } else
        a[pos] = new_val;
}
```

Обробка цього запиту відбувається також за час $O(\log^2 n)$.

#### Пошук найменшого числа, більше або рівного заданого, в зазначеному відрізку. Ускорение з допомогою техніки "часткового каскадування"

Покращимо час відповіді на запит пошуку до $O(\log n)$ за допомогою застосування техніки "часткового каскадування" ("fractional cascading").

Часткове каскадування - це простий прийом, який дозволяє покращити час роботи кількох бінарних пошуків, що ведуться за одним і тим же значенням. Насправді, відповідь на запит пошуку полягає в тому, що ми розбиваємо нашу задачу на декілька підзадач, кожна з яких потім вирішується бінарним пошуком за числом $x$. Часткове каскадування дозволяє замінити всі ці двійкові пошуки на один.

Простішим і найбільш очевидним прикладом часткового каскадування є наступна задача: є кілька відсортованих списків чисел, і ми повинні в кожному списку знайти перше число, більше або рівне заданому.

Якщо ми розв'язували б задачу "в лоб", то змушені були б запустити бінарний пошук для кожного з цих списків. Якщо списків багато, то це стає дуже важливим фактором. Якщо всього списків $k$, то асимптотика складе $O(k\log(n/k))$, де $n$ - сумарний розмір всіх списків. Асимптотика така, оскільки найгірший випадок полягає в тому, що всі списки мають приблизно однакову довжину, тобто рівні $n/k$.

Замість цього, ми могли б об'єднати всі ці списки в один відсортований список, в якому для кожного числа $n_i$ зберігати список позицій: позицію в першому списку першого числа, більше або рівного $n_i$, аналогічну позицію у другому списку, і так далі. Іншими словами, для кожного зустрічаються числа ми зберігаємо разом з цим числом результати бінарного пошуку по ньому в кожному зі списків. У такому випадку асимптотика відповіді на запит складає $O(\log n + k)$, що істотно краще, однак ми змушені платити великою потребою в пам'яті: а саме, нам потрібно $O(nk)$ елементів пам'яті.

Техніка часткового каскадування дозволяє вирішувати цю задачу, використовуючи $k$ списків замість одного великого списку довжиною $n$. Це дозволяє зменшити витрати пам'яті до $O(n)$, а час відповіді на запит складає $O(\log n + k)$. Для цього кожен список зберігається разом з кожним другим елементом з наступного списку. Крім того, для кожного числа зберігається його позиція в обох списках (поточному і наступному). Це дозволяє ефективно відповідати на запит: спочатку здійснюється двійковий пошук в першому списку, а потім по спискам йдуть по порядку, переходячи кожен раз до наступного списку з допомогою попередньо обчислених покажчиків. При цьому з кожним кроком вліво у наступному списку враховується, що половина чисел вже була учтена.

Але в нашому додатку до дерева відрізків не потрібна повна міць цієї техніки. Справа в тому, що список в поточній вершині містить всі числа, які можуть зустрічатися в лівому та правому синах. Тому, щоб уникнути бінарного пошуку по списку сина, нам достатньо для кожного списку в дереві відрізків порахувати для кожного числа його позиції в списках лівого та правого синів (точніше, позиції першого числа, меншого або рівного поточному).

Таким чином, замість звичайного списку всіх чисел ми будемо зберігати список трійок: саме число, позицію в списку лівого сина та позицію в списку правого сина. Це дозволить нам за $O(1)$ визначати позицію в списку лівого або правого сина замість того, щоб робити двійковий пошук по ньому.

Найпростіше застосовувати цю техніку до задачі, коли відсутні запити на модифікацію. Тоді ці позиції є просто числами, а їх легко підраховувати всередині алгоритму злиття двох відсортованих послідовностей. Російське слово "модифікації" можна замінити на українське "зміни".

У разі, коли дозволені запити модифікації, все дещо ускладнюється: ці позиції тепер потрібно зберігати у вигляді ітераторів всередині $\rm multiset$, а при запиті оновлення - правильно зменшувати/збільшувати для тих елементів, для яких це необхідно.

Так чи інакше, задача вже зводиться до чисто реалізаційних тонкощів, а основна ідея - заміна $O(\log n)$ бінарних пошуків одним бінарним пошуком по списку в корені дерева - описана повністю.

#### Інші можливі напрямки

Зауважимо, що ця техніка передбачає цілий клас можливих застосувань - все визначається структурою даних, обраною для зберігання в кожній вершині дерева. Вище були розглянуті застосування з використанням $\rm vector$ та $\rm multiset$, тоді як загалом можна використовувати будь-яку іншу компактну структуру даних: інше дерево відрізків (про це трохи сказано нижче в розділі про багатовимірні дерева відрізків), [дерево Фенвіка](fenwick_tree), [декартове дерево](treap) тощо.

### Оновлення на відрізку

Вище розглядалися лише задачі, коли запит на модифікацію стосувався одного елемента масиву. Насправді, дерево відрізків дозволяє робити запити, які застосовуються до цілих відрізків послідовних елементів, причому виконувати ці запити можна за той же час $O(\log n)$.

#### Додаток до відрізка

Почнемо розгляд дерев відрізків такого типу з найпростішого випадку: запит модифікації полягає у додаванні числа $x$ до всіх чисел на підвідрізку $a[l \ldots r]$. Запит читання - як і раніше - полягає у зчитуванні значення деякого числа $a[i]$. Російське слово "всім" можна замінити на "усіх".

Щоб зробити запит додавання ефективнішим, будемо зберігати в кожній вершині дерева відрізків значення, яке потрібно додати до всіх чисел у цьому відрізку. Наприклад, якщо приходить запит "додати до всього масиву $a[0 \ldots n-1]$ число 2", то ми поставимо в корені дерева число $2$. Це дозволить нам ефективно обробляти запит додавання на будь-якому підвідрізку, замість того, щоб змінювати всі $O(n)$ значень.

Якщо зараз надходить запит на читання значення якогось числа, то нам достатньо спуститися по дереву, підсумувавши всі зустрічені по шляху значення, записані в вершинах дерева.

<!--- TODO: specify code snippet id -->
``` cpp
void build(int a[], int v, int tl, int tr) {
    if (tl == tr)
        t[v] = a[tl];
    else {
        int tm = (tl + tr) / 2;
        build(a, v * 2, tl, tm);
        build(a, v * 2 + 1, tm + 1, tr);
    }
}

void update(int v, int tl, int tr, int l, int r, int add) {
    if (l > r)
        return;
    if (l == tl && tr == r)
        t[v] += add;
    else {
        int tm = (tl + tr) / 2;
        update(v * 2, tl, tm, l, min(r, tm), add);
        update(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, add);
    }
}

int get(int v, int tl, int tr, int pos) {
    if (tl == tr)
        return t[v];
    int tm = (tl + tr) / 2;
    if (pos <= tm)
        return t[v] + get(v * 2, tl, tm, pos);
    else
        return t[v] + get(v * 2 + 1, tm + 1, tr, pos);
}
```

#### Присвоєння на відрізку

Нехай тепер запит на модифікацію представляє собою присвоєння всім елементам деякого підрозділу $a[l \ldots r]$ певного значення $p$. Як інший запит, будемо розглядати зчитування значення елементу масиву $a[i]$.

Щоб робити модифікацію на цілому відрізку, доведеться зберігати у кожній вершині дерева відрізків інформацію про те, чи пофарбований цей відрізок цілком в якийсь колір, або ні (і якщо пофарбований, то зберігати саме це число). Це дозволить нам робити **"затримане" оновлення** дерева відрізків: при запиті модифікації ми замість того, щоб змінювати значення у всіх вершинах дерева відрізків, змінюємо тільки деякі з них, залишаючи прапорці "пофарбований" для інших відрізків, що означає, що весь цей відрізок разом зі своїми підвідрізками повинен бути пофарбований в цей колір.

Отже, після виконання запиту на модифікацію дерево відрізків стає, загалом кажучи, неактуальним - у ньому залишилися невиконані деякі модифікації.

Наприклад, якщо надійшов запит на модифікацію "присвоїти всім елементам масиву $a[0 \ldots n-1]$ яке-небудь число", то в дереві відрізків ми здійснюємо єдину зміну - помічаємо корінь дерева, що він повністю забарвлений у це число. Решта вершин дерева залишаються незмінними, хоча насправді всі дерево має бути забарвлене в одне і те ж число.

Припустимо тепер, що в тому ж дереві відрізків надійшов другий запит модифікації - пофарбувати першу половину масиву $a[0 \ldots n/2]$ у яке-небудь інше число. Щоб обробити такий запит, ми повинні пофарбувати цілком лівого сина кореня в цей новий колір, проте перед тим, як зробити це, ми повинні розібратися з коренем дерева. Тонкощ тут у тому, що в дереві має зберегтися те, що права половина пофарбована у старий колір, а в даний момент в дереві немає жодної інформації для правої половини.

Вихідний варіант має граматичну помилку. Правильно буде: провести **переприсвоєння** інформації з кореня, тобто якщо корінь дерева був пофарбований у яке-небудь число, то пофарбувати в це число його правого і лівого сина, а з кореня цю позначку видалити. Після цього ми можемо спокійно фарбувати лівого сина кореня, не втрачаючи жодної необхідної інформації.

Узагальнюючи, отримуємо: при будь-яких запитах з таким деревом (запит модифікації або читання) під час спуску по дереву ми завжди повинні передавати інформацію з поточної вершини в обох її синів. Можна розуміти це так, що під час спуску по дереву ми застосовуємо відкладені модифікації, але лише настільки, наскільки це необхідно (щоб не погіршувати асимптотику з $O(\log n)$).

При реалізації цього означає, що нам потрібно створити функцію $\rm push$, якій буде передаватися вершина дерева відрізків, і вона буде виконувати проштовхування інформації з цієї вершини в обох її синів. Виклик цієї функції має відбуватися в самому початку функцій обробки запитів (але не викликати її з листя, оскільки з листа проталкивати інформацію не потрібно, і некуди).

<!--- TODO: specify code snippet id -->
``` cpp
void push(int v) {
    if (t[v] != -1) {
        t[v * 2] = t[v * 2 + 1] = t[v];
        t[v] = -1;
    }
}

void update(int v, int tl, int tr, int l, int r, int color) {
    if (l > r)
        return;
    if (l == tl && tr == r)
        t[v] = color;
    else {
        push(v);
        int tm = (tl + tr) / 2;
        update(v * 2, tl, tm, l, min(r, tm), color);
        update(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, color);
    }
}

int get(int v, int tl, int tr, int pos) {
    if (tl == tr)
        return t[v];
    push(v);
    int tm = (tl + tr) / 2;
    if (pos <= tm)
        return get(v * 2, tl, tm, pos);
    else
        return get(v * 2 + 1, tm + 1, tr, pos);
}
```

Функцію $\rm get$ можна було б реалізувати інакше: не робити в ній відкладених оновлень, а зразу повертати відповідь, коли вона потрапляє в вершину дерева відрізків, яка повністю забарвлена у певний колір.

#### Додаток на відрізку, запит максимуму

Нехай тепер запитом модифікації знову буде додавання до всіх чисел деякого підвідрізку одного і того ж числа, а запитом читання буде знаходження максимуму в деякому підвідрізку.

Значить, в кожній вершині дерева відрізків потрібно буде додатково зберігати максимум на всьому цьому піддіапазоні. Але тонкість полягає в тому, як потрібно перераховувати ці значення.

Наприклад, нехай відбувся запит "додати до всієї першої половини, тобто $a[0 \ldots n/2]$, число 2". Значить, в дереві це відобразиться записом числа $2$ в лівого сина кореня. Як тепер порахувати нове значення максимуму в лівому сині та в корені? Тут стає важливо не заплутатися - який максимум зберігається в вершині дерева: максимум без обліку додавання на всій цій вершині, чи ж з урахуванням його. Можна вибрати будь-який з цих підходів, але головне - послідовно використовувати його всюди. Наприклад, при першому підході максимум в корені буде виходити як максимум з двох чисел: максимум в лівому сині плюс додаток в лівому сині, і максимум в правому сині плюс додаток в ньому. При іншому підході максимум в корені буде виходити як додаток в корені плюс максимум з максимумів в лівому і правому синах.

#### Інші напрямки

Тут були розглянуті тільки базові застосування дерев відрізків у завданнях з модифікаціями на відрізку. Решта задач виходять на основі тих же ідей, що описані тут.

Важливо лише бути дуже обережним під час роботи з відкладеними модифікаціями: потрібно пам'ятати, що навіть якщо в поточній вершині ми вже "протолкнули" відкладену модифікацію, то в лівому і правому синах, швидше за все, цього ще не зробили. Тому часто необхідним є викликати $\rm push$ також від лівого і правого синів поточної вершини, або ж обережно враховувати відкладені модифікації в них.

### Узагальнення на великі розмірності

Дерево відрізків узагальнюється цілком природнім чином на двовимірний і загалом багатовимірний випадок. Якщо в одновимірному випадку ми розбивали індекси масиву на відрізки, то в двовимірному випадку спочатку розбиваємо все за першими індексами, а для кожного відрізку за першими індексами будуємо звичайне дерево відрізків за іншими індексами. Таким чином, основна ідея розв'язку полягає у вкладенні дерев відрізків за іншими індексами всередину дерева відрізків за першими індексами.

Пояснімо цю ідею на прикладі конкретної задачі.

#### Двовимірне дерево відрізків у найпростішому варіанті

Дана прямокутна матриця $a_{n \times m}$, і надходять запити пошуку суми (або мінімуму/максимуму) на деяких підпрямокутниках $a_{x_1 \ldots x_2, y_1 \ldots y_2}$, а також запити модифікації окремих елементів матриці (тобто запити увазі $a_{x,y} = p$).

Отже, ми будемо будувати двовимірне дерево відрізків: спочатку дерево відрізків за першою координатою ($x$), а потім - за другою ($y$).

Щоб **процес побудови** був більш зрозумілим, можна на час забути, що початковий масив був двовимірним, і залишити тільки першу координату. Будемо будувати звичайне одновимірне дерево відрізків, працюючи тільки з першою координатою. Але в якості значення кожного відрізку ми будемо записувати не яке-небудь число, як в одновимірному випадку, а ціле дерево відрізків: тобто в цей момент ми згадуємо, що у нас є ще й друга координата, але т.до. В цей момент вже зафіксовано, що перша координата є деяким відрізком $[l \ldots r]$, тому ми фактично працюємо з такою смугою $a[l \ldots r, 0 \ldots m-1]$, і для її будування ми будуємо дерево відрізків.

Наведемо реалізацію операції побудови двовимірного дерева. Вона фактично представляє собою два окремі блоки: побудова дерева відрізків по координаті $x$ (\texttt{build\_x}) і по координаті $y$ (\texttt{build\_y}). Якщо перша функція майже нічим не відрізняється від звичайного одновимірного дерева, то друга змушена розбиратися окремо з двома випадками: коли поточний відрізок по першій координаті ($[tlx \ldots trx]$) має одиничну довжину, і коли - довжину, велику одиницю. У першому випадку ми просто беремо потрібне значення з матриці $a[][]$, а в другому - об'єднуємо значення двох дерев відрізків з лівого сина і правого сина по координаті $x$.

<!--- TODO: specify code snippet id -->
``` cpp
void build_y(int vx, int lx, int rx, int vy, int ly, int ry) {
    if (ly == ry)
        if (lx == rx)
            t[vx][vy] = a[lx][ly];
        else
            t[vx][vy] = t[vx * 2][vy] + t[vx * 2 + 1][vy];
    else {
        int my = (ly + ry) / 2;
        build_y(vx, lx, rx, vy * 2, ly, my);
        build_y(vx, lx, rx, vy * 2 + 1, my + 1, ry);
        t[vx][vy] = t[vx][vy * 2] + t[vx][vy * 2 + 1];
    }
}

void build_x(int vx, int lx, int rx) {
    if (lx != rx) {
        int mx = (lx + rx) / 2;
        build_x(vx * 2, lx, mx);
        build_x(vx * 2 + 1, mx + 1, rx);
    }
    build_y(vx, lx, rx, 1, 0, m - 1);
}
```

Таке дерево відрізків займає, як і раніше, лінійний об'єм пам'яті, але вже з більшою константою: $16nm$ осередків пам'яті. Зрозуміло, що воно будується описаною вище процедурою $\rm build\_x$ також за лінійний час.

Перейдемо тепер до **обробки запитів**. Відповідати на двовимірний запит будемо за тим самим принципом: спочатку розбивати запит по першій координаті, а потім, коли ми дійдемо до якоїсь вершини дерева відрізків по першій координаті - викликати запит від відповідного дерева відрізків по другій координаті.

<!--- TODO: specify code snippet id -->
``` cpp
int sum_y(int vx, int vy, int tly, int try_, int ly, int ry) {
    if (ly > ry)
        return 0;
    if (ly == tly && try_ == ry)
        return t[vx][vy];
    int tmy = (tly + try_) / 2;
    return sum_y(vx, vy * 2, tly, tmy, ly, min(ry, tmy)) + sum_y(vx, vy * 2 + 1, tmy + 1, try_, max(ly, tmy + 1), ry);
}

int sum_x(int vx, int tlx, int trx, int lx, int rx, int ly, int ry) {
    if (lx > rx)
        return 0;
    if (lx == tlx && trx == rx)
        return sum_y(vx, 1, 0, m - 1, ly, ry);
    int tmx = (tlx + trx) / 2;
    return sum_x(vx * 2, tlx, tmx, lx, min(rx, tmx), ly, ry) + sum_x(vx * 2 + 1, tmx + 1, trx, max(lx, tmx + 1), rx, ly, ry);
}
```

Ця функція працює за час $O(\log n \log m)$, оскільки спочатку вона спускається по дереву за першою координатою, а для кожної пройденої вершини цього дерева робить запит у звичайне дерево відрізків за другою координатою. Також потрібно замінити "звичайного" на "звичайне".

Нарешті, розглянемо **запит на модифікацію**. Ми хочемо навчитися модифікувати дерево відрізків відповідно до зміни значення якого-небудь елементу $a[x][y] = p$. Зрозуміло, що зміни стануться тільки в тих вершинах першого дерева відрізків, які накривають координату $x$ (а таких буде $O(\log n)$), а для дерев відрізків, відповідних їм - зміни стануться тільки в тих вершинах, які накривають координату $y$ (і таких буде $O(\log m)$). Тому реалізація запиту на модифікацію не буде сильно відрізнятися від одновимірного випадку, тільки тепер ми спочатку спускаємося по першій координаті, а потім - по другій.

<!--- TODO: specify code snippet id -->
``` cpp
void update_y(int vx, int lx, int rx, int vy, int ly, int ry, int x, int y, int new_val) {
    if (ly == ry) {
        if (lx == rx)
            t[vx][vy] = new_val;
        else
            t[vx][vy] = t[vx * 2][vy] + t[vx * 2 + 1][vy];
    } else {
        int my = (ly + ry) / 2;
        if (y <= my)
            update_y(vx, lx, rx, vy * 2, ly, my, x, y, new_val);
        else
            update_y(vx, lx, rx, vy * 2 + 1, my + 1, ry, x, y, new_val);
        t[vx][vy] = t[vx][vy * 2] + t[vx][vy * 2 + 1];
    }
}

void update_x(int vx, int lx, int rx, int x, int y, int new_val) {
    if (lx != rx) {
        int mx = (lx + rx) / 2;
        if (x <= mx)
            update_x(vx * 2, lx, mx, x, y, new_val);
        else
            update_x(vx * 2 + 1, mx + 1, rx, x, y, new_val);
    }
    update_y(vx, lx, rx, 1, 0, m - 1, x, y, new_val);
}
```

#### Стиснення двовимірного дерева відрізків

Нехай задача наступна: є $n$ точок на площині, заданих своїми координатами $(x_i,y_i)$, і надходять запити "порахувати кількість точок, що лежать в прямокутнику $((x_1,y_1),(x_2,y_2))$". Зрозуміло, що в такому випадку будувати двовимірне дерево відрізків з $O(n^2)$ елементами є невиправдано розтріскуванням пам'яті. Більшість цієї пам'яті буде витрачена впусту, оскільки кожна окрема точка може потрапити тільки в $O(\log n)$ відрізків дерева відрізків за першою координатою, а отже, сумарний "полезний" розмір всіх дерев відрізків за другою координатою є величиною $O(n \log n)$.

Значить, вчинимо наступним чином: в кожній вершині дерева відрізків по першій координаті будемо зберігати дерево відрізків, побудоване лише за тими іншими координатами, які зустрічаються в поточному відрізку перших координат. Іншими словами, при побудові дерева відрізків всередині якоїсь вершини з номером $vx$ та кордонами $tlx, trx$, ми будемо розглядати лише ті точки, які потрапляють в цей відрізок $x \in [tlx; trx]$, та будувати дерево відрізків лише над ними.

Тим самим ми досягнемо того, що кожне дерево відрізків за другою координатою буде займати стільки пам'яті, скільки має. В результаті сумарний **обсяг пам'яті** зменшиться до $O(n \log n)$. **Відповідь на запит** ми будемо давати так само, як і раніше за $O(\log^2 n)$, просто тепер при виклику запиту до дерева відрізків за другою координатою ми повинні будемо зробити бінарний пошук за другою координатою, але асимптотика цього не погіршиться.

Але ціною стане неможливість робити будь-який запит на модифікацію: насправді, якщо з'явиться нова точка, то це призведе до того, що ми повинні будемо в якому-небудь дереві відрізків за другою координатою додати новий елемент в середину, що ефективно зробити неможливо.

В завершення відзначимо, що стислий описаний чином двовимірний граф відрізків стає практично **еквівалентним** описаній вище модифікації одновимірного графа відрізків (див. "Збереження всього підмасиву в кожній вершині графа відрізків"). Зокрема, виходить, що описуваний тут двовимірний граф відрізків - це просто приватний випадок збереження підмасиву в кожній вершині графа, де підмасив сам зберігається у вигляді графа відрізків. Звідси випливає, що якщо доводиться відмовитися від двовимірного графа відрізків через неможливість виконання того або іншого запиту, то має сенс спробувати замінити вкладений граф відрізків на яку-небудь більш потужну структуру даних, наприклад, [декартове дерево](treap).

### Дерево відрізків зі збереженням історії його значень (поліпшення до структури даних зі збереженням)

Persistent-структурою даних називається така структура даних, яка при кожній модифікації запам'ятовує свій попередній стан. Це дозволяє, при необхідності, звернутися до будь-якої цікавої нас версії цієї структури даних і виконати запит на ній.

Дерево відрізків є однією з тих структур даних, яка може бути перетворена на стійку структуру даних (звісно, ми розглядаємо ефективну стійку структуру, а не таку, яка копіює себе цілком перед кожним оновленням).

Насправді, будь-який запит на зміну в дереві відрізків призводить до зміни даних у $O(\log n)$ вершинах, причому вздовж шляху, що починається з кореня. Означає, якщо ми будемо зберігати дерево відрізків на вказівниках (тобто вказівники на лівого і правого синів зробити вказівниками, що зберігаються в вершині), то при запиті оновлення ми повинні просто створити нові вершини замість зміни наявних вершин, посилання з яких направлять на старі вершини. Таким чином, при запиті оновлення буде створено $O(\log n)$ нових вершин, в тому числі новий корінь дерева відрізків, а вся попередня версія дерева, підвішена за старий корінь, залишиться без змін.

Наведемо приклад реалізації для найпростішого дерева відрізків: коли є тільки запит підрахунку суми на підвідрізку і запит модифікації єдиного числа.

<!--- TODO: specify code snippet id -->
``` cpp
struct vertex {
    vertex *l, *r;
    int sum;

    vertex(int val) : l(NULL), r(NULL), sum(val) {}

    vertex(vertex *l, vertex *r) : l(l), r(r), sum(0) {
        if (l)
            sum += l->sum;
        if (r)
            sum += r->sum;
    }
};

vertex *build(int a[], int tl, int tr) {
    if (tl == tr)
        return new vertex(a[tl]);
    int tm = (tl + tr) / 2;
    return new vertex(build(a, tl, tm), build(a, tm + 1, tr));
}

int get_sum(vertex *t, int tl, int tr, int l, int r) {
    if (l > r)
        return 0;
    if (l == tl && tr == r)
        return t->sum;
    int tm = (tl + tr) / 2;
    return get_sum(t->l, tl, tm, l, min(r, tm)) + get_sum(t->r, tm + 1, tr, max(l, tm + 1), r);
}

vertex *update(vertex *t, int tl, int tr, int pos, int new_val) {
    if (tl == tr)
        return new vertex(new_val);
    int tm = (tl + tr) / 2;
    if (pos <= tm)
        return new vertex(update(t->l, tl, tm, pos, new_val), t->r);
    else
        return new vertex(t->l, update(t->r, tm + 1, tr, pos, new_val));
}
```

За допомогою цього підходу можна перетворити практично будь-яке дерево відрізків в структуру даних з постійним збереженням.