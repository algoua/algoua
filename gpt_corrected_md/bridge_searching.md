# Пошук мостів

Нехай задано неорієнтований граф. Містом називається таке ребро, видалення якого робить граф незв'язним (або, точніше, збільшує число компонент зв'язності). Потрібно знайти всі мости в заданому графі.

Неформально ця задача ставиться наступним чином: потрібно знайти на заданій мапі доріг всі "важливі" дороги, тобто такі дороги, що видалення будь-якої з них призведе до зникнення шляху між якоюсь парою міст.

Нижче ми опишемо алгоритм, заснований на [обхіді в глибину](dfs), і працюючий за час $O(n+m)$, де $n$ - кількість вершин, $m$ - ребер у графі.

Зауважимо, що на сайті також описаний [онлайн алгоритм пошуку мостів](bridge_searching_online) - на відміну від описаного тут алгоритму, онлайн алгоритм може підтримувати всі мости графа в змінюючомуся графі (мається на увазі додавання нових ребер).

## Алгоритм

Запустимо [обхід у глибину](dfs) з довільної вершини графа; позначимо її через $\rm root$. Зауважимо наступний **факт** (який не складно довести):

* Нехай ми знаходимося в обході в глибину і зараз просматриваємо всі ребра з вершини $v$. Якщо поточне ребро $(v,to)$ таке, що з вершини $to$ та будь-якого її нащадка в дереві обходу в глибину немає зворотного ребра в вершину $v$ або до якогось її предка, то це ребро є мостом. У протилежному випадку воно мостом не є. (Насправді, ця умова перевіряє, чи існує якийсь інший шлях з $v$ до $to$, крім як спуск по ребру $(v,to)$ дерева обходу в глибину).

Тепер залишилося навчитися перевіряти цей факт для кожної вершини ефективно. Для цього скористаємося "часом входу в вершину", який обчислюється [алгоритмом обходу в глибину](dfs).

Отже, нехай $tin[v]$ - це час початку пошуку в глибину в вершині $v$. Тепер введемо масив $fup[v]$, який дозволить нам відповідати на вищеописані запити. Час $fup[v]$ дорівнює мінімуму з часу початку пошуку в самій вершині $tin[v]$, часів початку пошуку в кожній вершині $p$, що є кінцем деякого зворотного ребра $(v,p)$, а також з усіх значень $fup[to]$ для кожної вершини $to$, яка є безпосереднім сином $v$ в дереві пошуку

$$
fup[v] = \min \cases{
tin[v], & \cr
tin[p], & {\rm for all} (v,p){\rm\ - back edge } \cr
fup[to], & {\rm for all} (v,to){\rm\ - tree edge } \cr
}
$$

Тут "зворотнє ребро" - "зворотнє зв'язок", "ребро дерева" - "деревовидний зв'язок"

Значить, з вершини $v$ або її нащадка є зворотнє ребро в її предка тоді і тільки тоді, коли знайдеться такий син $to$, що $fup[to] \le tin[v]$. (Якщо $fup[to] = tin[v]$, то це означає, що знайдеться зворотнє ребро, що приходить точно в $v$; якщо ж $fup[to] < tin[v]$, то це означає наявність зворотнього ребра в якогось предка вершини $v$).

Таким чином, якщо для поточного ребра $(v,to)$ (належить дереву пошуку) виконується $fup[to] < tin[v]$, то це ребро є мостом; в іншому випадку воно мостом не є.

## Реалізація

Якщо мова йде про реалізацію, то нам потрібно вміти розрізняти три випадки: коли ми йдемо по глибині дерева пошуку, коли йдемо по зворотньому ребру і коли намагаємося пройти по ребру дерева в зворотному напрямку. Відповідно, це випадки:

* $used[\text{було}]=\text{хибний}$ - критерій ребра дерева пошуку;
* $used[to]=\text{true}\ \text{і}\ to \neq \text{батько}$ - критерій зворотного ребра;
* $to = parent$ - критерій проходження по ребру дерева пошуку в зворотному напрямку.

Таким чином, для реалізації цих критеріїв нам потрібно передавати в функцію пошуку в глибину вершину-предка поточної вершини.

<!--- TODO: specify code snippet id -->
``` cpp
const int MAXN = ...;
vector<int> g[MAXN];
bool used[MAXN];
int timer, tin[MAXN], fup[MAXN];

void dfs(int v, int p = -1) {
    used[v] = true;
    tin[v] = fup[v] = timer++;
    for (size_t i = 0; i < g[v].size(); ++i) {
        int to = g[v][i];
        if (to == p)
            continue;
        if (used[to])
            fup[v] = min(fup[v], tin[to]);
        else {
            dfs(to, v);
            fup[v] = min(fup[v], fup[to]);
            if (fup[to] > tin[v])
                IS_BRIDGE(v, to);
        }
    }
}

void find_bridges() {
    timer = 0;
    for (int i = 0; i < n; ++i)
        used[i] = false;
    for (int i = 0; i < n; ++i)
        if (!used[i])
            dfs(i);
}
```

Тут основна функція для виклику - ${\rm знайти\_мости}$ - вона здійснює необхідну ініціалізацію та запуск обходу в глибину для кожної компоненти зв'язності графу.

При цьому ${\rm IS\_BRIDGE}(a,b)$ - це якась функція, яка буде реагувати на те, що ребро $(a,b)$ є мостом, наприклад, виводити це ребро на екран.

Константу ${\rm MAXN}$ потрібно задати на початку коду рівною максимально можливій кількості вершин у вхідному графі.

Варто зазначити, що ця реалізація некоректно працює при наявності в графі **кратних ребер**: вона фактично не звертає увагу на кратні ребра, або ребро взагалі ігнорується. Зрозуміло, кратні ребра не повинні входити в відповідь, тому при виклику $\rm IS\_BRIDGE$ можна додатково перевірити, чи не є ребро кратним, і тільки потім додавати його до відповіді. Інший спосіб - більш аккуратна робота з предками, тобто передача в $\rm dfs$ не вершини-предка, а номера ребра, по якому ми ввійшли в вершину (для цього потрібно буде додатково зберігати номера всіх ребер).

## Завдання в онлайн-суддях

Список задач, в яких потрібно шукати мости:

* [UVA #796 **"Critical Links"** [складність: низька]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=737)

* [UVA #610 **"Street Directions"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=551)