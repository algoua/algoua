# Принцип включення-виключення

Принцип включень-виключень є важливим комбінаторним прийомом, який дозволяє підраховувати розмір множин або обчислювати ймовірність складних подій.

## Формулювання за принципом включення-виключення

### Словесная формулювання

Принцип включення-виключення виглядає наступним чином:

Щоб порахувати розмір об'єднання декількох множин, потрібно підсумувати розміри цих множин **окремо**, потім відняти розміри всіх **попарних** перетинів цих множин, додати назад розміри перетинів всіх **трійок** множин, відняти розміри перетину **четвірок**, і так далі, аж до перетину **всіх** множин.

### Формулювання у термінах множин

У математичній формі, наведеній вище, словесне формулювання має наступний вигляд:

$$
\left| \bigcup_{i=1}^n A_i \right| = \sum_{i=1}^n \left| A_i \right| ~~ - \sum_{i,j : \atop 1 \le i < j \le n} \left| A_i \cap A_j \right| ~~ + \sum_{i,j,k : \atop 1 \le i < j < k \le n} \left| A_i \cap A_j \cap A_k \right| ~ - ~ \ldots ~ + ~ (-1)^{n-1} \left| A_1 \cap \ldots \cap A_n \right|.
$$

Її можна записати більш компактно через суму по підмножинах. Позначимо через $B$ множину, елементами якої є $A_i$. Отже, принцип включення-виключення має вигляд:

$$
\left| \bigcup_{i=1}^n A_i \right| = \sum_{C \subseteq B} (-1)^{size(C)-1} \left| \bigcap_{e \in C} e \right|.
$$

Цю формулу приписують Муавру (Аврааму де Муавру).

### Формулювання з використанням діаграм Венна

Нехай на діаграмі позначені три фігури: $A$, $B$ і $C$

\img{inclusion_exclusion_1.png}

Значить, площа об'єднання $A \cup B \cup C$ дорівнює сумі площ $A$, $B$ і $C$, з виключенням двічі покритих площ $A \cap B$, $A \cap C$, $B \cap C$, але з додаванням тричі покритої площі $A \cap B \cap C$

$$
S(A \cup B \cup C) = S(A) ~ + ~ S(B) ~ + ~ S(C) ~ - ~ S(A \cap B) ~ - ~ S(A \cap C) ~ - ~ S(B \cap C) ~ + ~ S(A \cap B \cap C).
$$

Аналогічним чином це узагальнюється і на об'єднання $n$ фігур.

### Формулювання з використанням теорії ймовірностей

Якщо $A_i$ $(i = 1 \ldots n)$ - це події, ${\cal P}(A_i)$ - їх ймовірності, то ймовірність їх об'єднання (тобто того, що відбудеться хоча б одна з цих подій) дорівнює:

$

$$
\begin{eqnarray}
{\cal P} \left( \bigcup_{i=1}^n A_i \right) & = & \sum_{i=1}^n {\cal P} \left( A_i \right) ~~ - \sum_{i,j : \atop 1 \le i < j \le n} {\cal P} \left( A_i \cap A_j \right) ~~ + \cr
& + & \sum_{i,j,k : \atop 1 \le i < j < k \le n} {\cal P} \left( A_i \cap A_j \cap A_k \right) ~ - ~ \ldots ~ + ~ (-1)^{n-1} {\cal P} \left( A_1 \cap \ldots \cap A_n \right). \cr
\nonumber
\end{eqnarray}
$$

$

Цю суму також можна записати у вигляді суми по підмножинах множини $B$, елементами яких є події $A_i$:

$$
{\cal P} \left( \bigcup_{i=1}^n A_i \right) = \sum_{C \subseteq B} (-1)^{size(C)-1} \cdot {\cal P} \left( \bigcap_{e \in C} e \right).
$$

## Доведення принципом включень-виключень

Для доведення зручно користуватися математичним формулюванням в термінах теорії множин:

$$
\left| \bigcup_{i=1}^n A_i \right| = \sum_{C \subseteq B} (-1)^{size(C)-1} \left| \bigcap_{e \in C} e \right|,
$$

де $B$, нагадаємо, - це множина, що складається з $A_i$.

Нам потрібно довести, що будь-який елемент, який міститься хоча б в одному з множин $A_i$, буде врахований формулою рівно один раз. (Зауважимо, що інші елементи, які не містяться ні в одному з $A_i$, не можуть бути враховані, оскільки відсутні в правій частині формули).

Розглянемо довільний елемент $x$, який міститься в $k \ge 1$ множинах $A_i$. Покажемо, що його можна порахувати за допомогою формули лише один раз.

Зазначимо, що:

* У тих доданках, у яких $|C|=1$, елемент $x$ буде врахований $k$ разів зі знаком плюс

* У тих доданках, де $size(C) = 2$, елемент $x$ буде врахований (зі знаком мінус) $C_k^2$ рази, оскільки $x$ зустрічається тільки в доданках, що відповідають двом множинам з $k$ множин, що містять $x$

* У тих доданках, де $size(C) = 3$, елемент $x$ враховується $C_k^3$ рази зі знаком плюс

* $\ldots$

* У тих доданках, де $size(C) = k$, елемент $x$ враховується $C_k^k$ разів зі знаком $(-1)^{k-1}$

* У тих доданках, де $size(C) > k$, елемент $x$ не буде врахований жодного разу.

Таким чином, нам потрібно порахувати таку суму [біноміальних коефіцієнтів](binomial_coeff):

$$
T = C_k^1 - C_k^2 + C_k^3 - \ldots + (-1)^{i-1} \cdot C_k^i + \ldots + (-1)^{k-1} \cdot C_k^k.
$$

Простіше все порахувати цю суму, порівнявши її з розкладом в біном Ньютона виразу $(1-x)^k:

$$
(1-x)^k = C_k^0 - C_k^1 \cdot x + C_k^2 \cdot x^2 - C_k^3 \cdot x^3 + \ldots + (-1)^k \cdot C_k^k \cdot x^k.
$$

Видно, що при $x=1$ вираз $(1-x)^k$ представляє собою не що інше, як $0$. Отже, $T = 1 - (1-1)^k = 1$, що і потрібно довести.

## Застосування під час розв'язання задач

Принцип включення-виключення складно зрозуміти без вивчення прикладів його застосувань.

Спочатку ми розглянемо три прості задачі "на папері", що ілюструють застосування принципу, потім розглянемо більш практичні задачі, які важко розв'язати без використання принципу включень-виключень.

Особливо варто відзначити задачу "пошук кількості шляхів", оскільки в ній демонструється, що принцип включень-виключень можна іноді застосовувати для отримання поліноміальних рішень, а не обов'язково експоненційних.

### Проста задача про перестановки

Скільки є перестановок чисел від $0$ до $9$ таких, що перший елемент більше $1$, а останній - менше $8$?

Порахуємо кількість "поганих" перестановок, тобто таких, у яких перший елемент $\leq 1$ і/або останній $\geq 8$.

Позначимо через $X$ множину перестановок, в яких перший елемент $\leq 1$, а через $Y$ - в яких останній елемент $\geq 8$. Отже, кількість "поганих" перестановок за формулою включень-виключень дорівнює:

$$
|X| + |Y| - |X \cap Y|.
$$

Провівши прості комбінаторні обчислення, отримуємо, що це дорівнює:

$$
2 \cdot 9! + 2 \cdot 9! - 2 \cdot 2 \cdot 8!
$$

Віднімаючи це число від загального числа перестановок $10!$, ми отримаємо відповідь.

### Проста задачка про (0,1,2)-послідовностях

Скільки існує послідовностей довжини $n$, що складаються тільки з чисел $0,1,2$, причому кожне число зустрічається хоча б раз?

Знову перейдемо до оберненої задачі, тобто будемо розглядати кількість послідовностей, в яких не міститься жодного з чисел.

Позначимо через $A_i$ ($i = 0 \ldots 2$) множину послідовностей, в яких не зустрічається число $i$. Отже, за формулою включень-виключень число "поганих" послідовностей дорівнює:

$$
|A_0| + |A_1| + |A_2| - |A_0 \cap A_1| - |A_0 \cap A_2| - |A_1 \cap A_2| + |A_0 \cap A_1 \cap A_2|.
$$

Розміри кожного з $A_i$ рівні $2^n$ (оскільки в таких послідовностях можуть зустрічатися тільки дві цифри). Місткості кожного попарного перетину $A_i \cap A_j$ рівні $1$ (оскільки залишається доступною тільки одна цифра). Нарешті, місткість перетину всіх трьох множин рівна $0$ (оскільки доступних цифр взагалі не залишається).

Згадуючи, що ми вирішували зворотню задачу, отримуємо підсумкову **відповідь**:

$$
3^n - 3 \cdot 2^n + 3 \cdot 1 - 0.
$$

### Кількість цілих розв'язків рівняння

Дано рівняння:

$$
x_1 + x_2 + x_3 + x_4 + x_5 + x_6 = 20,
$$

де всі $0 \le x_i \le 8$ (де $i = 1,\ldots,6$).

Потрібно порахувати кількість розв'язків цієї рівняння.

Спочатку забудемо про обмеження $x_i \le 8$ і просто порахуємо число невід'ємних рішень цього рівняння. Це легко зробити через [біноміальні коефіцієнти](binomial_coeff) - ми хочемо розбити $20$ елементів на $6$ груп, тобто розподілити $5$ "стінок", які розділяють групи, по $25$ місць:

$$
N_0 = C_{25}^5
$$

Порахуймо тепер за формулою включень-виключень кількість "поганих" рішень, тобто тих рішень рівняння, в яких один або декілька $x_i$ більше 9.

Позначимо через $A_k$ (де $k = 1 \ldots 6$) множину таких розв'язків рівняння, в яких $x_k \ge 9$, а всі інші $x_i \ge 0$ (для всіх $i \ne k$). Щоб порахувати розмір множини $A_k$, зауважимо, що по суті це та ж комбінаторна задача, що розв'язувалась двома абзацами вище, тільки тепер $9$ елементів виключені з розгляду і точно належать першій групі. Таким чином:

$$
| A_k | = C_{16}^5
$$

Аналогічно, потужність перетину двох множин $A_k$ і $A_p$ рівна числу:

$$
\left| A_k \cap A_p \right| = C_7^5
$$

Мінімальна місткість кожного перетину трьох і більш множин дорівнює нулю, оскільки для трьох і більше змінних, більше або рівних $9$, $20$ елементів недостатньо.

Об'єднавши все це у формулу включень-виключень і враховуючи, що ми вирішували зворотню задачу, отримуємо **відповідь**:

$$
C_{25}^5 - C_6^1 \cdot C_{16}^5 + C_6^2 \cdot C_7^5.
$$

### Кількість взаємно простих чисел на заданому відрізку

Нехай задані числа $n$ і $r$. Потрібно порахувати кількість чисел у відрізку $[1;r]$, які є взаємно простими з $n$.

Відразу перейдемо до зворотної задачі - порахуємо кількість чисел, які не є взаємно простими.

Розглянемо всі прості дільники числа $n$; позначимо їх через $p_i$ ($i = 1 \ldots k$).

Скільки чисел в відрізку $[1;r]$, діляться на $p_i$? Их кількість рівне:

$$
\left\lfloor \frac{ r }{ p_i } \right\rfloor
$$

Однак, якщо ми просто підсумуємо ці числа, то отримаємо неправильну відповідь - деякі числа будуть підсумовані декілька разів (те, яке ділиться одразу на кілька $p_i$). Тому треба скористатися формулою включень-виключень.

Наприклад, можна перебрати підмножини множини всіх $p_i$-х за допомогою $2^k$, порахувати їх добуток, і додати або відняти черговий доданок в формулі включень-виключень.

Підсумкова **реалізація** для підрахунку кількості взаємно простих чисел:

<!--- TODO: specify code snippet id -->
``` cpp
int solve(int n, int r) {
    vector<int> p;
    for (int i = 2; i * i <= n; ++i)
        if (n % i == 0) {
            p.push_back(i);
            while (n % i == 0)
                n /= i;
        }
    if (n > 1)
        p.push_back(n);

    int sum = 0;
    for (int msk = 1; msk < (1 << p.size()); ++msk) {
        int mult = 1, bits = 0;
        for (int i = 0; i < (int)p.size(); ++i)
            if (msk & (1 << i)) {
                ++bits;
                mult *= p[i];
            }

        int cur = r / mult;
        if (bits % 2 == 1)
            sum += cur;
        else
            sum -= cur;
    }

    return r - sum;
}
```

Асимптотика розв'язку складає $O(\sqrt{n})$.

### Кількість чисел у заданому відрізку, кратних хоча б одному з заданих чисел

Дано $n$ чисел $a_i$ і число $r$. Потрібно порахувати кількість чисел у відрізку $[1; r]$, які кратні хоча б одному з $a_i$.

Алгоритм розв'язку практично збігається з попереднім завданням - ми будуємо формулу включень-виключень над числами $a_i$. Кожен доданок в цій формулі - це кількість чисел, які діляться на піднабір чисел $a_i$ (іншими словами, діляться на їх [найменше спільне кратне](euclid_algorithm)). Російське слово "завдань" можна замінити на українське "елементів".

Таким чином, розв'язок зводиться до того, щоб за $2^n$ перебрати піднабор чисел, за $O(n \log r)$ операцій знайти їх найменше спільне кратне, і додати або відняти з відповіді наступне значення.

### Кількість рядків, що задовольняють задану кількість патернів

Дано $n$ патернів - стрічок однакової довжини, які складаються тільки з букв та знаків питання. Також задано число $k$. Потрібно порахувати кількість стрічок, які задовольняють рівно $k$ патернам або, в іншій постановці, принаймні $k$ патернам.

Зауважимо на початку, що ми можемо **легко порахувати кількість рядків**, які задовольняють зразу всім зазначеним шаблонам. Для цього потрібно просто "перетнути" ці шаблони: подивитися на перший символ (у всіх шаблонах на першій позиції має бути питання, або не у всіх - тоді перший символ визначається однозначно), на другий символ і т.д.

Навчимось тепер розв'язувати **перший вид задачі**: коли шукані рядки повинні задовольняти рівно $k$ патернам.

Для цього переберемо та зафіксуємо конкретну підмножину $X$ патернів розміру $k$. Тепер ми повинні порахувати кількість рядків, які задовольняють цьому набору патернів і тільки йому. Для цього скористаємося формулою включень-виключень: ми підсумуємо по всіх надмножинах множини $X$, і або додаємо до поточної відповіді, або віднімаємо від неї кількість рядків, відповідних поточній множині

$$
ans(X) = \sum_{Y \supseteq X} (-1)^{|Y|-k} \cdot f(Y),
$$

де $f(Y)$ позначає кількість рядків, що відповідають набору патернів $Y$.

Якщо ми підсумуємо $ans(X)$ для всіх $X$, то отримаємо відповідь:

$$
ans = \sum_{X ~ : ~ |X| = k} ans(X).
$$

Однак, таким чином ми отримали розв'язок за час порядку $O(2^k \cdot k)$.

Розв'язок можна прискорити, помітивши, що в різних $ans(X)$ підсумовування найчастіше ведеться по одним і тим же безлічам $Y$.

Перевернімо формулу включень-виключень і будемо вести підсумовування по $Y$. Очевидно, що множину $Y$ враховано в $C_{|Y|}^k$ формулах включень-виключень, де кожна формула містить множину $Y$ зі знаком $(-1)^{|Y|-k}$

$$
ans = \sum_{Y ~ : ~ |Y| \ge k} (-1)^{|Y|-k} \cdot C_{|Y|}^k \cdot f(Y).
$$

Розв'язок має асимптотику $O(2^k \cdot k)$.

Перейдемо тепер до **другого варіанту завдання**: коли шукані рядки повинні задовольняти принаймні $k$ патернам.

Зрозуміло, ми можемо скористатися розв'язком першого варіанту задачі і підсумувати відповіді від $k$ до $n$. Однак можна замітити, що всі міркування, як і раніше, будуть вірні, тільки в цьому варіанті задачі сума по $X$ йде не тільки по тим множинам, розмір яких дорівнює $k$, а по всіх множинах з розміром $\ge k$.

Таким чином, перед $f(Y)$ в ітоговій формулі буде стояти інший коефіцієнт: не один біноміальний коефіцієнт з якимось знаком, а їх сума:

$$
(-1)^{|Y|-k} \cdot C_{|Y|}^k ~~ + ~~ (-1)^{|Y|-k-1} \cdot C_{|Y|}^{k+1} ~~ + ~~ (-1)^{|Y|-k-2} \cdot C_{|Y|}^{k+2} ~~ + ~~ \ldots ~~ + ~~ (-1)^{|Y|-|Y|} \cdot C_{|Y|}^{|Y|}.
$$

Заглянув до Греама (\book{Греам, Кнут, Паташник}{"Конкретна математика"}{1998}{graham.djvu}), ми бачимо таку відому формулу для [біноміальних коефіцієнтів](binomial_coeff):

$$
\sum_{k=0}^m (-1)^k \cdot C_n^k = (-1)^m \cdot C_{n-1}^m.
$$

Застосовуючи її тут, отримуємо, що вся ця сума біноміальних коефіцієнтів скорочується до:

$$
(-1)^{|Y|-k} \cdot C_{|Y|-1}^{|Y|-k}.
$$

Таким чином, для цього варіанту задачі ми також отримали розв'язок з асимптотикою $O(2^k \cdot k)$

$$
ans = \sum_{Y ~ : ~ |Y| \ge k} (-1)^{|Y|-k} \cdot C_{|Y|-1}^{|Y|-k} \cdot f(Y).
$$

### Кількість шляхів

Є поле $n\times m$, деякі $k$ клітин цього поля є непрохідними стінками. На полі в клітинці $(1,1)$ (лівий нижній кут) спочатку знаходиться робот. Робот може рухатися тільки вправо або вгору, і в підсумку він повинен потрапити в клітинку $(n,m)$, уникнувши всі перешкоди. Потрібно порахувати кількість шляхів, якими він може це зробити.

Припускаємо, що розміри $n$ і $m$ дуже великі (наприклад, до $10^9$), а кількість $k$ - невелика (близько $100$).

Для розв'язання зразу **заради зручності відсортуємо** перешкоди в тому порядку, в якому ми можемо їх обійти: тобто, наприклад, за координатою $x$, а при рівності - за координатою $y$.

Також одразу навчимося розв'язувати задачу без перешкод: а саме, навчимося рахувати кількість способів дійти від однієї клітини до іншої. Якщо по одній координаті нам потрібно пройти $x$ клітин, а по іншій - $y$ клітин, то зі спрощеної комбінаторики ми отримуємо таку формулу через [біноміальні коефіцієнти](binomial_coeff):

$$
C_{x+y}^{x}
$$

Тепер, щоб порахувати число способів дійти від однієї клітини до іншої, уникнувши всіх перешкод, можна скористатися **формулою з обмеженням**: порахуємо число способів дійти, не наступивши на жодне перешкоди.

Для цього можна, наприклад, перебрати підмножини тих перешкод, на які ми точно наступимо, порахувати кількість способів зробити це (просто помноживши кількість способів дійти від стартової клітинки до першої з обраних перешкод, від першої перешкоди до наступної, і так далі), і потім додати або відняти цю кількість від відповіді, відповідно до стандартної формули включень-виключень.

Однак це знову буде неполіноміальний розв'язок - за асимптотику $O(2^k k)$. Покажемо, як отримати **поліноміальний розв'язок**.

Розв'язуватимемо **динамічним програмуванням**: навчимося обчислювати числа $d[i][j]$ - число способів дійти від $i$-ої точки до $j$-ої, не наступивши при цьому на жодне перешкоду (крім самих $i$ і $j$, звичайно). Всього у нас буде $k+2$ точки, оскільки до перешкод додаються стартова і кінцева клітини.

Якщо ми на секунду забудемо про всі перешкоди і просто порахуємо кількість шляхів з клітини $i$ в клітинку $j$, то тим самим ми врахуємо деякі "погані" шляхи, що проходять через перешкоди. Навчимося рахувати кількість цих "поганих" шляхів. Переберемо першу з перешкод $i < t < j$, на яку ми наступимо, тоді кількість шляхів буде рівна $d[i][t]$, помноженому на кількість довільних шляхів з $t$ в $j$. Просумувавши це по всіх $t$, ми порахуємо кількість "поганих" шляхів.

Таким чином, ми навчилися обчислювати значення $d[i][j]$ за час $O(k)$. Отже, асимптотична складність розв'язання всієї задачі становить $O(k^3)$.

### Число взаємно простих четвірок

Дано $n$ чисел: $a_1, a_2, \ldots, a_n$. Потрібно порахувати кількість способів вибрати з них чотири числа так, щоб їх спільний найбільший дільник був рівний одиниці.

Будемо розв'язувати зворотню задачу - порахуємо кількість "поганих" четвірок, тобто таких четвірок, в яких всі числа діляться на число $d > 1$.

Скористаємось формулою включень-виключень, підсумовуючи кількість четвірок, які діляться на дільник $d$ (але можливо, діляться і на більший дільник):

$$
ans = \sum_{d \ge 2} (-1)^{deg(d)-1} \cdot f(d),
$$

де $deg(d)$ - це кількість простих множників у факторизації числа $d$, $f(d)$ - кількість четвірок, що діляться на $d$.

Щоб порахувати функцію $f(d)$, потрібно просто порахувати кількість чисел, кратних $d$, та біноміальним коефіцієнтом порахувати кількість способів вибрати з них четвірку.

Таким чином, за допомогою формули включень-виключень ми підсумовуємо кількість четвірок, які діляться на прості числа. Потім віднімаємо кількість четвірок, які діляться на добуток двох простих чисел, додаємо кількість четвірок, які діляться на три простих числа і т.д. Російське слово "четвёрки" слід замінити на українське "четвірки".

### Число гармонійних трійок

Дано число $n \le 10^6$. Потрібно порахувати кількість трійок $(a,b,c)$ таких, що $2 \le a < b < c \le n$ та $(a,b,c)$ є гармонічною трійкою, тобто:

* або ${\rm gcd}(a,b) = {\rm gcd}(a,c) = {\rm gcd}(b,c) = 1$,
* або ${\rm gcd}(a,b) > 1$, ${\rm gcd}(a,c) > 1$, ${\rm gcd}(b,c) > 1$.

По-перше, зразу перейдемо до зворотної задачі - тобто порахуємо кількість неармонійних трійок.

По-друге, зауважимо, що в будь-якій негармонічній трійці рівно два її числа знаходяться в такій ситуації, що це число взаємно просте з одним числом трійки і не взаємно просте з іншим числом трійки.

Таким чином, кількість негармонічних трійок дорівнює сумі по всіх числах від $2$ до $n$ добутку кількості чисел, які є взаємно простими з поточним числом, на кількість чисел, які не є взаємно простими з ним.

Тепер все, що нам залишилося для розв'язання задачі - це навчитися враховувати для кожного числа в відрізку $[2;n]$ кількість чисел, взаємно простих (або не взаємно простих) з ним. Хоча ця задача вже розглядалась нами вище, описаний вище підхід не підходить тут - він потребує факторизації кожного з чисел від $2$ до $n$, а потім перебору всіх можливих добутків простих чисел з факторизації.

Тому нам знадобиться більш швидкий розв'язок, який обчислює відповіді для всіх чисел з діапазону $[2;n]$ одночасно.

Для цього можна реалізувати таку **модифікацію решета Єратосфена**:

* По-перше, нам потрібно знайти всі числа в інтервалі $[2;n]$, у факторизації яких жодне просте число не входить двічі. Крім того, для формули включень-виключень нам знадобиться знати, скільки простих містить факторизація кожного такого числа.

Для цього потрібно створити масиви $deg[]$, що зберігають для кожного числа кількість простих чисел у його факторизації, та $good[]$, який містить для кожного числа значення $true$ або $false$ - чи всі прості числа, що входять у нього, мають степінь $\le 1$ чи ні. Російське слово "факторизація" потрібно замінити на "розклад на прості множники".

Після цього, під час реалізації алгоритму решета Ератосфена, при обробці наступного простого числа, ми проходимося по всіх числах, кратних поточному числу, та збільшуємо $deg[]$ у них. А у всіх чисел, кратних квадрату від поточного простого, ми встановлюємо $good = false$.

* По-друге, нам потрібно порахувати відповідь для всіх чисел від $2$ до $n$, тобто масив $cnt[]$ - кількість чисел, що не є взаємно простими з даними.

Для цього згадаємо, як працює формула включення-виключення - тут фактично ми реалізуємо її, але з перевернутою логікою: ми словно перебираємо доданок і дивимося, в які формули включення-виключення для яких чисел цей доданок входить.

Отже, нехай у нас є число $i$, для якого $good[i]=\text{true}$, тобто це число бере участь у формулі включень-виключень. Переберемо всі числа, кратні $i$, і до відповіді $cnt$ кожного з таких чисел ми повинні додати або відняти величину $\lfloor N/i \rfloor$. Знак - додаток або віднімання - залежить від $deg[i]$: якщо $deg[i]$ непарне, то треба додавати, інакше віднімати.

**Реалізація**:

<!--- TODO: specify code snippet id -->
``` cpp
int n;
bool good[MAXN];
int deg[MAXN], cnt[MAXN];

long long solve() {
    memset(good, 1, sizeof good);
    memset(deg, 0, sizeof deg);
    memset(cnt, 0, sizeof cnt);

    long long ans_bad = 0;
    for (int i = 2; i <= n; ++i) {
        if (good[i]) {
            if (deg[i] == 0)
                deg[i] = 1;
            for (int j = 1; i * j <= n; ++j) {
                if (j > 1 && deg[i] == 1)
                    if (j % i == 0)
                        good[i * j] = false;
                    else
                        ++deg[i * j];
                cnt[i * j] += (n / i) * (deg[i] % 2 == 1 ? +1 : -1);
            }
        }
        ans_bad += (cnt[i] - 1) * 1ll * (n - 1 - cnt[i]);
    }

    return (n - 1) * 1ll * (n - 2) * (n - 3) / 6 - ans_bad / 2;
}
```

Асимптотика такого розв'язку складає $O(n \ln n)$, оскільки майже для кожного числа $i$ він здійснює приблизно $n/i$ ітерацій вкладеного циклу.

### Число перестановок без нерухомих точок

Доведемо, що кількість перестановок довжини $n$ без нерухомих точок рівна наступному числу:
$$
n! \cdot \sum_{i=0}^{n} \frac{(-1)^i}{i!}
$$

$$
n! - C_n^1 \cdot (n-1)! + C_n^2 \cdot (n-2)! - C_n^3 \cdot (n-3)! + \ldots \pm C_n^n \cdot (n-n)!
$$

і приблизно дорівнює числу:

$$
\frac{ n! }{ e }
$$

Більше того, якщо округлити цей вираз до найближчого цілого, то вийде число перестановок без нерухомих точок

Позначимо через $A_k$ множину перестановок довжини $n$ з фіксованою точкою в позиції $k$ ($1 \le k \le n$).

Скористаємося тепер формулою включень-виключень, щоб порахувати кількість перестановок з хоча б однією нерухомою точкою. Для цього нам потрібно навчитися розраховувати розміри перетинів множин $A_i$, вони виглядають наступним чином:

$$
\left| A_p \right| = (n-1)! ~,
$$

$$
\left| A_p \cap A_q \right| = (n-2)! ~,
$$

$$
\left| A_p \cap A_q \cap A_r \right| = (n-3)! ~,
$$

$$
\ldots ~,
$$

оскільки, якщо ми знаємо, що кількість нерухомих точок дорівнює $x$, то ми так само знаємо позиції $x$ елементів перестановки, а всі інші $(n-x)$ елементів можуть стояти де завгодно.

Підставляючи це в формулу включень-виключень і враховуючи, що кількість способів вибрати підмножину розміру $x$ з $n$-елементного множини дорівнює $C_n^x$, отримуємо формулу для кількості перестановок з принаймні однією нерухомою точкою:

$$
C_n^1 \cdot (n-1)! - C_n^2 \cdot (n-2)! + C_n^3 \cdot (n-3)! - \ldots \pm C_n^n \cdot (n-n)!
$$

Значить, кількість перестановок без нерухомих точок дорівнює:

$$
n! - C_n^1 \cdot (n-1)! + C_n^2 \cdot (n-2)! - C_n^3 \cdot (n-3)! + \ldots \pm C_n^n \cdot (n-n)!
$$

Упрощуючи цей вираз, отримуємо **точний і наближений вираз для кількості перестановок без фіксованих точок**:

$$
n! \left( 1 - \frac{1}{1!} + \frac{1}{2!} - \frac{1}{3!} + \ldots \pm \frac{1}{n!} \right) \approx \frac{n!}{e}.
$$

(Оскільки сума у дужках - це перші $n+1$ членів розкладу в ряд Тейлора $e^{-1}$)

В заключенні варто відзначити, що аналогічно вирішується задача, коли потрібно, щоб нерухомих точок не було серед $m$ перших елементів перестановок (а не серед усіх, як ми тільки що вирішували). Формула вийде така, як наведена вище точна формула, тільки в ній сума буде йти до $k$, а не до $n$.

## Завдання в онлайн-суддях

Список задач, які можна вирішити, використовуючи принцип включення-виключення:

* [UVA #10325 **"The Lottery"** [складність: низька]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1266)

* [UVA #11806 **"Cheerleaders"** [складність: низька]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2906)

* [TopCoder SRM 477 **"CarelessSecretary"** [складність: низька]](http://www.topcoder.com/stat?c=problem_statement&pm=10875)

* [TopCoder TCHS 16 **"Divisibility"** [складність: низька]](http://community.topcoder.com/stat?c=problem_statement&pm=6658&rd=10068)

* [SPOJ #6285 NGM2 **"Another Game With Numbers"** [складність: низька]](http://www.spoj.pl/problems/NGM2/)

* [TopCoder SRM 382 **"CharmingTicketsEasy"** [складність: середня]](http://community.topcoder.com/stat?c=problem_statement&pm=8470)

* [TopCoder SRM 390 **"SetOfPatterns"** [складність: середня]](http://www.topcoder.com/stat?c=problem_statement&pm=8307)

* [TopCoder SRM 176 **"Deranged"** [складність: середня]](http://community.topcoder.com/stat?c=problem_statement&pm=2013)

* [TopCoder SRM 457 **"TheHexagonsDivOne"** [складність: середня]](http://community.topcoder.com/stat?c=problem_statement&pm=10702&rd=14144&rm=303184&cr=22697599)

* [SPOJ #4191 MSKYCODE **"Sky Code"** [складність: середня]](http://www.spoj.pl/problems/MSKYCODE/)

* [SPOJ #4168 SQFREE **"Square-free integers"** [складність: середня]](http://www.spoj.pl/problems/SQFREE/)

* [CodeChef **"Count Relations"** [складність: середня]](http://www.codechef.com/JAN11/problems/COUNTREL/)

## Література

* [Debra K. Borkovitz. **"Derangements and the Inclusion-Exclusion Principle"**](http://faculty.wheelock.edu/dborkovitz/articles/ngm6.htm)