# Решітка Ератосфена

Решітка Ератосфена - це алгоритм, який дозволяє знайти всі прості числа в діапазоні $[1; n]$ за $O(n \log \log n)$ операцій.

Ідея проста - запишемо ряд чисел $1 \ldots n$, і будемо викреслювати спочатку всі числа, які діляться на $2$, крім самого числа $2$, потім діляться на $3$, крім самого числа $3$, потім на $5$, потім на $7$, $11$, і всі інші прості до $n$.

## Реалізація

Відразу наведемо реалізацію алгоритму:

<!--- TODO: specify code snippet id -->
``` cpp
int n;
vector<char> prime(n + 1, true);
prime[0] = prime[1] = false;
for (int i = 2; i <= n; ++i)
    if (prime[i])
        if (i * 1ll * i <= n)
            for (int j = i * i; j <= n; j += i)
                prime[j] = false;
```

Цей код спочатку позначає всі числа, крім нуля і одиниці, як прості, а потім починає процес відсіювання складених чисел. Для цього ми перебираємо в циклі всі числа від $2$ до $n$, і, якщо поточне число $i$ є простим, то помічаємо всі числа, кратні йому, як складові.

При цьому ми починаємо йти від $i^2$, оскільки всі менші числа, кратні $i$, обов'язково мають простий дільник менше $i$, а значить, всі вони вже були відсіяні раніше. (Але оскільки $i^2$ легко можливо переповнити тип $int$, у коді перед іншим вкладеним циклом робиться додаткова перевірка з використанням типу $long~long$).

При такій реалізації алгоритм використовує $O(n)$ пам'яті (що очевидно) і виконує $O(n \log \log n)$ операцій (це доводиться в наступному розділі).

## Асимптотика

Доведемо, що асимптотика алгоритму дорівнює $O(n \log \log n)$.

Отже, для кожного простого $p \le n$ буде виконуватися внутрішній цикл, який виконає $\frac{n}{p}$ дій. Отже, нам потрібно оцінити наступну величину:

$$
\sum_{ \scriptstyle p \le n, \atop\scriptstyle p~is~prime } \frac{n}{p} = n \cdot \sum_{ \scriptstyle p \le n, \atop\scriptstyle p~is~prime } \frac{1}{p}.
$$

Згадаймо тут два відомі факти: що кількість простих чисел, менших або рівних $n$, приблизно дорівнює $\frac{n}{\ln n}$, і що $k$-те просте число приблизно дорівнює $k \ln k$ (це випливає з першого твердження). Отже, суму можна записати таким чином:

$$
\sum_{ \scriptstyle p \le n, \atop\scriptstyle p~is~prime } \frac{1}{p} \approx \frac{1}{2} + \sum_{k=2}^{\frac{n}{\ln n}} \frac{1}{k \ln k}.
$$

Тут ми виділили перший доданок з суми, оскільки при $k = 1$ згідно наближення $k \ln k$ буде дорівнювати $0$, що призведе до ділення на нуль.

Тепер оцінимо таку суму за допомогою інтеграла від тієї ж функції по $k$ від $2$ до $\frac{n}{\ln n}$ (ми можемо використовувати таке наближення, оскільки, фактично, сума відповідає інтегралу як його наближення за формулою прямокутників):

$$
\sum_{k=2}^{\frac{n}{\ln n}} \frac{1}{k \ln k} \approx \int\limits_2^{\frac{n}{\ln n}} \frac{1}{k \ln k}\ dk.
$$

Первою похідною для підінтегральної функції є $\ln \ln k$. Виконуючи підстановку і видаляючи члени меншого порядку, отримуємо:

$$
\int\limits_2^{\frac{n}{\ln n}} \frac{1}{k \ln k}\ dk = \ln \ln \frac{n}{\ln n} - \ln \ln 2 = \ln (\ln n - \ln \ln n) - \ln \ln 2 \approx \ln \ln n.
$$

Тепер, повертаючись до початкової суми, отримуємо її приблизну оцінку:

$$
\sum_{ \scriptstyle p \le n, \atop\scriptstyle p~is~prime } \frac{n}{p} \approx n \ln \ln n + o(n),
$$

що потрібно довести?

Більш суворе доведення (і з більш точною оцінкою з точністю до константних множників) можна знайти в книзі Гарді та Райта "Вступ до теорії чисел" (стор. 349).

## Різні оптимізації решітки Ератосфена

Найбільшою недолікою алгоритму є те, що він "гуляє" по пам'яті, постійно виходячи за межі кеш-пам'яті, через що константа, яка прихована в $O(n \log \log n)$, є порівняно великою.

Крім того, для достатньо великих $n$ вузьким місцем стає обсяг використаної пам'яті.

Нижче розглянуті методи дозволяють як зменшити кількість виконуваних операцій, так і значно скоротити використання пам'яті.

### Процедура просіювання до простих коренів

Найочевиднішим моментом є те, що для знаходження всіх простих чисел до $n$ достатньо виконати просіювання тільки простими числами, які менші за корінь з $n$.

Таким чином, зміниться зовнішній цикл алгоритму:

<!--- TODO: specify code snippet id -->
``` cpp
for (int i = 2; i * i <= n; ++i)```

На асимптотику така оптимізація не впливає. Дійсно, повторивши доведення, наведене вище, ми отримаємо оцінку $n \ln \ln \sqrt{n} + o(n)$, що, згідно з властивостями логарифма, асимптотично є те саме. Хоча кількість операцій помітно зменшиться.

### Решітка просіює тільки непарні числа

Оскільки всі парні числа, крім $2$, є складовими, то можна взагалі не обробляти жодне парне число і працювати тільки з непарними числами.

По-перше, це дозволить зменшити обсяг необхідної пам'яті вдвічі. По-друге, це зменшить кількість операцій, які виконує алгоритм, приблизно вдвічі.

### Зменшення обсягу використаної пам'яті

Зауважимо, що алгоритм Ератосфена фактично оперує з $n$ бітами пам'яті. Отже, можна істотно заощадити використання пам'яті, зберігаючи не $n$ байт - змінні булевого типу, а $n$ біт, тобто $n/8$ байтів пам'яті.

Однак такий підхід - "бітове стиснення" - істотно ускладнить операції з цими бітами. Будь-яке зчитування або запис біта буде вимагати кількох арифметичних операцій, що в підсумку призведе до сповільнення алгоритму.

Таким чином, цей підхід є обґрунтованим лише у випадку, коли $n$ настільки велике, що неможливо виділити $n$ байт пам'яті. Заощадивши пам'ять у $8$ разів, ми заплатимо за це значним уповільненням алгоритму.

У завершення варто зазначити, що у мові C++ вже реалізовані контейнери, які автоматично здійснюють бітове стиснення: vector<bool> та bitset<>. Однак, якщо швидкість роботи є дуже важливою, то краще реалізувати бітове стиснення вручну, за допомогою бітових операцій - на сьогоднішній день компілятори все ще не можуть згенерувати достатньо швидкий код.

### Блочне решітка

З оптимізації "просіювання простими до кореня" випливає, що не потрібно зберігати весь масив $prime[1 \ldots n]$ протягом усього часу. Для виконання просіювання достатньо зберігати лише прості числа до кореня з $n$, тобто $prime[1 \ldots \sqrt{n}]$, а решту масиву $prime$ можна будувати блоками, зберігаючи в поточний момент часу лише один блок.

Нехай $s$ - константа, що визначає розмір блоку. Тоді всього буде $\left\lceil \frac{n}{s} \right\rceil$ блоків, $k$-ий блок ($k = 0 \ldots \left\lfloor \frac{n}{s} \right\rfloor$) містить числа в інтервалі $[ks; ks+s-1]$. Будемо обробляти блоки по черзі, тобто для кожного $k$-го блоку будемо перебирати всі прості числа (від $1$ до $\sqrt{n}$) і виконувати ними просіювання тільки всередині поточного блоку. Акуратно варто обробляти перший блок: по-перше, прості числа з $[1; \sqrt{n}]$ не повинні вилучати самі себе, по-друге, числа $0$ і $1$ повинні бути особливо позначені як непрості. При обробці останнього блоку також випливає необхідність пам'ятати про те, що останнє потрібне число $n$ не обов'язково знаходиться в кінці блоку.

Наведемо реалізацію блочного сита. Програма зчитує число $n$ і знаходить кількість простих чисел від $1$ до $n$:

<!--- TODO: specify code snippet id -->
``` cpp
константа int SQRT_MAXN = 100000; // корінь з максимального значення N
const int S = 10000;
bool nprime[SQRT_MAXN], bl[S];
int primes[SQRT_MAXN], cnt;

int main() {
    int n;
    cin >> n;
    int nsqrt = (int)sqrt(n + .0);
    for (int i = 2; i <= nsqrt; ++i)
        if (!nprime[i]) {
            primes[cnt++] = i;
            if (i * 1ll * i <= nsqrt)
                for (int j = i * i; j <= nsqrt; j += i)
                    nprime[j] = true;
        }

    int result = 0;
    for (int k = 0, maxk = n / S; k <= maxk; ++k) {
        memset(bl, 0, sizeof bl);
        int start = k * S;
        for (int i = 0; i < cnt; ++i) {
            int start_idx = (start + primes[i] - 1) / primes[i];
            int j = max(start_idx, 2) * primes[i] - start;
            for (; j < S; j += primes[i])
                bl[j] = true;
        }
        if (k == 0)
            bl[0] = bl[1] = true;
        for (int i = 0; i < S && start + i <= n; ++i)
            if (!bl[i])
                ++result;
    }
    cout << result;
}
```

Асимптотика блочного решета така сама, як і звичайного решета Ератосфена (якщо, звісно, розмір $s$ блоків не буде занадто малим), але об'єм використовуваної пам'яті скоротиться до $O(\sqrt{n} + s)$ і зменшиться "блукання" по пам'яті. Але, з іншого боку, для кожного блоку для кожного простого з $[1; \sqrt{n}]$ буде виконуватися ділення, що суттєво вплине на швидкість при менших розмірах блоку. Отже, при виборі константи $s$ необхідно дотримуватися балансу.

Як показують експерименти, найкраща швидкість роботи досягається, коли $s$ має значення приблизно від $10^4$ до $10^5$.

### Покращення роботи до лінійного часу

Алгоритм Ератосфена можна перетворити на інший алгоритм, який буде працювати за лінійний час - див. статтю ["Решітка простих чисел з лінійним часом роботи"](prime_sieve_linear). (Проте, цей алгоритм має свої недоліки).