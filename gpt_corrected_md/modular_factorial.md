# Обчислення факторіала за модулем

У деяких випадках потрібно враховувати простий модуль $p$ при обчисленні складних формул, які можуть містити факторіали. Тут ми розглянемо випадок, коли $p$ є порівняно малим. Очевидно, що ця задача має сенс лише тоді, коли факторіали зустрічаються як у чисельнику, так і у знаменнику дробів. Факторіал $p!$ та всі наступні обертаються в нуль за модулем $p$. Проте у дробах всі множники, які містять $p$, можуть скоротитися, і отриманий вираз буде відмінним від нуля за модулем $p$.

Таким чином, формально **завдання** полягає в обчисленні $n!$ за простим модулем $p$, при цьому не враховуючи всі кратні $p$ множники, що входять до факторіалу. Навчившись ефективно обчислювати такий факторіал, ми зможемо швидко обчислювати значення різних комбінаторних формул (наприклад, [біноміальні коефіцієнти](https://uk.wikipedia.org/wiki/%D0%91%D1%96%D0%BD%D0%BE%D0%BC%D1%96%D0%B0%D0%BB%D1%8C%D0%BD%D0%B8%D0%B9_%D0%BA%D0%BE%D0%B5%D1%84%D1%96%D1%86%D1%96%D1%94%D0%BD%D1%82)).

## Алгоритм

Випишемо цей "модифікований" факторіал у явному вигляді:

$$
n!_{\%p} =
$$

$$
= 1 \cdot 2 \cdot 3 \cdot \ldots \cdot (p-2) \cdot (p-1) \cdot \underbrace{1}_{p} \cdot (p+1) \cdot (p+2) \cdot \ldots \cdot (2p-1) \cdot \underbrace{2}_{2p} \cdot (2p+1) \cdot \ldots \cdot
$$

$$
\cdot (p^2-1) \cdot \underbrace{1}_{p^2} \cdot (p^2+1) \cdot \ldots \cdot n =
$$

$$
= 1 \cdot 2 \cdot 3 \cdot \ldots \cdot (p-2) \cdot (p-1) \cdot \cdot \underbrace{1}_{p} \cdot 1 \cdot 2 \cdot \ldots \cdot (p-1) \cdot \underbrace{2}_{2p} \cdot 1 \cdot 2 \cdot \ldots \cdot (p-1) \cdot \underbrace{1}_{p^2} \cdot
$$

$$
\cdot 1 \cdot 2 \cdot \ldots \cdot (n\%p) \pmod p.
$$

При такій записі видно, що "змодифікований" факторіал розпадається на кілька блоків довжини $p$ (останній блок, можливо, коротший), які всі однакові, за винятком останнього елементу:

$$
n!_{\%p} = \underbrace{ 1 \cdot 2 \cdot \ldots \cdot (p-2) \cdot (p-1) \cdot 1}_{1st} \cdot \underbrace{ 1 \cdot 2 \cdot \ldots \cdot (p-1) \cdot 2 }_{2nd} \cdot \ldots \cdot \underbrace{ 1 \cdot 2 \cdot \ldots \cdot (p-1) \cdot 1 }_{p-th} \cdot \ldots \cdot
$$

$$
\cdot \underbrace{ 1 \cdot 2 \cdot \ldots \cdot (n\%p)}_{tail} \pmod p.
$$

Загальну частину блоків можна легко порахувати - це просто $(p-1)!\ {\rm mod}\ p$, яку можна порахувати програмно або за теоремою Вільсона зразу знайти $(p-1)!\ {\rm mod}\ p = p-1$. Щоб перемножити ці загальні частини всіх блоків, потрібно зведену величину піднести до ступеня за модулем $p$, що можна зробити за $O(\log n)$ операцій (див. [Бінарне піднесення до ступеня](binary_pow); проте можна замітити, що ми фактично підносимо мінус одиницю до деякого степеня, тому результатом завжди буде або $1$, або $p-1$, залежно від парності показника. Значення в останньому, неповному блоку також можна порахувати окремо за $O(p)$. Залишилися тільки останні елементи блоків, розглянемо їх уважніше:

$$
n!_{\%p} = \underbrace{ \ldots \cdot 1 } \cdot \underbrace{ \ldots \cdot 2 } \cdot \underbrace{ \ldots \cdot 3 } \cdot \ldots \cdot \underbrace{ \ldots \cdot (p-1) } \cdot \underbrace{ \ldots \cdot 1 } \cdot \underbrace{ \ldots \cdot 1 } \cdot \underbrace{ \ldots \cdot 2 } \ldots
$$

І ми знову дійшли до "модифікованого" факторіалу меншої розмірності (стільки, скільки було повних блоків, а їх було $\left\lfloor n / p \right\rfloor$). Таким чином, обчислення "модифікованого" факторіалу $n!_{\%p}$ ми звели за $O(p)$ операцій до обчислення вже $(n/p)!_{\%p}$. Розкриваючи цю рекурентну залежність, ми отримуємо, що глибина рекурсії буде $O(\log_p n)$, отже **асимптотика** алгоритму складає $O

## Реалізація

Зрозуміло, що при реалізації не обов'язково використовувати рекурсію у явному вигляді: оскільки рекурсія хвостова, її легко розвернути в цикл.

<!--- TODO: specify code snippet id -->
``` cpp
int factmod(int n, int p) {
    int res = 1;
    while (n > 1) {
        res = (res * ((n / p) % 2 ? p - 1 : 1)) % p;
        for (int i = 2; i <= n % p; ++i)
            res = (res * i) % p;
        n /= p;
    }
    return res % p;
}
```

Ця реалізація працює за $O(p \log_p n)$.