# Пошук усіх тандемних повторів у рядках. Алгоритм Мейна-Лоренца

Дана рядок $s$ довжини $n$.

**Тандемним повтором** (тандемним повторенням) називаються два входження однієї і тієї ж підстрічки, що знаходяться в рядку поруч. Іншими словами, тандемне повторення можна описати парою індексів $i < j$, для яких підстрічка $s[i \ldots j]$ складається з двох однакових підряд розташованих стрічок.

Задача полягає в тому, щоб **знайти всі тандемні повтори**. Спрощені варіанти цієї задачі полягають у знаходженні **будь-якого** тандемного повтору або **довгого** тандемного повтору.

Зауваження. Щоб уникнути плутанини, всі рядки в статті будемо вважати індексованими з нуля, тобто перший символ рядка має індекс 0.

Описаний тут алгоритм був опублікований у 1982 році Мейном і Лоренцем (див. список літератури).

## Приклад

Розглянемо тандемні повтори на прикладі якої-небудь простої стрічки, наприклад:

$$
"acababaee"
$$

У цьому реченні присутні такі тандемні повтори:

* $[2;5] = "abab"$
* $[3;6] = "baba"$
* $[7;8] = "ee"$

Інший приклад:

$$
"abaaba"
$$

Тут є лише два повторення тандемів:

* $[0;5] = "abaaba"$
* $[2;3] = "aa"$

## Число тандемних повторів

Загалом кажучи, кількість тандемних повторів у стрічках довжини $n$ може бути порядку $O(n^2)$.

Очевидним прикладом є стрічка, складена з $n$ однакових букв - у такій стрічці тандемним повтором є будь-яка підстрічка парної довжини, кількість яких становить приблизно $n^2 / 4$. Загалом, будь-яка періодична стрічка з коротким періодом буде містити дуже багато тандемних повторів

З іншого боку, сам по собі цей факт ніяк не перешкоджає існуванню алгоритму з асимптотикою $O(n \log n)$, оскільки алгоритм може видаляти тандемні повтори у тому чи іншому стислому вигляді групами по декілька штук одразу.

Більше того, існує поняття **серій** - четвірок чисел, які описують цілу групу періодичних підстрічок. Було доведено, що кількість серій у будь-якій стрічці лінійно залежить від довжини стрічки.

Проте, описаний нижче алгоритм не використовує поняття серій, тому не будемо деталізувати це поняття.

Наведемо тут інші цікаві результати, що стосуються кількості тандемних повторень:

* Відомо, що якщо розглядати лише примітивні тандемні повтори (тобто ті, чиї половинки не є кратними рядками), то їх кількість у будь-якій стрічці складає $O(n \log n)$.

* Якщо кодувати тандемні повтори трійками чисел $(i,p,r)$ (називається трійками Крочемора (Crochemore)), де $i$ - позиція початку, $p$ - довжина повторюваної підстрічки, $r$ - кількість повторів, то всі тандемні повтори будь-якої стрічки можна вивести з допомогою $O(n \log n)$ таких трійок. Такий результат отримується на виході алгоритму Крочемора знаходження всіх тандемних повторів.

* Рядки Фібоначчі визначаються наступним чином:

$$
t_0 = b,
$$

$$
t_1 = a,
$$

$$
t_i = t_{i-1} + t_{i-2},
$$

є "сильно" периодичными.

Число тандемних повторів у $i$-ій стрічці Фібоначчі довжини $f_i$, навіть стиснених за допомогою трійок Крочемора, становить $O(f_i \log f_i)$.

Число примітивних тандемних повторів у рядках Фібоначчі також має порядок $O(f_n \log f_n)$.

## Алгоритм Мейн-Лоренца

Ідея алгоритму Мейна-Лоренца досить стандартна: це алгоритм "розділяй і володарюй".

Коротко, він полягає в тому, що початковий рядок розбивається навпіл, розв'язок запускається окремо від кожної з двох половинок (тим самим ми знайдемо всі тандемні повтори, що розташовані тільки в першій або тільки в другій половині). Далі йде сама складна частина - знаходження тандемних повторів, які починаються в першій половині і закінчуються у другій (назвемо такі тандемні повтори для зручності **перетинаючими**). Як саме це робиться - і є сама суть алгоритму Мейн-Лоренца; ми детально опишемо це нижче.

Асимптотика алгоритму "розділяй і володарюй" добре досліджена. Зокрема, для нас важливо, що якщо ми навчимося шукати перетинаючі тандемні повтори в рядках довжини $n$ за $O(n)$, то підсумкова асимптотика всього алгоритму буде $O(n \log n)$.

### Пошук перетину тандемних повторів

Отже, алгоритм Мейн-Лоренца зводиться до того, щоб навчитися шукати всі перетинаючіся тандемні повтори за заданою стрічкою $s$, тобто такі, що починаються в першій половині стрічки і закінчуються в другій.

Позначимо $u$ та $v$ дві підрядки стрічки $s$, які є її половинками

$$
s = u + v
$$

(їх довжини приблизно дорівнюють довжині рядка $s$, розділеної навпіл).

#### Праві та ліві тандемні повторення

Розглянемо довільний тандемний повтор і подивимося на його середній символ (точніше, на той символ, з якого починається друга половина тандема; тобто якщо тандемний повтор - це підстрічка $s[i \ldots j]$, то середнім символом буде $(i+j+1)/2$.

Значить, назвемо тандемний повтор "лівим" або "правим" залежно від того, де знаходиться цей символ - у стрічці $u$ чи у стрічці $v$. (Можна сказати і так: тандемний повтор називається "лівим", якщо більша його частина лежить у лівій половині стрічки $s$; інакше - тандемний повтор називається "правим").

Навчимося знаходити **всі ліві тандемні повтори**; для правих все буде аналогічно.

#### Центральна позиція $cntr$ тандемного повторення

Позначимо довжину шуканого лівого тандемного повтору через $k$ (тобто довжина кожної половинки тандемного повтору - це $k$). Розглянемо перший символ тандемного повтору, що потрапляє в стрічку $v$ (він має значення в стрічці $s$ на позиції $length(u)$). Він збігається з символом, що стоїть на $k$ позицій раніше нього; позначимо цю позицію через $cntr$.

Шукатимемо всі тандемні повтори, перебираючи дану позицію $cntr$. Тобто, спочатку знайдемо всі тандемні повтори з однаковим значенням $cntr$, потім з іншим значенням і так далі, перебираючи всі можливі значення $cntr$ від $0$ до $length(u)-1$.

Наприклад, розглянемо такий рядок:

$$
s = "cac|ada"
$$

(символ вертикальної риски розділяє дві половинки $u$ та $v$)

Тандемний повтор "сaca", що міститься в цьому рядку, буде виявлений, коли ми переглянемо значення $cntr = 1$. Саме в позиції $1$ повинен бути символ 'с', який збігається з першим символом тандемного повтору, який потрапив до половини $v$.

#### Критерій наявності тандемного повтору з заданим центром $cntr$

Отже, ми повинні навчитися швидко знаходити всі тандемні повтори, що відповідають зафіксованому значенню $cntr$.

Отримуємо таку схему (для абстрактної стрічки, в якій міститься тандемний повтор $"abcabc"$):

$$$
\setlength{\unitlength}{2mm}

\begin{picture}(30,20)

* nethickness{0.075mm}
\put(0,10)%
{\line(0,1){2}}
\put(30,10)%
{\line(0,1){2}}
\put(0,10)%
{\line(1,0){30}}
\put(0,12)%
{\line(1,0){30}}

\put(10.5,10)%
{\line(0,1){2}}
\put(12,10)%
{\line(0,1){2}}
\put(11.25,6.1)%
{\vector(0,1){3.4}}
\put(10.5,5)%
{$cntr$}

* nethickness{0.4mm}
\put(15,10)%
{\line(0,1){2}}
* nethickness{0.075mm}

\put(9.3,10.5)
{a}
\put(10.8,10.5)
{b}
\put(12.3,10.5)
{c}
\put(13.8,10.5)
{a}
\put(15.3,10.5)
{b}
\put(16.8,10.5)
{c}

\put(12,12.5)%
{\oval(3,0.6)[t]}
\put(11.5,13.5)%
{$l_2$}
\put(16.5,12.5)%
{\oval(3,0.6)[t]}
\put(16,13.5)%
{$l_2$}

\put(9.75,9.5)%
{\oval(1.5,0.6)[b]}
\put(9.1,7.5)%
{$l_1$}
\put(14.25,9.5)%
{\oval(1.5,0.6)[b]}
\put(13.6,7.5)%
{$l_1$}

\end{picture}
$$$

Тут ми обозначили довжини двох шматочків тандемного повтору як $l_1$ та $l_2$: $l_1$ - довжина частини тандемного повтору до позиції $cntr-1$, а $l_2$ - довжина частини тандемного повтору від $cntr$ до кінця половинки тандемного повтору. Таким чином, $l_1+l_2+l_1+l_2$ є довжиною тандемного повтору.

Взгляньте на цю картинку, можна зрозуміти, що **необхідна і достатня** умова того, що з центром в позиції $cntr$ знаходиться тандемний повтор довжини $2 l = 2 (l_1 + l_2) = 2 (length(u) - cntr)$, полягає у наступному:

* Нехай $k_1$ - це найбільше число таке, що $k_1$ символів перед позицією $cntr$ співпадають з останніми $k_1$ символами рядка $u$:

$$
u[ cntr-k_1 \ldots cntr-1 ] == u[ length(u)-k_1 \ldots length(u)-1 ].
$$

* Нехай $k_2$ - це найбільше число таке, що $k_2$ символів, починаючи з позиції $cntr$, співпадають з першими $k_2$ символами рядка $v$:

$$
u[ cntr \ldots cntr+k_2-1] == v[ 0 \ldots k_2-1 ].
$$

* Значить, потрібно виконати:

$$
\cases{
l_1 \le k_1, \cr
l_2 \le k_2.
}
$$

Цей критерій можна **переформулювати** наступним чином. Зафіксуємо певне значення $cntr$, тоді:

* Усі тандемні повтори, які ми будемо зараз виявляти, матимуть довжину $2l = 2(length(u) - cntr)$.

Однак таких тандемних повторів може бути кілька: все залежить від вибору довжин шматочків $l_1$ і $l_2 = l - l_1$.

* Знайдемо $k_1$ та $k_2$, як описано вище.

* Значить, підходящими будуть тандемні повтори, для яких довжини шматочків $l_1$ та $l_2$ задовольняють умови:

$$
\cases{
l_1 + l_2 = l = length(u) - cntr, \cr
l_1 \le k_1, \cr
l_2 \le k_2.
}
$$

#### Алгоритм знаходження довжин $k_1$ і $k_2$

Отже, вся задача зводиться до швидкого обчислення довжин $k_1$ і $k_2$ для кожного значення $cntr$.

Нагадаємо їхнє визначення:

* $k_1$ - найбільше невід'ємне число, для якого виконується:

$$
u[ cntr-k_1 \ldots cntr-1 ] == u[ length(u)-k_1 \ldots length(u)-1 ].
$$

* $k_2$ - найбільше невід'ємне число, для якого виконується:

$$
u[ cntr \ldots cntr+k_2-1] == v[ 0 \ldots k_2-1 ].
$$

На обидва ці запити можна відповісти за $O(1)$, використовуючи **[алгоритм знаходження Z-функції](https://uk.wikipedia.org/wiki/Z-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D1%96%D1%8F)**:

* Для швидкого знаходження значень $k_1$ заздалегідь порахуємо Z-функцію для стрічки $\overline{u}$ (тобто стрічки $u$, записаної в зворотному порядку).

Значення $k_1$ для конкретного $cntr$ буде просто рівне відповідним значенням масиву Z-функції.

* Для швидкого знаходження значень $k_2$ заздалегідь порахуємо Z-функцію для рядка $v+\#+u$ (тобто рядка $u$, доданого до рядка $v$ через символ-роздільник).

Знову ж таки, значення $k_2$ для конкретного $cntr$ потрібно буде просто взяти з відповідного елементу Z-функції.

#### Пошук правильних тандемних повторів

До цього моменту ми працювали тільки з лівими тандемними повтореннями.

Щоб шукати правильні тандемні повтори, потрібно діяти аналогічно: ми визначаємо центр $cntr$ як символ, що відповідає останньому символу тандемного повтору, який потрапив до першого рядка.

Значить, довжина $k_1$ буде визначатися як найбільше число символів до позиції $cntr$ включно, що співпадають з останніми символами рядка $u$. Довжина $k_2$ буде визначатися як максимальна кількість символів, що починаються з $cntr+1$ та співпадають з першими символами рядка $v$.

Таким чином, для швидкого знаходження $k_1$ та $k_2$ потрібно буде заздалегідь порахувати Z-функцію для стрічок $\overline{u} \# \overline{v}$ та $v`$ відповідно. Після цього, перебираючи конкретне значення $cntr$, ми за тим самим критерієм будемо знаходити всі праві тандемні повтори.

#### Асимптотика

Асимптотика алгоритму Мейн-Лоренца становить $O(n \log n)$. Оскільки цей алгоритм є алгоритмом "розділяй і володарюй", кожен рекурсивний запуск працює за час, лінійний щодо довжини рядка. Для кожних чотирьох рядків за лінійний час знаходиться їх [Z-функція](https://uk.wikipedia.org/wiki/Z-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D1%96%D1%8F), а потім перебираються значення $cntr$, після чого виводяться всі групи виявлених тандемних повторів.

Тандемні повтори виявляються алгоритмом Мейн-Лоренца у вигляді своєрідних **груп**: таких четвірок $(центр, l, к_1, к_2)$, кожна з яких позначає групу тандемних повторів з довжиною $l$, центром $центр$ і з усіма можливими довжинами шматочків $l_1$ і $l_2$, що задовольняють умовам:

$$
\cases{
l_1 + l_2 = l, \cr
l_1 \le k_1, \cr
l_2 \le k_2.
}
$$

## Реалізація

Наведемо реалізацію алгоритму Мейн-Лоренца, яка за час $O(n \log n)$ знаходить всі тандемні повтори даної стрічки у стислому вигляді (у вигляді груп, описуваних чотирма числами).

У цілях демонстрації виявлені тандемні повтори за час $O(n^2)$ "розгортаються" і виводяться окремо. Цей висновок при вирішенні реальних задач легко можна замінити на інші, більш ефективні дії, наприклад, на пошук найдовшого тандемного повтору або підрахунок кількості тандемних повторів.

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> z_function(const string &s) {
    int n = (int)s.length();
    vector<int> z(n);
    for (int i = 1, l = 0, r = 0; i < n; ++i) {
        if (i <= r)
            z[i] = min(r - i + 1, z[i - l]);
        while (i + z[i] < n && s[z[i]] == s[i + z[i]])
            ++z[i];
        if (i + z[i] - 1 > r)
            l = i, r = i + z[i] - 1;
    }
    return z;
}

void output_tandem(const string &s, int shift, bool left, int cntr, int l, int l1, int l2) {
    int pos;
    if (left)
        pos = cntr - l1;
    else
        pos = cntr - l1 - l2 - l1 + 1;
    cout << "[" << shift + pos << ".." << shift + pos + 2 * l - 1 << "] = " << s.substr(pos, 2 * l) << endl;
}

void output_tandems(const string &s, int shift, bool left, int cntr, int l, int k1, int k2) {
    for (int l1 = 1; l1 <= l; ++l1) {
        if (left && l1 == l)
            break;
        if (l1 <= k1 && l - l1 <= k2)
            output_tandem(s, shift, left, cntr, l, l1, l - l1);
    }
}

inline int get_z(const vector<int> &z, int i) { return 0 <= i && i < (int)z.size() ? z[i] : 0; }

void find_tandems(string s, int shift = 0) {
    int n = (int)s.length();
    if (n == 1)
        return;

    int nu = n / 2, nv = n - nu;
    string u = s.substr(0, nu), v = s.substr(nu);
    string ru = string(u.rbegin(), u.rend()), rv = string(v.rbegin(), v.rend());

    find_tandems(u, shift);
    find_tandems(v, shift + nu);

    vector<int> z1 = z_function(ru), z2 = z_function(v + '#' + u),

                z3 = z_function(ru + '#' + rv), z4 = z_function(v);
    for (int cntr = 0; cntr < n; ++cntr) {
        int l, k1, k2;
        if (cntr < nu) {
            l = nu - cntr;
            k1 = get_z(z1, nu - cntr);
            k2 = get_z(z2, nv + 1 + cntr);
        } else {
            l = cntr - nu + 1;
            k1 = get_z(z3, nu + 1 + nv - 1 - (cntr - nu));
            k2 = get_z(z4, (cntr - nu) + 1);
        }
        if (k1 + k2 >= l)
            output_tandems(s, shift, cntr < nu, cntr, l, k1, k2);
    }
}
```

## Література

* [Michael Main, Richard J. Lorentz. **An O (n log n) Algorithm for Finding All Repetitions in a String** [1982]](http://www.cs.colorado.edu/department/publications/reports/docs/CU-CS-241-82.pdf)

* Bill Smyth. **Computing Patterns in Strings** [2003]

* Білл Сміт. **Методи та алгоритми обчислень на рядках** [2006]