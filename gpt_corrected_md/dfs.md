# Пошук у глибину

Це є один з основних алгоритмів на графах.

У результаті пошуку в глибину знайдено лексикографічно перший шлях у графі.

Алгоритм працює з часовою складністю **O(N+M)**.

## Застосування алгоритму

* Пошук будь-якого шляху в графі.
* Пошук лексикографічно першого шляху в графі.
* Перевірка, чи є одна вершина дерева предком іншої:
На початку та наприкінці ітерації пошуку в глибину буде запам'ятовуватися "час" входу та виходу у кожній вершині. Тепер за допомогою O(1) можна знайти відповідь: вершина i є предком вершини j тоді й тільки тоді, коли start<sub>i</sub> < start<sub>j</sub> і end<sub>i</sub> > end<sub>j</sub>.
* Задача НЗП (найменший загальний предок)
* [Топологічна сортування](topological_sort):
Запускаємо послідовний пошук в глибину, щоб обійти всі вершини графа. Відсортовуємо вершини за часом виходу у порядку зменшення - це є відповіддю.
* Перевірка графа на ациклічність та знаходження циклу
* Пошук компонентів сильної зв'язності:
Спочатку робимо топологічне сортування, потім транспонуємо граф і знову проводимо серію пошуків у глибину в порядку, що визначається топологічним сортуванням. Кожне дерево пошуку - сильно зв'язна компонента.
* [Пошук мостів](bridge_searching):
Спочатку перетворюємо граф на орієнтований, роблячи серію проходжень у глибину, та орієнтуючи кожне ребро так, щоб ми намагалися пройти по ньому. Потім знаходимо сильно зв'язні компоненти. Мостами є ті ребра, кінці яких належать різним сильно зв'язним компонентам.

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
vector<vector<int>> g; // граф
int вершин;                 // кількість вершин

vector<int> кольори; // кольори вершин (0, 1 або 2)

вектори `time_in` та `time_out` містять "час" заходу та виходу з вершини
int timer_dfs = 0;             // "таймер" для визначення часу

void dfs(int v) {
    time_in[v] = dfs_timer++;
    color[v] = 1;
    for (vector<int>::iterator i = g[v].begin(); i != g[v].end(); ++i)
        if (color[*i] == 0)
            dfs(*i);
    color[v] = 2;
    time_out[v] = dfs_timer++;
}
```
Це найбільш загальний код. У багатьох випадках часи заходу і виходу з вершини не є важливими, так само як і кольори вершин (але тоді потрібно ввести аналогічний за змістом булевий масив used). Ось найпростіша реалізація:

<!--- TODO: specify code snippet id -->
``` cpp
vector<vector<int>> g; // граф
int вершин;           // кількість вершин

vector<char> used;

void dfs(int v) {
    used[v] = true;
    for (vector<int>::iterator i = g[v].begin(); i != g[v].end(); ++i)
        if (!used[*i])
            dfs(*i);
}
```