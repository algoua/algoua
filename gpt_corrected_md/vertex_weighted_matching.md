# Знаходження найважливішого за вагою вершинно-зваженого паросполучення

Даний двудольний граф G. Для кожної вершини першої частини вказано її вага. Потрібно знайти паросполуку найбільшої ваги, тобто з найбільшою сумою ваг насичених вершин.

Нижче ми опишемо і доведемо алгоритм, заснований на [алгоритмі Куна](kuhn_matching), який буде знаходити оптимальне розв'язок.

## Алгоритм

Сам алгоритм надзвичайно простий. **Відсортуємо** вершини першої частини в порядку зменшення (точніше кажучи, незростання) ваг, і застосуємо до отриманого графу **[алгоритм Куна](https://uk.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9A%D1%83%D0%BD%D0%B0)**.

Стверджується, що отримана при цьому максимальна (з точки зору кількості ребер) паросполука буде оптимальною з точки зору суми ваг насичених вершин (незважаючи на те, що після сортування ми фактично більше не використовуємо ці ваги).

Таким чином, реалізація буде приблизно такою:

<!--- TODO: specify code snippet id -->
``` cpp
int n;
vector<vector<int>> g(n);
vector<char> used(n);
масив int order(n); // список вершин, відсортований по вазі
... читання...

    for (int i = 0; i < n; ++i) {
    int v = order[i];
    used.assign(n, false);
    try_kuhn(v);
}
```
Функція try_kuhn() береться без будь-яких змін з алгоритму Куна.

## Доведення

Нагадаємо основні положення **теорії матроїдів**.

Матроїд M - це упорядкована пара (S, I), де S - деяка множина, I - непорожня сім'я підмножин множини S, які задовольняють наступні умови:

<ol>
* Безліч S кінцеве.
* Сімейство $I$ є успадковуваним, тобто якщо деяка множина належить $I$, то всі її підмножини також належать $I$.
* Структура М володіє властивістю заміни, тобто якщо A належить I, і B належить I, і |A|<|B|, то знайдеться такий елемент x, який належить A-B, що A об'єднане з x належить I.
</ol>
Елементи сім'ї I називаються незалежними підмножинами.

Матроїд називається зваженим, якщо для кожного елементу $x\in S$ визначена деяка вага. Вагою підмножини називається сума ваг його елементів.

Нарешті, найважливіша теорема в теорії взважених матроїдів: для отримання оптимальної відповіді, тобто незалежної підмножини з найбільшим вагою, потрібно діяти жадібно: починаючи з порожньої підмножини, будемо додавати (якщо, звісно, поточний елемент можна додати без порушення незалежності) всі елементи по одному в порядку зменшення (точніше, невиростаючого) їх ваги:

<!--- TODO: specify code snippet id -->
``` cpp
відсортувати множину S за невисхідною вагою
ans = [];
foreach (x in S)
    if (ans & cup; x & isin; I)
        ans = ans & cup;
x;
```
Стверджується, що після завершення цього процесу ми отримаємо підмножину з найбільшою вагою.

Тепер доведемо, що наша задача - це не що інше, як зважений матроїд.

Нехай S - множина всіх вершин першої частини. Щоб звести нашу задачу в двудольному графі до матроїду щодо вершин першої частини, поставимо відповідність кожному паросполученню таку підмножину S, яка складається з насичених вершин першої частини. Можна також визначити зворотню відповідність (з множини насичених вершин - в паросполучення), яка, хоча і не буде однозначною, однак цілком підійде для наших потреб.

Значить, визначимо сімейство $\mathcal{I}$ як сімейство таких підмножин множини $S$, для яких знайдеться хоча б одна відповідна паросполучення.

Далі, для кожного елементу S, тобто для кожної вершини першої частини, за умови визначена деяка вага. При цьому вага підмножини, як нам і потрібно в рамках теорії матроїдів, визначається як сума ваг елементів у ньому.

Значить, задача про знаходження паросполучення найбільшої ваги тепер переформулюється як задача знаходження незалежної підмножини найбільшої ваги.

Залишилося перевірити, що виконані три вищеописані умови, накладені на матроїд. По-перше, очевидно, що S є скінченним. По-друге, очевидно, що видалення ребра з паросполучення еквівалентне видаленню вершини з множини насичених вершин, тому властивість наслідування виконується. По-третє, як випливає з коректності алгоритму Куна, якщо поточне паросполучення не максимальне, то завжди знайдеться така вершина, яку можна наситити, не видаляючи з множини насичених вершин інші вершини.

Отже, ми показали, що наша задача є зваженим матроїдом щодо множини насичених вершин першої частини, тому до неї застосуємо жадібний алгоритм.

Залишилося показати, що **алгоритм Куна є жадібним алгоритмом**.

Однак це досить очевидний факт. Алгоритм Куна на кожному кроці намагається наситити поточну вершину - або просто проводячи ребро в ненасичену вершину другої частини, або знаходячи удовгу ланцюг і чергуючи паросполуку уздовж нього. І в тому, і в іншому випадку жодні вже насичені вершини не перестають бути ненасиченими, а ненасичені на попередніх кроках вершини першої частини не насичуються і на цьому кроці. Таким чином, алгоритм Куна є жадібним алгоритмом, який будує оптимальне незалежне підмножину матроїда, що і завершує наше доведення.