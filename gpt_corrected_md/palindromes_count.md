# Знаходження всіх підпаліндромів

## Постановка завдання

Дано рядок $s$ довжини $n$. Потрібно знайти всі пари $(i,j)$, де $i<j$, такі, що підрядок $s[i \ldots j]$ є паліндромом (тобто читається однаково зліва направо і справа наліво).

### Уточнення постановки

Зрозуміло, що в гіршому випадку кількість таких підрядків-паліндромів може бути $O(n^2)$, і на перший погляд здається, що алгоритм з лінійною асимптотикою існувати не може.

Однак інформацію про знайдені паліндроми можна подати більш **компактно**: для кожної позиції $i=0 \ldots n-1$ знайдемо значення $d_1[i]$ та $d_2[i]$, що позначають кількість паліндромів відповідно непарної та парної довжини з центром в позиції $i$.

Наприклад, у рядку $s = абабабц$ є три паліндроми непарної довжини з центром у символі $s[3]=б$, тобто значення $d_1[3]=3$:

$$
a\ \overbrace{b\ a\ \underbrace{b}_{s_3}\ a\ b}^{d_1[3]=3}\ c
$$

А в рядку $s = cbaabd$ є два паліндроми парної довжини з центром у символі $s[3]=a$, тобто значення $d_2[3]=2$:

$$
c\ \overbrace{b\ a\ \underbrace{a}_{s_3}\ b}^{d_2[3]=2}\ d
$$

тобто, ідея полягає в тому, що якщо є паліндром довжини $l$ з центром в деякій позиції $i$, то є також паліндроми довжини $l-2$, $l-4$ і т.д. з центрами в $i$. Тому двох таких масивів $d_1[i]$ і $d_2[i]$ достатньо для зберігання інформації про всі паліндроми цієї рядка.

Досить неочікуваним фактом є те, що існує досить простий алгоритм, який обчислює ці "масиви паліндромностей" $d_1[]$ і $d_2[]$ за лінійний час. Цей алгоритм описується в даній статті.

## Розв'язок

Взагалі кажучи, дана задача має кілька відомих рішень: з допомогою [техніки хешування](string_hashes) її можна розв'язати за $O(n \log n)$, а з допомогою [суфіксних дерев](ukkonen) та [швидкого алгоритму LCA](lca_linear) цю задачу можна розв'язати за $O(n)$.

Однак описаний у даній статті метод значно простіший і має менше прихованих констант у асимптотиці часу та пам'яті. Цей алгоритм був відкритий Гленном Манакером (Glenn Manacher) у 1975 році.

### Тривалий алгоритм

Щоб уникнути неоднозначностей при подальшому описі, домовимось про те, що таке "тривіальний алгоритм".

Це алгоритм, який для пошуку відповіді в позиції $i$ раз за разом намагається збільшити відповідь на одиницю, кожен раз порівнюючи пару відповідних символів.

Такий алгоритм занадто повільний, весь результат можна обчислити лише за час $O(n^2)$.

Наведемо для наочності його реалізацію:

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> d1(n), d2(n);
for (int i = 0; i < n; ++i) {
    d1[i] = 1;
    while (i - d1[i] >= 0 && i + d1[i] < n && s[i - d1[i]] == s[i + d1[i]])
        ++d1[i];

    d2[i] = 0;
    while (i - d2[i] - 1 >= 0 && i + d2[i] < n && s[i - d2[i] - 1] == s[i + d2[i]])
        ++d2[i];
}
```

### Алгоритм Манакера

Навчимося спочатку знаходити всі підпаліндроми непарної довжини, тобто обчислювати масив $d_1[]$. Розв'язок для паліндромів парної довжини (тобто знаходження масиву $d_2[]$) вийде з невеликою модифікацією цього.

Для швидкого обчислення будемо підтримувати **межі $[l,r]$** самого правого з виявлених паліндромів (тобто паліндрому з найбільшим значенням $r$). Спершу можна покласти $l=0, r=-1$.

Отже, нехай ми хочемо обчислити значення $d_{1}[i]$ для наступного $i$, при цьому всі попередні значення $d_{1}[]$ вже підраховані.

* Якщо $i$ не знаходиться в межах поточного підпаліндрому, тобто $i > r$, то просто застосуємо тривіальний алгоритм.

тобто, будемо послідовно збільшувати значення $d_1[i]$, і перевіряти кожен раз - чи правда, що поточний підрядок $[i-d_1[i]+1; i+d_1[i]-1]$ є паліндромом. Коли ми знайдемо перше розходження або дійдемо до межі рядка $s$, зупиняємося: ми остаточно порахували значення $d_1[i]$. Після цього ми повинні не забути оновити значення $(l,r)$.

* Розглянемо тепер випадок, коли $i \leq r$.

Спробуємо витягти частину інформації з уже підрахованих значень $d_1[]$. Зокрема, відобразимо позицію $i$ всередині підпаліндрому $(l,r)$, тобто отримаємо позицію $j = l + (r - i)$ і розглянемо значення $d_1[j]$. Оскільки $j$ - позиція, симетрична позиції $i$, то **майже завжди** ми можемо просто присвоїти $d_1[i] = d_1[j]$. Це ілюструється наступним чином (паліндром навколо $j$ фактично "копіюється" в паліндром навколо $i"):

$$
\ldots \overbrace{s_l\ \ldots\ \underbrace{s_{j-d_1[j]+1}\ \ldots\ s_j\ \ldots\ s_{j+d_1[j]-1}}_{\rm palindrome}\ \ldots\ \underbrace{s_{i-d_1[j]+1}\ \ldots\ s_i\ \ldots\ s_{i+d_1[j]-1}}_{\rm palindrome}\ \ldots\ s_r\ \ldots}^{\rm palindrome}
$$

Однак тут є **тонкість**, яку потрібно обробити правильно: коли "внутрішній паліндром" досягає межі зовнішнього або вилазить за її межі, тобто $j-d_1[j]+1 \le l$ (або, що то ж саме, $i+d_1[j]-1 \ge r$). Оскільки за межами зовнішнього паліндрому ніякої симетрії не гарантується, то просто присвоїти $d_1[i] = d_1[j]$ буде вже некоректно: у нас недостатньо даних, щоб стверджувати, що в позиції $i$ підпаліндром має таку ж довжину.

Насправді, щоб правильно обробляти такі ситуації, потрібно "скоротити" довжину паліндрому, тобто присвоїти $d_1[i] = \min(r - i, d_1[mirr])$. Після цього можна запустити тривіальний алгоритм, який буде намагатися збільшити значення $d_1[i]$, поки це можливо.

Ілюстрація цього випадку (на ній паліндром з центром у $j$ зображений вже "обрізаним" до такої довжини, що він точно поміщається у зовнішній паліндром):

$$
\ldots \overbrace{\underbrace{s_l\ \ldots\ s_j\ \ldots\ s_{j+(j-l)}}_{\rm palindrome}\ \ldots\ \underbrace{s_{i-(r-i)}\ \ldots\ s_i\ \ldots\ s_r}_{\rm palindrome}}^{\rm palindrome}\ \underbrace{\ldots\ldots\ldots\ldots}_{\rm try\ moving\ here}
$$

(На цій ілюстрації показано, що, хоча паліндром з центром у позиції $j$ може бути і більш довгим, виходячим за межі зовнішнього паліндрому, але в позиції $i$ ми можемо використовувати тільки ту його частину, яка цілком поміщається у зовнішній паліндром. Але відповідь для позиції $i$ може бути більшою, ніж ця частина, тому далі ми повинні запустити тривіальний пошук, який буде намагатися розсунути його за межі зовнішнього паліндрому, тобто в область "спробуйте рухатися сюди").

В завершенні опису алгоритму потрібно лише нагадати, що потрібно оновлювати значення $(l,r)$ після обчислення наступного значення $d_1[i]$.

Також повторимося, що вище ми описали міркування для обчислення масиву непарних паліндромів $d_1[]$; для масиву парних паліндромів $d_2[]$ всі міркування аналогічні.

### Оцінка асимптотики алгоритму Манакера

На перший погляд неочевидно, що цей алгоритм має лінійну асимптотику: під час обчислення відповіді для певної позиції нерідко запускається тривіальний алгоритм пошуку паліндромів.

Однак більш уважний аналіз показує, що алгоритм все ж таки лінійний. (Варто посилатися на відомий [алгоритм побудови Z-функції рядка](z_function), який внутрішньо сильно нагадує даний алгоритм, і працює також за лінійний час).

Насправді, легко простежити за алгоритмом, що кожна ітерація, яку виконує тривіальний пошук, призводить до збільшення межі $r$ на одиницю. При цьому зменшення $r$ по ходу алгоритму неможливе. Отже, тривіальний алгоритм в сумі виконає лише $O(n)$ операцій.

Враховуючи те, що крім тривіальних пошуків, всі інші частини алгоритму Манакера очевидно працюють за лінійний час, ми отримуємо підсумкову асимптотику: $O(n)$.

### Реалізація алгоритму Манакера

Для випадку паліндромів непарної довжини, тобто для обчислення масиву $d_1[]$, отримуємо такий код:

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> d1(n);
int l = 0, r = -1;
for (int i = 0; i < n; ++i) {
    int k = i > r ? 1 : min(d1[l + r - i], r - i + 1);
    while (i + k < n && i - k >= 0 && s[i + k] == s[i - k])
        ++k;
    d1[i] = k;
    if (i + k - 1 > r)
        l = i - k + 1, r = i + k - 1;
}
```

Для підпаліндромів парної довжини, тобто для обчислення масиву $d_2[]$, лише трохи змінюються арифметичні вирази:

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> d2(n);
l = 0, r = -1;
for (int i = 0; i < n; ++i) {
    int k = i > r ? 0 : min(d2[l + r - i + 1], r - i + 1);
    while (i + k < n && i - k - 1 >= 0 && s[i + k] == s[i - k - 1])
        ++k;
    d2[i] = k;
    if (i + k - 1 > r)
        l = i - k, r = i + k - 1;
}
```

## Завдання в онлайн-суддях

Список завдань, які можна виконати за допомогою цього алгоритму:

* [UVA #11475 **"Extend to Palindrome"** [складність: низька]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2470)