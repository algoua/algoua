# Алгоритм Диніца

## Постанова завдання

Нехай задана мережа, тобто орієнтований граф $G$, в якому кожному ребру $(u,v)$ приписана пропускна здатність $c_{uv}$, а також виділені дві вершини - джерело $s$ і стік $t$.

Потрібно знайти у цій мережі потік $f_{uv}$ з джерела $s$ до стоку $t$ максимальної величини.

## Трохи історії

Цей алгоритм був опублікований українським (ізраїльським) вченим Єфімом **Дініцем** (Yefim Dinitz, іноді пишеться як "Dinic") у 1970 році, тобто навіть на два роки раніше, ніж опубліковання алгоритму Едмондса-Карпа (втім, обидва алгоритми були незалежно відкриті в 1968 році).

Крім того, варто зазначити, що деякі спрощення алгоритму були здійснені Шимоном Івеном (Shimon Even) і його учнем Алоном Ітаї (Alon Itai) у 1979 році. Саме завдяки їм алгоритм отримав свій сучасний вигляд: вони застосували до ідеї Дініца концепцію блокуючих потоків Александра Карзанова (Alexander Karzanov, 1974 р.), а також переформулювали алгоритм до комбінації обходу в ширину і в глибину, в якій зараз цей алгоритм викладається всюди.

Розвиток ідей щодо потокових алгоритмів дуже цікаво розглядати, враховуючи "залізний занавіс" тих років, який розділяв СРСР та Захід. Видно, як іноді схожі ідеї з'являлися майже одночасно (як у випадку алгоритму Дініца та алгоритму Едмондса-Карпа), проте мали різну ефективність (алгоритм Дініца на один порядок швидший). Іноді ж, навпаки, з'явлення ідеї по одну сторону "занавіса" опережало аналогічний хід по іншу сторону більш ніж на десятиліття (як алгоритм Карзанова проштовхування в 1974 році та алгоритм Голдберга проштовхування в 1985 році).

## Необхідні визначення

Введемо три необхідні визначення, кожне з яких є незалежним від інших і буде використовуватися в алгоритмі Дініца.

Остаточною мережею $G^R$ щодо мережі $G$ та деякого потоку $f$ в ній називається мережа, в якій кожному ребру $(u,v) \in G$ з пропускною здатністю $c_{uv}$ та потоком $f_{uv}$ відповідають два ребра:

* $(u,v)$ з пропускною здатністю $c_{uv}^R = c_{uv} - f_{uv}$

* $(v,u)$ із пропускною здатністю $c_{vu}^R = f_{vu}$

Варто відзначити, що при такому визначенні в залишковій мережі можуть з'являтися кратні ребра: якщо в початковій мережі було як ребро $(u,v)$, так і $(v,u)$.

Остаточне ребро можна інтуїтивно розуміти як міру того, наскільки ще можна збільшити потік уздовж якогось ребра. Насправді, якщо протікає потік $f_{uv}$ по ребру $(u,v)$ з пропускною здатністю $c_{uv}$, то потенційно по ньому можна пропустити ще $c_{uv}-f_{uv}$ одиниць потоку, а в зворотному напрямку можна пропустити до $f_{uv}$ одиниць потоку, що буде означати скасування потоку в первісному напрямку.

**Блокуючим потоком** в даній мережі називається такий потік, що будь-який шлях з джерела $s$ в стік $t$ містить ребро, на якому потік досягнув максимальної пропускної здатності. Іншими словами, в даній мережі не знайдеться такого шляху з джерела в стік, уздовж якого можна без перешкод збільшити потік.

Блокуючий потік не обов'язково є максимальним. Теорема Форда-Фалкерсона стверджує, що потік буде максимальним тоді і тільки тоді, коли в залишковій мережі не знайдеться $s-t$ шляху; у блокуючому потоці не затверджується наявність шляхів по ребрах, які з'являються у залишковій мережі.

**Шарова мережа** для даної мережі будується наступним чином. Спочатку визначаються довжини найкоротших шляхів з джерела $s$ до всіх інших вершин; назвемо рівнем ${\rm level}[v]$ вершини її відстань від джерела. Тоді в шарову мережу включаються всі ті ребра $(u,v)$ вихідної мережі, які ведуть з одного рівня на якийсь інший, більш пізній рівень, тобто ${\rm level}[u] + 1 = {\rm level}[v]$ (чому в цьому випадку різниця відстаней не може перевищувати одиницю, випливає з властивості найкоротших відстаней). Таким чином, видаляються всі ребра, розташовані цілком всередині рівнів, а також ребра, що ведуть назад до попередніх рівнів.

Очевидно, що шарувата мережа є ациклічною. Крім того, будь-який $s-t$ шлях у шаруватій мережі є найкоротшим шляхом у вихідній мережі.

Побудувати шарову мережу по даній мережі дуже легко: для цього треба запустити обхід в ширину по ребрах цієї мережі, вважаючи тим самим для кожної вершини величину ${\rm level}[]$, і потім внести до шарової мережі всі підходящі ребра.

Зауваження. Термін "шарувата мережа" україномовною літературою не використовується; зазвичай цю конструкцію називають просто "вспоміжним графом". Однак, на англійській мові зазвичай використовується термін "layered network".

## Алгоритм

### Схема алгоритму

Алгоритм представляє собою кілька **фаз**. На кожній фазі спочатку будується залишкова мережа, потім до неї будується шарувата мережа (обходом в ширину), в якій шукається довільний блокуючий потік. Знайдений блокуючий потік додається до поточного потоку, і цим завершується чергова ітерація.

Цей алгоритм схожий на алгоритм Едмондса-Карпа, але основна відмінність полягає в тому, що на кожній ітерації потік збільшується не вздовж одного найкоротшого $s-t$ шляху, а вздовж цілого набору таких шляхів (адже саме такі шляхи є шляхами в блокуючому потоці шаруватої мережі). В тексті не слід використовувати російські слова. Також рекомендується використовувати слово "шарувата" замість "слойова".

### Коректність алгоритму

Покажемо, що якщо алгоритм завершується, то на виході з нього отримується потік саме максимальної величини.

Насправді, припустимо, що в якийсь момент у шаруватій мережі, побудованій для залишкової мережі, не вдалося знайти блокуючий потік. Це означає, що стік $t$ взагалі не досяжний у шаруватій мережі з джерела $s$. Але оскільки шарувата мережа містить всі найкоротші шляхи з джерела в залишкову мережу, це в свою чергу означає, що в залишковій мережі немає шляхів з джерела до стоку. Отже, застосовуючи теорему Форда-Фалкерсона, отримуємо, що поточний потік насправді максимальний.

### Оцінка кількості фаз

Покажемо, що алгоритм Дініца завжди виконує **не більше $n$ фаз**. Для цього доведемо дві леми:

**Лема 1**. Найкоротша відстань від джерела до кожної вершини не зменшується з кожною ітерацією, тобто

$$
{\rm level}_{i+1}[v] \ge {\rm level}_i[v]
$$

де нижній індекс позначає номер фази, перед якою взяті значення цих змінних.

**Доведення**. Зафіксуємо довільну фазу $i$ і довільну вершину $v$ і розглянемо будь-який найкоротший $s$-$v$ шлях $P$ в мережі $G_{i+1}^\text{res}$ (нагадаємо, так ми позначаємо залишкову мережу, взяту перед виконанням $(i+1)$-ої фази). Очевидно, довжина шляху $P$ дорівнює ${\rm level}_{i+1}[v]$.

Зауважимо, що у залишкову мережу $G^R_{i+1}$ можуть входити тільки ребра з $G^R$, а також ребра, зворотні до ребер з $G^R$ (це випливає з визначення залишкової мережі). Розглянемо два випадки:

* Шлях $P$ містить лише ребра з $G^R$. Отже, зрозуміло, що довжина шляху $P$ більша або дорівнює ${\rm level}_i[v]$ (адже ${\rm level}_i[v]$ за визначенням - це довжина найкоротшого шляху), що і означає виконання нерівності.
* Шлях $P$ містить щонайменше одне ребро, яке не міститься в $G^R$ (але зворотне до якогось ребра з $G^R$). Розглянемо перше таке ребро; нехай це буде ребро $(u,w)$.

$$
s \Longrightarrow u \rightarrow w \Longrightarrow v
$$

Ми можемо застосувати нашу лему до вершини $u$, оскільки вона підпадає під перший випадок; отже, ми отримуємо нерівність ${\rm level}_{i+1}[u] \ge {\rm level}_i[u]$.

Тепер зауважимо, що оскільки ребро $(u,w)$ з'явилося в залишковій мережі тільки після виконання $i$-ої фази, то звідси випливає, що уздовж ребра $(w,u)$ був додатково пропущений якийсь потік; отже, ребро $(w,u)$ належало шаруватій мережі перед $i$-ою фазою, а тому ${\rm level}_i[u] = {\rm level}_i[w] + 1$. Врахуємо, що за властивістю найкоротших шляхів ${\rm level}_{i+1}[w] = {\rm level}_{i+1}[u] + 1$, і об'єднуючи цю рівність з двома попередніми нерівностями, отримуємо:

$$
{\rm level}_{i+1}[w] \ge {\rm level}_i[w] + 2.
$$

Тепер ми можемо застосовувати ті ж самі міркування до всього залишку шляху до $v$ (тобто що кожне зворотне ребро додає до $\rm level$ як мінімум два), і в підсумку отримаємо необхідну нерівність.

Лема 2. Відстань між джерелом та стоком строго збільшується після кожної фази алгоритму, тобто:

$$
{\rm level}^\prime[t] > {\rm level}[t],
$$

де штрихом позначено значення, отримане на наступній фазі алгоритму.

Доведення: від протилежного. Припустимо, що після виконання поточної фази виявилося, що ${\rm level}^\prime[t] = {\rm level}[t]$. Розглянемо найкоротший шлях з джерела до стоку; згідно з припущенням, його довжина повинна залишатися незмінною. Однак, залишкова мережа на наступній фазі містить тільки ребра залишкової мережі перед виконанням поточної фази або зворотні до них. Таким чином, ми приходимо до протиріччя: знайдено $s-t$ шлях, який не містить насичених ребер і має ту саму довжину, що й найкоротший шлях. Цей шлях повинен був бути "заблокований" блокуючим потоком, що не сталося, і тому ми довели протиріччя, що і було потрібно.

Цю лему інтуїтивно можна розуміти наступним чином: на $i$-ій фазі алгоритму Дініца виявляється і насичується всі $s-t$ шляхи довжини $i$.

Оскільки довжина найкоротшого шляху з $s$ до $t$ не може перевищувати $n-1$, то алгоритм Дініца здійснює **не більше $n-1$ фаз**.

### Пошук блокуючого потоку

Щоб завершити побудову алгоритму Дініца, потрібно описати алгоритм знаходження блокуючого потоку в шаруватій мережі - ключове місце алгоритму.

Ми розглянемо три можливі варіанти реалізації пошуку блокуючого потоку:

* Шукати $s-t$ шляхи по черзі, доки знайдуться всі можливі шляхи. Шлях можна знайти за $O(m)$ обходом в ширину, а всього таких шляхів буде $O(m)$ (оскільки кожний шлях насичує як мінімум одне ребро). Підсумкова асимптотика пошуку всіх блокуючих потоків складе $O(m^2)$.

* Аналогічно до попередньої ідеї, проте потрібно видаляти "зайві" ребра під час обходу глибини графа, тобто ребра, які не дозволяють дійти до стоку.

Це дуже легко реалізувати: достатньо видаляти ребро після того, як ми просканували його в обході в глибину (крім випадку, коли ми пройшли вздовж ребра і знайшли шлях до стоку). З точки зору реалізації потрібно просто підтримувати в списку суміжності кожної вершини вказівник на перше невидалене ребро і збільшувати цей вказівник у циклі всередині обходу в глибину.

Оцінимо асимптотику цього розв'язку. Кожен обхід в глибину завершується або насиченням як мінімум одного ребра (якщо цей обхід досяг стоку), або продвиженням вперед як мінімум одного вказівника (в іншому випадку). Можна зрозуміти, що один запуск обходу в глибину з основної програми працює за $O(k + n)$, де $k$ - число продвижень вказівників. Враховуючи, що всього запусків обходу в глибину в рамках пошуку одного блокуючого потоку буде $O(p)$, де $p$ - число ребер, насичених цим блокуючим потоком, то весь алгоритм пошуку блокуючого потоку відпрацює за $O(pk + pn)$, що, враховуючи, що всі вказівники в сумі пройшли відстань $O(m)$, дає асимптотику $O(m + pn)$. В гіршому випадку, коли блокуючий потік насичує всі ребра, асимптотика виходить $O(nm)$; ця асимптотика і буде використовуватися далі.

Можна сказати, що цей спосіб знаходження блокуючого потоку надзвичайно ефективний у тому сенсі, що для пошуку одного збільшення шляху він тратить $O(n)$ операцій у середньому. Саме в цьому і полягає різниця на цілий порядок ефективностей алгоритму Дініца та Едмондса-Карпа (останній шукає одне збільшення шляху за $O(m)$).

Цей спосіб розв'язку є, як і раніше, простим для реалізації, але достатньо ефективним, тому найчастіше застосовується на практиці.

* Можна застосувати спеціальні структури даних - динамічні дерева Слейтора (Sleator) і Тар'яна (Tarjan). Отже, кожен блокуючий потік можна знайти за час $O(m \log n)$.

### Асимптотика

Таким чином, весь алгоритм Дініца виконується за $O(n^2 m)$, якщо блокуючий потік шукати описаним вище способом за $O(n m)$. Реалізація з використанням динамічних дерев Слетора і Тар'яна буде працювати за час $O(n m \log n)$.

#### Одиночні мережі

"Одиночною мережею" ("одинична мережа") називається мережа, в якій пропускні здатності всіх існуючих ребер дорівнюють одиниці, а в будь-якій вершині, крім джерела і стоку, лише одне ребро може виходити або входити.

Цей випадок є досить важливим, оскільки в задачі пошуку **максимального паросполука** побудована мережа є саме одиничною.

**Доведемо**, що на одиничних мережах алгоритм Дініца навіть у простій реалізації (яка на довільних графах працює за $O(n^2 m)$) працює за час $O(m \sqrt{n})$, досягаючи на задачі пошуку найбільшого паросполука один з кращих відомих алгоритмів - алгоритм Хопкрофта-Карпа.

По-перше, відзначимо, що наведений вище алгоритм пошуку блокуючого потоку, який на довільних мережах працює за час $O(n m)$, в мережах з одиничними пропускними здібностями буде працювати за $O(m)$: через те, що кожне ребро не буде переглянуто більше одного разу.

По-друге, оцінимо загальну кількість фаз, яка могла статися в випадку одиничних мереж.

Нехай вже було проведено $\sqrt{n}$ фаз алгоритму Дініца; тоді всі шляхи довжини не більше $\sqrt{n}$ вже знайдені. Нехай $f$ - поточний знайдений потік, а $f^*$ - шуканий максимальний потік; розглянемо їх різницю: $f^* - f$. Вона представляє собою потік у залишковій мережі $G^R$. Цей потік має величину $|f^*| - |f|$, і уздовж кожного ребра дорівнює нулю або одиниці. Його можна розкласти на набір з $|f^*| - |f|$ шляхів з $s$ в $t$ і, можливо, циклів. Оскільки мережа єдинична, то всі ці шляхи не можуть мати спільних вершин, тому, враховуючи вищезазначене, сумарну кількість вершин в них $cnt$ можна оцінити як:

$$
cnt \ge (|f^*| - |f|) \cdot \sqrt{n}.
$$

З іншого боку, з урахуванням того, що $cnt \le n$, ми отримуємо:

$$
|f^*| - |f| \le \sqrt{n},
$$

що означає, що ще через $\sqrt{n}$ фаз алгоритму Дініца гарантовано знайдеться максимальний потік.

Отже, потрібно довести, що загальне число фаз алгоритму Дініца, яке виконується на одиничних мережах, можна оцінити як $2 \sqrt{n}$.

## Реалізація

Наведемо дві реалізації алгоритму за $O(n^2 m)$, що працюють на мережах, заданих матрицями суміжності та списками суміжності відповідно.

### Реалізація графів у вигляді матриць суміжності

<!--- TODO: specify code snippet id -->
``` cpp
кількість вершин: const int MAXN = ...;
const int INF = 1000000000; // константа-нескінченність

int n, c[MAXN][MAXN], f[MAXN][MAXN], s, t, d[MAXN], ptr[MAXN], q[MAXN];

bool bfs() {
    int qh = 0, qt = 0;
    q[qt++] = s;
    memset(d, -1, n * sizeof d[0]);
    d[s] = 0;
    while (qh < qt) {
        int v = q[qh++];
        for (int to = 0; to < n; ++to)
            if (d[to] == -1 && f[v][to] < c[v][to]) {
                q[qt++] = to;
                d[to] = d[v] + 1;
            }
    }
    return d[t] != -1;
}

int dfs(int v, int flow) {
    if (!flow)
        return 0;
    if (v == t)
        return flow;
    for (int &to = ptr[v]; to < n; ++to) {
        if (d[to] != d[v] + 1)
            continue;
        int pushed = dfs(to, min(flow, c[v][to] - f[v][to]));
        if (pushed) {
            f[v][to] += pushed;
            f[to][v] -= pushed;
            return pushed;
        }
    }
    return 0;
}

int dinic() {
    int flow = 0;
    for (;;) {
        if (!bfs())
            break;
        memset(ptr, 0, n * sizeof ptr[0]);
        while (int pushed = dfs(s, INF))
            flow += pushed;
    }
    return flow;
}
```

Мережу потрібно попередньо зчитати: мають бути задані змінні $n$, $s$, $t$, а також зчитана матриця пропускної здатності $c[][]$. Основна функція розв'язку - $\rm dinic()$, яка повертає величину знайденого максимального потоку.

### Реалізація графів у вигляді списків суміжності

<!--- TODO: specify code snippet id -->
``` cpp
кількість вершин: const int MAXN = ...;
const int INF = 1000000000; // константа-нескінченність

struct edge {
    int a, b, cap, flow;
};

int n, s, t, d[MAXN], ptr[MAXN], q[MAXN];
vector<edge> e;
vector<int> g[MAXN];

void add_edge(int a, int b, int cap) {
    edge e1 = {a, b, cap, 0};
    edge e2 = {b, a, 0, 0};
    g[a].push_back((int)e.size());
    e.push_back(e1);
    g[b].push_back((int)e.size());
    e.push_back(e2);
}

bool bfs() {
    int qh = 0, qt = 0;
    q[qt++] = s;
    memset(d, -1, n * sizeof d[0]);
    d[s] = 0;
    while (qh < qt && d[t] == -1) {
        int v = q[qh++];
        for (size_t i = 0; i < g[v].size(); ++i) {
            int id = g[v][i], to = e[id].b;
            if (d[to] == -1 && e[id].flow < e[id].cap) {
                q[qt++] = to;
                d[to] = d[v] + 1;
            }
        }
    }
    return d[t] != -1;
}

int dfs(int v, int flow) {
    if (!flow)
        return 0;
    if (v == t)
        return flow;
    for (; ptr[v] < (int)g[v].size(); ++ptr[v]) {
        int id = g[v][ptr[v]], to = e[id].b;
        if (d[to] != d[v] + 1)
            continue;
        int pushed = dfs(to, min(flow, e[id].cap - e[id].flow));
        if (pushed) {
            e[id].flow += pushed;
            e[id ^ 1].flow -= pushed;
            return pushed;
        }
    }
    return 0;
}

int dinic() {
    int flow = 0;
    for (;;) {
        if (!bfs())
            break;
        memset(ptr, 0, n * sizeof ptr[0]);
        while (int pushed = dfs(s, INF))
            flow += pushed;
    }
    return flow;
}
```

Мережу потрібно передбачити заздалегідь: повинні бути задані змінні $n$, $s$ та $t$, а також додані всі ребра (орієнтовані) за допомогою функції $\rm add\_edge$. Основна функція для вирішення задачі - $\rm dinic()$, яка повертає величину знайденого максимального потоку.