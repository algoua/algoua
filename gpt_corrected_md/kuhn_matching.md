# Алгоритм Куна знаходження найбільшого паросполука в дводольному графі

Даний двудольний граф $G$ з $n$ вершинами і $m$ ребрами. Потрібно знайти максимальну паросполученість, тобто вибрати якомога більше ребер, щоб жодне з вибраних ребер не мало загальної вершини з іншим вибраним ребром.

## Опис алгоритму

### Необхідні визначення

**Паросочетанням** $M$ називається набір попарно несуміжних ребер графа (іншими словами, будь-якій вершині графа має бути інцидентно не більше одного ребра з множини $M$). Міцністю паросочетання назвемо кількість ребер у ньому. Найбільшим (або максимальним) паросочетанням назвемо паросочетання, міцність якого максимальна серед усіх можливих паросочетань у даному графі. Усі ті вершини, у яких є суміжне ребро з паросочетанням (тобто які мають ступінь рівний один в підграфі, утвореному $M$), називаються насиченими цим паросочетанням.

Ланцюгом довжини $k$ назвемо деякий простий шлях (тобто такий, що не містить повторюваних вершин або ребер), що містить $k$ ребер.

"Чергуючимся ланцюгом" (у двудольному графі, щодо деякого паросполука) називається ланцюг, в якому ребра чергуються належні/неналежні паросполуку.

Увеличувальною ланкою (у двудольному графі щодо деякої підмножини вершин) називається чергуюча ланка, в якій початкова та кінцева вершини не належать підмножині вершин.

### Теорема Берга

Паросочетання є максимальним тоді і тільки тоді, коли не існує ланцюгів, які збільшують його.

**Доведення необхідності**. Покажемо, що якщо паросполучення $M$ максимальне, то не існує збільшувальних щодо нього ланцюгів. Доведення буде конструктивним: ми покажемо, як збільшити потужність паросполучення $M$ на одиницю з допомогою цього збільшувального ланцюга $P$.

Для цього виконаємо так зване чергування паростоків уздовж ланцюга $P$. Ми пам'ятаємо, що по визначенню перше ребро ланцюга $P$ не належить паростоку, друге - належить, третє - знову не належить, четверте - належить, і т.д. Давайте змінимо стан всіх ребер уздовж ланцюга $P$: ті ребра, які не входили до паростоку (перше, третє і т.д. до останнього) включимо до паростоку, а ребра, які раніше входили до паростоку (друге, четверте і т.д. до передостаннього) - видалимо з нього.

Зрозуміло, що потужність паросполучення при цьому збільшилася на одиницю (тому що було додано одне ребро більше, ніж видалено). Залишилося перевірити, що ми побудували коректне паросполучення, тобто що жодна вершина графа не має одразу двох суміжних ребер з цього паросполучення. Для всіх вершин чергуючого ланцюга $P$, крім першої і останньої, це випливає з самого алгоритму чергування: спочатку ми видалили суміжне ребро, а потім додали. Для першої і останньої вершини ланцюга $P$ також нічого не могло бути порушено, оскільки до чергування вони повинні були бути ненасиченими. Нарешті, для всіх інших вершин, які не входять до ланцюга $P$, очевидно, нічого не змінилося. Таким чином, ми насправді побудували паросполучення потужністю на одиницю більше, ніж попереднє, що і завершує доведення необхідності.

Доведення достатності. Доведемо, що якщо щодо деякого паросполучення $M$ не існують шляхів, які можна збільшити, то воно є максимальним.

Доведення проведемо від протилежного. Нехай є паросполука $M^\prime$, яка має більшу потужність, ніж $M$. Розглянемо симетричну різницю $Q$ цих двох паросполук, тобто залишимо всі ребра, які належать до $M$ або $M^\prime$, але не належать одночасно до обох.

Зрозуміло, що множина ребер $Q$ вже, напевно, не є паросполученням. Розглянемо, який вигляд має ця множина ребер; для зручності будемо розглядати її як граф. У цьому графі кожна вершина, очевидно, має ступінь не більше 2 (тому що кожна вершина може мати максимум два суміжні ребра - з одного паросполучення і з іншого). Легко зрозуміти, що тоді цей граф складається тільки з циклів або шляхів, причому ні ті, ні інші не перетинаються один з одним.

Тепер звернімо увагу, що шляхи в графі $Q$ можуть бути лише парної довжини. Насправді, у будь-якому шляху в графі $Q$ ребра чергуються: після ребра з $M$ йде ребро з $M'$ і навпаки. Якщо розглянути шлях непарної довжини в графі $Q$, то вийде, що в вихідному графі $G$ це буде збільшуючим ланцюгом або для паросполука $M$, або для $M'$. Але цього бути не може, оскільки в разі паросполука $M$ це суперечить умові, а в разі $M'$ - його максимальності (адже ми вже довели необхідність теореми, з якої випливає, що при наявності збільшуючого ланцюга паросполука не може бути максимальною).

Доведемо тепер аналогічне твердження і для циклів: всі цикли в графі $Q$ можуть мати лише парну довжину. Це довести досить просто: зрозуміло, що в циклі ребра також повинні чергуватися (належати по черзі то $M$, то $M^\prime$), але ця умова не може виконуватися в циклі непарної довжини - в ньому обов'язково знайдуться два сусідні ребра з одного паросполука, що суперечить визначенню паросполука.

Таким чином, всі шляхи та цикли графа $Q = M \oplus M'$ мають парну довжину. Отже, граф $Q$ містить рівну кількість ребер з $M$ та з $M'$. Але, зважаючи на те, що в $Q$ містяться всі ребра $M$ та $M'$, за винятком їх загальних ребер, то звідси випливає, що потужності $M$ та $M'$ збігаються. Ми прийшли до протиріччя: за припущенням, паросполучення $M$ було не максимальним, отже, теорема доведена.

### Алгоритм Куна

Алгоритм Куна - це безпосереднє застосування теореми Бержа. Його можна коротко описати так: спочатку беремо порожню паросполуку, а потім - доки в графі можливо знайти збільшуючий ланцюг, - будемо виконувати чергування паросполуки вздовж цього ланцюгу і повторювати процес пошуку збільшуючих ланцюгів. Як тільки такий ланцюг знайти не вдається - процес зупиняємо, - поточна паросполука і є максимальною.

Залишається деталізувати спосіб знаходження збільшуючих ланок. **Алгоритм Куна** просто шукає будь-яку з таких ланок з допомогою **[пошуку в глибину](dfs)** або **[пошуку в ширину](bfs)**. Алгоритм Куна переглядає всі вершини графа по черзі, запускаючи з кожної обхід, що намагається знайти збільшувальну ланку, що починається з цієї вершини.

Зручніше описувати цей алгоритм, вважаючи, що граф вже розбитий на дві частини (хоча насправді алгоритм можна реалізувати таким чином, щоб йому не давали на вхід граф, явно розбитий на дві частини).

Алгоритм переглядає всі вершини $v$ першої частини графа: $v = 1 \ldots n_1$. Якщо поточна вершина $v$ вже насичена поточною паросполукою (тобто вже вибрано яке-небудь суміжне їй ребро), то цю вершину пропускаємо. Інакше - алгоритм намагається наситити цю вершину, для чого запускається пошук збільшуючим ланцюгом, що починається з цієї вершини.

Пошук збільшуючих ланцюгів здійснюється за допомогою спеціального обходу в глибину або ширину (зазвичай для простоти реалізації використовують саме обхід в глибину). Спочатку обхід в глибину варто робити з поточної ненасиченої вершини $v$ для пошуку першої частки. Переглядаємо всі ребра з цієї вершини, нехай поточне ребро - це ребро $(v,to)$. Якщо вершина $to$ ще не насичена партнером, то, очевидно, ми знайшли збільшуючий ланцюг: він складається з єдиного ребра $(v,to)$; в такому випадку просто включаємо це ребро в паросполуку і припиняємо пошук збільшуючих ланцюгів з вершини $v$. Інакше, якщо $to$ вже насичена якимось ребром $(p,to)$, то намагаємося пройти вздовж цього ребра: таким чином ми намагаємося знайти збільшуючий ланцюг, що проходить через ребра $(v,to)$, $(to,p)$. Для цього просто переходимо в нашому обході в вершину $p$ - тепер ми вже намагаємося знайти збільшуючий ланцюг з цієї вершини.

Можна зрозуміти, що під час цього обходу, запущеного з вершини $v$, або буде знайдено збільшуючий ланцюг і тим самим насичена вершина $v$, або ж такий збільшуючий ланцюг не буде знайдений (і, отже, ця вершина $v$ вже не може бути насиченою).

Після того, як всі вершини $v = 1 \ldots n_1$ будуть переглянуті, поточна паросполучення буде максимальною.

### Час роботи

Отже, алгоритм Куна можна уявити як серію з $n$ запусків обходу в ширину на усьому графі. Таким чином, цей алгоритм виконується за час $O(n m)$, що в гіршому випадку становить $O(n^3)$.

Однак цю оцінку можна трохи покращити. Виявляється, для алгоритму Куна важливо, яка частина обрана за першу, а яка - за другу. Насправді, в описаній вище реалізації запуски обходу в глибину/ширину відбуваються тільки з вершин першої частини, тому весь алгоритм виконується за час $O(n_1 m)$, де $n_1$ - кількість вершин першої частини. У гіршому випадку це становить $O(n_1^2 n_2)$ (де $n_2$ - кількість вершин другої частини). Звідси видно, що вигідніше, коли перша частина містить менше кількість вершин, ніж друга. На дуже несбалансованих графах (коли $n_1$ і $n_2$ сильно відрізняються) це призводить до значної різниці часу роботи.

## Реалізація

Наведемо реалізацію описаного алгоритму, основану на обході в глибину, та приймаючу двудольний граф у вигляді явно розділеного на дві частини графа. Ця реалізація дуже лаконічна, і, можливо, її варто запам'ятати саме в такому вигляді.

Тут $n$ - кількість вершин у першій частині, $k$ - у другій частині, $g[v]$ - список ребер з вершини $v$ першої частини (тобто список номерів вершин, в які ведуть ці ребра з $v$). Вершини в обох частках занумеровані незалежно, тобто перша частина - з номерами $1 \ldots n$, друга - з номерами $1 \ldots k$.

Далі йдуть два допоміжні масиви: $\rm mt$ і $\rm used$. Перший - $\rm mt$ - містить інформацію про поточний паросполучник. Для зручності програмування, інформація ця міститься тільки для вершин другої частини: $mt[i]$ - це номер вершини першої частини, з'єднаної ребром з вершиною $i$ другої частини (або $-1$, якщо жодного ребра паросполучника з $i$ не виходить). Другий масив - $\rm used$ - звичайний масив "відвідуваності" вершин при обході в глибину (він потрібен, щоб обхід в глибину не заходив в одну вершину двічі).

Функція $\rm try\_kuhn$ - це обхід у глибину. Вона повертає $\rm true$, якщо їй вдалося знайти збільшуючий ланцюг з вершини $v$. При цьому вважається, що ця функція вже здійснила чергування паросполука вздовж знайденого ланцюгу.

Усередині функції переглядаються всі ребра, що виходять з вершини $v$, і спочатку перевіряється: якщо це ребро веде в ненасичену вершину $to$, або якщо ця вершина $to$ насичена, але вдається знайти збільшуючий ланцюг рекурсивним запуском з $\rm mt[to]$, то ми говоримо, що ми знайшли збільшуючий ланцюг, і перед поверненням з функції з результатом $\rm true$ виконуємо чергування в поточному ребрі: перенаправляємо ребро, суміжне з $to$, в вершину $v$.

У основній програмі спочатку вказується, що поточна паросполучення є порожньою (список $\rm mt$ заповнюється числами $-1$). Потім перебирається вершина $v$ першої частини, і з неї запускається обхід в глибину $\rm try\_kuhn$, попередньо обнуливши масив $\rm used$.

Варто зазначити, що розмір паросполучення легко отримати як число викликів $\rm try\_kuhn$ в основній програмі, що повернули результат $\rm true$. Саме шукане максимальне паросполучення міститься в масиві $\rm mt$.

<!--- TODO: specify code snippet id -->
``` cpp
int n, k;
vector<vector<int>> g;
vector<int> mt;
vector<char> used;

bool try_kuhn(int v) {
    if (used[v])
        return false;
    used[v] = true;
    for (size_t i = 0; i < g[v].size(); ++i) {
        int to = g[v][i];
        if (mt[to] == -1 || try_kuhn(mt[to])) {
            mt[to] = v;
            return true;
        }
    }
    return false;
}

int main() {
...читання графу...

        mt.assign(k, -1);
    for (int v = 0; v < n; ++v) {
        used.assign(n, false);
        try_kuhn(v);
    }

    for (int i = 0; i < k; ++i)
        if (mt[i] != -1)
            printf("%d %d\n", mt[i] + 1, i + 1);
}
```

Ще раз наголосимо, що алгоритм Куна легко реалізовувати так, щоб він працював на графах, про які відомо, що вони двудольні, але явне їх розбиття на дві частини не знайдено. У цьому випадку доведеться відмовитися від зручного розбиття на дві частини і зберігати всю інформацію для всіх вершин графа. Для цього масив списків $g$ тепер задається не тільки для вершин першої частини, а для всіх вершин графа (зрозуміло, тепер вершини обох частин нумеруються в загальній нумерації - від $1$ до $n$). Масиви $\rm mt$ і $\rm used$ тепер також визначені для вершин обох частин і, відповідно, їх потрібно підтримувати в цьому стані.

## Покращена реалізація

Модифікуємо алгоритм наступним чином. До основного циклу алгоритму знайдемо якимось простим алгоритмом **будь-яку паросполученість** (простим **евристичним алгоритмом**), і лише потім будемо виконувати цикл з викликами функції kuhn(), який буде покращувати цю паросполученість. В результаті алгоритм буде працювати помітно швидше на випадкових графах - тому що в більшості графів можна легко набрати паросполученість достатньо великої ваги з допомогою евристики, а потім покращити знайдену паросполученість до максимальної вже звичайним алгоритмом Куна. Тим самим ми зекономимо на запусках обходу в глибину з тих вершин, які ми вже включили з допомогою евристики в поточну паросполученість.

Наприклад, можна просто перебрати всі вершини першої частини, і для кожної з них знайти довільне ребро, яке можна додати в паросполуку, і додати його. Навіть така проста евристика здатна прискорити алгоритм Куна в декілька разів.

Слід звернути увагу на те, що основний цикл доведеться трохи модифікувати, оскільки при виклику функції $\rm try\_kuhn$ в основному циклі передбачається, що поточна вершина ще не входить в паросполуку, тому потрібно додати відповідну перевірку.

У реалізації зміниться тільки код у функції main()

<!--- TODO: specify code snippet id -->
``` cpp
int main() {
...читання графу...

        mt.assign(k, -1);
    vector<char> used1(n);
    for (int i = 0; i < n; ++i)
        for (size_t j = 0; j < g[i].size(); ++j)
            if (mt[g[i][j]] == -1) {
                mt[g[i][j]] = i;
                used1[i] = true;
                break;
            }
    for (int i = 0; i < n; ++i) {
        if (used1[i])
            continue;
        used.assign(n, false);
        try_kuhn(i);
    }

    for (int i = 0; i < k; ++i)
        if (mt[i] != -1)
            printf("%d %d\n", mt[i] + 1, i + 1);
}
```

Іншою хорошою евристикою є наступне. На кожному кроці треба шукати вершину з найменшою кількістю ребер (але не ізольовану), з неї вибирати будь-яке ребро і додавати його до паросполуки, потім видаляти обидві ці вершини з усіма інцидентними їм ребрами з графа. Така жадібність працює дуже добре на випадкових графах, навіть у більшості випадків будує максимальну паросполуку (хоча є тести, на яких вона знайде паросполуку значно меншого розміру, ніж максимальну).