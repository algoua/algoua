# Знаходження найкоротших шляхів від заданої вершини до всіх інших вершин алгоритмом Дейкстри

## Постановка завдання

Даний орієнтований або неорієнтований зважений граф з $n$ вершинами і $m$ ребрами. Ваги всіх ребер невід'ємні. Вказано деяку стартову вершину $s$. Потрібно знайти довжини найкоротших шляхів з вершини $s$ до всіх інших вершин, а також надати спосіб виведення самих найкоротших шляхів.

Ця задача називається "задачею про найкоротші шляхи з єдиним джерелом" (single-source shortest paths problem).

## Алгоритм

Тут описується алгоритм, який запропонував голландський дослідник **Дейкстра** (Dijkstra) у 1959 році.

Заведемо масив $d[]$, в якому для кожної вершини $v$ будемо зберігати поточну довжину $d[v]$ найкоротшого шляху з $s$ в $v$. Спочатку $d[s]=0$, а для всіх інших вершин ця довжина рівна нескінченності (при реалізації на комп'ютері зазвичай в якості нескінченності вибирають просто достатньо велике число, свідомо більше можливої довжини шляху)

$$
d[v] = \infty, v \ne s
$$

Крім того, для кожної вершини $v$ будемо зберігати, чи вона вже позначена, тобто заведемо булевий масив $u[]$. Спочатку всі вершини не позначені, тобто

$$
u[v] = {\rm false}
$$

Сам алгоритм Дейкстри складається з $n$ **ітерацій**. На наступній ітерації вибирається вершина $v$ з найменшою величиною $d[v]$ серед ще не відвіданих, тобто:

$$
d[v] = \min_{p:\ u[p]={\rm false}} d[p]
$$

Зрозуміло, що на першій ітерації буде обрана стартова вершина $s$.

Обрана таким чином вершина $v$ позначається як помічена. Далі, на поточній ітерації, з вершини $v$ виконуються **релаксації**: переглядаються всі ребра $(v,to)$, що виходять з вершини $v$, і для кожної такої вершини $to$ алгоритм намагається покращити значення $d[to]$. Нехай довжина поточного ребра дорівнює $\rm len$, тоді релаксація виглядає у вигляді наступного коду:

$$
d[to] = \min (d[to], d[v] + {\rm len})
$$

На цій ітерації алгоритм закінчує свою роботу, переходячи до наступної ітерації (знову вибирається вершина з найменшою величиною $d$, робляться релаксації тощо). Після $n$ ітерацій всі вершини графа стають поміченими, і алгоритм завершує свою роботу. Зазначається, що знайдені значення $d[v]$ є шуканими довжинами найкоротших шляхів з $s$ до $v$.

Варто зазначити, що якщо не всі вершини графа доступні з вершини $s$, то значення $d[v]$ для них залишаться нескінченними. Зрозуміло, що декілька останніх ітерацій алгоритму будуть саме вибирати ці вершини, але вони не будуть корисними (оскільки нескінченна відстань не зможе прорелаксувати інші, навіть також нескінченні відстані). Тому алгоритм можна зупинити, якщо обрано вершину з нескінченною відстанню.

**Відновлення шляхів**. Зрозуміло, зазвичай потрібно знати не тільки довжини найкоротших шляхів, але й отримати самі шляхи. Покажемо, як зберегти інформацію, достатню для подальшого відновлення найкоротшого шляху з $s$ до будь-якої вершини. Для цього достатньо так званого **масиву предків**: масиву $p[]$, в якому для кожної вершини $v \ne s$ зберігається номер вершини $p[v]$, яка є передостанньою в найкоротшому шляху до вершини $v$. Тут використовується той факт, що якщо ми візьмемо найкоротший шлях до якоїсь вершини $v$, а потім видалимо з цього шляху останню вершину, то вийде шлях, що закінчується деякою вершиною $p[v]$, і цей шлях буде найкоротшим для вершини $p[v]$. Отже, якщо ми будемо володіти цим масивом предків, то найкоротший шлях можна буде відновити по ньому, просто кожного разу беручи предка від поточної вершини, поки ми не прийдемо в стартову вершину $s$ - так ми отримаємо шуканий найкоротший шлях, але записаний у зворотному порядку. Отже, найкоротший шлях $P$ до вершини $v$ дорівнює:

$$
P = (s, \ldots, p[p[p[v]]], p[p[v]], p[v], v)
$$

Залишилося зрозуміти, як будувати цей масив предків. Однак це робиться дуже просто: при кожній успішній релаксації, тобто коли з обраної вершини $v$ відбувається поліпшення відстані до деякої вершини $to$, ми записуємо, що предком вершини $to$ є вершина $v$:

$$
p[to] = v
$$

## Доведення

Основне твердження, на якому ґрунтується коректність алгоритму Дейкстри, полягає в тому, що після того, як будь-яка вершина $v$ стає поміченою, поточна відстань до неї $d[v]$ вже є найкоротшою і, відповідно, не змінюватиметься. Русизми замінено на українські слова.

**Доведення** будемо виробляти за допомогою індукції. Для першої ітерації справедливість його очевидна - для вершини $s$ маємо $d[s]=0$, що і є довжина найкоротшого шляху до неї. Нехай тепер це твердження виконано для всіх попередніх ітерацій, тобто всіх вже помічених вершин; доведемо, що воно не порушується після виконання поточної ітерації. Нехай $v$ - вершина, обрана на поточній ітерації, тобто вершина, яку алгоритм збирається помітити. Доведемо, що $d[v]$ дійсно дорівнює довжині найкоротшого шляху до неї (позначимо цю довжину через $l[v]$).

Розглянемо найкоротший шлях $P$ до вершини $v$. Зрозуміло, що цей шлях можна розбити на два шляхи: $P_1$, що складається тільки з позначених вершин (як мінімум, стартова вершина $s$ буде в цьому шляху), і решта частини шляху $P_2$ (вона також може містити позначені вершини, але починається обов'язково з непозначеної). Позначимо через $p$ першу вершину шляху $P_2$, а через $q$ - останню вершину шляху $P_1$.

Доведемо спочатку наше твердження для вершини $p$, тобто доведемо рівність $d[p] = l[p]$. Однак це практично очевидно: адже на одній з попередніх ітерацій ми вибирали вершину $q$ і виконували релаксацію з неї. Оскільки (в силу самого вибору вершини $p$) найкоротший шлях до $p$ дорівнює кратчайшому шляху до $q$ плюс ребро $(p,q)$, то при виконанні релаксації з $q$ величина $d[p]$ дійсно встановиться в необхідне значення.

У зв'язку з тим, що вартості ребер є не меншими за нуль, довжина найкоротшого шляху до вершини $v$, $l[v]$, не перевищує довжину найкоротшого шляху до вершини $p$, $l[p]$, яка, як ми вже довели, дорівнює $d[p]$. Зважаючи на те, що алгоритм Дейкстри не може знайти шлях коротший за можливий, маємо: $l[v] \le d[v]$. Загалом, ми отримуємо наступне співвідношення:

$$
d[p] = l[p] \le l[v] \le d[v]
$$

З іншого боку, оскільки як $p$, так і $v$ є непоміченими вершинами, то, оскільки на поточній ітерації була обрана саме вершина $v$, а не вершина $p$, отримуємо іншу нерівність:

$$
d[p] \ge d[v]
$$

З цих двох нерівностей ми можемо зробити висновок про рівність $d[p] = d[v]$. Після цього ми можемо скористатися знайденими раніше співвідношеннями, щоб отримати:

$$
d[v] = l[v]
$$

що потрібно довести?

## Реалізація

Отже, алгоритм Дейкстри представляє собою $n$ ітерацій, на кожній з яких вибирається непозначена вершина з найменшою величиною $d[v]$. Ця вершина позначається, і потім проглядаються всі ребра, що виходять з даної вершини, і уздовж кожного ребра робиться спроба покращити значення $d[]$ в кінці ребра. Русизми "непомеченная" та "уздовж" замінено на відповідні українські слова.

Час роботи алгоритму складається з наступних етапів:

* $n$ разів шукати вершину з найменшою величиною $d[v]$ серед усіх непозначених вершин, тобто серед $O(n)$ вершин
* $m$ разів виготовляється спроба релаксації

При найпростішій реалізації цих операцій на пошук вершини буде затрачуватися $O(n)$ операцій, а на одну релаксацію - $O(1)$ операцій, і підсумкова **асимптотична складність** алгоритму становить:

$$
O(n^2+m)
$$

**Реалізація**:

<!--- TODO: specify code snippet id -->
``` cpp
const int INF = 1000000000;

int main() {
    int n;
    ... читання n... vector<vector<pair<int, int>>> g(n);
... читання графу... int s = ...; // стартова вершина

    vector<int> d(n, INF), p(n);
    d[s] = 0;
    vector<char> u(n);
    for (int i = 0; i < n; ++i) {
        int v = -1;
        for (int j = 0; j < n; ++j)
            if (!u[j] && (v == -1 || d[j] < d[v]))
                v = j;
        if (d[v] == INF)
            break;
        u[v] = true;

        for (size_t j = 0; j < g[v].size(); ++j) {
            int to = g[v][j].first, len = g[v][j].second;
            if (d[v] + len < d[to]) {
                d[to] = d[v] + len;
                p[to] = v;
            }
        }
    }
}
```

Тут граф $g$ зберігається у вигляді списків суміжності: для кожної вершини $v$ список $g[v]$ містить список ребер, що виходять з цієї вершини, тобто список пар $\rm pair<int,int>$, де перший елемент пари - вершина, до якої веде ребро, а другий елемент - вага ребра. Також, будь ласка, замініть "список ребер, вихідних" на "список ребер, що виходять".

Після читання створюються масиви відстаней $d[]$, міток $u[]$ та предків $p[]$. Потім виконується $n$ ітерацій. На кожній ітерації спочатку знаходиться вершина $v$, яка має найменшу відстань $d[]$ серед непомічених вершин. Якщо відстань до обраної вершини $v$ виявляється рівною нескінченності, то алгоритм зупиняється. Інакше вершина позначається як помічена, і проглядаються всі ребра, які виходять з даної вершини, і уздовж кожного ребра виконуються релаксації. Якщо релаксація успішна (тобто відстань $d[to]$ змінюється), то перераховується відстань $d[to]$ і зберігається предок $p[]$.

Після виконання всіх ітерацій у масиві $d[]$ виявляються довжини найкоротших шляхів до всіх вершин, а в масиві $p[]$ - предки всіх вершин (крім стартової $s$). Шлях до будь-якої вершини $t$ можна відновити наступним чином:
<!--- TODO: specify code snippet id -->
``` cpp
vector<int> path;
for (int v = t; v != s; v = p[v])
    path.push_back(v);
path.push_back(s);
reverse(path.begin(), path.end());
```

## Література

* \book{Томас Кормен, Чарльз Лейзерсон, Рональд Рівест, Кліффорд Штайн}{Алгоритми: Побудова та аналіз}{2005}{cormen.djvu}
* \book{Edsger Dijkstra}{A note on two problems in connexion with graphs}{1959}