# Угорський алгоритм розв'язання задачі про призначення

## Постановка задачі щодо призначень

Задача про призначення ставиться дуже природно.

Наведемо кілька **варіантів формулювання** (як легко бачити, всі вони еквівалентні один одному):

* Є $n$ працівників і $n$ завдань. Для кожного працівника відомо, скільки грошей він запитує за виконання того чи іншого завдання. Кожен працівник може взяти собі тільки одне завдання. Потрібно розподілити завдання між працівниками так, щоб мінімізувати загальні витрати.

* Дана матриця $A$ розміру $n \times n$. Потрібно в кожній її рядку вибрати по одному числу так, щоб в будь-якому стовпці також було вибрано рівно по одному числу, і при цьому сума обраних чисел була б мінімальною.

* Дана матриця $A$ розміру $n \times n$. Потрібно знайти таку перестановку $p$ довжини $n$, що величина $\sum\limits_{i=1}^{n} A_{i,p_i}$ є мінімальною.

* Даний повний двудольний граф з $n$ вершинами; кожному ребру приписана деяка вага. Потрібно знайти паросполуку мінімальної ваги.

Відзначимо, що всі наведені вище постановки "**квадратні**": в них обидві розмірності завжди збігаються (і рівні $n$). На практиці часто зустрічаються аналогічні "**прямокутні**" постановки, коли $n \ne m$, і треба вибрати $\min(n,m)$ елементів. Втім, як легко замітити, від "прямокутної" задачі завжди можна перейти до "квадратної", додавши рядки/стовпці з нульовими/безкінечними значеннями відповідно.

Також зауважимо, що за аналогією з пошуком **найменшого** розв'язку також можна ставити задачу пошуку **найбільшого** розв'язку. Проте ці дві задачі еквівалентні одна одній: достатньо всі ваги помножити на $-1$.

## Угорський метод

### Історична довідка

Алгоритм був розроблений і опублікований Гарольдом **Куном** (Harold Kuhn) в 1955 році. Сам Кун дав алгоритму назву "угорський", тому що він був значною мірою заснований на більш ранніх роботах двох угорських математиків: Денеша **Кеньїга** (Dénes Kőnig) і Ейгена **Егерварі** (Jenő Egerváry).

У 1957 році Джеймс **Манкрес** (James Munkres) показав, що цей алгоритм працює за (строго) поліноміальний час (тобто за час порядку полінома від $n$, що не залежить від величини вартостей).

Тому в літературі цей алгоритм відомий не тільки як "угорський", але й як "алгоритм Куна-Манкреса" або "алгоритм Манкреса".

Втім, недавно (у 2006 році) виявилося, що точно такий самий алгоритм був винаходом німецького математика Карла Густава Якобі (Carl Gustav Jacobi), і це стало відомо **століття до Куна**. Справа в тому, що його робота "Про дослідження порядку системи довільних звичайних диференціальних рівнянь", яка була написана латинською мовою і містила, крім інших результатів, поліноміальний алгоритм розв'язання задачі про призначення, була опублікована посмертно в 1890 році, але не була помічена математиками.

Також варто відзначити, що початковий алгоритм Куна мав асимптотику $O(n^4)$, і тільки пізніше Джек **Едмондс** (Jack Edmonds) і Річард **Карп** (Richard Karp) (і незалежно від них **Томідзава** (Tomizawa)) показали, як поліпшити його до асимптотики $O(n^3)$.

### Побудова алгоритму за $O(n^4)$

Відразу відзначимо, щоб уникнути неоднозначностей, що ми в основному розглядаємо тут задачу про призначення у матричній постановці (тобто дана матриця $a$, і треба вибрати з її $n$ елементів, що знаходяться в різних рядках і стовпцях). Індексацію масивів ми починаємо з одиниці, тобто, наприклад, матриця $a$ має індекси $a[1 \ldots n][1 \ldots n]$.

Також ми будемо вважати, що всі числа в матриці $a[][]$ **невід'ємні** (якщо цього не відбувається, то завжди можна перейти до не від'ємної матриці, додавши до всіх чисел деяке число).

Назвемо **потенціалом** пару довільних масивів чисел $u[1 \ldots n]$ і $v[1 \ldots n]$, якщо виконується умова:

$$
u[i] + v[j] \le a[i][j] (i = 1 \ldots n, ~~ j = 1 \ldots n).
$$

Як видно, числа $u[i]$ відповідають рядкам, а числа $v[j]$ - стовпцям матриці.

Назвемо **потенціалом $f$** суму його значень:

$$
f = \sum_{i=1}^n u[i] + \sum_{i=1}^n v[i].
$$

З одного боку, легко помітити, що вартість шуканого розв'язку $sol$ **не може бути меншою за** значення будь-якого потенціалу:

$$
sol \ge f.
$$

(Доведення. Шуканий розв'язок задачі представляє собою $n$ осередків матриці, і для кожного з них виконується умова $u[i] + v[j] \le a[i][j]$. Оскільки всі елементи знаходяться в різних рядках і стовпцях, то, підсумовуючи ці нерівності по всім обраним $a[i][j]$, в лівій частині нерівності отримуємо $f$, а в правій - $sol$, що і потрібно довести).

З іншого боку, виявляється, що завжди існує розв'язок і потенціал, при яких ця нерівність **стає рівністю**. Угорський алгоритм, описаний нижче, буде конструктивним доказом цього факту. Поки що ми звернемо увагу на те, що якщо який-небудь розв'язок має вартість, рівну по величині якомусь потенціалу, то цей розв'язок є **оптимальним**.

Зафіксуємо певний потенціал. Назвемо ребро $(i,j)$ **жорстким**, якщо воно задовольняє наступну умову:

$$
u[i] + v[j] = a[i][j].
$$

Згадаймо про альтернативну постановку задачі про призначення з використанням двудольного графа. Позначимо через $H$ двудольний граф, що складається тільки з жорстких ребер. Фактично, угорський алгоритм підтримує для поточного потенціалу **максимальну за кількістю ребер паросполучення $M$** графа $H$: і як тільки це паросполучення стане містити $n$ ребер, ребра цього паросполучення і будуть бути шуканим оптимальним розв'язком (адже це буде розв'язок, вартість якого збігається з величиною потенціалу).

Перейдемо безпосередньо до **опису алгоритму**.

* На початку алгоритму потенціали покладаються рівними нулю: $u_i = v_i = 0$, а паросполучення $M$ є порожнім.

* Далі, на кожному кроці алгоритму ми намагаємося, не змінюючи потенціалу, збільшити потужність поточного паросполучення $M$ на одиницю (нагадуємо, паросполучення шукається в графі жорстких ребер $H$).

Для цього фактично використовується звичайний [алгоритм Куна пошуку максимального паросполука у двудольних графах](https://uk.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9A%D1%83%D0%BD%D0%B0). Нагадаємо тут цей алгоритм.

Усі ребра паросполука $M$ орієнтуються по напрямку від другої до першої частини, всі інші ребра графа $H$ орієнтуються в протилежному напрямку.

Нагадаємо (з термінології пошуку паросочетання), що вершина називається насиченою, якщо до неї сміжне ребро з поточного паросочетання. Вершина, до якої не сміжне жодне ребро з поточного паросочетання, називається ненасиченою. Шлях непарної довжини, в якому перше ребро не належить паросочетанню, а для всіх наступних ребер відбувається чергування (належить/не належить) - називається збільшуючим шляхом.

З усіх ненасичених вершин запускається обхід [в глибину](dfs)/[в ширину](bfs). Якщо в результаті обходу вдалося досягти ненасиченої вершини другої частини, то це означає, що ми знайшли збільшуючий шлях з першої частини. Якщо чергувати ребра уздовж цього шляху (тобто перше ребро включити в паросполуку, друге виключити, третє включити, і т.д.), то тим самим ми збільшимо потужність паросполуки на одиницю.

Якщо ж шляхи не можна збільшити, то це означає, що поточний паросполука $M$ є максимальною в графі $H$, тому в такому випадку переходимо до наступного пункту.

* Якщо на поточному етапі не вдалося збільшити потужність поточного паросполучення, то проводиться перерахунок потенціалу таким чином, щоб на наступних етапах з'явилося більше можливостей для збільшення паросполучення.

Позначимо через $Z_1$ множину вершин першої частини, які були відвідані обходом алгоритму Куна при спробі пошуку збільшуючих ланцюгів; через $Z_2$ - множину відвіданих вершин другої частини.

Порахуємо величину $\Delta$:

$$
\Delta = \min_{i \in Z_1, j \notin Z_2} \{ a[i][j] - u[i] - v[j] \}.
$$

Ця величина є строго позитивною.

(Доведення. Припустимо, що $\Delta = 0$. Значить існує жорстке ребро $(i,j)$, причому $i \in Z_1$ і $j \notin Z_2$. З цього випливає, що ребро $(i,j)$ мало бути орієнтованим від другої частини до першої, тобто це жорстке ребро $(i,j)$ має входити в паросполуку $M$. Однак це неможливо, оскільки ми не могли потрапити в насичену вершину $i$, крім як пройшовши по ребру з $j$ в $i$. Прийшли до протиріччя, отже, $\Delta > 0

Тепер **перерахуємо потенціал** таким чином: для всіх вершин $i \in Z_1$ зробимо $u[i] = u[i] + \Delta$, а для всіх вершин $j \in Z_2$ - зробимо $v[j] = v[j] - \Delta$. Отриманий потенціал, як і раніше, залишиться коректним.

Доведення. Для цього потрібно показати, що як і раніше для всіх $i$ і $j$ виконується: $u[i] + v[j] \le a[i][j]$. Для випадків, коли $i \in Z_1 \cap j \in Z_2$ або $i \notin Z_1 \cap j \notin Z_2$ - це так, оскільки для них сума $u[i]$ і $v[j]$ не змінилась. Коли $i \notin Z_1 \cap j \in Z_2$ - нерівність тільки зміцнюється. Нарешті, для випадку $i \in Z_1 \cap j \notin Z_2$ - хоча ліва частина нерівності збільшується, нерівність все ж зберігається, оскільки величина $\Delta$, як видно з її визначення - це саме максимальне збільшення, що не порушує нерівності.

Крім того, стару паросполученість $M$ з жорстких ребер можна залишити, тобто всі ребра паросполученості залишаться жорсткими.

(Доведення. Щоб деяке жорстке ребро $(i,j)$ перестало бути жорстким в результаті зміни потенціалу, потрібно, щоб рівність $u[i] + v[j] = a[i][j]$ перетворилася на нерівність $u[i] + v[j] < a[i][j]$. Однак ліва частина могла зменшитися тільки в одному випадку: коли $i \notin Z_1 \& j \in Z_2$. Але якщо $i \notin Z_1$, то це означає, що ребро $(i,j)$ не могло бути ребром паросполука, що і потрібно довести).

Нарешті, щоб показати, що зміни потенціалу **не можуть відбуватися безмежно**, зауважимо, що при кожній такій зміні потенціалу кількість вершин, досяжних обходом, тобто $|Z_1|+|Z_2|$, строго збільшується. (При цьому не можна стверджувати, що збільшується кількість жорстких ребер).

(Доведення. По-перше, будь-яка вершина, яка була досяжною, залишиться досяжною. Насправді, якщо деяка вершина досяжна, то до неї є деякий шлях з досяжних вершин, що починається в ненасиченій вершині першої частини; а оскільки для ребер $(i,j)$, де $i \in Z_1$ та $j \in Z_2$, сума $u[i] + v[j]$ не змінюється, то весь цей шлях залишиться досяжним і після зміни потенціалу, що і потрібно довести. По-друге, покажемо, що в результаті перерахунку потенціалу з'явиться хоча б одна нова досяжна вершина. Але це майже очевидно, якщо повернутися до визначення $\Delta$: ребро $(i,j)$, на якому був досягнутий мінімум, тепер стане жорстким, а, значить, вершина $j$ стане досяжною завдяки цьому ребру і вершині $i$. )

Таким чином, загалом може відбутися не більше ніж $n$ перерахунків потенціалу, перед тим як буде виявлено збільшення ланцюжка і збільшиться потужність паросполучення $M$.

Таким чином, рано або пізно буде знайдено потенційне рішення, якому відповідає вчинена пара об'єктів $M$, що є відповіддю на задачу.

Якщо говорити про **асимптотику** алгоритму, то вона складає $O(n^4)$, оскільки всього має статися $n$ збільшень паросполука, перед кожним з яких відбувається не більше $n$ перерахунків потенціалу, кожний з яких виконується за час $O(n^2)$.

Реалізацію за $O(n^4)$ ми тут не приводимо, оскільки вона все одно вийде не коротше, ніж описана нижче реалізація за $O(n^3)$.

### Побудова алгоритму з часовою складністю $O(n^3)$ ($O(n^2 m)$)

Навчимось тепер реалізовувати той самий алгоритм з асимптотикою $O(n^3)$ (для прямокутних задач розмірності $n \times m$ - $O(n^2 m)$).

Ключова ідея: тепер ми будемо **додавати до розгляду рядки матриці один за одним**, а не розглядати їх всі одразу. Таким чином, описаний вище алгоритм матиме наступний вигляд:

* Додаємо до розгляду наступний рядок матриці $a$.

* Наразі ми перераховуємо потенціал лише для ланцюгів, що починаються з цієї рядка, не використовуючи збільшувальних ланцюгів.

* Як тільки з'являється ланцюг, збільшуємо його, чергуємо паросполучення вздовж нього (включаючи останнє), і переходимо до початку (до розгляду наступного рядка).

Щоб досягти необхідної асимптотики, потрібно реалізувати кроки 2-3, які виконуються для кожного рядка матриці, за час $O(n^2)$ (для прямокутних задач - за $O(n m)$).

Для цього ми згадаємо два факти, доведені нами вище:

* При зміні потенціалу вершини, які були досяжні обходом Куна, залишаться досяжними.

* Всього могло статися лише $O(n)$ перерахунків потенціалів, перш ніж буде знайдено збільшуючий ланцюг.

Звідси випливають **ключові ідеї**, які дозволяють досягти необхідної асимптотики

* Для перевірки наявності збільшувального ланцюжка та необхідності запускати обхід Куна заново після кожного перерахунку потенціалу не потрібно. Замість цього можна оформити обхід Куна в ітеративному вигляді: після кожного перерахунку потенціалу ми перевіряємо додані жорсткі ребра і, якщо їх ліві кінці були досяжними, помічаємо їх праві кінці як досяжні і продовжуємо обхід з них. Таким чином, збільшувальний ланцюжок можна шукати без повторного запуску обходу Куна.

* Розвиваючи цю ідею далі, можна прийти до такого представлення алгоритму: це цикл, на кожному кроці якого спочатку перераховується потенціал, потім знаходиться стовпець, ставший досяжним (а такий завжди знайдеться, оскільки після перерахунку потенціалу завжди з'являються нові досяжні вершини), і якщо цей стовпець був ненасиченим, то знайдена вершина збільшує ланцюг, а якщо стовпець був насиченим - то відповідна йому в паросполуці рядок також стає досяжною.

Тепер алгоритм має наступний вигляд: цикл додавання стовпців, на кожному з яких спочатку перераховується потенціал, а потім позначається як досяжний якийсь новий стовпець.

* Щоб швидко перераховувати потенціали (швидше, ніж наївний різновид за $O(n^2)$), потрібно підтримувати допоміжні мінімуми по кожному з рядків $j$:

$$
minv[j] = \min_{i \in Z_1} \{ a[i][j] - u[i] - v[j] \}.
$$

Як легко бачити, шукана величина $\Delta$ виражається через них наступним чином:

$$
\Delta = \min_{j \notin Z_2} \{ minv[j] \}.
$$

Таким чином, знаходження $\Delta$ тепер можливо провести за $O(n)$.

Підтримувати цей масив $minv[]$ необхідно при появі нових відвіданих рядків. Це, очевидно, можна зробити за $O(n)$ на один доданий рядок (що в сумі дасть $O(n^2)$). Також потрібно оновлювати масив $minv[]$ при перерахунку потенціалу, що також робиться за час $O(n)$ на один перерахунок потенціалу (оскільки $minv[]$ змінюється тільки для недосяжних на даний момент стовпців: а саме, зменшується на $\Delta$).

Таким чином, алгоритм має такий вигляд: у зовнішньому циклі ми додаємо до розгляду рядки матриці один за одним. Кожен рядок обробляється за час $O(n^2)$, оскільки при цьому може відбуватися лише $O(n)$ перерахунків потенціалу (кожен - за час $O(n)$), для чого за час $O(n^2)$ підтримується масив $minv[]$; алгоритм Куна сумарно працює за час $O(n^2)$ (оскільки він представлений у формі $O(n)$ ітерацій, на кожній з яких відвідується новий стовпець).

Підсумкова асимптотика становить $O(n^3)$ - або, якщо задача є прямокутною, $O(n^2 m)$.

### Реалізація угорського алгоритму за $O(n^3)$ ($O(n^2m)$)

Наведена реалізація фактично була розроблена **Андрієм Лопатиным** декілька років тому. Вона відрізняється надзвичайною лаконічністю: весь алгоритм поміщається в **30 рядків коду**.

Дана реалізація шукає розв'язок для прямокутної вхідної матриці $a[1 \ldots n][1 \ldots m]$, де $n \le m$. Матриця зберігається в $1$-індексації для зручності та стислості коду. Проблема полягає в тому, що в даній реалізації вводяться фіктивні нульова рядок та нульовий стовпець, що дозволяє написати багато циклів у загальному вигляді без додаткових перевірок.

Масиви $u[0 \ldots n-1]$ і $v[0 \ldots m-1]$ зберігають потенціали. Спочатку вони є нульовими, що вірно для матриці, що складається з нульових рядків. (Варто зауважити, що для даної реалізації неважливо, чи містить матриця $a[][]$ від'ємні числа).

Масив $p[0 \ldots m]$ містить пари: для кожного стовпчика $i = 1 \ldots m$ він зберігає номер відповідної обраної рядка $p[i]$ (або $0$, якщо поки нічого не вибрано). При цьому $p[0]$ для зручності реалізації приймається рівним номеру поточної розглянутої рядка.

Масив $minv[1 \ldots m]$ містить для кожного стовпця $j$ допоміжні мінімуми, необхідні для швидкого перерахунку потенціалу

$$
minv[j] = \min_{i \in Z_1} \{ a[i][j] - u[i] - v[j] \}.
$$

Масив $way[1 \ldots m]$ містить інформацію про те, де ці мінімуми досягаються, щоб ми згодом могли відновити збільшуючий ланцюг. На перший погляд здається, що в масиві $way[]$ для кожного стовпця треба зберігати номер рядка, а також завести ще один масив: для кожного рядка запам'ятати номер стовпця, з якого ми в неї прийшли. Однак замість цього можна замітити, що алгоритм Куна завжди потрапляє в рядки, проходячи по ребру паросполучення зі стовпців, тому номери рядків для відновлення ланцюга завжди можна взяти з паросполучення (тобто з масиву $p[]$). Таким чином, $way[j]$ для кожного стовпця $j$ містить номер попереднього стовпця (або $0$, якщо такого немає).

Сам алгоритм представляє собою зовнішній **цикл по рядках матриці**, всередині якого відбувається додавання до розгляду $i$-ої рядка матриці. Внутрішня частина представляє собою цикл "do-while (p[j0] ≠ 0)", який працює, доки не буде знайдений вільний стовпець $j0$. Кожна ітерація циклу позначає новий стовпець з номером $j0$ (підрахований на попередній ітерації, а спочатку дорівнює нулю - тобто ми починаємо з фіктивного стовпця), а також новий рядок $i0$ - суміжний з ним у паросполученні (тобто $p[j0]$; а спочатку при $j0=0$ береться $i$-то рядок). Через появу нового відвіданого рядка $i0$ потрібно відповідним чином перерахувати масив $minv[]$, при цьому ми знаходимо мінімум в ньому - величину $delta$, і в якому стовпці $j1$ цей мінімум був досягнутий (зауважимо, що при такій реалізації $delta$ може виявитися рівним нулю, що означає, що на поточному кроці потенціал можна не змінювати: новий досяжний стовпець є і без того). Після цього відбувається перерахунок потенціалу $u[], v[]$, відповідна зміна масиву $minv[]$. Після закінчення циклу "do-while" ми знаходимо збільшувальний ланцюг, що закінчується в стовпці $j0$, "розкручуємо", користуючись масивом предків $way[]$.

Константа $INF$ - це "нескінченність", тобто число, свідомо більше за всі можливі числа у вхідній матриці $a[][]$.

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> u(n + 1), v(m + 1), p(m + 1), way(m + 1);
for (int i = 1; i <= n; ++i) {
    p[0] = i;
    int j0 = 0;
    vector<int> minv(m + 1, INF);
    vector<char> used(m + 1, false);
    do {
        used[j0] = true;
        int i0 = p[j0], delta = INF, j1;
        for (int j = 1; j <= m; ++j)
            if (!used[j]) {
                int cur = a[i0][j] - u[i0] - v[j];
                if (cur < minv[j])
                    minv[j] = cur, way[j] = j0;
                if (minv[j] < delta)
                    delta = minv[j], j1 = j;
            }
        for (int j = 0; j <= m; ++j)
            if (used[j])
                u[p[j]] += delta, v[j] -= delta;
            else
                minv[j] -= delta;
        j0 = j1;
    } while (p[j0] != 0);
    do {
        int j1 = way[j0];
        p[j0] = p[j1];
        j0 = j1;
    } while (j0);
}
```

Відновлення відповіді у більш звичному форматі, тобто знаходження номера вибраного стовпця $ans[i]$ для кожного рядка $i = 1 \ldots n$, здійснюється наступним чином:

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> ans(n + 1);
for (int j = 1; j <= m; ++j)
    ans[p[j]] = j;
```

Стоимість знайденого паросполука можна просто взяти як потенціал нульового стовпчика (з протилежним знаком). Насправді, як легко прослідкувати по коду, $-v[0]$ містить в собі суму всіх величин $delta$, тобто сумарна зміна потенціалу. Хоча при кожній зміні потенціалу змінюватися могли зразу кілька величин $u[i]$ і $v[j]$, сумарна зміна величини потенціалу точно дорівнює $delta$, оскільки поки немає збільшувальних ланцюгів, число досяжних стрічок дорівнює на одиницю більше числу досяжних стовпців (тільки поточно рядок $i$ не має "пари" у вигляді відвіданого стовпця):

<!--- TODO: specify code snippet id -->
``` cpp
int cost = -v[0];
```

## Приклади завдань

Наведемо тут кілька прикладів розв'язку задачі про призначення: починаючи з дуже простих і закінчуючи менш очевидними завданнями:

* Даний двудольний граф, потрібно знайти в ньому паросполуку **максимальної мінімальної ваги** (тобто в першу чергу максимізується розмір паросполуки, а в другу чергу - мінімізується її вага).

Для розв'язання просто будуємо задачу про призначення, ставлячи на місце відсутніх ребер число "нескінченність". Після цього вирішуємо задачу за допомогою венгерського алгоритму і видаляємо з відповіді ребра нескінченної ваги (вони могли увійти до відповіді, якщо в задачі немає розв'язку у вигляді повної паросполученості).

* Даний двудольний граф, потрібно знайти в ньому **максимальну паросполученість максимальної ваги**.

Розв'язок знову очевидний, треба лише помножити всі ваги на мінус одиницю (або в алгоритмі Унгарі замінити всі мінімуми на максимуми, а нескінченності - на мінус нескінченність).

* Задача **виявлення рухливих об'єктів на знімках**: було зроблено два знімки, за результатами яких отримано два набори координат. Потрібно встановити відповідність між об'єктами на першому і другому знімках, тобто визначити, які точки другого знімка відповідають кожній точці першого знімка. При цьому необхідно мінімізувати суму відстаней між відповідними точками (тобто ми шукаємо розв'язок, в якому об'єкти в сумі пройшли найменший шлях).

Для розв'язання ми просто будуємо і вирішуємо задачу про призначення, де в якості ваг ребер виступають євклідові відстані між точками.

* Задача **виявлення рухомих об'єктів за допомогою локаторів**: є два локатори, які можуть визначати не тільки напрямок на об'єкт, але й його положення в просторі. З обох локаторів (розташованих у різних точках) отримано інформацію у вигляді $n$ напрямків. Потрібно визначити положення об'єктів, тобто знайти пари напрямків, які відповідають кожному об'єкту, щоб зменшити суму відстаней від об'єктів до лучів-напрямків.

Розв'язок - знову ж, просто будуємо та вирішуємо задачу про призначення, де вершинами першої частини є $n$ напрямків з першого локатора, вершинами другої частини - $n$ напрямків з іншого локатора, а вагами ребер - відстані між відповідними променями.

* Покриття **орієнтованого ациклічного графа шляхами**: дано орієнтований ациклічний граф, потрібно знайти найменше число шляхів (при рівності - з найменшою сумою ваг), щоб кожна вершина графа лежала в одному шляху.

Розв'язок полягає у побудові відповідного двудольного графа за заданим графом та у знаходженні максимальної паросполуки мінімальної ваги. Детальніше можна прочитати у статті про [покриття шляхів](path_cover).

* **Розфарбування дерева**. Дано дерево, в якому кожна вершина, крім листя, має $k-1$ синів. Потрібно вибрати для кожної вершини деякий колір з $k$ кольорів так, щоб жодні дві сусідні вершини не мали одного й того ж кольору. Крім того, для кожної вершини і кожного кольору відома вартість фарбування цієї вершини у цей колір, і потрібно мінімізувати сумарну вартість.

Для розв'язку скористаємось методом динамічного програмування. Зокрема, навчимося рахувати величину $d[v][c]$, де $v$ - номер вершини, $c$ - номер кольору, а саме значення $d[v][c]$ - це мінімальна вартість розфарбування вершини $v$ разом з її нащадками, причому сама вершина $v$ має колір $c$. Щоб порахувати таку величину $d[v][c]$, потрібно розподілити інші $k-1$ квітів між синами вершини $v$, а для цього потрібно побудувати і розв'язати задачу про призначення (в якій вершини однієї частини - кольори, вершини іншої частини - вершини-сини, а ваги ребер - це значення відповідних динамік $d[][]$).

Таким чином, кожна величина $d[v][c]$ обчислюється за допомогою розв'язку задачі про призначення, що в підсумку дає асимптотику $O(n k^4)$.

* Якщо в задачі про призначення ваги задані не на ребрах, а на вершинах, причому тільки **однієї частини**, то можна обійтися без угорського алгоритму, а достатньо лише відсортувати вершини за вагою і запустити звичайний [алгоритм Куна](kuhn_matching) (детальніше див. [окрему статтю](vertex_weighted_matching)).

* Розглянемо наступний **приватний випадок**. Нехай кожній вершині першої частини приписано деяке число $\alpha[i]$, а кожній вершині другої частини - $\beta[j]$. Нехай вага будь-якого ребра $(i,j)$ дорівнює $\alpha[i] \cdot \beta[j]$ (числа $\alpha[i]$ і $\beta[j]$ нам відомі). Розв'язати задачу про призначення.

Для розв'язку без угорського алгоритму розглянемо спочатку випадок, коли в обох частинках по дві вершини. У цьому випадку, як нескладно переконатися, вигідно з'єднувати вершини в зворотньому порядку: вершину з меншою $\alpha[i]$ з'єднати з вершиною з більшою $\beta[j]$. Це правило легко узагальнити на довільну кількість вершин: потрібно відсортувати вершини першої частинки в порядку зростання $\alpha[i]$, другої частинки - в порядку спадання $\beta[j]$, і з'єднувати вершини попарно в такому порядку. Таким чином, ми отримуємо розв'язок з асимптотикою $O(n \log n)$.

* **Задача про потенціали**. Дана матриця $A[1 \ldots n][1 \ldots m]$. Потрібно знайти два масиви $u[1 \ldots n]$ і $v[1 \ldots m]$ такі, що для будь-яких $i$ і $j$ виконується $u[i] + v[j] \le A[i][j]$, але при цьому сума елементів масивів $u[]$ і $v[]$ максимальна.

Знаючи угорський алгоритм, розв'язок цієї задачі не становить жодної складності: угорський алгоритм саме знаходить потенціали $u[], v[]$, які задовольняють умовам задачі. З іншого боку, без знання угорського алгоритму розв'язати таку задачу майже неможливо.

## Література

* \book{Ravindra Ahuja, Thomas Magnanti, James Orlin}{Network Flows}{1993}{ahuja_flows.djvu}

* \book{Harold Kuhn}{The Hungarian Method for the Assignment Problem}{1955}

* \book{James Munkres}{Algorithms for Assignment and Transportation Problems}{1957}

## Завдання на онлайн-суддівстві

Список задач на розв'язок задачі про призначеннях:

* [UVA #10746 **"Crime Wave – The Sequel"** [складність: низька]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1687)

* [UVA #10888 **"Warehouse"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1829)

* [UVA #3276 **"The Great Wall Game"** [складність: висока]](http://livearchive.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1277)

* [UVA #10296 **"Jogging Trails"** [складність: висока]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1237)