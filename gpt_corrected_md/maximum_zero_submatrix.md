# Знаходження найбільшої нульової підматриці

Дана матриця $a$ розміром $n \times m$. Потрібно знайти в ній таку підматрицю, що складається тільки з нулів, і серед всіх таких - має найбільшу площу (підматриця - це прямокутна область матриці).

Тривіальний алгоритм, який перебирає шукану підматрицю, навіть при дуже хорошій реалізації, буде працювати з складністю $O(n^2 m^2)$. Нижче описується алгоритм, який працює за $O(n m)$, тобто за лінійний час від розмірів матриці.

## Алгоритм

Для усунення неоднозначностей відразу зауважимо, що $n$ дорівнює кількості рядків матриці $a$, відповідно, $m$ - це кількість стовпців. Елементи матриці будемо нумерувати з $0$-індексацією, тобто в позначенні $a[i][j]$ індекси $i$ і $j$ пробігають діапазони $i = 0 \ldots n-1$, $j = 0 \ldots m-1$.

### Крок 1: Допоміжна динаміка

Спочатку порахуємо наступну допоміжну динаміку: $d[i][j]$ - найближча зверху одиниця для елементу $a[i][j]$. Формально кажучи, $d[i][j]$ дорівнює найбільшому номеру рядка (серед рядків діапазону від $-1$ до $i$), в якому у $j$-му стовпці зустрічається одиниця. Зокрема, якщо такого рядка немає, то $d[i][j]$ приймається рівним $-1$ (це можна розуміти як те, що вся матриця якби обмежена ззовні одиницями).

Цю динаміку легко вважати, рухаючись по матриці зверху вниз: нехай ми знаходимося в $i$-ій рядку, і відоме значення динаміки для попередньої рядка. Тоді достатньо скопіювати ці значення в динаміку для поточної рядка, змінивши лише ті елементи, в яких в матриці стоїть одиниця. Зрозуміло, що тоді навіть не потрібно зберігати всю прямокутну матрицю динаміки, а достатньо лише одного масиву розміру $m$:

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> d(m, -1);
for (int i = 0; i < n; ++i) {
    for (int j = 0; j < m; ++j)
        if (a[i][j] == 1)
            d[j] = i;

Вирахували $d$ для $i$-ої рядка, можемо тут використовувати ці значення
}
```

### Крок 2: Розв'язання задачі

Вже зараз ми можемо розв'язати задачу за $O(nm^2)$ - просто перебираючи в поточній рядку номер лівого і правого стовпців шуканої підматриці, і з допомогою динаміки $d[][]$ обчислювати за $O(1)$ верхню межу нульової підматриці. Однак можна піти далі і значно покращити асимптотику розв'язку.

Ясно, що шукана нульова підматриця обмежена з усіх чотирьох сторін якимись одиницями (або межами поля), що заважають їй збільшуватися в розмірах та покращувати відповідь. Тому, щоб уникнути цього, ми будемо діяти наступним чином: спочатку переберемо номер $i$ нижнього рядка нульової підматриці, потім переберемо, в якому стовпці $j$ ми будемо упиратися вгору нульову підматрицю. За значенням $d[i][j]$ ми зразу отримаємо номер верхнього рядка нульової підматриці. Залишається тепер визначити оптимальні ліву і праву межі нульової підматриці, тобто максимально розсунути цю підматрицю вліво та вправо від $j$-го стовпця.

Що означає розсунути максимально вліво? Це означає знайти такий індекс $k_1$, для якого виконується умова $d[i][k_1] > d[i][j]$, при цьому $k_1$ є найближчим ліворуч індексом до $j$, для якого ця умова виконується. Якщо такого індексу немає, то встановлюємо $k_1=-1$ (це означає, що ми змогли розширити поточну нульову підматрицю вліво до межі всієї матриці $a$). Якщо ж індекс $k_1$ знайдено, то номер лівого стовпця шуканої нульової підматриці дорівнює $k_1+1$.

Симетрично можна визначити індекс $k_2$ для правої межі: це найближчий справа від $j$ індекс, для якого виконується умова $d[i][k_2] > d[i][j]$ (або $m$, якщо такого індексу немає).

Отже, індекси $k_1$ та $k_2$, якщо ми навчимося ефективно їх шукати, дадуть нам усю необхідну інформацію про поточну нульову підматрицю. Зокрема, її площа буде рівна $(i - d[i][j]) \cdot (k_2 - k_1 - 1)$.

Як шукати ці індекси $k_1$ і $k_2$ ефективно при фіксованих $i$ і $j$? Нас задовольнить тільки асимптотика $O(1)$, хоча б у середньому.

Досягнути такої асимптотики можна за допомогою стеку наступним чином. Навчимося спочатку знаходити індекс $k_1$ та зберігати його значення для кожного індексу $j$ всередині поточного рядка $i$ в динаміці $d_1[i][j]$. Для цього переглядатимемо всі стовпці $j$ зліва направо і заведемо стек, в якому завжди лежатимуть тільки ті стовпці, в яких значення динаміки $d[][]$ строго більше $d[i][j]$. Зрозуміло, що при переході від стовпчика $j$ до наступного стовпчика $j+1$ потрібно оновити зміст цього стеку. Стверджується, що потрібно спочатку покласти в стек стовпець $j$ (оскільки для нього стек "хороший"), а потім, поки на вершині стека лежить непідходящий елемент (тобто у якого значення $d \le d[i][j+1]$), - вилучати цей елемент. Легко зрозуміти, що вилучати зі стеку достатньо тільки з його вершини, і ні з яких інших місць (тому що стек буде містити зростаючу по $d$ послідовність стовпців).

Значення $d_1[i][j]$ для кожного $j$ буде рівне значенню, що знаходиться на вершині стеку в цей момент.

Ясно, що оскільки додавання в стек на кожній строці $i$ відбувається у кількості $m$, то і видалення не може бути більше, отже, сумарна складність буде лінійною.

Динаміка $d_{2}[i][j]$ для знаходження індексів $k_{2}$ вважається аналогічно, проте потрібно переглядати стовпці зправа наліво.

Також слід відзначити, що цей алгоритм використовує $O(m)$ пам'яті (не враховуючи вхідні дані - матрицю $a[][]$).

## Реалізація

Ця реалізація описаного алгоритму зчитує розміри матриці, потім саму матрицю (як послідовність чисел, розділених пробілами або переводами рядків), і потім виводить відповідь - розмір найбільшої нульової підматриці.

Легко покращити цю реалізацію, щоб вона також виводила саму нульову підматрицю. Для цього потрібно при кожній зміні $\rm ans$ запам'ятовувати також номери рядків і стовпців підматриці. Номером рядка буде $d[j]+1$, а номером стовпця - $i$. Для нульової підматриці номером верхнього лівого кута буде $d1[j]+1$, а номером нижнього правого кута - $d2[j]-1$.

<!--- TODO: specify code snippet id -->
``` cpp
int n, m;
cin >> n >> m;
vector<vector<int>> a(n, vector<int>(m));
for (int i = 0; i < n; ++i)
    for (int j = 0; j < m; ++j)
        cin >> a[i][j];

int ans = 0;
vector<int> d(m, -1), d1(m), d2(m);
stack<int> st;
for (int i = 0; i < n; ++i) {
    for (int j = 0; j < m; ++j)
        if (a[i][j] == 1)
            d[j] = i;
    while (!st.empty())
        st.pop();
    for (int j = 0; j < m; ++j) {
        while (!st.empty() && d[st.top()] <= d[j])
            st.pop();
        d1[j] = st.empty() ? -1 : st.top();
        st.push(j);
    }
    while (!st.empty())
        st.pop();
    for (int j = m - 1; j >= 0; --j) {
        while (!st.empty() && d[st.top()] <= d[j])
            st.pop();
        d2[j] = st.empty() ? m : st.top();
        st.push(j);
    }
    for (int j = 0; j < m; ++j)
        ans = max(ans, (i - d[j]) * (d2[j] - d1[j] - 1));
}

cout << ans;
```