# Біноміальні коефіцієнти

Біноміальним коефіцієнтом $C_n^k$ називається кількість способів вибрати набір $k$ предметів з $n$ різних предметів без обліку порядку розташування цих елементів (тобто кількість неупорядкованих наборів).

Також біноміальні коефіцієнти - це коефіцієнти в розкладі $(a+b)^n$ (т.н. біном Ньютона):

$$
(a+b)^n = C_n^0 a^n + C_n^1 a^{n-1} b + C_n^2 a^{n-2} b^2 + \ldots + C_n^k a^{n-k} b^k + \ldots + C_n^n b^n
$$

Вважається, що ця формула, як і трикутник, дозволяє ефективно знаходити коефіцієнти і була відкрита Блезом Паскалем (Blaise Pascal), який жив у 17 столітті. Тим не менш, вона була відома ще китайському математику Яну Хуєю (Yang Hui), який жив у 13 столітті. Можливо, її відкрив перський учений Омар Хайям (Omar Khayyam). Більше того, індійський математик Пінгала (Pingala), який жив ще у 3 столітті до н.е., отримав подібні результати. Заслуга Ньютона полягає в тому, що він узагальнив цю формулу для степенів, які не є натуральними.

## Обчислення

**Аналітична формула** для обчислення:

$$
C_n^k = \frac{n!}{k! (n-k)!}
$$

Цю формулу легко отримати з задачі про неупорядкований вибір (кількість способів неупорядковано вибрати $k$ елементів з $n$ елементів). Спочатку порахуємо кількість упорядкованих вибірок. Вибрати перший елемент можна $n$ способами, другий - $n-1$, третій - $n-2$, і так далі. Таким чином, для кількості упорядкованих вибірок отримуємо формулу: $ n (n-1) (n-2) \ldots (n-k+1) = \frac{n!}{(n-k)!} $. До неупорядкованих вибірок легко перейти, якщо помітити, що кожній неупорядкованій вибірці відповідає рівно $k!$ упорядкованих вибірок (тобто кількість всіх можливих перестановок $k$ елементів). В результаті, ділячи $\frac{n!}{(n-k)!}$ на $k!$, ми отримуємо шукану формулу.

Рекурентна формула (яка пов'язана зі знаменитим "трикутником Паскаля"):

$$
C_n^k = C_{n-1}^{k-1} + C_{n-1}^k
$$

Її легко вивести через попередню формулу.

Варто зазначити, що особливо при $n<k$ значення $C_n^k$ завжди дорівнює нулю.

## Властивості

Біноміальні коефіцієнти мають безліч властивостей. Наведемо найпростіші з них:

* Правило симетрії:

$$
C_n^k = C_n^{n-k}
$$

* Внесение-вынесение:

$$
C_n^k = \frac{n}{k} C_{n-1}^{k-1}
$$

* Підсумовуючи за $k$:

$$
\sum_{k=0}^n C_n^k = 2^n
$$

* Підсумовуючи за $n$:

$$
\sum_{m=0}^n C_m^k = C_{n+1}^{k+1}
$$

* Підсумовування за $n$ та $k$:

$$
\sum_{k=0}^{m} C_{n+k}^k = C_{n+m+1}^m
$$

* Підсумовування квадратів:

$$
(C_n^0)^2 + (C_n^1)^2 + \ldots + (C_n^n)^2 = C_{2n}^n
$$

* Взважене підсумовування:

$$
1 C_n^1 + 2 C_n^2 + \ldots + n C_n^n = n 2^{n-1}
$$

* Зв'язок з числами Фібоначчі:

$$
C_n^0 + C_{n-1}^1 + \ldots + C_{n-k}^k + \ldots + C_0^n = F_{n+1}
$$

## Обчислення в програмі

### Безпосередні обчислення за аналітичною формулою

Обчислення за першою непосредственною формулою досить легко програмувати, проте цей спосіб піддається переповненням навіть при порівняно невеликих значеннях $n$ і $k$ (навіть якщо відповідь повністю поміщається в який-небудь тип даних, обчислення проміжних факторіалів може призвести до переповнення). Тому дуже часто цей спосіб можна застосовувати тільки разом з [[Довга арифметика|Довгою арифметикою]]:

<!--- TODO: specify code snippet id -->
``` cpp

int C(int n, int k) {
    int res = 1;
    for (int i = n - k + 1; i <= n; ++i)
        res *= i;
    for (int i = 2; i <= k; ++i)
        res /= i;
}
```

### Покращена реалізація

Можна замітити, що в наведеній вище реалізації в чисельнику і знаменнику варто мати однакову кількість множників ($k$), кожний з яких не менше одиниці. Тому можна замінити наш дріб на добуток $k$ дробів, кожен з яких є дійсним числом. Однак можна замітити, що після множення поточної відповіді на кожний наступний дріб, усе рівне буде виходити цілим числом (це, наприклад, випливає з властивості "внесення-виведення"). Таким чином, отримуємо таку реалізацію:

<!--- TODO: specify code snippet id -->
``` cpp

int C(int n, int k) {
    double res = 1;
    for (int i = 1; i <= k; ++i)
        res = res * (n - k + i) / i;
    return (int)(res + 0.01);
}
```

Тут ми аккуратно наводимо дробове число до цілого, враховуючи, що через накопичення похибок воно може виявитися трохи меншим, ніж істинне значення (наприклад, $2.99999$ замість трьох).

### Трикутник Паскаля

За допомогою рекурентного співвідношення можна побудувати таблицю біноміальних коефіцієнтів (фактично, трикутник Паскаля), і отримувати результат з неї. Перевага цього методу полягає в тому, що проміжні результати ніколи не перевищують відповіді, і для обчислення кожного нового елементу таблиці потрібно всього лише одне додавання. Недоліком є повільна робота для великих N і K, якщо насправді таблиця не потрібна, а потрібне лише одне значення (тому що для обчислення $C_n^k$ знадобиться будувати таблицю для всіх $C_i^j,\ \ 1 \le i \le n,\ \ 1 \le j \le n$, або хоча б до $1 \le j \le \min(i,2k)$).

<!--- TODO: specify code snippet id -->
``` cpp

const int maxn = ...;
int C[maxn + 1][maxn + 1];
for (int n = 0; n <= maxn; ++n) {
    C[n][0] = C[n][n] = 1;
    for (int k = 1; k < n; ++k)
        C[n][k] = C[n - 1][k - 1] + C[n - 1][k];
}
```

Якщо вся таблиця значень не потрібна, то, як легко помітити, достатньо зберігати від неї лише дві рядки (поточний - $n$-ий рядок і попередній - $n-1$-ий).

### Обчислення з O(1)

Нарешті, у деяких ситуаціях виявляється вигідним передрахувати заздалегідь значення всіх факторіалів, щоб потім обчислювати будь-який необхідний біноміальний коефіцієнт, роблячи лише два ділення. Це можливо бути вигідним при використанні [Довгої арифметики](big_integer), коли пам'ять не дозволяє передрахувати весь трикутник Паскаля, або коли потрібно виконувати обчислення за деяким простим модулем (якщо модуль не є простим, то виникають складності при діленні чисельника дробу на знаменник; їх можна подолати, якщо факторизувати модуль і зберігати всі числа у вигляді векторів зі степенів цих простих; див. [розділ "Довга арифметика в факторизованому вигляді"](big_integer)).