# Знаходження Ейлерівого шляху за O(M)

Ейлерів шлях - це шлях у графі, який проходить через всі його ребра. Ейлерів цикл - це ейлерів шлях, який є циклом.

Задача полягає в тому, щоб знайти Ейлерів шлях в **ненаправленому мультиграфі з петлями**.

## Алгоритм

Спочатку перевіримо, чи існує Ейлерів шлях. Потім знайдемо всі прості цикли і об'єднаємо їх в один - це і буде Ейлеровим циклом. Якщо граф такий, що Ейлерів шлях не є циклом, то додамо недостаюче ребро, знайдемо Ейлерів цикл, потім видалимо зайве ребро.

Щоб перевірити, чи існує Ейлерів шлях або цикл, потрібно скористатися наступною теоремою. Ейлерів цикл існує тоді і тільки тоді, коли степені всіх вершин парні. Ейлерів шлях існує тоді і тільки тоді, коли кількість вершин з непарними степенями дорівнює двом (або нулю, якщо існує Ейлерів цикл). Російське слово "шлях" можна замінити на "шляхетність" або "маршрут", якщо це відповідає контексту.

Крім того, звісно, граф повинен бути достатньо зв'язним (тобто якщо вилучити з нього всі ізольовані вершини, то повинен вийти зв'язний граф).

Шукатимемо всі цикли і об'єднуватимемо їх однією рекурсивною процедурою:

<pre>procedure FindEulerPath (V)
1. перебрати всі ребра, що виходять з вершини V;
Кожне таке ребро потрібно видалити з графа, і..
Викликаємо функцію FindEulerPath з іншого кінця цього ребра;
Додаємо вершину V до відповіді
Складність цього алгоритму, очевидно, є лінійною щодо кількості ребер.

Але цей алгоритм ми можемо записати у **нерекурсивному** варіанті:

<pre>stack St;
у St кладемо будь-яку вершину (стартову вершину);
поки $St$ не порожній
Нехай V - значення на вершині стеку St;
Якщо ступінь дієслова (V) дорівнює 0, то..
Додаємо "в" до відповіді
Знімаємо V з вершини St;
    інакше
Знаходимо будь-яке ребро, що виходить з V;
Видаляємо його з графу
Другий кінець цього ребра кладемо в множину St
</pre>
Не складно перевірити еквівалентність цих двох форм алгоритму. Однак друга форма, очевидно, працює швидше, причому коду буде не більше.

## Задача про доміно

Наведемо тут класичну задачу на Ейлерів цикл - задачу про доміно.

Є $N$ доміношок. На двох концах кожної доміношки записано по одному числу (зазвичай від 1 до 6, але в нашому випадку не важливо). Потрібно викласти всі доміношки в ряд так, щоб у будь-яких двох сусідніх доміношках числа, записані на їх загальній стороні, збігалися. Дозволяється перевертати доміношки.

Переформулюємо задачу: числа, що записані на доміношках, є вершинами графа, а доміношки - ребрами цього графа (кожна доміношка з числами (a,b) - це ребро (a,b) і (b,a)). Отже, наша задача полягає в знаходженні ейлерового шляху в цьому графі.

## Реалізація

Приведенная нижче програма шукає і виводить ейлерів цикл або шлях в графі, або виводить -1, якщо його не існує.

Спочатку програма перевіряє степені вершин: якщо є вершини з непарним степенем, то в графі є ейлерів цикл; якщо є 2 вершини з непарним степенем, то в графі є тільки ейлерів шлях (ейлерів цикл відсутній); якщо ж таких вершин більше 2, то в графі немає ні ейлерів циклу, ні ейлерів шляху. Щоб знайти ейлерів шлях (не цикл), треба з'єднати ребром дві вершини з непарним степенем, потім знайти в отриманому графі ейлерів цикл (він, очевидно, буде існувати), і видалити з відповіді "фіктивне" ребро. Ейлерів цикл шукатимемо так само, як описано вище (за допомогою нерекурсивної версії). Після закінчення алгоритму перевіримо, чи був граф зв'язним (якщо граф був не зв'язним, то в графі залишаться деякі ребра, і в такому випадку виведемо -1). Нарешті, програма враховує, що в графі можуть бути ізольовані вершини.

<!--- TODO: specify code snippet id -->
``` cpp
int main() {
    int n;
    vector<vector<int>> g(n, vector<int>(n));
...зчитування графа у матрицю суміжності...

        vector<int>
            deg(n);
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            deg[i] += g[i][j];

    int first = 0;
    while (!deg[first])
        ++first;

    int v1 = -1, v2 = -1;
    bool bad = false;
    for (int i = 0; i < n; ++i)
        if (deg[i] & 1)
            if (v1 == -1)
                v1 = i;
            else if (v2 == -1)
                v2 = i;
            else
                bad = true;

    if (v1 != -1)
        ++g[v1][v2], ++g[v2][v1];

    stack<int> st;
    st.push(first);
    vector<int> res;
    while (!st.empty()) {
        int v = st.top();
        int i;
        for (i = 0; i < n; ++i)
            if (g[v][i])
                break;
        if (i == n) {
            res.push_back(v);
            st.pop();
        } else {
            --g[v][i];
            --g[i][v];
            st.push(i);
        }
    }

    if (v1 != -1)
        for (size_t i = 0; i + 1 < res.size(); ++i)
            if (res[i] == v1 && res[i + 1] == v2 || res[i] == v2 && res[i + 1] == v1) {
                vector<int> res2;
                for (size_t j = i + 1; j < res.size(); ++j)
                    res2.push_back(res[j]);
                for (size_t j = 1; j <= i; ++j)
                    res2.push_back(res[j]);
                res = res2;
                break;
            }

    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            if (g[i][j])
                bad = true;

    if (bad)
        puts("-1");
    else
        for (size_t i = 0; i < res.size(); ++i)
            printf("%d ", res[i] + 1);
}
```