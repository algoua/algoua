# Тернарний пошук

## Постановка завдання

Нехай дана функція $f(x)$, **унімодальна** на деякому відрізку $[l;r]$. Під унімодальністю розуміється один з двох варіантів. Перший: функція спочатку строго зростає, потім досягає максимуму (в одній точці або на цілому відрізку), потім строго зменшується. Другий різновид, симетричний: функція спочатку зменшується, досягає мінімуму, потім зростає. Надалі ми будемо розглядати перший різновид, другий буде абсолютно симетричний йому.

Потрібно **знайти максимум** функції $f(x)$ на відрізку $[l;r]$.

## Алгоритм

Візьмемо будь-які дві точки $m_1$ і $m_2$ на цьому відрізку: $l < m_1 < m_2 < r$. Обчислимо значення функції $f(m_1)$ і $f(m_2)$. Потім маємо три варіанти:

* Якщо виявиться, що $f(m_1) < f(m_2)$, то шуканий максимум не може перебувати в лівій частині, тобто в діапазоні $[l;m_1]$. Цим легко переконатися: якщо в лівій точці функція менше, ніж в правій, то або ці дві точки знаходяться в області "підйому" функції, або тільки ліва точка знаходиться там. У будь-якому випадку, це означає, що максимум далі має сенс шукати тільки в відрізку $[m_1;r]$.

* Якщо навпаки, $f(m_1) < f(m_2)$, то ситуація аналогічна попередній з точністю до симетрії. Тепер шуканий максимум не може перебувати в правій частині, тобто в частині $[m_2;r]$, тому переходимо до відрізка $[l;m_1]$.

* Якщо $f(m_1) = f(m_2)$, то або обидві ці точки знаходяться в області максимуму, або ліва точка знаходиться в області зростання, а права - в області спадання (тут істотно використовується те, що зростання/спадання є строгим). Таким чином, в подальшому пошук варто проводити в відрізку $[m_1;m_2]$, але (в цілях спрощення коду) цей випадок можна віднести до будь-якого з двох попередніх.

Таким чином, після порівняння значень функції в двох внутрішніх точках ми замість поточного інтервалу пошуку $[l;r]$ знаходимо новий інтервал $[l^\prime;r^\prime]$. Повторюємо всі дії для цього нового інтервалу, знову отримуємо новий, строго менший, інтервал, і так далі.

Раніше чи пізніше довжина відрізку стане надто малою, меншою за певну наперед задану константу точності, і процес можна зупинити. Цей метод є чисельним, тому після зупинки алгоритму можна приблизно вважати, що максимум досягається у всіх точках відрізку $[l;r]$; як відповідь можна взяти, наприклад, точку $l$.

Залишається зауважити, що ми не накладали жодних обмежень на вибір точок $m_1$ і $m_2$. Від цього способу залежатиме швидкість збіжності (і похибка). Найбільш поширений спосіб - вибирати точки так, щоб відрізок $[l;r]$ ділився ними на 3 рівні частини

$$
m_1 = l + \frac{r-l}{3}
$$

$$
m_2 = r - \frac{r-l}{3}
$$

Проте, при другому виборі, коли $m_1$ і $m_2$ знаходяться ближче один до одного, швидкість збіжності дещо збільшиться.

### Випадок цілочисельного аргументу

Якщо аргумент функції $f$ є цілим числом, то відрізок $[l;r]$ також стає дискретним. Однак, оскільки ми не накладали жодних обмежень на вибір точок $m_1$ і $m_2$, це не впливає на коректність алгоритму. Можна як і раніше вибирати $m_1$ і $m_2$ так, щоб вони ділили відрізок $[l;r]$ на 3 частини, але вже приблизно рівні.

Другий відмінний момент - критерій зупинки алгоритму. У цьому випадку тернарний пошук треба буде зупиняти, коли стане $r-l<3$, оскільки в такому випадку вже неможливо буде вибрати точки $m_1$ і $m_2$ так, щоб вони були різними та відрізнялися від $l$ і $r$, і це може призвести до зациклення. Після того, як алгоритм тернарного пошуку зупиниться і стане $r-l<3$, з залишилися кілька точок-кандидатів $(l,l+1,\ldots,r)$ треба вибрати точку з максимальним значенням функції.

## Реалізація

Реалізація для неперервного випадку (тобто функція $f$ має вигляд: $\rm double\ f\ (\rm double\ x)$):

<!--- TODO: specify code snippet id -->
``` cpp
double l = ..., r = ..., е = ...; // вхідні дані
while (r - l > EPS) {
    double m1 = l + (r - l) / 3, m2 = r - (r - l) / 3;
    if (f(m1) < f(m2))
        l = m1;
    else
        r = m2;
}
```

Тут $\rm EPS$ - фактично **абсолютна похибка** відповіді (не враховуючи похибок, пов'язаних з неточним обчисленням функції).

Замість критерію "while (r - l > EPS)" можна вибрати такий критерій зупинки:
<!--- TODO: specify code snippet id -->
``` cpp
for (int it = 0; it < iterations; ++it)```

З однієї сторони, доведеться підібрати константу $\rm iterations$, щоб забезпечити необхідну точність (зазвичай достатньо декількох сотень, щоб досягти максимальної точності). Але з іншої сторони, число ітерацій перестає залежати від абсолютних величин $l$ і $r$, тобто ми фактично за допомогою $\rm iterations$ задаємо необхідну **відносну похибку**.