# Лема Бернсайда. Теорема Пойа

## Лема Бернсайда

Ця лема була сформульована і доведена Бернсайдом у 1897 році. Однак було встановлено, що ця формула була раніше відкрита Фробеніусом у 1887 році, а ще раніше - Коші у 1845 році. Тому цю формулу іноді називають лемою Бернсайда, а іноді - теоремою Коші-Фробеніуса.

Лема Бернсайда дозволяє порахувати кількість класів еквівалентності в деякій множині, ґрунтуючись на її внутрішній симетрії.

### Об'єкти і уявлення

Проведемо чітку межу між кількістю об'єктів і кількістю уявлень.

Одному і тому ж об'єкту можуть відповідати різні уявлення, але, звісно, будь-яке уявлення відповідає лише одному об'єкту. Отже, множину всіх уявлень можна розбити на класи еквівалентності. Наша задача полягає у підрахунку саме кількості об'єктів, або, що те саме, кількості класів еквівалентності.

### Приклад задачі: раскраска бінарних дерев

Припустимо, що ми розглядаємо наступну задачу. Потрібно порахувати кількість способів розфарбувати кореневі бінарні дерева з $n$ вершинами у 2 кольори, якщо у кожної вершини ми не розрізняємо правого та лівого сина.

Безліч об'єктів тут - це множина різних у цьому розумінні розфарбувань дерев.

Визначимо тепер множину уявлень. Кожній розфарбуванню поставимо у відповідність задаючу його функцію $f(v)$, де $v = 1 \ldots n$, а $f(v)=0 \ldots 1$. Отже, множина уявлень - це множина різних функцій такого вигляду, і розмір його, очевидно, дорівнює $2^n$. В той же час, на цій множині..
у нашій роботі ми ввели розбиття на класи еквівалентності

Наприклад, нехай $n=3$, а дерево має наступну структуру: корінь - вершина 1, а вершини 2 і 3 - її дочки. Отже, наступні функції $f_1$ і $f_2$ вважаються еквівалентними:

$$
\matrix{
f_1(1)=0 & f_2(1)=0 \cr
f_1(2)=1 & f_2(2)=0 \cr
f_1(3)=0 & f_2(3)=1 \cr
}
$$

### Інваріантні перестановки

Чому ці дві функції $f_1$ і $f_2$ належать одному класу еквівалентності? Інтуїтивно це зрозуміло - тому що ми можемо переставити місцями сині вершини вершини 1, тобто вершини 2 і 3, а після такої перестановки функції $f_1$ і $f_2$ зберігають свої значення. Але формально це означає, що існує така **інваріантна перестановка** $\pi$ (тобто така, яка за умовою задачі не змінює сам об'єкт, а тільки його уявлення), що:

$$
f_2 \pi \equiv f_1
$$

Отже, виходячи з умови задачі, ми можемо знайти всі інваріантні перестановки, тобто такі, застосування яких не переводить нас з одного класу еквівалентності в інший. Значить, щоб перевірити, чи є дві функції $f_1$ і $f_2$ еквівалентними (тобто відповідають одному й тому ж об'єкту), потрібно для кожної інваріантної перестановки $\pi$ перевірити, чи не виконується умова $f_2 \pi \equiv f_1$ (або, що те саме, $f_1 \pi \equiv f_2$). Якщо хоча б для однієї перестановки ця рівність виконується, то $f_1$ і $f_2$ є еквівалентними, інакше вони не еквівалентні.

Знаходження всіх інваріантних перестановок, щодо яких наша задача є інваріантною, є ключовим кроком для застосування як леми Бернсайда, так і теореми Пойа. Зрозуміло, що ці інваріантні перестановки залежать від конкретної задачі, і їх знаходження - процес чисто евристичний, заснований на інтуїтивних міркуваннях. Однак у більшості випадків достатньо вручну знайти декілька "основних" перестановок, з яких всі інші перестановки можуть бути отримані шляхом їх всевозможних добутків (і цю, виключно механічну, частину роботи можна переложити на комп'ютер; більш детально це буде розглянуто нижче на прикладі конкретної задачі).

Легко зрозуміти, що інваріантні перестановки утворюють **групу**, оскільки добуток будь-яких інваріантних перестановок також є інваріантною перестановкою. Позначимо **групу інваріантних перестановок** як $G$.

### Формулювання тези (леми):

Для формулювання залишилося нагадати одне поняття з алгебри. **Нерухомою точкою** $f$ для перестановки $\pi$ називається такий елемент, який інваріантний щодо цієї перестановки: $f \equiv f \pi$. Наприклад, у нашому прикладі нерухомими точками будуть ті функції $f$, які відповідають розфарбуванням, що не змінюються при застосуванні до них перестановки $\pi$ (не змінюються саме у формальному сенсі рівності двох функцій). Позначимо через $I(\pi)$ **кількість нерухомих точок** для перестановки $\pi$.

Значить **лема Бернсайда** звучить наступним чином: кількість класів еквівалентності дорівнює сумі кількостей нерухомих точок по всіх перестановках з групи $G$, поділеній на розмір цієї групи

$$
{\rm ClassesCount} = \frac{1}{|G|} \sum_{\pi \in G} I(\pi)
$$

Хоча лема Бернсайда сама по собі не є такою зручною для застосування на практиці (поки що невідомо, як швидко знаходити величину $I(\pi)$), вона найбільш чітко розкриває математичну суть, на якій ґрунтується ідея підрахунку класів еквівалентності.

### Доведення леми Бернсайда

Описане тут доведення леми Бернсайда не є настільки важливим для її розуміння та застосування на практиці, тому його можна пропустити при першому читанні.

Приведене тут доведення є найпростішим з відомих і не використовує теорію груп. Це доведення було опубліковане Богартом (Bogart) та Кеннетом (Kenneth) у 1991 році.

Отже, нам потрібно довести твердження:

$$
{\rm ClassesCount} |G| = \sum_{\pi \in G} I(\pi)
$$

Величина, що стоїть справа, це не що інше, як кількість "інваріантних пар" $(f, \pi)$, тобто таких пар, що $f \pi \equiv f$. Очевидно, що ми маємо право змінити порядок підсумовування - зробити зовнішню суму по елементах $f$, а всередині неї поставити величину $J(f)$ - кількість перестановок, щодо яких $f$ є інваріантною

$$
{\rm ClassesCount} |G| = \sum_{f} J(f)
$$

Для доведення цієї формули складемо таблицю, стовпці якої будуть підписані всіма значеннями $f_i$, рядки - всіма перестановками $\pi_j$, а в комірках таблиці будуть стояти добутки $f_i \pi_j$. Отже, якщо ми будемо розглядати стовпці цієї таблиці як множини, то деякі з них можуть співпадати, і це означатиме, що відповідні цим стовпцям $f$ також еквівалентні. Таким чином, кількість різних множинових стовпців дорівнюватиме шуканій величині $\rm ClassesCount$. До речі, з точки зору теорії груп, стовпець таблиці, підписаний деяким елементом $f_i$, є орбітою цього елемента; для еквівалентних елементів, очевидно, орбіти збігаються, і число різних орбіт дорівнює саме $\rm ClassesCount$.

Отже, стовпці таблиці розпадаються на класи еквівалентності. Зафіксуємо який-небудь клас і розглянемо стовпці в ньому. По-перше, зауважимо, що в цих стовпцях можуть бути тільки елементи $f_i$ одного класу еквівалентності (інакше вийшло б, що деяким еквівалентним перетворенням $\pi_j$ ми перейшли в інший клас еквівалентності, що неможливо). По-друге, кожен елемент $f_i$ буде зустрічатися однакову кількість разів у всіх стовпцях (це також випливає з того, що стовпці відповідають еквівалентним елементам). Звідси можна зробити висновок, що всі стовпці всередині одного класу еквівалентності збігаються один з іншим як мультимножини.

Тепер зафіксуємо довільний елемент $f$. З однієї сторони, він зустрічається у своєму стовпці $J(f)$ разів (згідно з визначенням $J(f)$). З іншої сторони, всі стовпці всередині одного класу еквівалентності однакові як мультимножини. Отже, всередині кожного стовпця даного класу еквівалентності будь-який елемент $g$ зустрічається рівно $J(g)$ разів.

Таким чином, якщо ми візьмемо довільний клас еквівалентності та від нього візьмемо по одному елементу з кожної колонки, а потім підсумуємо кількість елементів, то отримаємо, з однієї сторони, ${\rm ClassesCount} |G|$ (це виходить, просто помноживши кількість стовпців на їх розмір), а з іншої сторони - суму величин $J(f)$ по всіх $f$ (це випливає з усіх попередніх розсуджень):

$$
{\rm ClassesCount} |G| = \sum_{f} J(f)
$$

що потрібно довести?

## Теорема Пуанкаре. Найпростіший випадок

Теорема **Поля** (Polya) є узагальненням леми Бернсайд, крім того, вона надає більш зручний інструмент для знаходження кількості класів еквівалентності. Слід зауважити, що ще до Пойа цю теорему було відкрито і доведено Редфілдом (Redfield) в 1927 році, проте його публікація пройшла непоміченою серед математиків того часу. Поля незалежно прийшов до того ж результату лише в 1937 році, і його публікація була більш успішною.

Тут ми розглянемо формулу, яка отримується як приватний випадок теореми Пуанкаре, і яку дуже зручно використовувати для обчислень на практиці. Загальна теорема Пуанкаре в даній статті розглядатися не буде.

Позначимо через $C(\pi)$ кількість циклів у перестановці $\pi$. Тоді виконується наступна формула (приватний випадок теореми Пойа):

$$
{\rm ClassesCount} = \frac{1}{|G|} \sum_{\pi \in G} k^{ C(\pi) }
$$

де $k$ - кількість значень, які може приймати кожен елемент уявлення $f(v)$. Наприклад, в нашій задачі-прикладі (розфарбування кореневого бінарного дерева в 2 кольори) $k = 2$.

### Доведення

Ця формула є прямим наслідком леми Бернсайд. Щоб отримати її, нам потрібно просто знайти явний вираз для величини $I(\pi)$, що фігурує в лемі (нагадаємо, це кількість нерухомих точок перестановки $\pi$).

Отже, розглянемо деяку перестановку $\pi$ та деякий елемент $f$. Під дією перестановки $\pi$ елементи $f$ передвигаються по циклах перестановки. Зауважимо, що оскільки $f \equiv f \pi$, то всередині кожного циклу перестановки повинні перебувати однакові елементи $f$. В той же час, для різних циклів не виникає жодного зв'язку між значеннями елементів. Таким чином, для кожного циклу перестановки $\pi$ ми вибираємо по одному значенню (серед $k$ варіантів), і тим самим отримуємо всі уявлення $f$, інваріантні щодо цієї перестановки

$$
I(\pi) = k ^ {C(\pi)}
$$

де $C(\pi)$ - кількість циклів у перестановці.

## Приклад задачі: Намиста

Задача "намисто" - це одна з класичних комбінаторних задач. Потрібно порахувати кількість різних намист, що складаються з $n$ бусинок, кожна з яких може бути пофарбована в один з $k$ кольорів. При порівнянні двох намист їх можна повертати, але не обертати (тобто дозволяється зробити циклічний зсув).

У цій задачі ми можемо знайти групу інваріантних перестановок. Очевидно, вона буде складатися з $n!$ перестановок:

$$
\pi_0 = 1\ 2\ 3\ \ldots\ n
$$

$$
\pi_1 = 2\ 3\ \ldots\ n\ 1
$$

$$
\pi_2 = 3\ \ldots\ n\ 1\ 2
$$

$$
\ldots
$$

$$
\pi_{n-1} = n\ 1\ 2\ \ldots\ (n-1)
$$

Знайдемо явну формулу для обчислення $C(\pi_i)$. По-перше, зауважимо, що перестановки мають такий вигляд, що в $i$-ій перестановці на $j$-ій позиції стоїть число $i+j$ (взяте за модулем $n$, якщо воно більше $n$). Якщо ми будемо розглядати циклічну структуру $i$-ої перестановки, то побачимо, що одиниця переходить в $1+i$, $1+i$ переходить в $1+2i$, $1+2i$ - в $1+3i$, і так далі, поки не прийдемо до числа $1 + kn$; для інших елементів виконуються схожі заяви. Звідси можна зрозуміти, що всі цикли мають однакову довжину, рівну ${\rm lcm}(i,n) / i$, тобто $n / {\rm gcd}(i,n)$ ("gcd" - найбільший спільний дільник, "lcm" - найменше спільне кратне). Значить, кількість циклів в $i$-ій перестановці буде рівна просто ${\rm gcd}(i,n)$.

Підставляючи знайдені значення у теорему Пуанкаре, отримуємо **розв'язок**:

$$
{\rm Ans} = \frac{1}{n} \sum_{i=1}^{n} k ^ {{\rm gcd}(i,n)}
$$

Можна залишити формулу в такому вигляді, але можна її ще більше спростити. Перейдемо від суми по всім $i$ до суми тільки по дільниках $n$. Дійсно, в нашій сумі буде багато однакових доданків: якщо $i$ не є дільником $n$, то такий дільник знайдеться після обчислення ${\rm НСД}(i,n)$. Отже, для кожного дільника $d|n$ його доданок $k^{{\rm НСД}(d,n)} = k^d$ врахується декілька разів, тобто суму можна записати у такому вигляді:

$$
{\rm Ans} = \frac{1}{n} \sum_{d|n} C_d k^d
$$

де $C_d$ - кількість таких чисел $i$, що ${\rm gcd}(i,n) = d$. Знайдемо явний вираз для цієї кількості. Будь-яке таке число $i$ має вигляд: $i=dm$, де ${\rm gcd}(m,n/d) = 1$ (інакше ${\rm gcd}(i,n) > d$). Згадуючи [функцію Ойлера](euler_function), ми знаходимо, що кількість таких $m$ - це значення функції Ойлера $\phi(n/d)$. Таким чином, $C_d = \phi(n/d)$, і остаточно отримуємо **формулу**:

$$
{\rm Ans} = \frac{1}{n} \sum_{d|n} \phi \left( \frac{n}{d} \right) k^d
$$

## Застосування леми Бернсайда разом з програмними обчисленнями

Далеко не завжди вдається чисто аналітичним шляхом отримати явну формулу для кількості класів еквівалентності. У багатьох завданнях кількість перестановок, що входять до групи, може бути занадто великою для ручних обчислень, і обчислити аналітично кількість циклів в них не є можливим.

У такому випадку потрібно вручну знайти кілька "основних" перестановок, яких буде достатньо для породження всієї групи $G$. Далі можна написати програму, яка згенерує всі перестановки групи $G$, підрахує кількість циклів в кожній з них і підставить їх у формулу.

Розглянемо, наприклад, **задачу про кількості розфарбувань тора**. Є прямокутний клітинний аркуш паперу розміром $n \times m$ $(n < m)$, деякі з клітин пофарбовані в чорний колір. Потім з цього аркуша отримують циліндр, склеюючи дві сторони з довжинами $m$. Потім з циліндра отримують тор, склеюючи два круга (основи циліндра) без перекручування. Потрібно порахувати кількість різних розфарбувань тора (аркуш був спочатку пофарбований довільно), вважаючи, що лінії склеювання нерозрізнимі, а тор можна повертати і перевертати.

У даній задачі представленням можна вважати листок бумаги розміром $n \times m$, деякі клітинки якого забарвлені в чорний колір. Легко зрозуміти, що наступні типи перетворень зберігають клас еквівалентності: циклічний зсув рядків листка, циклічний зсув стовпців листка, поворот листка на 180 градусів; також зрозуміло, що цих трьох типів перетворень достатньо для породження всієї групи інваріантних перетворень. Якщо ми якимось чином пронумеруємо клітинки поля, то ми зможемо записати три перестановки $p_1$, $p_2$, $p_3$, що відповідають цим типам перетворень. Далі залишається тільки згенерувати всі перестановки, що отримуються як складання цих трьох перестановок. Очевидно, що всі такі перестановки мають вигляд $p_1^{i_1} p_2^{i_2} p_3^{i_3}$, де $i_1 = 0 \ldots m-1$, $i_2 = 0 \ldots n-1$, $i_3 = 0 \ldots 1$.

Таким чином, ми можемо написати реалізацію розв'язку цієї задачі:

<!--- TODO: specify code snippet id -->
``` cpp
void mult(vector<int> &a, const vector<int> &b) {
    vector<int> aa(a);
    for (size_t i = 0; i < a.size(); ++i)
        a[i] = aa[b[i]];
}

int cnt_cycles(vector<int> a) {
    int res = 0;
    for (size_t i = 0; i < a.size(); ++i)
        if (a[i] != -1) {
            ++res;
            for (size_t j = i; a[j] != -1;) {
                size_t nj = a[j];
                a[j] = -1;
                j = nj;
            }
        }
    return res;
}

int main() {
    int n, m;
    cin >> n >> m;

    vector<int> p(n * m), p1(n * m), p2(n * m), p3(n * m);
    for (int i = 0; i < n * m; ++i) {
        p[i] = i;
        p1[i] = (i % n + 1) % n + i / n * n;
        p2[i] = (i / n + 1) % m * n + i % n;
        p3[i] = (m - 1 - i / n) * n + (n - 1 - i % n);
    }

    int sum = 0, cnt = 0;
    set<vector<int>> s;
    for (int i1 = 0; i1 < n; ++i1) {
        for (int i2 = 0; i2 < m; ++i2) {
            for (int i3 = 0; i3 < 2; ++i3) {
                if (!s.count(p)) {
                    s.insert(p);
                    ++cnt;
                    sum += 1 << cnt_cycles(p);
                }
                mult(p, p3);
            }
            mult(p, p2);
        }
        mult(p, p1);
    }

    cout << sum / cnt;
}
```