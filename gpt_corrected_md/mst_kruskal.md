# Мінімальне каркасне дерево. Алгоритм Крускала

Даний зважений неорієнтований граф. Потрібно знайти таке піддерево цього графа, яке б з'єднувало всі його вершини, і при цьому мало найменшу вагу (тобто суму ваг ребер) з усіх можливих. Таке піддерево називається мінімальним остовним деревом або просто мінімальним каркасом.

Тут будуть розглянуті кілька важних фактів, пов'язаних з мінімальними остовами. Потім буде розглянуто алгоритм Крускала у його найпростішій реалізації.

### Властивості мінімального острови

* Мінімальний каркас є унікальним, якщо ваги всіх ребер є різними. У іншому випадку може існувати кілька мінімальних каркасів (конкретні алгоритми зазвичай отримують один з можливих каркасів).
* Мінімальний каркас є також каркасом з мінімальною сумою ваг ребер.
Доводиться це легко, достатньо замінити ваги всіх ребер на їх логарифми
* Мінімальний каркас є також каркасом з мінімальною вагою найважчого ребра.
Це твердження випливає з правильності алгоритму Крускала
* Остов максимальної ваги шукається аналогічно каркасу мінімальної ваги. Для цього достатньо поміняти знаки всіх ребер на протилежні і виконати будь-який з алгоритмів мінімального остову.

### Алгоритм Крускала

Даний алгоритм був описаний Крускaлом (Kruskal) у 1956 році.

Алгоритм Крускала спочатку поміщує кожну вершину в своє дерево, а потім поступово об'єднує ці дерева, об'єднуючи на кожній ітерації два деяких дерева деяким ребром. Перед початком виконання алгоритму всі ребра упорядковані за вагою (в порядку неспадання). Потім починається процес об'єднання: перебираються всі ребра від першого до останнього (в порядку сортування), і якщо у поточного ребра його кінці належать різним піддеревам, то ці піддерева об'єднуються, а ребро додається до відповіді. Після перебору всіх ребер всі вершини будуть належати одному піддереву, і відповідь буде знайдена.

### Найпростіша реалізація

Цей код безпосередньо реалізує описаний вище алгоритм і виконується за **O(M log N + N<sup>2</sup>)**. Сортування ребер вимагає O(M log N) операцій. Приналежність вершини до піддерева зберігається за допомогою масиву tree_id - для кожної вершини зберігається номер дерева, до якого вона належить. Для кожного ребра ми за O(1) визначаємо, чи належать його кінці різним деревам. Нарешті, об'єднання двох дерев здійснюється за O(N) простим проходом по масиву tree_id. Зважаючи на те, що всього операцій злиття буде N-1, ми отримуємо асимптотику **O(M log N + N<sup>2</sup>)**.

<!--- TODO: specify code snippet id -->
``` cpp
int m;
вектор пар <інт, пара<інт, інт>> g(m); // вага - вершина 1 - вершина 2

int cost = 0;
vector<pair<int, int>> res;

sort(g.begin(), g.end());
vector<int> tree_id(n);
for (int i = 0; i < n; ++i)
    tree_id[i] = i;
for (int i = 0; i < m; ++i) {
    int a = g[i].second.first, b = g[i].second.second, l = g[i].first;
    if (tree_id[a] != tree_id[b]) {
        cost += l;
        res.push_back(make_pair(a, b));
        int old_id = tree_id[b], new_id = tree_id[a];
        for (int j = 0; j < n; ++j)
            if (tree_id[j] == old_id)
                tree_id[j] = new_id;
    }
}
```

### Покращена реалізація

З використанням структури даних ["Система неперетинних множин"](dsu) можна написати більш швидку реалізацію [алгоритму Крускала з асимптотикою O(M log N)](mst_kruskal_with_dsu).