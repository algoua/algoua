# Пошук загальних дотичних до двох окружностей

Дано два кола. Потрібно знайти всі їх загальні дотичні, тобто всі прямі, які стосуються обох колів одночасно.

Описаний алгоритм буде працювати також у випадку, коли одне (або обидва) кола вироджуються в точки. Таким чином, цей алгоритм можна використовувати також для знаходження дотичних до кола, які проходять через задану точку.

## Кількість загальних дотичних

Відразу відзначимо, що ми не розглядаємо **вироджені** випадки: коли кола збігаються (у цьому випадку вони мають нескінченно багато загальних дотичних), або одне коло лежить всередині іншого (у цьому випадку вони не мають загальних дотичних, або, якщо кола стосуються, є одна загальна дотична).

У більшості випадків два кола мають **чотири** спільні дотичні.

Якщо кола **доторкуються**, то у них буде три спільні дотичні, але це можна розуміти як випадок дотику, коли дві дотичні збігаються.

Більше того, описаний нижче алгоритм буде працювати навіть у випадку, коли одне або обидва кола мають нульовий радіус: у цьому випадку буде, відповідно, дві або одна загальна касательна.

Підводячи підсумок, ми, за винятком описаних на початку випадків, завжди будемо шукати **чотири дотичні**. У вироджених випадках деякі з них можуть збігатися, проте ці випадки також вписуються в загальну картину.

## Алгоритм

У цілях простоти алгоритму, будемо вважати, не втрачаючи загальності, що центр першого кола має координати $(0;0)$. (Якщо це не так, то цього можна досягти простим зсувом всієї картини, а після знаходження розв'язку - зсувом отриманих прямих назад).

Позначимо через $r_1$ та $r_2$ радіуси першого та другого кола відповідно, а через $v$ - координати центру другого кола (точка $v$ відмінна від початку координат). Ми не розглядаємо випадок, коли кола збігаються або одне коло знаходиться всередині іншого. Російське слово "точка" слід замінити на українське "крапка".

Для розв'язку задачі підійдемо до неї чисто **алгебраїчно**. Нам потрібно знайти всі прямі у вигляді $ax+by+c=0$, які лежать на відстані $r_1$ від початку координат, і на відстані $r_2$ від точки $v$. Крім того, налагоджуємо умову нормування прямої: сума квадратів коефіцієнтів $a$ і $b$ повинна бути рівна одиниці (це необхідно, інакше однієї і тієї ж прямої буде відповідати нескінченна кількість уявлень у вигляді $ax+by+c=0$). Разом отримуємо таку систему рівнянь на шукані $a,b,c$:

$$
\begin{cases}
a^2 + b^2 = 1, \\
| a \cdot 0 + b \cdot 0 + c | = r_1, \\
| a \cdot v_x + b \cdot v_y + c | = r_2.
\end{cases}
$$

Щоб позбутися модулів, зауважимо, що є чотири способи розкрити модулі в цій системі. Усі ці способи можна розглянути загальним випадком, якщо розуміти розкриття модуля як те, що коефіцієнт в правій частині можливо помножити на $-1$.

Іншими словами, ми переходимо до такої системи:

$$
\begin{cases}
a^2 + b^2 = 1, \\
c = \pm r_1, \\
a \cdot v_x + b \cdot v_y + c = \pm r_2.
\end{cases}
$$

Введу позначення $d_1 = \pm r_1$ та $d_2 = \pm r_2$. Це дозволить нам розв'язати систему чотири рази

$$
\begin{cases}
a^2 + b^2 = 1, \\
c = d_1, \\
a \cdot v_x + b \cdot v_y + c = d_2.
\end{cases}
$$

Розв'язок цієї системи зводиться до розв'язку квадратного рівняння. Ми опустимо всі громіздкі викладки і зразу наведемо готову відповідь:

$$
\begin{cases}
a = \frac{ (d_2-d_1)v_x \pm v_y \sqrt{ v_x^2 + v_y^2 - (d_2-d_1)^2 } }{ v_x^2 + v_y^2 }, \\
b = \frac{ (d_2-d_1)v_y \mp v_x \sqrt{ v_x^2 + v_y^2 - (d_2-d_1)^2 } }{ v_x^2 + v_y^2 }, \\
c = d_1.
\end{cases}
$$

Разом у нас вийшло $8$ розв'язків замість $4$. Однак легко зрозуміти, в якому місці виникають зайві розв'язки: насправді, в останній системі достатньо брати тільки один розв'язок (наприклад, перший). Насправді, геометричний зміст того, що ми беремо $\pm r_1$ і $\pm r_2$, зрозумілий: ми фактично перебираємо, по якій стороні від кожного з колів буде пряма. Тому два способи, які виникають при рішенні останньої системи, є зайвими: достатньо вибрати один з двох розв'язків (тільки, звісно, у всіх чотирьох випадках треба вибрати одне й те саме сімейство розв'язків).

Останнє, що ми ще не розглянули - це **як зсувати прямі** в тому випадку, коли перша коло не знаходилась спочатку в початку координат. Однак тут все просто: з лінійності рівняння прямої випливає, що від коефіцієнта $c$ треба відняти величину $a \cdot x_0 + b \cdot y_0$ (де $x_0$ і $y_0$ - координати початкового центру першого кола).

## Реалізація

Опишемо спочатку всі необхідні структури даних та інші допоміжні визначення:

<!--- TODO: specify code snippet id -->
``` cpp
struct pt {
    double x, y;

    pt operator-(pt p) {
        pt res = {x - p.x, y - p.y};
        return res;
    }
};

struct circle : pt {
    double r;
};

struct line {
    double a, b, c;
};

const double EPS = 1E-9;

double sqr(double a) { return a * a; }
```

Значить, саме розв'язок можна записати таким чином (де основна функція для виклику - друга; а перша функція - допоміжна):

<!--- TODO: specify code snippet id -->
``` cpp
void tangents(pt c, double r1, double r2, vector<line> &ans) {
    double r = r2 - r1;
    double z = sqr(c.x) + sqr(c.y);
    double d = z - sqr(r);
    if (d < -EPS)
        return;
    d = sqrt(abs(d));
    line l;
    l.a = (c.x * r + c.y * d) / z;
    l.b = (c.y * r - c.x * d) / z;
    l.c = r1;
    ans.push_back(l);
}

vector<line> tangents(circle a, circle b) {
    vector<line> ans;
    for (int i = -1; i <= 1; i += 2)
        for (int j = -1; j <= 1; j += 2)
            tangents(b - a, a.r * i, b.r * j, ans);
    for (size_t i = 0; i < ans.size(); ++i)
        ans[i].c -= ans[i].a * a.x + ans[i].b * a.y;
    return ans;
}
```