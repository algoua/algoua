# Дерево Фенвіка

**Дерево Фенвіка** - це структура даних, дерево на масиві, що має наступні властивості:

Дозволяє обчислювати значення деякої оборотної операції G на будь-якому відрізку [L; R] за час O(log N)

Дозволяє змінювати значення будь-якого елемента за **O(log N)**;

Вимагає **O(N)** пам'яті, а точніше, рівне стільки ж, скільки і масив з N елементів;

Легко узагальнюється на випадок багатовимірних масивів.

Найбільш поширене застосування дерева Фенвіка - обчислення суми на відрізку, тобто функція G (X1, ..., Xk) = X1 + ... + Xk.

Дерево Фенвіка було вперше описано у статті "Нова структура даних для таблиць кумулятивної частоти" (Пітер М. Фенвік, 1994).

## Опис

Для простоти опису ми припускаємо, що операція G, по якій ми будуємо дерево, - це **додавання**.

Нехай задано масив A[0..N-1]. Дерево Фенвіка - це масив **T**[0..N-1], в кожному елементі якого зберігається сума певних елементів масиву A:

$$
T<sub>i</sub> = сума A<sub>j</sub> для всіх j, для яких F(i) ≤ j ≤ i,
$$

де $F(i)$ - деяка функція, яку ми визначимо дещо пізніше.

Тепер ми можемо написати **псевдокод** для функції обчислення суми на відрізку [0; R] та для функції зміни центру

<!--- TODO: specify code snippet id -->
``` cpp
int sum(int r) {
    int result = 0;
    while (r >= 0) {
        result += t[r];
        r = f(r) - 1;
    }
    return result;
}

void inc(int i, int delta) {
Для всіх j, для яких F(j) ≤ i ≤ j { t[j] += дельта; }
}
```
Функція `sum` працює наступним чином. Замість того, щоб йти по всіх елементах масиву `A`, вона рухається по масиву `T`, роблячи "стрибки" через відрізки, де це можливо. Спочатку вона додає до відповіді значення суми на відрізку [F(R); R], потім бере суму на відрізку [F(F(R)-1); F(R)-1] і так далі, поки не дійде до нуля.

Функція `inc` рухається в прямому напрямку - в сторону збільшення індексів, оновлюючи значення суми `T<sub>j</sub>` тільки для тих позицій, для яких це потрібно, тобто для всіх `j`, для яких `F(j) ≤ i ≤ j`.

Очевидно, що від вибору функції F буде залежати швидкість виконання обох операцій. Зараз ми розглянемо функцію, яка дозволить досягти логарифмічної продуктивності в обох випадках.

**Визначимо значення функції F(X)** наступним чином. Розглянемо двійкове представлення цього числа і подивимося на його молодший біт. Якщо він дорівнює нулю, то F(X) = X. Інакше двійкове представлення числа X закінчується на групу з однієї або кількох одиниць. Замінимо всі одиниці з цієї групи на нулі, і отримане число буде значенням функції F(X).

Цьому досить складному опису відповідає дуже проста формула:

$$
**F(X) = X & (X+1)**,
$$

де "&" - це операція побітового логічного "І".

Не складно переконатися, що ця формула відповідає словесному опису функції, наведеному вище.

&nbsp;

Нам залишилося тільки навчитися швидко знаходити такі числа j, для яких F(j) ≤ i та j ≤ i.

Однак легко переконатися в тому, що всі такі числа j випливають з i послідовними замінами саме правого (найменшого) нуля в двійковому поданні. Наприклад, для i = 10 ми отримаємо, що j = 11, 15, 31, 63 і т.д.

Як ні дивно, така операція (заміна самого молодшого нуля на одиницю) також відповідає дуже простій формулі:

$$
**H(X) = X | (X+1)**,
$$

де | - це операція побітового логічного "АБО".

## Реалізація дерева Фенвіка для обчислення суми в одновимірному випадку:

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> t;
int n;

void init(int nn) {
    n = nn;
    t.assign(n, 0);
}

int sum(int r) {
    int result = 0;
    for (; r >= 0; r = (r & (r + 1)) - 1)
        result += t[r];
    return result;
}

void inc(int i, int delta) {
    for (; i < n; i = (i | (i + 1)))
        t[i] += delta;
}

int sum(int l, int r) { return sum(r) - sum(l - 1); }

void init(vector<int> a) {
    init((int)a.size());
    for (unsigned i = 0; i < a.size(); i++)
        inc(i, a[i]);
}
```

## Реалізація дерева Фенвіка для мінімуму в одновимірному випадку:

Слід зразу зауважити, що оскільки дерево Фенвіка дозволяє знайти значення функції в довільному відрізку [0;R], то ми не зможемо знайти мінімум на відрізку [L;R], де L > 0. Крім того, всі зміни значень повинні відбуватися тільки в сторону зменшення (так як неможливо звернути функцію min). Це значні обмеження.

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> t;
int n;

const int INF = 1000 * 1000 * 1000;

void init(int nn) {
    n = nn;
    t.assign(n, INF);
}

int getmin(int r) {
    int result = INF;
    for (; r >= 0; r = (r & (r + 1)) - 1)
        result = min(result, t[r]);
    return result;
}

void update(int i, int new_val) {
    for (; i < n; i = (i | (i + 1)))
        t[i] = min(t[i], new_val);
}

void init(vector<int> a) {
    init((int)a.size());
    for (unsigned i = 0; i < a.size(); i++)
        update(i, a[i]);
}
```

## Реалізація дерева Фенвіка для суми в двовимірному випадку:

Як вже було зазначено, дерево Фенвіка легко узагальнюється на випадок багатовимірного простору.

<!--- TODO: specify code snippet id -->
``` cpp
vector<vector<int>> t;
int n, m;

int sum(int x, int y) {
    int result = 0;
    for (int i = x; i >= 0; i = (i & (i + 1)) - 1)
        for (int j = y; j >= 0; j = (j & (j + 1)) - 1)
            result += t[i][j];
    return result;
}

void inc(int x, int y, int delta) {
    for (int i = x; i < n; i = (i | (i + 1)))
        for (int j = y; j < m; j = (j | (j + 1)))
            t[i][j] += delta;
}
```