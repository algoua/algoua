# Ігри на довільних графах

Нехай гра ведеться двома гравцями на певному графі G. Тобто, поточний стан гри - це певна вершина графа, і з кожної вершини йдуть ребра до тих вершин, в які можна зробити наступний хід.

Ми розглядаємо найзагальніший випадок - випадок довільного орієнтованого графа з циклами. Потрібно для заданої початкової позиції визначити, хто переможе при оптимальній грі обох гравців (або визначити, що результатом буде нічия).

Ми вирішимо цю задачу дуже ефективно - знайдемо відповіді для всіх вершин графа за лінійний час щодо кількості ребер - **O(M)**.

## Опис алгоритму

Про деякі вершини графа заздалегідь відомо, що вони є виграшними або програшними; очевидно, такі вершини не мають вихідних ребер.

Маємо наступні факти:

* Якщо з деякої вершини є ребро до проигрової вершини, то ця вершина є виграшною
* Якщо з деякої вершини всі ребра виходять у виграшні вершини, то ця вершина є програшною
* Якщо в якийсь момент залишилися невизначені вершини, але жодна з них не відповідає ні першому, ні другому правилу, то всі ці вершини є нейтральними.

Таким чином, ми маємо алгоритм, який працює за асимптотику O(NM) - ми перебираємо всі вершини, намагаємося до кожної застосувати перше або друге правило, і якщо ми внесли зміни, то повторюємо все заново.

Однак цей процес пошуку і відновлення можна значно прискорити, довівши асимптотику до лінійної.

Переберемо всі вершини, про які спочатку відомо, що вони є виграшними або програшними. З кожної з них запустимо наступний пошук у глибину, який буде рухатися по зворотнім ребрам. По-перше, він не буде заходити в вершини, які вже визначені як виграшні або програшні. Далі, якщо пошук у глибину намагається піти з програшної вершини до деякої вершини, то вона позначається як виграшна, і пошук продовжується з неї. Але якщо пошук у глибину намагається піти з виграшної вершини до деякої вершини, то потрібно перевірити, чи всі ребра ведуть з цієї вершини в виграшні. Цю перевірку легко здійснити за O(1), якщо в кожній вершині зберігати лічильник ребер, які ведуть до виграшних вершин. Отже, якщо пошук у глибину намагається піти з виграшної вершини до деякої вершини, то лічильник збільшується в цій вершині, і якщо лічильник дорівнює кількості ребер, що виходять з цієї вершини, то ця вершина позначається як програшна, і пошук у глибину продовжується з неї. Якщо цільова вершина так і не визначена як виграшна або програшна, то пошук у глибину до неї не заходить.

Разом ми отримуємо, що кожна виграшна та кожна програшна вершина відвідується нашим алгоритмом рівно один раз, а нічийні вершини зовсім не відвідуються. Отже, асимптотика дійсно **O(M)**.

## Реалізація

Розглянемо реалізацію пошуку в глибину з припущенням, що граф гри побудований в пам'яті, ступені виходу підраховані і записані в degree (це буде якраз лічильник, який буде зменшуватися, якщо є ребро в виграшну вершину), а також виграшні або програшні вершини вже позначені.

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> g[100];
bool win[100];
bool loose[100];
bool used[100];
int degree[100];

void dfs(int v) {
    used[v] = true;
    for (vector<int>::iterator i = g[v].begin(); i != g[v].end(); ++i)
        if (!used[*i]) {
            if (loose[v])
                win[*i] = true;
            else if (--degree[*i] == 0)
                loose[*i] = true;
            else
                continue;
            dfs(*i);
        }
}
```

## Приклад задачі: "Поліцейський та злодій"

Щоб алгоритм став більш зрозумілим, розглянемо його на конкретному прикладі.

**Умова задачі**. Є поле розміром $M \times N$ клітин, у деякі з яких неможливо зайти. Відомі початкові координати поліцейського та злодія. Також на мапі може бути присутній вихід. Якщо поліцейський опиниться в одній клітині зі злодієм, то переможець - поліцейський. Якщо ж злодій опиниться в клітині з виходом (при умові, що в цій клітині немає поліцейського), то переможець - злодій. Поліцейський може ходити в 8 напрямках, злодій - тільки в 4 (уздовж осей координат). Як поліцейський, так і злодій можуть пропустити свій хід. Першим ходить поліцейський.

**Побудова графу**. Побудуємо граф гри. Ми повинні сформалізувати правила гри. Поточний стан гри визначається координатами поліцейського P, злодія T, а також булевою змінною Pstep, яка визначає, хто буде робити наступний хід. Отже, вершина графу визначена трійкою (P,T,Pstep). Граф побудувати легко, просто відповідно до умови.

Далі потрібно визначити, які вершини є виграшними або програшними спочатку. Тут є **тонкий момент**. Виграшність/програшність вершини, окрім координат, залежить від Pstep - чий зараз хід. Якщо зараз хід у поліцейського, то вершина виграшна, якщо координати поліцейського і злодія збігаються; вершина програшна, якщо вона не виграшна і злодій знаходиться на виході. Якщо ж зараз хід у злодія, то вершина виграшна, якщо злодій знаходиться на виході, і програшна, якщо вона не виграшна і координати поліцейського і злодія збігаються.

Єдиний момент, який потрібно розв'язати - будувати **граф явно** або робити це "**під час**" пошуку в глибину. З однієї сторони, якщо будувати граф попередньо, то буде менше ймовірність помилки. З іншої сторони, це збільшить об'єм коду, а час роботи буде в декілька разів повільніший, ніж якщо будувати граф "під час" пошуку в глибину.

Реалізація всієї програми:

<!--- TODO: specify code snippet id -->
``` cpp
struct state {
    char p, t;
    bool pstep;
};

vector<state> g[100][100][2];
// 1 = policeman coords; 2 = thief coords; 3 = 1 if policeman\'s step or 0 if thief\'s.
bool win[100][100][2];
bool loose[100][100][2];
bool used[100][100][2];
int degree[100][100][2];

void dfs(char p, char t, bool pstep) {
    used[p][t][pstep] = true;
    for (vector<state>::iterator i = g[p][t][pstep].begin(); i != g[p][t][pstep].end(); ++i)
        if (!used[i->p][i->t][i->pstep]) {
            if (loose[p][t][pstep])
                win[i->p][i->t][i->pstep] = true;
            else if (--degree[i->p][i->t][i->pstep] == 0)
                loose[i->p][i->t][i->pstep] = true;
            else
                continue;
            dfs(i->p, i->t, i->pstep);
        }
}

int main() {
    int n, m;
    cin >> n >> m;
    vector<string> a(n);
    for (int i = 0; i < n; ++i)
        cin >> a[i];

    for (int p = 0; p < n * m; ++p)
        for (int t = 0; t < n * m; ++t)
            for (char pstep = 0; pstep <= 1; ++pstep) {
                int px = p / m, py = p % m, tx = t / m, ty = t % m;
                if (a[px][py]==\'*\' || a[tx][ty]==\'*\')  continue;
                
                bool & wwin = win[p][t][pstep];
                bool & lloose = loose[p][t][pstep];
                if (pstep)
                    wwin = px==tx && py==ty,   lloose = !wwin && a[tx][ty] == \'E\';
                else
                    wwin = a[tx][ty] == \'E\',   lloose = !wwin && px==tx && py==ty;
                if (wwin || lloose)  continue;

                state st = { p, t, !pstep };
                g[p][t][pstep].push_back (st);
                st.pstep = pstep != 0;
                degree[p][t][pstep] = 1;
                
                const int dx[] = { -1, 0, 1, 0,   -1, -1, 1, 1 };
                const int dy[] = { 0, 1, 0, -1,   -1, 1, -1, 1 };
                for (int d=0; d<(pstep?8:4); ++d) {
                    int ppx = px, ppy = py, ttx = tx, tty = ty;
                    if (pstep)
                        ppx += dx[d], ppy += dy[d];
                    else
                        ttx += dx[d], tty += dy[d];
                    if (ppx>=0 && ppx<n && ppy>=0 && ppy<m && a[ppx][ppy]!=\'*\' &&
                        ttx>=0 && ttx<n && tty>=0 && tty<m && a[ttx][tty]!=\'*\')
                    {
                        g[ppx * m + ppy][ttx * m + tty][!pstep].push_back(st);
                        ++degree[p][t][pstep];
                    }
                }
            }

    for (int p = 0; p < n * m; ++p)
        for (int t = 0; t < n * m; ++t)
            for (char pstep = 0; pstep <= 1; ++pstep)
                if ((win[p][t][pstep] || loose[p][t][pstep]) && !used[p][t][pstep])
                    dfs(p, t, pstep != 0);

    int p_st, t_st;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
            if (a[i][j] == \'C\')
                p_st = i*m+j;
            else if (a[i][j] == \'T\')
                t_st = i*m+j;

    cout << (win[p_st][t_st][true] ? "WIN" : loose[p_st][t_st][true] ? "LOSS" : "DRAW");
}
```