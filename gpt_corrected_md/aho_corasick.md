# Алгоритм Ахо-Корасіка

Нехай маємо набір рядків у алфавіті розміру $k$ з сумарною довжиною $m$. Алгоритм Ахо-Корасік будує для цього набору рядків структуру даних "префіксне дерево", а потім за допомогою цього дерева будує автомат, все це за $O(m)$ часу та $O(m k)$ пам'яті. Отриманий автомат можна використовувати в різних задачах, простіша з яких - знаходження всіх входжень кожного рядка з даного набору в деякий текст за лінійний час.

Даний алгоритм був запропонований канадським вченим Альфредом Ао (Alfred Vaino Aho) та вченою Маргарет Корасік (Margaret John Corasick) у 1975 році.

## Бор. Побудова префіксного дерева

Формально, **префіксне дерево** - це дерево з коренем в вершині $\rm Root$, причому кожне ребро дерева позначене деякою буквою. Якщо ми розглядаємо список ребер, які виходять з даної вершини (крім ребра, що веде до предка), то всі ребра повинні мати різні мітки.

Розглянемо в лісі будь-який шлях з кореня; випишемо послідовно мітки ребер цього шляху. В результаті ми отримаємо деяку стрічку, яка відповідає цьому шляху. Якщо ж ми розглянемо будь-яку вершину префіксного дерева, то їй поставимо у відповідність стрічку, відповідну шляху з кореня до цієї вершини.

Кожна вершина префіксного дерева також має прапорець $\rm leaf$, який дорівнює $\rm true$, якщо в цій вершині закінчується яка-небудь стрічка з даного набору.

Відповідно, **побудувати префіксне дерево** за допомогою даного набору рядків - це означає побудувати таке префіксне дерево, при якому кожній $\rm leaf$-вершині буде відповідати якийсь рядок з набору, і, навпаки, кожному рядку з набору буде відповідати певна $\rm leaf$-вершина.

Опишемо тепер, **як побудувати префіксне дерево** за заданим набором рядків за лінійний час щодо їх сумарної довжини.

Введемо структуру, яка відповідає вершинам префіксного дерева:

<!--- TODO: specify code snippet id -->
``` cpp
struct vertex {
    int next[K];
    bool leaf;
};

vertex t[NMAX + 1];
int sz;
```

тобто, ми будемо зберігати префіксне дерево у вигляді масиву $t$ (кількість елементів у масиві - це $sz$) структур $\rm vertex$. Структура $\rm vertex$ містить прапорець $\rm leaf$, і ребра у вигляді масиву $\rm next[]$, де $\rm next[i]$ - вказівник на вершину, до якої веде ребро за символом $i$, або $-1$, якщо такого ребра немає.

На початку префіксне дерево складається тільки з однієї вершини - кореня (договоримося, що корінь завжди має індекс $0$ в масиві $t$). Тому **ініціалізація** префіксного дерева полягає в наступному:

<!--- TODO: specify code snippet id -->
``` cpp
memset(t[0].next, 255, sizeof t[0].next);
sz = 1;
```

Тепер реалізуємо функцію, яка буде **додавати до префіксного дерева** задану стрічку $s$. Реалізація дуже проста: ми стаємо в корінь префіксного дерева, дивимося, чи є з кореня перехід по букві $s[0]$: якщо перехід є, то просто переходимо по ньому в іншу вершину, інакше створюємо нову вершину і додаємо перехід в цю вершину по букві $s[0]$. Потім, стоячи в якійсь вершині, повторюємо процес для букви $s[1]$, і т.д. Після закінчення процесу помічаємо останню відвідану вершину прапорцем $\rm leaf = true$.

<!--- TODO: specify code snippet id -->
``` cpp
void add_string(const string &s) {
    int v = 0;
    for (size_t i = 0; i < s.length(); ++i) {
Залежно від алфавіту, символ c дорівнює s[i] - 'a'
        if (t[v].next[c] == -1) {
            memset(t[sz].next, 255, sizeof t[sz].next);
            t[v].next[c] = sz++;
        }
        v = t[v].next[c];
    }
    t[v].leaf = true;
}
```

Лінійний час роботи, а також лінійна кількість вершин в борі є очевидними. Оскільки на кожну вершину витрачається $O(k)$ пам'яті, то використання пам'яті є $O(n k)$.

Потребування пам'яті можна зменшити до лінійного ($O(n)$), але за рахунок збільшення асимптотики роботи до $O(n \log k)$. Для цього достатньо зберігати переходи $\rm next$ не масивом, а словником $\rm map<char,int>$.

## Побудова автомату

Нехай ми побудували префіксне дерево для заданого набору рядків. Подивимося на нього тепер трохи з іншого боку. Якщо ми розглянемо будь-яку вершину, то рядок, який відповідає їй, є префіксом одного або кількох рядків з набору; отже, кожну вершину префіксного дерева можна розуміти як позицію в одному або кількох рядках з набору.

Фактично, вершини префіксного дерева можна розуміти як стан **кінцевого детермінованого автомата**. Знаходячись у якомусь стані, ми під впливом деякої вхідної літери переходимо в інший стан - тобто в іншу позицію в наборі рядків. Наприклад, якщо в дереві знаходиться тільки рядок $"abc"$ і ми стоїмо в стані $2$ (якому відповідає рядок $"ab"$), то під впливом літери $"c"$ ми перейдемо в стан $3$.

тобто, ми можемо розуміти гілки префіксного дерева як переходи в автоматі за відповідною буквою. Однак, обмежуватися лише гілками префіксного дерева недостатньо. Якщо ми намагаємося здійснити перехід за певною буквою, а відповідної гілки в дереві немає, то ми все одно повинні перейти в якийсь стан.

Більш строго, нехай ми знаходимося в стані $p$, якому відповідає деяка стрічка $t$, і бажаємо виконати перехід по символу $c$. Якщо в борі з вершини $p$ є перехід за літерою $c$, то ми просто переходимо по цій дуги і потрапляємо в вершину, якій відповідає стрічка $tc$. А якщо такої дуги немає, то ми повинні знайти стан, відповідний найдовшому власному суфіксу стрічки $t$ (найдовшому з наявних в борі), і спробувати виконати перехід по літері $c$ з нього.

Наприклад, якщо префіксне дерево побудовано за рядками "аб" і "бц", а ми, під впливом стрічки "аб", перейшли в деякий стан, який є листком, то це означає, що під впливом букви "ц" ми змушені перейти в стан, що відповідає рядку "б", і тільки звідти виконати перехід по букві "ц".

**Суфіксне посилання** для кожної вершини $p$ - це вершина, в якій закінчується найдовший власний суфікс рядка, відповідного вершині $p$. Єдиний особливий випадок - корінь префіксного дерева; для зручності суфіксне посилання з нього проведемо в себе ж. Тепер ми можемо переформулювати твердження щодо переходів в автоматі так: поки з поточної вершини префіксного дерева немає переходу по відповідній букві (або поки ми не прийдемо в корінь префіксного дерева), ми повинні переходити по суфіксному посиланню.

Таким чином, ми звели задачу побудови автомата до задачі знаходження суфіксних посилань для всіх вершин префіксного дерева. Однак, ми будемо будувати ці суфіксні посилання з допомогою побудованих в автоматі переходів.

Зауважимо, що якщо ми бажаємо дізнатися суфіксне посилання для деякої вершини $v$, то ми можемо перейти до її предка $p$ (нехай $c$ - літера, по якій з $p$ є перехід до $v$), потім перейти по його суфіксному посиланню, а потім виконати перехід в автоматі за допомогою букви $c$.

Таким чином, задача знаходження переходу звелася до задачі знаходження суфіксного посилання, а задача знаходження суфіксного посилання - до задачі знаходження суфіксного посилання і переходу, але вже для більш близьких до кореня вершин. Ми отримали рекурсивну залежність, але не безкінечну, і, більше того, її можна вирішити за лінійний час.

Перейдемо тепер до **реалізації**. Зауважимо, що нам тепер знадобиться для кожної вершини зберігати її предка $\rm p$, а також символ $\rm pch$, за яким з предка є перехід в нашу вершину. Також в кожній вершині будемо зберігати $\rm int~link$ - суфіксне посилання (або $-1$, якщо вона ще не обчислена), і масив $\rm int~go[k]$ - переходи в автоматі по кожному з символів (знову ж, якщо елемент масиву дорівнює $-1$, то він ще не обчислений). Наведемо тепер повну реалізацію всіх необхідних функцій:

<!--- TODO: specify code snippet id -->
``` cpp
struct vertex {
    int next[K];
    bool leaf;
    int p;
    char pch;
    int link;
    int go[K];
};

vertex t[NMAX + 1];
int sz;

void init() {
    t[0].p = t[0].link = -1;
    memset(t[0].next, 255, sizeof t[0].next);
    memset(t[0].go, 255, sizeof t[0].go);
    sz = 1;
}

void add_string(const string &s) {
    int v = 0;
    for (size_t i = 0; i < s.length(); ++i) {
        char c = s[i] - 'a';
        if (t[v].next[c] == -1) {
            memset(t[sz].next, 255, sizeof t[sz].next);
            memset(t[sz].go, 255, sizeof t[sz].go);
            t[sz].link = -1;
            t[sz].p = v;
            t[sz].pch = c;
            t[v].next[c] = sz++;
        }
        v = t[v].next[c];
    }
    t[v].leaf = true;
}

int go(int v, char c);

int get_link(int v) {
    if (t[v].link == -1)
        if (v == 0 || t[v].p == 0)
            t[v].link = 0;
        else
            t[v].link = go(get_link(t[v].p), t[v].pch);
    return t[v].link;
}

int go(int v, char c) {
    if (t[v].go[c] == -1)
        if (t[v].next[c] != -1)
            t[v].go[c] = t[v].next[c];
        else
            t[v].go[c] = v == 0 ? 0 : go(get_link(v), c);
    return t[v].go[c];
}
```

Не важко зрозуміти, що завдяки запам'ятовуванню знайдених суфіксних посилань та переходів, загальний час знаходження всіх суфіксних посилань та переходів буде лінійним.

## Застосування

### Пошук усіх рядків з заданого набору в тексті

Даний набір рядків та текст. Потрібно знайти всі входження кожного рядка з набору в тексті за час $O({\rm Len + Ans})$, де $\rm Len$ - довжина тексту, а $\rm Ans$ - розмір відповіді.

Побудуємо за даним набором рядків префіксне дерево. Тепер будемо обробляти текст по одній букві, переміщуючись відповідним чином по дереву, фактично - по станах автомата. Спочатку ми знаходимося в корені дерева. Нехай ми на наступному кроці знаходимося в стані $v$, і чергова літера тексту $c$. Отже, ми повинні перейти в стан ${\rm go} (v, c)$, тим самим або збільшуючи на 1 довжину поточної збігаючої підстрічки, або зменшуючи її, проходячи по суфіксному посиланню.

Як тепер дізнатися про поточний стан $v$ і чи є збіг з якимись рядками з набору? По-перше, якщо ми знаходимося в позначеному листі ($\rm leaf=true$), то є збіг з тим шаблоном, який в дереві закінчується в вершині $v$. Однак це не єдиний можливий випадок досягнення збігу: рухаючись по суфіксним посиланням, ми можемо досягти однієї або кількох позначених листків, тоді збіг буде відбуватися для шаблонів, що закінчуються в цих станах. Простим прикладом такої ситуації є коли набір рядків складається з $\{"dabce", "abc", "bc"\}$, а текст є $"dabc"$.

Таким чином, якщо у кожній поміченій вершині зберігати номер зразка, що закінчується в ній (або список номерів, якщо допускаються повторювані зразки), то ми зможемо для поточного стану за $O(n)$ знайти номера всіх зразків, для яких досягнуто збіг, просто пройшовши по суфіксним посиланням від поточної вершини до кореня. Однак це не є ефективним рішенням, оскільки в сумі асимптотика складе $O(n \cdot {\rm Len})$. Однак можна помітити, що рух по суфіксним посиланням можна оптимізувати, попередньо визначивши для кожної вершини найближчу до неї позначену вершину, досяжну по суфіксним посиланням (це називається "функцією виходу"). Цю величину можна визначити за лінійний час. Отже, для поточної вершини ми зможемо за $O(1)$ знаходити наступну в суфіксному шляху позначену вершину, тобто відбувається збіг. Тим самим, на кожен збіг буде витрачатися $O(1)$ дій, і в сумі отримаємо асимптотику $O({\rm Len + Ans})$.

У більш простому випадку, коли потрібно знайти не самі входження, а лише їх кількість, можна замість функції виходу порахувати кількість помічених вершин, досяжних з поточної вершини $v$ за допомогою ледачої динаміки. Ця величина може бути підрахована за $O(n)$ в сумі, і тоді для поточного стану $v$ ми зможемо за $O(1)$ знайти кількість входжень всіх зразків в текст, що закінчуються в поточній позиції. Таким чином, задачу знаходження загальної кількості входжень можна вирішити за $O({\rm Len})$.

### Знаходження лексикографічно найменшої стрічки заданої довжини, яка не містить жодного з заданих зразків

Даний набір зразків та довжина $L$. Потрібно знайти стрічку довжини $L$, яка не містить жодного з зразків, та серед усіх таких стрічок вивести лексикографічно найменшу.

Побудуємо за даним набором рядків префіксне дерево. Нагадаємо, що ті вершини, з яких можна досягти помічених вершин за допомогою суфіксних посилань (а такі вершини можна знайти за $O(n)$, наприклад, лінивою динамікою), можна сприймати як входження якої-небудь стрічки з набору в текст завдання. Оскільки в даній задачі ми повинні уникати входжень, то це можна розуміти як те, що в такі вершини ми не можемо заходити. З іншого боку, в усі інші вершини ми можемо заходити. Таким чином, ми видаляємо з автомата всі "погані" вершини, а з залишку графу автомата потрібно знайти лексикографічно найменший шлях довжини $L$. Цю задачу вже можна розв'язати за $O(L)$, наприклад, за допомогою [пошуку в глибину](dfs).

### Знаходження найкоротшої стрічки, що містить усі зразки одночасно

Знову скористаємося тією самою ідеєю. Для кожної вершини будемо зберігати маску, що позначає зразки, для яких відбулося входження в даній вершині. Отже, задачу можна переформулювати так: спочатку, знаходячись у стані $(v={\rm Root},~{\rm Msk}=0)$, потрібно дійти до стану $(v,~{\rm Msk}=2^n-1)$, де $n$ - кількість зразків. Переходи зі стану в стан будуть представляти собою додавання однієї букви до тексту, тобто перехід по ребру автомата в іншу вершину з відповідною зміною маски. Запустивши [обхід в ширину](bfs) на такому графі, ми знайдемо шлях до стану $(v,~{\rm Msk}=2^n-1)$ найменшої довжини, що нам якраз і потрібно.

### Знаходження лексикографічно найменшої стрічки довжини $L$, що містить дані зразки у кількості $k$ раз

Як і в попередніх завданнях, порахуємо для кожної вершини кількість входжень, яке відповідає їй (тобто кількість позначених вершин, досяжних з її по суфіксних посиланнях). Переформулюємо задачу таким чином: поточний стан визначається трійкою чисел $(v,~{\rm Len,~Cnt})$, і потрібно зі стану $({\rm Root},~0,~0)$ прийти в стан $(v,~L,~k)$, де $v$ - будь-яка вершина. Переходи між станами - це просто переходи по ребрах автомата з поточної вершини. Таким чином, достатньо просто знайти [обхідом в глибину](dfs) шлях між цими двома станами (якщо обхід в глибину буде переглядати букви в їх природному порядку, то знайдений шлях автоматично буде лексикографічно найменшим).

## Завдання на онлайн-суддях

Задачі, які можна вирішити за допомогою префіксного дерева або алгоритму Ахо-Корасіка:

* [UVA #11590 **"Prefix Lookup"** [складність: низька]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2637)

* [UVA #11171 **"SMS"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2112)

* [UVA #10679 **"I Love Strings!!!"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1620)