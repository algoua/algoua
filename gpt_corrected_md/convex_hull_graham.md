# Побудова опуклої оболонки обходом Грехема

Дано $N$ точок на площині. Потрібно побудувати їх опуклу оболонку, тобто найменший опуклий багатокутник, який містить всі ці точки.

Ми розглянемо метод **Ґрехема** (Graham) (запропонований у 1972 р.) з удосконаленнями Ендрю (Andrew) (1979 р.). З його допомогою можна побудувати опуклу оболонку за час **O(N log N)** з використанням тільки операцій порівняння, додавання і множення. Алгоритм є асимптотично оптимальним (доведено, що не існує алгоритму з кращою асимптотикою), хоча в деяких завданнях він неприйнятний (у випадку паралельної обробки або при online-обробці).

## Опис

Алгоритм. Знайдемо найлівішу і найправішу точки A і B (якщо таких точок кілька, то візьмемо найнижчу серед лівих і найвищу серед правих). Зрозуміло, що і A, і B обов'язково потраплять в опуклу оболонку. Далі проведемо через них пряму AB, розділивши множину всіх точок на верхню та нижню підмножини S1 і S2 (точки, що лежать на прямій, можна віднести до будь-якої з двох множин - вони все одно не ввійдуть в оболонку). Точки A і B віднесемо до обох множин. Тепер побудуємо для S1 верхню оболонку, а для S2 - нижню оболонку, і об'єднаємо їх, отримавши відповідь. Щоб отримати, скажімо, верхню оболонку, потрібно відсортувати всі точки за абсцисою, потім пройтися по всім точкам, розглядаючи на кожному кроці окрім самої точки дві попередні точки, що ввійшли до оболонки. Якщо поточна трійка точок утворює не правий поворот (що легко перевірити за допомогою [Орієнтованої площі](oriented_area)), то ближнього сусіда потрібно вилучити з оболонки. В кінці залишаться тільки точки, що входять до опуклої оболонки.

Отже, алгоритм полягає у сортуванні всіх точок за абсцисою та в двох (у гіршому випадку) обходах всіх точок. Тому необхідна асимптотика O(N log N) досягнута.

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
struct pt {
    double x, y;
};

bool cmp(pt a, pt b) { return a.x < b.x || a.x == b.x && a.y < b.y; }

bool cw(pt a, pt b, pt c) { return a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y) < 0; }

bool ccw(pt a, pt b, pt c) { return a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y) > 0; }

void convex_hull(vector<pt> &a) {
    if (a.size() == 1)
        return;
    sort(a.begin(), a.end(), &cmp);
    pt p1 = a[0], p2 = a.back();
    vector<pt> up, down;
    up.push_back(p1);
    down.push_back(p1);
    for (size_t i = 1; i < a.size(); ++i) {
        if (i == a.size() - 1 || cw(p1, a[i], p2)) {
            while (up.size() >= 2 && !cw(up[up.size() - 2], up[up.size() - 1], a[i]))
                up.pop_back();
            up.push_back(a[i]);
        }
        if (i == a.size() - 1 || ccw(p1, a[i], p2)) {
            while (down.size() >= 2 && !ccw(down[down.size() - 2], down[down.size() - 1], a[i]))
                down.pop_back();
            down.push_back(a[i]);
        }
    }
    a.clear();
    for (size_t i = 0; i < up.size(); ++i)
        a.push_back(up[i]);
    for (size_t i = down.size() - 2; i > 0; --i)
        a.push_back(down[i]);
}
```