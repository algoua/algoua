# Пошук у ширину

Пошук у ширину (обхід у ширину, breadth-first search) - це один з основних алгоритмів на графах.

У результаті пошуку в ширину знаходиться найкоротший шлях у невагованому графі, тобто шлях, що містить найменше число ребер.

Алгоритм працює у часі $O(n+m)$, де $n$ - кількість вершин, $m$ - кількість ребер.

## Опис алгоритму

На вхід алгоритму подається граф (незважений) та номер стартової вершини $s$. Граф може бути як орієнтованим, так і неорієнтованим, це не має значення для алгоритму.

Сам алгоритм можна розуміти як процес "підпалу" графа: на нульовому кроці підпалюємо тільки вершину $s$. На кожному наступному кроці вогонь з кожної вже горящої вершини перекидається на всіх її сусідів; тобто за одну ітерацію алгоритму відбувається розширення "кільця вогню" в ширину на одиницю (звідси і назва алгоритму).

Більш строго це можна уявити наступним чином. Створимо чергу $q$, до якої будуть додаватися горящі вершини, а також створимо булевий масив $\rm used[]$, в якому для кожної вершини будемо відзначати, чи горить вона вже, чи ні (іншими словами, чи була вона переглянута).

Спочатку в чергу поміщається лише вершина $s$, і $\rm used[s] = true$, а для всіх інших вершин $\rm used[] = false$. Потім алгоритм представляє собою цикл: доки черга не порожня, вийняти з її початку одну вершину, переглянути всі ребра, що виходять з цієї вершини, і якщо деякі з переглянутих вершин ще не відвідані, то відвідати їх і додати в кінець черги.

У результаті, коли черга опустіє, обхід в ширину обійде всі досяжні з $s$ вершини, причому до кожної дійде найкоротшим шляхом. Також можна порахувати довжини найкоротших шляхів (для чого просто треба створити масив довжин шляхів $d[]$), і компактно зберегти інформацію, достатню для відновлення всіх цих найкоротших шляхів (для цього треба створити масив "предків" $p[]$, в якому для кожної вершини зберігати номер вершини, через яку ми потрапили в цю вершину).

## Реалізація

Реалізуємо описаний алгоритм на мові C++.

"Вхідні дані:"

<!--- TODO: specify code snippet id -->
``` cpp

vector<vector<int>> g; // граф
int вершин;            // кількість вершин
int s;                 // початкова вершина (вершини всюди нумеруються з нуля)

Читання графу
...
```

Самообхід:

<!--- TODO: specify code snippet id -->
``` cpp

queue<int> q;
q.push(s);
vector<bool> used(n);
vector<int> d(n), p(n);
used[s] = true;
p[s] = -1;
while (!q.empty()) {
    int v = q.front();
    q.pop();
    for (size_t i = 0; i < g[v].size(); ++i) {
        int to = g[v][i];
        if (!used[to]) {
            used[to] = true;
            q.push(to);
            d[to] = d[v] + 1;
            p[to] = v;
        }
    }
}
```

Якщо зараз потрібно відновити та вивести найкоротший шлях до певної вершини $\rm to$, це можна зробити наступним чином:

<!--- TODO: specify code snippet id -->
``` cpp

if (!used[to])
    cout << "No path!";
else {
    vector<int> path;
    for (int v = to; v != -1; v = p[v])
        path.push_back(v);
    reverse(path.begin(), path.end());
    cout << "Path: ";
    for (size_t i = 0; i < path.size(); ++i)
        cout << path[i] + 1 << " ";
}
```

## Додатки до алгоритму

* Пошук **найкоротшого шляху** в невзваженому графі.

* Пошук **компонент зв'язності** у графі за $O(n+m)$.

Для цього ми просто запускаємо обхід в ширину від кожної вершини, за винятком вершин, які залишилися відвіданими ($\rm used=true$) після попередніх запусків. Таким чином, ми виконуємо звичайний запуск в ширину від кожної вершини, але не обнулюємо кожний раз масив $\rm used[]$, завдяки чому ми кожен раз будемо обходити нову компоненту зв'язності, а сумарний час роботи алгоритму складе, як і раніше, $O(n+m)$ (так кілька запусків обходу на графі без обнулення масиву $\rm used$ називаються серією обходів в ширину).

* Знаходження розв'язку якої-небудь задачі (гри) **з найменшою кількістю кроків**, якщо кожен стан системи можна уявити як вершину графа, а переходи з одного стану в інший - ребра графа.

Класичний приклад - гра, де робот рухається по полю, при цьому його можна передвигати ящики, що знаходяться на цьому ж полі, і потрібно за найменшу кількість ходів передвинути ящики в необхідні позиції. Це розв'язується обходом в ширину по графу, де станом (вершиною) є набір координат: координати робота і координати всіх ящиків.

* Знаходження найкоротшого шляху в **0-1-графі** (тобто графі з вагами, що дорівнюють тільки 0 або 1) можна здійснити за допомогою модифікованого алгоритму пошуку в ширину. Якщо поточне ребро має вагу 0 і до якоїсь вершини відбувається поліпшення відстані, то цю вершину потрібно додати не в кінець, а в початок черги.

* Знаходження **найкоротшого циклу** в орієнтованому невагованому графі: виконуємо пошук в ширину з кожної вершини; якщо під час проходження ми намагаємося перейти з поточної вершини по ребру в вже відвідану вершину, то це означає, що ми знайшли найкоротший цикл, і зупиняємо пошук в ширину; серед усіх таких знайдених циклів (по одному з кожного запуску пошуку) вибираємо найкоротший.

* Знайти всі ребра, що лежать **на будь-якому найкоротшому шляху** між заданою парою вершин $(a,b)$. Для цього потрібно запустити 2 пошуки в ширину: з $a$ та з $b$. Позначимо через $d_a[]$ масив найкоротших відстаней, отриманий в результаті першого обходу, а через $d_b[]$ - в результаті другого обходу. Тепер для будь-якого ребра $(u,v)$ легко перевірити, чи лежить воно на будь-якому найкоротшому шляху: критерієм буде умова $d_a[u] + w(u,v) + d_b[v] = d_a[b]$. ($w(u,v)$ позначає вагу ребра $(u,v)$).

* Знайти всі вершини, що лежать **на якомусь найкоротшому шляху** між заданою парою вершин $(a,b)$. Для цього потрібно запустити 2 пошуки в ширину: з $a$ та з $b$. Позначимо через $d_a[]$ масив найкоротших відстаней, отриманий в результаті першого обходу, а через $d_b[]$ - в результаті другого обходу. Тепер для будь-якої вершини $v$ легко перевірити, чи лежить вона на якомусь найкоротшому шляху: критерієм буде умова $d_a[v] + d_b[v] = d_a[b]$.

* Знайти **найкоротший парний шлях** в графі (тобто шлях парної довжини). Для цього потрібно побудувати допоміжний граф, вершинами якого будуть стан $(v,c)$, де $v$ - номер поточної вершини, $c = 0 \ldots 1$ - поточна парність. Будь-яке ребро $(a,b)$ вихідного графа в цьому новому графі перетвориться на два ребра $((u,0),(v,1))$ і $((u,1),(v,0))$. Після цього на цьому графі потрібно обійти в ширину і знайти найкоротший шлях зі стартової вершини в кінцеву, з парністю, рівною 0.

## Завдання для онлайн-суддів

Список задач, які можна вирішити, використовуючи обхід в ширину:

TODO