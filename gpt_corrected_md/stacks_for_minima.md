# Модифікація стека і черги для знаходження мінімуму за O (1)

Тут ми розглянемо три задачі: модифікацію стека з додаванням знаходження найменшого елементу за O(1), аналогічну модифікацію черги, а також застосування їх до задачі знаходження мінімуму у всіх підвідрізках фіксованої довжини даного масиву за O(N).

## Модифікація стеку

Потрібно додати можливість знаходження мінімуму в стеці за O(1), зберігаючи таку ж асимптотику додавання та видалення елементів зі стека.

Для цього ми будемо зберігати не самі елементи в стеці, а пари: елемент і мінімум в стеці, починаючи з цього елементу і нижче. Іншими словами, якщо уявити стек як масив пар, то

$$
stack[i].second = min { stack[j].first }
                 j = 0..i
$$

Зрозуміло, що тоді знаходження мінімуму у всьому стеку буде полягати просто в отриманні значення stack.top().second.

Також очевидно, що при додаванні нового елементу до стеку величина другого буде дорівнювати мінімальному значенню між stack.top().second та new_element. Видалення елементу зі стеку нічим не відрізняється від видалення зі звичайного стеку, оскільки видалення елемента ніяк не може вплинути на значення другого для залишених елементів.

Реалізація:

<!--- TODO: specify code snippet id -->
``` cpp
stack<pair<int, int>> st;
```

* Додавання елемента:
<!--- TODO: specify code snippet id -->
``` cpp
int minima = st.empty() ? new_element : min(new_element, st.top().second);
st.push(make_pair(new_element, minima));
```
* Вилучення елементу:
<!--- TODO: specify code snippet id -->
``` cpp
int result = st.top().first;
st.pop();
```
* Знаходження мінімуму:
<!--- TODO: specify code snippet id -->
``` cpp
minima = st.top().second;
```

## Модифікація черги. Спосіб 1

Тут розглянемо простий спосіб модифікації черги, але має той недолік, що модифіковану чергу реально можливо зберігати не всі елементи (тобто при добуванні елементу з черги нам треба буде знати значення елементу, який ми хочемо вилучити). Ясно, що це дуже специфічна ситуація (зазвичай чергу потрібна саме для того, щоб дізнаватися черговий елемент, а не навпаки), проте цей спосіб приваблює своєю простотою. Також цей метод можна застосувати до задачі про знаходження мінімуму в підвідрізках (див. нижче).

Ключова ідея полягає в тому, щоб реально зберігати в чергах не всі елементи, а тільки ті, які потрібні нам для визначення мінімуму. А саме, нехай черга представляє собою неспадну послідовність чисел (тобто в голові зберігається найменше значення), причому, звісно, не довільну, а завжди містить мінімум. Значить, мінімум у всій черзі завжди буде першим її елементом. Перед додаванням нового елементу в чергу достатньо провести "срізку": поки в хвості черги знаходиться елемент, більший нового елементу, будемо видаляти цей елемент з черги; потім додамо новий елемент в кінець черги. Тим самим ми, з одного боку, не порушимо порядку, а з іншого боку, не втратимо поточний елемент, якщо він на якомусь наступному кроці виявиться мінімумом. Але при добуванні елементу з голови черги його там, взагалі кажучи, можливо вже не буде - наша модифікована черга могла викинути цей елемент в процесі перестроювання. Тому при видаленні елементу нам потрібно знати значення вилучуваного елементу - якщо елемент з цим значенням знаходиться в голові черги, то вилучаємо його; інакше просто нічого не робимо.

Розглянемо реалізацію вищезазначених операцій:

<!--- TODO: specify code snippet id -->
``` cpp
deque<int> q;
```

* Знаходження мінімуму:
<!--- TODO: specify code snippet id -->
``` cpp
current_minimum = q.front();
```
* Додавання елемента:
<!--- TODO: specify code snippet id -->
``` cpp
while (!q.empty() && q.back() > added_element)
    q.pop_back();
q.push_back(added_element);
```
* Вилучення елементу:
<!--- TODO: specify code snippet id -->
``` cpp
if (!q.empty() && q.front() == removed_element)
    q.pop_front();
```

Зрозуміло, що середній час виконання всіх цих операцій становить O(1).

## Модифікація черги. Спосіб другий

Розглянемо тут інший спосіб модифікації черги для знаходження мінімуму за O(1), який дещо складніший для реалізації, проте позбавлений основного недоліку попереднього методу: всі елементи черги дійсно зберігаються в ній, і зокрема, при вилученні елементу не потрібно знати його значення.

Ідея полягає в тому, щоб зведення задачі до задачі на стеках, яка вже була вирішена нами. Навчимося моделювати чергу за допомогою двох стеків.

Заведемо два стеки: s1 і s2; звісно, мається на увазі стеки, модифіковані для знаходження мінімуму за O(1). Додавати нові елементи будемо завжди в стек s1, а вилучати елементи - тільки зі стека s2. При цьому, якщо при спробі вилучення елементу зі стека s2 він виявився порожнім, просто перенесемо всі елементи зі стека s1 в стек s2 (при цьому елементи в стеці s2 отримаються вже в зворотньому порядку, що нам і потрібно для вилучення елементів; стек s1 ж стане порожнім). Нарешті, знаходження мінімуму в черзі фактично полягатиме в знаходженні мінімуму з мінімуму в стеці s1 і мінімуму в стеці s2.

Тим самим, ми виконуємо всі операції як і раніше за O(1) (з простої причини, що кожен елемент в гіршому випадку додається до стеку s1 лише один раз, потім переноситься до стеку s2 також лише один раз і витягується зі стеку s2 також лише один раз).

Реалізація:

<!--- TODO: specify code snippet id -->
``` cpp
stack<pair<int, int>> s1, s2;
```

* Знаходження мінімуму:
<!--- TODO: specify code snippet id -->
``` cpp
if (s1.empty() || s2.empty())
    current_minimum = s1.empty ? s2.top().second : s1.top().second;
else
    current_minimum = min(s1.top().second, s2.top().second);
```
* Додавання елементу:
<!--- TODO: specify code snippet id -->
``` cpp
int minima = s1.empty() ? new_element : min(new_element, s1.top().second);
s1.push(make_pair(new_element, minima));
```
* Вилучення елементу:
<!--- TODO: specify code snippet id -->
``` cpp
if (s2.empty())
    while (!s1.empty()) {
        int element = s1.top().first;
        s1.pop();
        int minima = s2.empty() ? element : min(element, s2.top().second);
        s2.push(make_pair(element, minima));
    }
result = s2.top().first;
s2.pop();
```

## Задача полягає в знаходженні мінімуму на кожному підвідрізку фіксованої довжини даного масиву

Нехай дано масив $A$ довжини $N$, і дано число $M \leq N$. Потрібно знайти мінімум в кожному підвідрізку довжини $M$ даного масиву, тобто знайти:

$$
min A[i],    min A[i],    min A[i],    ...,    min A[i]
0&le;i&le;M-1      1&le;i&le;M        2&le;i&le;M+1              N-M&le;i&le;N-1
$$

Вирішимо цю задачу за лінійний час, тобто O(N).

Для цього достатньо створити чергу, модифіковану для знаходження мінімуму за O(1), яку ми розглянули вище. При цьому в даній задачі підійде будь-який з двох методів реалізації такої черги. Далі розв'язок вже зрозумілий: додаємо до черги перші M елементів масиву, знаходимо в ній мінімум і виводимо його, потім додаємо до черги наступний елемент, вибираємо перший елемент масиву з черги, знову виводимо мінімум і т.д. Оскільки всі операції з чергою виконуються в середньому за константний час, то асимптотика всього алгоритму складає O(N).

Варто зазначити, що реалізація модифікованої черги за першим методом є простішою, але, ймовірно, потребує зберігання всього масиву (адже на кожному кроці потрібно знати i-й та (i-M)-й елементи масиву). При реалізації черги за другим методом, масив A не потрібно зберігати явно - достатньо знати лише i-й елемент черги.