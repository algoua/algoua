# Зворотня задача MST (зворотна задача мінімального остовного дерева) розв'язується за O(NM<sup>2</sup>)

Даний зважений неорієнтований граф G з N вершинами і M ребрами (без петель і кратних ребер). Відомо, що граф зв'язний. Також вказаний деякий каркас T цього графа (тобто вибрано N-1 ребер, які утворюють дерево з N вершинами). Потрібно змінити ваги ребер таким чином, щоб зазначений каркас T став мінімальним каркасом цього графа (точніше кажучи, одним з мінімальних кістяків), причому зробити це так, щоб сумарна зміна всіх ваг була найменшою.

## Розв'язок

Зведемо задачу inverse-MST до задачі min-cost-flow, точніше, до задачі двоїстої min-cost-flow (у сенсі двоїстості задач лінійного програмування); потім вирішимо останню задачу.

Отже, нехай дано граф G з N вершинами та M ребрами. Вагу кожного ребра позначимо через C<sub>i</sub>. Припустимо, не втрачаючи загальності, що ребра з номерами від 1 до N-1 є ребрами T.

### 1. Необходимое і достатню умова MST

Нехай дано деякий каркас S (не обов'язково мінімальний).

Введемо спочатку одне позначення. Розглянемо деяке ребро j, яке не належить до множини S. Очевидно, у графі S є єдиний шлях, який з'єднує кінці цього ребра, тобто єдиний шлях, який з'єднує кінці ребра j і складається тільки з ребер, що належать до множини S. Позначимо множину ребер, які утворюють цей шлях для ребра j, через P[j].

Для того, щоб деякий каркас S був мінімальним, **необхідно і достатньо**, щоб:

$$
C<sub>i</sub> ≤ C<sub>j</sub> для всіх j ∉ S та кожного i ∈ P[j]
$$

Можна замітити, що, оскільки **у нашій задачі** до каркасу T належать ребра 1..N-1, то ми можемо записати цю умову таким чином:

$$
C<sub>i</sub> ≤ C<sub>j</sub> для всіх j = N..M та кожного i ∈ P[j]
(причому всі і лежать в діапазоні від 1 до N-1)
$$

### 2. Граф маршрутів

Поняття графу шляхів безпосередньо пов'язане з попередньою теорією.

Нехай задано деякий каркас S (не обов'язково мінімальний).

Значить, **графом шляхів $H$** для графа $G$ буде наступний граф:

* Він містить M вершин, кожна вершина в H взаємно однозначно відповідає деякого ребру в G.
* Граф $H$ є двудольним. У першій його частині знаходяться вершини $i$, які відповідають ребрам у $G$, що належать каркасу $S$. Відповідно, у другій частині знаходяться вершини $j$, які відповідають ребрам, що не належать до $S$.
* Ребро проводиться з вершини i до вершини j тоді і тільки тоді, коли i належить до P[j].
Іншими словами, для кожної вершини j з другої частини її вхідні ребра повинні йти з усіх вершин першої частини, що відповідають безлічі ребер P[j].

У нашому випадку ми можемо трохи спростити опис графу шляхів

$$
ребро (i,j) існує в H, якщо i &isin; P[j],  j = N..M, i = 1..N-1
$$

### 3. Математична формулювання задачі

Чисто формально **задача зворотного MST** записується таким чином:

$$
знайти масив A[1..M], такий, що..
C<sub>i</sub> + A<sub>i</sub> <= C<sub>j</sub> + A<sub>j</sub> для всіх j = N..M і кожного i &isin; P[j] (i від 1 до N-1),
і мінімізувати суму |A<sub>1</sub>| + |A<sub>2</sub>| + ... + |A<sub>m</sub>|
$$

тут під шуканим масивом A ми маємо на увазі ті значення, які потрібно додати до ваг ребер (тобто, вирішивши задачу оберненої МST, ми замінюємо вагу C<sub>i</sub> кожного ребра i на величину C<sub>i</sub> + A<sub>i</sub>).

Очевидно, що немає сенсу збільшувати вагу ребер, які належать T, тобто

<pre>A<sub>i</sub> <= 0,  i = 1..N-1</pre>
і немає сенсу скорочувати ребра, які не належать T

$$
A<sub>i</sub> >= 0,  i = N..M
$$

(оскільки в іншому випадку ми тільки погіршимо відповідь)

Значить, ми можемо трохи **спростити** постановку задачі, вилучивши з суми модулі:

$$
знайти масив A[1..M], що задовольняє умову:
C<sub>i</sub> + A<sub>i</sub> &le; C<sub>j</sub> + A<sub>j</sub> для всіх j = N..M і кожного i &isin; P[j] (i від 1 до N-1),
A<sub>i</sub> <= 0,  i = 1..N-1,
A<sub>i</sub> >= 0,  i = N..M,
і мінімізувати суму A<sub>n</sub> + ... + A<sub>m</sub> - (A<sub>1</sub> + ... + A<sub>n-1</sub>)
$$

Нарешті, просто замінимо "мінімізацію" на "максимізацію", а в самій сумі замінимо всі знаки на протилежні:

$$
знайти масив A[1..M], такий, що..
C<sub>i</sub> + A<sub>i</sub> <= C<sub>j</sub> + A<sub>j</sub> для всіх j = N..M і кожного i ∈ P[j] (i від 1 до N-1),
A<sub>i</sub> <= 0,  i = 1..N-1,
A<sub>i</sub> >= 0,  i = N..M,
і максимізувати суму A<sub>1</sub> + ... + A<sub>n-1</sub> - (A<sub>n</sub> + ... + A<sub>m</sub>)
$$

### Спробуйте так:

4. Зведення задачі "inverse-MST" до двоїстої задачі про призначення

Формулювання задачі inverse-MST, яку ми щойно дали, є формулюванням задачі **лінійної оптимізації** з невідомими A<sub>1</sub>..A<sub>m</sub>.

Застосуємо класичний прийом - розглянемо **двоїну** її задачу.

За визначенням, щоб отримати двоїсту задачу, потрібно кожній нерівності сопоставити двоїсту змінну X<sub>ij</sub>, поміняти ролями цільову функцію (яку потрібно було мінімізувати) і коефіцієнти в правих частинах нерівностей, поміняти знаки "&lt;=" на ">=" і навпаки, поміняти максимізацію на мінімізацію.

Отже, задача **двоїста до оберненої МНД**:

$$
знайти всі $X_{ij}$ для кожного $(i,j) \in H$, такі, що:
всі X<sub>ij</sub> >= 0,
для кожного i=1..N-1 &sum; X<sub>ij</sub> по всіх j: (i,j) належить H ≤ 1
для кожного j від N до M сума по X<sub>ij</sub> по всім i, для яких (i,j) належить H, менше або дорівню
і мінімізувати &sum; X<sub>ij</sub> (C<sub>j</sub> - C<sub>i</sub>) для всіх (i,j) &isin; H
$$

Останнє завдання є **завданням про призначення**: нам потрібно у графі шляхів H вибрати кілька ребер так, щоб жодне ребро не перетиналося з іншим у вершині, а сума ваг ребер (вагу ребра (i,j) визначимо як C<sub>j</sub> - C<sub>i</sub>) була найменшою. Російські слова повинні бути замінені на українські.

Таким чином, **двоїста задача inverse-MST еквівалентна задачі про призначення**. Якщо ми навчимося розв'язувати двоїсту задачу про призначення, то ми автоматично вирішимо задачу inverse-MST.

### 5. Розв'язок двоїстої задачі про призначеннях

Спочатку приділимо трохи уваги частковій нагоді задачі про призначення, яку ми отримали. По-перше, це несбалансована задача про призначення, оскільки в одній частині знаходиться N-1 вершина, а в іншій - M вершин, тобто загалом кількість вершин у другій частині більша на цілий порядок. Для розв'язку такої двоїстої задачі про призначення є спеціалізований алгоритм, який розв'язує її за O(N^3), але тут цей алгоритм розглядатися не буде. По-друге, таку задачу про призначення можна назвати задачею про призначення з вагованими вершинами: ваги ребер покладемо рівними 0, вагу кожної вершини з першої частини покладемо рівною -C_i, з другої частини - рівною C_j, і розв'язок отриманої задачі буде тим же самим.

Ми будемо розв'язувати двоїсту задачу про призначення з використанням модифікованого алгоритму min-cost-flow, який знайде потік мінімальної вартості та одночасно розв'яже двоїсту задачу.

Зведення задачі про призначення до задачі min-cost-flow дуже легко, але для повноти картини ми опишемо цей процес.

Додамо до графа джерело $s$ і стік $t$. Від $s$ до кожної вершини першої частини проведемо ребро з пропускною здатністю $= 1$ і вартістю $= 0$. З кожної вершини другої частини проведемо ребро до $t$ з пропускною здатністю $= 1$ і вартістю $= 0$. Пропускні здатності всіх ребер між першою і другою частинами також покладемо рівними $1$.

Нарешті, щоб модифікований алгоритм мінімального потоку з мінімальними витратами (описаний нижче) працював, необхідно **додати ребро від s до t** з максимальною пропускною здатністю = N+1 та вартістю = 0.

### Модифікований алгоритм мінімального потоку з мінімальною вартістю для розв'язання задачі про призначення

Тут ми розглянемо **алгоритм послідовних найкоротших шляхів з потенціалами**, який нагадує звичайний алгоритм мінімального вартісного потоку, але використовує також поняття **потенціалів**, які до кінця роботи алгоритму будуть містити **розв'язок двоїстої задачі**.

Введемо позначення. Для кожного ребра (i,j) позначимо через $U_{ij}$ його пропускну здатність, через $C_{ij}$ - його вартість, через $F_{ij}$ - потік уздовж цього ребра.

Також введемо поняття потенціалів. Кожна вершина має свій потенціал PI<sub>i</sub>. Залишкова вартість ребра CPI<sub>ij</sub> визначається як:

$$
CPI<sub>ij</sub> = C<sub>ij</sub> - PI<sub>i</sub> + PI<sub>j</sub>
$$

У будь-який момент роботи алгоритму **потенціали такі**, що виконуються умови:

$$
якщо $F_{ij} = 0$, то $CPI_{ij} \geq 0$
якщо $F_{ij}=U_{ij}$, то $CPI_{ij} \leq 0$
інакше CPI<sub>ij</sub> = 0
$$

Алгоритм починає зі створення нульового потоку, і нам потрібно знайти певні початкові значення потенціалів, які задовольняли б зазначеним умовам. Не складно перевірити, що такий підхід є одним з можливих рішень

$$
PI<sub>j</sub> = 0   для j = N..M
PI<sub>i</sub> = min C<sub>ij</sub>, де (i,j) &isin; H
PI<sub>s</sub> = min PI<sub>i</sub>, де i = 1..N-1
PI<sub>t</sub> = 0
$$

Власне, сам алгоритм min-cost-flow складається з декількох ітерацій. На кожній ітерації ми знаходимо найкоротший шлях з s в t в залишковій мережі, причому в якості ваг ребер використовуємо остаточні вартості СПР. Потім ми збільшуємо потік уздовж знайденого шляху на одиницю і оновлюємо потенціали наступним чином:

$$
PI<sub>i</sub> -= D<sub>i</sub>
$$

де D<sub>i</sub> - знайдена найкоротша відстань від s до i (повторюємося, у залишковій мережі з вагами ребер КПІ).

Рано або пізно ми знайдемо той шлях з $s$ в $t$, який складається з єдиного ребра $(s,t)$. Значить, після цієї ітерації нам потрібно **завершити** роботу алгоритму. Дійсно, якщо ми не зупинимо алгоритм, то далі будуть перебувати шляхи з не від'ємною вартістю, і додавати їх до відповіді не потрібно.

До кінця роботи алгоритму ми отримаємо розв'язок задачі про призначення (у вигляді потоку F<sub>ij</sub>) та розв'язок двоїстої задачі про призначення (у масиві PI<sub>i</sub>).

(З PI<sub>i</sub> потрібно буде провести невелику модифікацію: від усіх значень PI<sub>i</sub> відняти PI<sub>s</sub>, оскільки їхнє значення має сенс тільки при PI<sub>s</sub> = 0)

### 6. Итог

Отже, ми вирішили подвійну задачу щодо призначень, а отже, і задачу зворотного Мінімального остовного дерева (inverse-MST).

Оцінимо **асимптотику** отриманого алгоритму.

Спочатку ми повинні побудувати граф шляхів. Для цього просто для кожного ребра j ∉ T обходом в ширину по каркасу T знайдемо шлях P[j]. Отже, граф шляхів ми побудуємо за O(M*N) = O(NM).

Потім ми знайдемо початкові значення потенціалів за O(N*M), де N та M - кількість елементів відповідних множин.

Потім ми будемо виконувати ітерації min-cost-flow, всього ітерацій буде не більше за N (адже з джерела виходить N ребер, кожне з пропускною здатністю = 1). На кожній ітерації ми шукатимемо в графі найкоротші шляхи від джерела до всіх інших вершин. Оскільки вершин у графі рівно M+2, а кількість ребер - O(NM), то якщо реалізувати пошук найкоротших шляхів найпростішим варіантом алгоритму Дейкстри, кожна ітерація min-cost-flow буде виконуватися за O(M<sup>2</sup>), а весь алгоритм min-cost-flow виконається за O(NM<sup>2</sup>). Крім того, будь ласка, уникайте використання російських слів та русизмів, дотримуючись української мови.

Підсумкова асимптотика алгоритму дорівнює **O(NM<sup>2</sup>)**.

## Реалізація

Реалізовуємо весь описаний алгоритм. Єдина зміна - замість [алгоритму Дейкстри](dijkstra) застосовується [алгоритм Левіта](levit_algorithm), який на багатьох тестах повинен працювати кілька разів швидше.

<!--- TODO: specify code snippet id -->
``` cpp
const int INF = 1000 * 1000 * 1000;

struct rib {
    int v, c, id;
};

struct rib2 {
    int a, b, c;
};

int main() {
    int n, m;
    cin >> n >> m;
Вектор векторів ребер графу у форматі списків суміжності: 

```
vector<vector<Edge>> g(n);
```
vector<Ребро2> ребра(m);     // всі ребра в одному списку
...читання графу...

        int nn = m + 2,
            s = nn - 2, t = nn - 1;
    vector<vector<int>> f(nn, vector<int>(nn));
    vector<vector<int>> u(nn, vector<int>(nn));
    vector<vector<int>> c(nn, vector<int>(nn));
    for (int i = n - 1; i < m; ++i) {
        vector<int> q(n);
        int h = 0, t = 0;
        rib2 &cur = ribs[i];
        q[t++] = cur.a;
        vector<int> rib_id(n, -1);
        rib_id[cur.a] = -2;
        while (h < t) {
            int v = q[h++];
            for (size_t j = 0; j < g[v].size(); ++j)
                if (g[v][j].id >= n - 1)
                    break;
                else if (rib_id[g[v][j].v] == -1) {
                    rib_id[g[v][j].v] = g[v][j].id;
                    q[t++] = g[v][j].v;
                }
        }
        for (int v = cur.b, pv; v != cur.a; v = pv) {
            int r = rib_id[v];
            pv = v != ribs[r].a ? ribs[r].a : ribs[r].b;
            u[r][i] = n;
            c[r][i] = ribs[i].c - ribs[r].c;
            c[i][r] = -c[r][i];
        }
    }
    u[s][t] = n + 1;
    for (int i = 0; i < n - 1; ++i)
        u[s][i] = 1;
    for (int i = n - 1; i < m; ++i)
        u[i][t] = 1;

    vector<int> pi(nn);
    pi[s] = INF;
    for (int i = 0; i < n - 1; ++i) {
        pi[i] = INF;
        for (int j = n - 1; j < m; ++j)
            if (u[i][j])
                pi[i] = min(pi[i], ribs[j].c - ribs[i].c);
        pi[s] = min(pi[s], pi[i]);
    }

    for (;;) {
        vector<int> id(nn);
        deque<int> q;
        q.push_back(s);
        vector<int> d(nn, INF);
        d[s] = 0;
        vector<int> p(nn, -1);
        while (!q.empty()) {
            int v = q.front();
            q.pop_front();
            id[v] = 2;
            for (int i = 0; i < nn; ++i)
                if (f[v][i] < u[v][i]) {
                    int new_d = d[v] + c[v][i] - pi[v] + pi[i];
                    if (new_d < d[i]) {
                        d[i] = new_d;
                        if (id[i] == 0)
                            q.push_back(i);
                        else if (id[i] == 2)
                            q.push_front(i);
                        id[i] = 1;
                        p[i] = v;
                    }
                }
        }
        for (int i = 0; i < nn; ++i)
            pi[i] -= d[i];
        for (int v = t; v != s; v = p[v]) {
            int pv = p[v];
            ++f[pv][v], --f[v][pv];
        }
        if (p[t] == s)
            break;
    }

    for (int i = 0; i < m; ++i)
        pi[i] -= pi[s];
    for (int i = 0; i < n - 1; ++i)
        if (f[s][i])
            ribs[i].c += pi[i];
    for (int i = n - 1; i < m; ++i)
        if (f[i][t])
            ribs[i].c += pi[i];

...висновок щодо графа...
}
```