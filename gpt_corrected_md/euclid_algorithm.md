# Алгоритм Евкліда знаходження НСД (найбільшого загального подільника)

Дано два цілих невід'ємних числа $a$ і $b$. Потрібно знайти їх найбільший загальний дільник, тобто найбільше число, яке є дільником одночасно $a$ і $b$. На англійській мові "найбільший загальний дільник" пишеться "greatest common divisor", а поширеним його позначенням є ${\rm gcd}$

$$
{\rm gcd}(a,b) = \max_{k=1 \ldots \infty \ :\  k|a \ \&\  k|b} k
$$

Тут символом "$\mid$" позначена діленість, тобто "$k\mid a$" позначає "$k$ ділить $a$"

Якщо одне з чисел дорівнює нулю, а інше відмінне від нуля, то їх найбільшим загальним дільником, згідно визначення, буде це друге число. Якщо обидва числа дорівнюють нулю, результат не визначений (підійде будь-яке нескінченно велике число). У цьому випадку ми покладемо найбільший загальний дільник рівним нулю. Тому можна сформулювати таке правило: якщо одне з чисел дорівнює нулю, то їх найбільший загальний дільник дорівнює другому числу.

Алгоритм Євкліда, розглянутий нижче, вирішує задачу знаходження найбільшого спільного дільника двох чисел $a$ і $b$ за $O(\log \min(a,b))$.

Даний алгоритм був вперше описаний у книзі "Елементи" Евкліда (близько 300 р. до н.е.), хоча, цілком можливо, що цей алгоритм має більш раннє походження.

## Алгоритм

Сам алгоритм надзвичайно простий і описується наступною формулою:

$$
{\rm gcd}(a,b) = \cases{ a, & {\rm if} b=0 \cr {\rm gcd} (b, a\ {\rm mod}\ b), & {\rm otherwise} }
$$

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
int gcd(int a, int b) {
    if (b == 0)
        return a;
    else
        return gcd(b, a % b);
}
```

Використовуючи тернарний оператор умови C++, алгоритм можна ще коротше записати:

<!--- TODO: specify code snippet id -->
``` cpp
int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }
```

Нарешті, наведемо нерекурсивну форму алгоритму:

<!--- TODO: specify code snippet id -->
``` cpp
int gcd(int a, int b) {
    while (b) {
        a %= b;
        swap(a, b);
    }
    return a;
}
```

## Доведення коректності

Спочатку зауважимо, що під час кожної ітерації алгоритму Євкліда його другий аргумент строго зменшується, отже, оскільки він не може бути від'ємним, то алгоритм Євкліда завжди завершується.

Для **доведення коректності** необхідно показати, що ${\rm НСД}(a,b) = {\rm НСД} (b, a\ {\rm mod}\ b)$ для будь-яких $a \ge 0, b > 0$.

Покажемо, що величина, яка стоїть у лівій частині рівності, ділиться на ту, що стоїть у правій, а та, що стоїть у правій, ділиться на ту, що стоїть у лівій. Очевидно, це означатиме, що ліва і права частини співпадають, що і доведе коректність алгоритму Євкліда.

Позначимо $d = \gcd(a,b)$. Значить, за визначенням, $d\mid a$ і $d\mid b$.

Далі розкладемо залишок від ділення $a$ на $b$ за їх приватністю:

$$
a\ {\rm mod}\ b = a - b \left\lfloor \frac{a}{b} \right\rfloor
$$

Але з цього випливає:

$$
d\ |\ (a\ {\rm mod}\ b)
$$

Отже, згадуючи твердження $d\mid b$, отримуємо систему:

$$
\cases{ d\ |\ b, \cr d\ |\ (a\ {\rm mod}\ b) }
$$

Скористаємося наступним простим фактом: якщо для довільних трьох чисел $p$, $q$ та $r$ виконується $p\mid q$ і $p\mid r$, то $p\mid {\rm gcd}(q,r)$. У нашій ситуації отримуємо:

$$
d\ |\ {\rm gcd}(b, a\ {\rm mod}\ b)
$$

Або, підставляючи замість $d$ його визначення як ${\rm НСД}(a,b)$, отримуємо:

$$
{\rm gcd}(a,b)\ |\ {\rm gcd}(b, a\ {\rm mod}\ b)
$$

Отже, ми провели половину доведення: показали, що ліва частина ділить праву. Друга половина доведення виконується аналогічно.

## Час роботи

Час роботи алгоритму оцінюється **теоремою Ламе**, яка встановлює дивовижний зв'язок між алгоритмом Євкліда та послідовністю Фібоначчі:

Якщо $a>b\ge 1$ і $b<F_n$ для деякого $n$, то алгоритм Євкліда виконає не більше $n-2$ рекурсивних викликів.

Більше того, можна показати, що верхня межа цієї теореми є оптимальною. При $a = F_n$, $b = F_{n-1}$ буде виконано саме $n-2$ рекурсивні виклики. Іншими словами, послідовні числа Фібоначчі є найгіршими вхідними даними для алгоритму Євкліда.

Враховуючи, що числа Фібоначчі зростають експоненційно (як константа у степені $n$), отримуємо, що алгоритм Євкліда виконується за $O(\log \min(a,b))$ операцій множення.

## НЗК (найменше загальне кратне)

Обчислення найменшого загального кратного (нзк) зводиться до обчислення $\gcd$ наступним простим твердженням:

$$
{\rm lcm}(a,b) = \frac{ a \cdot b }{ {\rm gcd}(a,b) }
$$

Таким чином, обчислення НСД також можна зробити з допомогою алгоритму Євкліда з тією ж асимптотичною складністю:

<!--- TODO: specify code snippet id -->
``` cpp
int lcm(int a, int b) { return a / gcd(a, b) * b; }
```

(Тут вигідно спочатку поділити на $\gcd$, а тільки потім домножувати на $b$, оскільки це допоможе уникнути переповнень в деяких випадках)

## Література

* \book{Томас Кормен, Чарльз Лейзерсон, Рональд Рівест, Кліффорд Штайн}{Алгоритми: Побудова та аналіз}{2005}{cormen.djvu}