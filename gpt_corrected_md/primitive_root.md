# Первісні корені

## Визначення

Первообразним коренем за модулем $n$ (примітивним коренем за модулем $n$) називається таке число $g$, всі степені якого за модулем $n$ пробігають усі числа, взаємно прості з $n$. Математично це формулюється так: якщо $g$ є примітивним коренем за модулем $n$, то для будь-якого цілого $a$ такого, що $({\rm НСД})(a,n)=1$, існує таке ціле $k$, що $g^k \equiv a \pmod{n}$.

Зокрема, для випадку простого $n$ степені первісного кореня пробігають всі числа від $1$ до $n-1$.

## Существование

Первісний корінь за модулем $n$ існує тоді і тільки тоді, коли $n$ є або степенем непарного простого числа, або подвійною степенню простого числа, а також у випадках $n=1$, $n=2$, $n=4$.

Ця теорема (яка була повністю доведена Гаусом у 1801 році) наводиться тут без доведення.

## Зв'Язок з [функцією Ейлера](euler_function)

Нехай $g$ - перший корінь за модулем $n$. Значить, можна показати, що найменше число $k$, для якого $g^k \equiv 1 \pmod{n}$ (тобто $k$ - показник $g$ (мультиплікативний порядок)), дорівнює $\phi(n)$. Більше того, цей факт є правильним і протилежним, і цей факт буде використовуватися нами нижче в алгоритмі знаходження першого кореня.

Крім того, якщо за модулем $n$ є хоча б один примітивний корінь, то всього їх $\phi( \phi(n) )$ (тобто циклічна група з $k$ елементами має $\phi(k)$ генераторів).

## Алгоритм знаходження примітивного кореня

Наївний алгоритм вимагає для кожного тестового значення $g$ $O(n)$ часу, щоб обчислити всі його степені і перевірити, що вони всі є різними. Це занадто повільний алгоритм. Нижче ми з допомогою кількох відомих теорем з теорії чисел отримаємо більш швидкий алгоритм.

Вище була наведена теорема про те, що якщо найменше число $k$, для якого $g^k \equiv 1 \pmod{n}$ (тобто $k$ - показник $g$), дорівнює $\phi(n)$, то $g$ - первісний корінь. Оскільки для будь-якого числа $a$, взаємно простого з $n$, виконується [теорема Ейлера](http://e-maxx.ua/algo/euler_function#4) ($a^{\phi(n)} \equiv 1 \pmod{n}$), то для перевірки того, що $g$ - первісний корінь, достатньо перевірити, що для всіх чисел $d$, менших $\phi(n)$, виконується $g^d \not\equiv 1 \pmod{n}$. Однак це є занадто повільним алгоритмом.

З теореми Ейлера випливає, що показник будь-якого числа за модулем $n$ із взаємно простим до $n$ основою є дільником $\phi(n)$. Таким чином, достатньо перевірити, що для всіх собственних подільників $d\ |\ \phi(n)$, для яких $\gcd(g,n)=1$, виконується $g^d \not\equiv 1 \pmod{n}$. Це вже значно швидший алгоритм, однак можна піти ще далі.

Факторизуємо число $\phi(n)$ як $\phi(n) = p_1^{a_1} \ldots p_s^{a_s}$. Доведемо, що в попередньому алгоритмі достатньо розглядати в якості $d$ лише числа увазі $\frac{\phi(n)}{p_i}$. Дійсно, нехай $d$ - довільний власний дільник $\phi(n)$. Значить, очевидно, знайдеться таке $j$, що $d\ |\ \frac{\phi(n)}{p_j}$, тобто $d \cdot k = \frac{\phi(n)}{p_j}$. Однак, якщо б $g^d \equiv 1 \pmod{n}$, то ми отримали б:

$$
g^{\frac{ \phi(n) }{ p_j }} \equiv g^{d \cdot k} \equiv {\left( g^d \right) }^k \equiv 1^k \equiv 1 \pmod{n},
$$

тобто, все ж таки серед чисел, що дорівнюють $\frac{\phi(n)}{p_i}$, знайшлося таке, для якого не виконується умова, яку потрібно довести.

Таким чином, алгоритм знаходження первісного кореня такий: знаходимо $\phi(n)$, факторизуємо його. Далі перебираємо всі числа $g$ від $1$ до $n$, і для кожного з них обчислюємо всі величини $g^{ \frac{ \phi(n) }{ p_i } } \pmod{n}$. Якщо для поточного $g$ всі ці числа виявилися відмінними від $1$, то це $g$ є шуканим первообразним коренем.

Час роботи алгоритму (вважаючи, що у чисел $\phi(n)$ є $O \left( \log \phi(n) \right)$ дільників, а піднесення в ступінь виконується алгоритмом [Бінарного піднесення в ступінь](binary_pow), тобто за $O(\log n)$) дорівнює $O \left( {\rm Ans} \cdot \log \phi(n) \cdot \log n \right)$ плюс час факторизації числа $\phi(n)$, де $\rm Ans$ - результат, тобто значення шуканого примітивного кореня.

Про швидкість росту першої похідної від коренів залежно від $n$ відомі лише приблизні оцінки. Відомо, що корені є порівняно невеликими величинами. Одна з відомих оцінок - оцінка Шупа (Shoup), яка припускає істинність гіпотези Рімана, стверджує, що перший корінь є $O(\log^6 n)$.

## Реалізація

Функція powmod() виконує бінарне піднесення до степеня за модулем, а функція генератор (int p) - знаходить примітивний корінь за простим модулем $p$ (розклад числа $\phi(n)$ тут здійснено найпростішим алгоритмом за $O(\sqrt{\phi(n)})$).

Щоб адаптувати цю функцію для довільних $p$, достатньо додати обчислення [функції Ойлера](https://uk.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D1%96%D1%8F_%D0%9E%D0%B9%D0%BB%D0%B5%D1%80%D0%B0) в змінній $phi$, а також відсіяти $res$, які не є взаємно простими з $n$.

<!--- TODO: specify code snippet id -->
``` cpp
int powmod(int a, int b, int p) {
    int res = 1;
    while (b)
        if (b & 1)
            res = int(res * 1ll * a % p), --b;
        else
            a = int(a * 1ll * a % p), b >>= 1;
    return res;
}

int generator(int p) {
    vector<int> fact;
    int phi = p - 1, n = phi;
    for (int i = 2; i * i <= n; ++i)
        if (n % i == 0) {
            fact.push_back(i);
            while (n % i == 0)
                n /= i;
        }
    if (n > 1)
        fact.push_back(n);

    for (int res = 2; res <= p; ++res) {
        bool ok = true;
        for (size_t i = 0; i < fact.size() && ok; ++i)
            ok &= powmod(res, phi / fact[i], p) != 1;
        if (ok)
            return res;
    }
    return -1;
}
```