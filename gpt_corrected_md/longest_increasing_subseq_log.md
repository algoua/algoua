# Знаходження найдовшої зростаючої підпослідовності

Умова задачі випливає. Даний масив з $n$ чисел: $a_{0 \ldots n-1}$. Потрібно знайти в цій послідовності строго зростаючу підпослідовність найбільшої довжини.

Формально це виглядає наступним чином: потрібно знайти таку послідовність індексів $i_1, \ldots, i_k$, що:

$$
i_1 < i_2 < \ldots < i_k,
$$

$$
a[i_1] < a[i_2] < \ldots < a[i_k].
$$

У даній статті розглядаються різні алгоритми для вирішення даної задачі, а також деякі завдання, які можна звести до цієї задачі.

## Розв'язок за $O(n^2)$: метод динамічного програмування

Динамічне програмування - це дуже загальна методика, яка дозволяє розв'язувати великий клас задач. Тут ми розглянемо цю методику щодо нашої конкретної задачі.

Навчимося спочатку шукати **довжину** найбільшої зростаючої підпослідовності, а відновленням самої підпослідовності займемося трохи пізніше.

### Динамічне програмування для знаходження довжини відповіді

Для цього давайте навчимося рахувати масив $d[0 \ldots n-1]$, де $d[i]$ - це довжина найдовшої зростаючої підпослідовності, що закінчується саме в елементі з індексом $i$. Масив цей (він і є - сама динаміка) будемо рахувати поступово: спочатку $d[0]$, потім $d[1]$ і т.д. На кінці, коли цей масив буде підрахований, відповідь на задачу буде дорівнювати максимуму в масиві $d[]$.

Отже, нехай поточний індекс - $i$, тобто ми хочемо порахувати значення $d[i]$, а всі попередні значення $d[0]$ до $d[i-1]$ вже обчислені
\ldots d[i-1] вже підраховані. Зауважимо, що у нас є два варіанти:

* Або $d[i]=1$, тобто шукана підпослідовність складається лише з числа $a[i]$.

* або $d[i] > 1$. Отже, перед числом $a[i]$ в шуканій підпослідовності варто вставити яке-небудь інше число. Давайте переберемо це число: це може бути будь-який елемент $a[j]$ $(j = 0 \ldots i-1)$, але такий, що $a[j] < a[i]$. Нехай ми розглядаємо деякий поточний індекс $j$. Оскільки динаміка $d[j]$ для нього вже підрахована, виходить, що це число $a[j]$ разом з числом $a[i]$ дає відповідь $d[j] + 1$. Таким чином, $d[i]$ можна обчислити за формулою:

$$
d[i] = \max_{j=0 \ldots i-1, \atop a[j] < a[i]} ( d[j] + 1 ).
$$

Об'єднуючи ці два варіанти в один, отримуємо остаточний алгоритм для обчислення $d[i]$:

$$
d[i] = \max \Big( 1, \max_{j=0 \ldots i-1, \atop a[j] < a[i]} ( d[j] + 1 ) \Big).
$$

Цей алгоритм є динамікою.

### Реалізація

Наведемо реалізацію описаного вище алгоритму, яка знаходить та виводить довжину найдовшої зростаючої підпослідовності:

<!--- TODO: specify code snippet id -->
``` cpp
int d[MAXN]; // Константа MAXN дорівнює найбільшому можливому значенню n

for (int i = 0; i < n; ++i) {
    d[i] = 1;
    for (int j = 0; j < i; ++j)
        if (a[j] < a[i])
            d[i] = max(d[i], 1 + d[j]);
}

int ans = d[0];
for (int i = 0; i < n; ++i)
    ans = max(ans, d[i]);
cout << ans << endl;
```

### Відновлення відповіді

Поки що ми лише навчилися шукати довжину відповіді, але саму найдовшу підпослідовність ми вивести не можемо, тобто не зберігаємо жодної додаткової інформації про те, де досягаються максимуми.

Щоб змогти відновити відповідь, окрім динаміки $d[0 \ldots n-1]$, потрібно також зберігати допоміжний масив $p[0 \ldots n-1]$, в якому буде зазначено місце досягнення максимуму для кожного значення $d[i]$. Іншими словами, індекс $p[i]$ вказуватиме на той самий індекс $j$, при якому було досягнуте найбільше значення $d[i]$. (Цей масив $p[]$ в динамічному програмуванні часто називають "масивом батьків").

Отже, щоб вивести відповідь, потрібно просто йти від елементу з максимальним значенням $d[i]$ по його батьківським елементам, доки не буде виведена вся підпослідовність, тобто доки не досягнемо елементу зі значенням $d = 1$. Російське слово "предок" слід замінити на українське "батько".

### Реалізація відновлення відповіді

Отже, у нас зміниться код самої динаміки, а також додатково буде додано код, який здійснює виведення найдовшої підпослідовності (виводяться індекси елементів підпослідовності в 0-індексації).

Для зручності спочатку ми присвоїли індексам $p[i] = -1$: для елементів, у яких динаміка дорівнює одиниці, це значення предка залишиться мінус одиницею, що трохи зручніше при відновленні відповіді.

<!--- TODO: specify code snippet id -->
``` cpp
int d[MAXN], p[MAXN]; // Константа MAXN дорівнює найбільшому можливому значенню n

for (int i = 0; i < n; ++i) {
    d[i] = 1;
    p[i] = -1;
    for (int j = 0; j < i; ++j)
        if (a[j] < a[i])
            if (1 + d[j] > d[i]) {
                d[i] = 1 + d[j];
                p[i] = j;
            }
}

int ans = d[0], pos = 0;
for (int i = 0; i < n; ++i)
    if (d[i] > ans) {
        ans = d[i];
        pos = i;
    }
cout << ans << endl;

vector<int> path;
while (pos != -1) {
    path.push_back(pos);
    pos = p[pos];
}
reverse(path.begin(), path.end());
for (int i = 0; i < (int)path.size(); ++i)
    cout << path[i] << ' ';
```

### Альтернативний спосіб відновлення відповідності

Втім, як майже завжди в разі застосування динамічного програмування, для відновлення відповіді можна не зберігати додатковий масив предків $p[]$, а просто заново перераховувати поточний елемент динаміки і шукати, на якому саме індексі був досягнутий максимум.

Цей спосіб реалізації призводить до трохи більш довгого коду, однак замість цього ми отримуємо економію пам'яті та абсолютну збіжність логіки програми під час підрахунку динаміки та відновлення.

## Розв'язок у $O(n \log n)$: динамічне програмування з бінарним пошуком

Щоб отримати швидший розв'язок задачі, побудуємо інший вид динамічного програмування з складністю $O(n^2)$, а потім з'ясуємо, як можна прискорити цей алгоритм до $O(n \log n)$.

Динаміка тепер буде такою: нехай $d[i]$ $(i = 0 \ldots n)$ - це число, на якому закінчується зростаюча підпослідовність довжини $i$ (а якщо таких чисел декілька - то найменше з них).

Спочатку ми вважаємо $d[0] = -\infty$, а всі інші елементи $d[i] = \infty$.

Вважати цю динаміку ми будемо поступово, обробивши число $a[0]$, потім $a[1]$, і т.д.

Наведемо реалізацію цієї динаміки за $O(n^2)$:

<!--- TODO: specify code snippet id -->
``` cpp
int d[MAXN];
d[0] = -INF;
for (int i = 1; i <= n; ++i)
    d[i] = INF;

for (int i = 0; i < n; i++)
    for (int j = 1; j <= n; j++)
        if (d[j - 1] < a[i] && a[i] < d[j])
            d[j] = a[i];
```

Зауважимо тепер, що у цій динаміці є одна **дуже важлива властивість**: $d[i-1] \le d[i]$ для всіх $i = 1 \ldots n$. Інша властивість полягає в тому, що кожний елемент $a[i]$ оновлює максимум один елемент $d[j]$.

Таким чином, це означає, що обробляти наступний елемент $a[i]$ ми можемо за $O(\log n)$, зробивши двійковий пошук у масиві $d[]$. Насправді, ми просто шукаємо перше число в масиві $d[]$, яке строго більше $a[i]$, і намагаємося провести оновлення цього елементу аналогічно до реалізації, наведеної вище.

### Реалізація за $O(n \log n)$

Скориставшись стандартним алгоритмом двійкового пошуку $upper\_bound$ у мові C++, який повертає позицію першого елементу, строго більшого даного, отримуємо таку просту реалізацію:

<!--- TODO: specify code snippet id -->
``` cpp
int d[MAXN];
d[0] = -INF;
for (int i = 1; i <= n; ++i)
    d[i] = INF;

for (int i = 0; i < n; i++) {
    int j = int(upper_bound(d.begin(), d.end(), a[i]) - d.begin());
    if (d[j - 1] < a[i] && a[i] < d[j])
        d[j] = a[i];
}
```

### Відновлення відповіді

За такої динаміки також можна відновити відповідь. Для цього, окрім динаміки $d[i]$, потрібно зберігати масив "попередників" $p[i]$, тобто індекс елемента, на якому закінчується оптимальна підпослідовність довжини $i$. Крім того, для кожного елемента масиву $a[i]$ потрібно зберігати його "попередника", тобто індекс елемента, який повинен стояти перед $a[i]$ в оптимальній підпослідовності.

Підтримуючи ці два масиви під час обчислення динаміки, в кінці буде легко відновити шукану підпослідовність.

Цікаво зауважити, що для даної динаміки відповідь можна відновлювати тільки за допомогою масивів предків. Без них відновлення відповіді після обчислення динаміки буде неможливим. Це один з рідкісних випадків, коли альтернативний спосіб відновлення не застосовується до динаміки.

## Розв'язок за $O(n \log n)$: структури даних

Якщо наведений вище спосіб з $O(n \log n)$ є дуже красивим, але не зовсім тривіальним ідеєно, то є інший шлях: скористатися однією з відомих простих структур даних.

Насправді, давайте повернемося до самої першої динаміки, де станом являлась просто поточна позиція. Поточне значення динаміки $d[i]$ обчислюється як максимум серед значень $d[j]$, де $j$ - всі такі елементи, що $a[j] < a[i]$.

Отже, якщо ми позначимо такий масив як $t[]$, до якого будемо записувати значення динаміки від чисел:

$$
t[a[i]] = d[i],
$$

таким чином, виходить, що все, що нам потрібно вміти - це шукати **максимум на префіксі** масиву $t$: $t[0 \ldots a[i]-1]$.

Задача пошуку максимуму на префиксах масиву (з урахуванням того, що масив можливо змінюватися) вирішується многими стандартными структурами данних, наприклад, [деревом відрізків](segment_tree) або [деревом Фенвіка](fenwick_tree).

Скориставшись будь-якою такою структурою даних, ми отримаємо розв'язок за $O(n \log n)$.

У цього способу розв'язку є явні **недоліки**: за довжиною і складністю реалізації цей шлях буде в будь-якому випадку гірший, ніж описана вище динаміка за $O(n \log n)$. Крім того, якщо вхідні числа $a[i]$ можуть бути достатньо великими, то швидше за все їх доведеться стискувати (тобто перенумеровувати від $0$ до $n-1$) - без цього багато стандартних структур даних не зможуть працювати через високе споживання пам'яті.

З іншого боку, у даному випадку є й переваги. По-перше, при такому способі розв'язання не доведеться думати про складну динаміку. По-друге, цей спосіб дозволяє розв'язувати деякі узагальнення нашої задачі (див. нижче).

## Суміжні задачі

Наведемо кілька задач, що тісно пов'язані з завданням пошуку найдовшої зростаючої підпослідовності.

### Найдовша незменшувана підпослідовність

Фактично, це та сама задача, тільки тепер у шуканій підпослідовності допускаються однакові числа (тобто ми повинні знайти нестрого зростаючу підпослідовність).

Розв'язок цієї задачі по суті не відрізняється від нашої вихідної задачі, просто при порівняннях зміняться знаки нерівностей, а також треба буде трохи змінити двійковий пошук.

### Кількість найдовших зростаючих підпослідовностей

Для розв'язання цієї задачі можна використовувати саму першу динаміку за $O(n^2)$ або підхід з допомогою структур даних для розв'язання за $O(n \log n)$. І в тому, і в тому випадку всі зміни полягають тільки в тому, що окрім значення динаміки $d[i]$ потрібно також зберігати, скількома способами це значення могло бути отримано.

На всій видимості, спосіб розв'язку даної задачі через динаміку за $O(n \log n)$ застосувати неможливо.

### Найменше число незменшуваних підпослідовностей, які покривають задану послідовність

Умова така. Даний масив з $n$ чисел $a[0 \ldots n-1]$. Потрібно розфарбувати його числа в найменшу кількість квітів так, щоб по кожному кольору утворювалася невисхідна підпослідовність.

Розв'язок. Твердиться, що мінімальна кількість необхідних квітів дорівнює довжині найдовшої зростаючої підпослідовності.

Доведення. Фактично, нам потрібно довести **двоїстість** цієї задачі і задачі пошуку найдовшої зростаючої підпослідовності.

Позначимо через $x$ довжину найбільшої зростаючої підпослідовності, а через $y$ - шукане найменше число незростаючих підпослідовностей. Нам потрібно довести, що $x=y$.

З одного боку, зрозуміло, чому не можна мати $y<x$: якщо є $x$ строго зростаючих елементів, то жодні два з них не можуть бути в одній невід'ємній підпослідовності, тому $y \ge x$.

Покажемо тепер, що, навпаки, $y$ не може бути $> x$. Доведемо це від протилежного: припустимо, що $y > x$. Значить, розглянемо будь-який оптимальний набір з $y$ незменшуваних підпослідовностей. Перетворимо цей набір таким чином: доти, поки є дві такі підпослідовності, що перша починається раніше другої, але при цьому перша починається з числа, більшого або рівного, ніж початок другої - відокремимо це стартове число від першої підпослідовності і додамо його на початок другої. Таким чином, через деяку кінцеву кількість кроків у нас залишиться $y$ підпослідовностей, причому їх стартові числа утворять зростаючу підпослідовність довжини $y$. Але $y > x$, тобто ми прийшли до протиріччя (адже не можливо мати зростаючих підпослідовностей довші за $x$).

Таким чином, насправді, $y = x$, що й потрібно довести.

Стверджується, що саме шукане розбиття на підпослідовності можна знайти жадібно, тобто йти зліва направо і відносити поточне число до тієї підпослідовності, яка зараз закінчується на мінімальне число, більше або рівне поточному.

## Завдання на онлайн-суддівстві

Список завдань, які можна вирішити з даної тематики:

* [MCCME #1793 **"Наибольшая зростаюча підпослідовність за O(n*log(n))"** [складність: низька]](http://informatics.mccme.ru/moodle/mod/statements/view3.php?chapterid=1793)

* [TopCoder SRM 278 **"500 IntegerSequence"** [складність: низька]](http://community.topcoder.com/stat?c=problem_statement&pm=5922&rd=8075)

* [TopCoder SRM 233 **"DIV2 1000 AutoMarket"** [складність: низька]](http://community.topcoder.com/stat?c=problem_statement&pm=3937&rd=6532)

* [Всеукраїнська олімпіада школярів з інформатики - задача F **"Турист"** [складність: середня]](http://codeforces.com/contest/76/problem/F)

* [Codeforces Beta Round #10 - завдання D **"НОВП"** [складність: середня]](http://codeforces.com/problemset/problem/10/D)

* [ACM.TJU.EDU.CN 2707 **"Greatest Common Increasing Subsequence"** [складність: середня]](http://acm.tju.edu.cn/toj/showp2707.html)

* [SPOJ #57 **"SUPPER. Supernumbers in a permutation"** [складність: середня]](http://www.spoj.pl/problems/SUPPER/)

* [TopCoder Open 2004 - Round 4 - **"1000. BridgeArrangement"** [складність: висока]](http://community.topcoder.com/stat?c=problem_statement&pm=2967&rd=5881)