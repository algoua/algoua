# Мінімальне каркасне дерево. Алгоритм Пріма

Даний зважений неорієнтований граф $G$ з $n$ вершинами і $m$ ребрами. Потрібно знайти таке піддерево цього графа, яке б з'єднувало всі його вершини, і при цьому мало найменшу можливу вагу (тобто суму ваг ребер). Піддерево - це набір ребер, що з'єднують всі вершини, причому з будь-якої вершини можна дістатися до будь-якої іншої за один простий шлях.

Таке піддерево називається мінімальним остовним деревом або просто **мінімальним каркасом**. Легко зрозуміти, що будь-який каркас обов'язково міститиме $n-1$ ребро.

У **природній постановці** ця задача звучить наступним чином: є $n$ міст, і для кожної пари відома вартість з'єднання їх дорогою (або відомо, що з'єднати їх не можна). Потрібно з'єднати всі міста так, щоб можна було дістатися з будь-якого міста до будь-якого іншого, а при цьому вартість прокладання доріг була б мінімальною.

## Алгоритм Пріма

Цей алгоритм називається на честь американського математика Роберта Пріма (Robert Prim), який відкрив його в 1957 році. Однак ще в 1930 році цей алгоритм був відкритий чеським математиком Войтеком Ярніком (Vojtěch Jarník). Крім того, Едсгер Дейкстра (Edsger Dijkstra) також винайшов цей алгоритм в 1959 році, незалежно від них.

### Опис алгоритму

Сам **алгоритм** має дуже простий вигляд. Іскомий мінімальний каркас будується поступово, додаванням до нього ребер по одному. Спочатку каркас складається з єдиної вершини (її можна вибрати довільно). Потім вибирається ребро мінімальної ваги, яке виходить з цієї вершини, і додається до мінімального каркасу. Після цього каркас містить вже дві вершини, і тепер шукається та додається ребро мінімальної ваги, яке має один кінець в одній з двох обраних вершин, а інший кінець - навпаки, у всіх інших, крім цих двох. І так далі, тобто кожного разу шукається мінімальне за вагою ребро, один кінець якого - вершина, яка вже є у каркасі, а інший кінець - ще не взята, і це ребро додається до каркасу (якщо таких ребер декілька, можна взяти будь-яке). Цей процес повторюється до тих пір, поки каркас не міститиме всі вершини (або, що те ж саме, $n-1$ ребро).

В результаті буде побудований каркас, який є мінімальним. Якщо граф спочатку не був зв'язним, то каркас не буде знайдений (кількість обраних ребер залишиться менше $n-1$).

### Доведення

Нехай граф $G$ є зв'язним. Позначимо каркас, знайдений алгоритмом Прима, через $T$, а мінімальний каркас - через $S$. Очевидно, що $T$ є каркасом, тобто піддеревом графа $G$. Покажемо, що ваги $S$ та $T$ співпадають.

Розглянемо перший момент часу, коли в $T$ відбулося додавання ребра, що не входить до оптимального каркасу $S$. Позначимо це ребро як $e$, його кінці як $a$ і $b$, а множину вершин, що на той момент входять до каркасу, як $V$ (згідно алгоритму, $a \in V$, $b \not\in V$, або навпаки). У оптимальному остові $S$ вершини $a$ і $b$ з'єднані деяким шляхом $P$; знайдемо в цьому шляху будь-яке ребро $g$, один кінець якого лежить в $V$, а інший - ні. Оскільки алгоритм Пріма обрав ребро $e$ замість ребра $g$, то це означає, що вага ребра $g$ більше або дорівнює вазі ребра $e$.

Видалемо тепер з $S$ ребро $g$ і додамо ребро $e$. За те, що щойно було сказано, вага острова в результаті не могла збільшитися (зменшитися вона теж не могла, оскільки $S$ було оптимальним). Крім того, $S$ не перестало бути каркасом (в тому, що зв'язність не порушилась, нескладно переконатися: ми замкнули шлях $P$ в цикл, а потім видалили з цього циклу одне ребро).

Отже, ми показали, що можна вибрати оптимальний каркас $S$ таким чином, щоб він містив ребро $e$. Повторюючи цю процедуру необхідну кількість разів, ми отримуємо, що можна вибрати оптимальний каркас $S$ так, щоб він співпадав з $T$. Отже, вага побудованого алгоритмом Пріма $T$ є мінімальною, що і потрібно довести.

## Реализации

Час роботи алгоритму суттєво залежить від того, як ми шукаємо наступне мінімальне ребро серед відповідних ребер. Тут можуть бути різні підходи, які призводять до різних асимптотичних оцінок та різних реалізацій.

### Тривіальна реалізація: алгоритми з $O(nm)$ та $O(n^2 + m\log n)$

Якщо шукати кожен раз ребро простим переглядом серед усіх можливих варіантів, то асимптотично буде потрібно переглянути $O(m)$ ребер, щоб знайти серед усіх допустимих ребер те, яке має найменший вагу. Сумарна асимптотика алгоритму в такому випадку становить $O(nm)$, що в гіршому випадку є $O(n^3)$, - занадто повільний алгоритм.

Цей алгоритм можна покращити, якщо переглядати кожен раз не всі ребра, а тільки по одному ребру з кожної вже обраної вершини. Для цього, наприклад, можна відсортувати ребра з кожної вершини в порядку зростання ваги і зберігати вказівник на перше допустиме ребро (нагадаємо, допустимі тільки ті ребра, які ведуть в множину ще не обраних вершин). Значить, якщо перераховувати ці вказівники при кожному додаванні ребра в каркас, сумарна асимптотика алгоритму буде $O(n^2 + m)$, але попередньо буде потрібно виконати сортування всіх ребер за $O(m \log n)$, що в гіршому випадку (для щільних графів) дає асимптотику $O(n^2 \log n)$.

Нижче ми розглянемо два трохи інші алгоритми: для щільних і для розріджених графів, отримавши в підсумку помітно кращу асимптотику.

### Випадок щільних графів: алгоритм з $O(n^2)$

Підійдемо до питання пошуку найменшого ребра з іншої сторони: для кожної ще не обраної вершини будемо зберігати мінімальне ребро, що веде до вже обраної вершини.

Отже, щоб на поточному кроці провести вибір мінімальної дуги, потрібно просто переглянути ці мінімальні дуги у кожній ще не обраній вершині - асимптотика складе $O(n)$.

Але тепер, при додаванні наступного ребра та вершини до каркасу, ці вказівники потрібно перераховувати. Зауважимо, що ці вказівники можуть лише зменшуватися, тому для кожної ще не перевіреної вершини потрібно або залишити її вказівник без зміни, або присвоїти йому вагу ребра до тільки що доданої вершини. Отже, цю фазу також можна виконати за $O(n)$.

Таким чином, ми отримали різновид алгоритму Прима з асимптотикою $O(n^2)$.

Зокрема, така реалізація особливо зручна для розв'язання так званої **євклідової задачі про мінімальний каркас**: коли задані $n$ точок на площині, відстань між якими вимірюється за стандартною євклідовою метрикою, і потрібно знайти каркас мінімальної ваги, що з'єднує їх всі (при цьому додавати нові вершини де-небудь інде заперечується). Цю задачу можна вирішити описаним тут алгоритмом за $O(n^2)$ часу і $O(n)$ пам'яті, чого не вдасться досягти [алгоритмом Крускала](mst_kruskal).

Реалізація алгоритму Пріма для графу, заданого матрицею суміжності $g[][]$:

<!--- TODO: specify code snippet id -->
``` cpp
// вхідні дані

int n;
vector<vector<int>> g;
const int INF = 1000000000; // значення "нескінченність"

// алгоритм
vector<bool> used(n);
vector<int> min_e(n, INF), sel_e(n, -1);
min_e[0] = 0;
for (int i = 0; i < n; ++i) {
    int v = -1;
    for (int j = 0; j < n; ++j)
        if (!used[j] && (v == -1 || min_e[j] < min_e[v]))
            v = j;
    if (min_e[v] == INF) {
        cout << "No MST!";
        exit(0);
    }

    used[v] = true;
    if (sel_e[v] != -1)
        cout << v << " " << sel_e[v] << endl;

    for (int to = 0; to < n; ++to)
        if (g[v][to] < min_e[to]) {
            min_e[to] = g[v][to];
            sel_e[to] = v;
        }
}
```

На вхід надають кількість вершин $n$ та матрицю $g[][]$ розміру $n \times n$, в якій відмічені ваги ребер. Якщо відповідне ребро відсутнє, то стоїть число $INF$. Алгоритм підтримує три масиви: прапор ${\rm used}[i] = {\rm true}$ означає, що вершина $i$ включена до каркасу; величина ${\rm min\_e}[i]$ зберігає вагу найменшого допустимого ребра з вершини $i$; елемент ${\rm sel\_e}[i]$ містить кінець цього найменшого ребра (це потрібно для виведення ребер у відповіді). Алгоритм робить $n$ кроків. На кожному з них вибирається вершина $v$ з найменшою міткою ${\rm min\_e}$, позначається ${\rm used}$ та переглядаються всі ребра з цієї вершини з перерахуванням їх міток.

### Випадок розріджених графів: алгоритм з $O(m \log n)$

У описаному вище алгоритмі можна побачити стандартні операції знаходження мінімуму в множині та зміни значень в цій множині. Ці дві операції є класичними і виконуються багатьма структурами даних, наприклад, реалізованими в мові C++ червоно-чорним деревом set.

За змістом алгоритм залишається точно таким самим, однак тепер ми можемо знайти мінімальне ребро за час $O(\log n)$. З іншого боку, час на перерахунок $n$ вказівників тепер складає $O(n \log n)$, що гірше, ніж у вищезгаданому алгоритмі.

Якщо врахувати, що всього буде $O(m)$ перерахунків вказівників і $O(n)$ пошуків мінімального ребра, то сумарна асимптотика складе $O(m \log n)$ - для розріджених графів це краще, ніж обидва описаних вище алгоритми, але на щільних графах цей алгоритм буде повільніший за попередній.

Реалізація алгоритму Пріма для графа, заданого списками суміжності $g[]$:

<!--- TODO: specify code snippet id -->
``` cpp
// вхідні дані
int n;
vector<vector<pair<int, int>>> g;
const int INF = 1000000000; // значення "нескінченність"

// алгоритм
vector<int> min_e(n, INF), sel_e(n, -1);
min_e[0] = 0;
set<pair<int, int>> q;
q.insert(make_pair(0, 0));
for (int i = 0; i < n; ++i) {
    if (q.empty()) {
        cout << "No MST!";
        exit(0);
    }
    int v = q.begin()->second;
    q.erase(q.begin());

    if (sel_e[v] != -1)
        cout << v << " " << sel_e[v] << endl;

    for (size_t j = 0; j < g[v].size(); ++j) {
        int to = g[v][j].first, cost = g[v][j].second;
        if (cost < min_e[to]) {
            q.erase(make_pair(min_e[to], to));
            min_e[to] = cost;
            sel_e[to] = v;
            q.insert(make_pair(min_e[to], to));
        }
    }
}
```

На вхід надходять кількість вершин $n$ і $n$ списків суміжності: $g[i]$ - це список всіх ребер, що виходять з вершини $i$, у вигляді пар (кінцева вершина ребра, вага ребра). Алгоритм підтримує два масиви: величина ${\rm min\_e}[i]$ зберігає вагу найменшого допустимого ребра з вершини $i$, а елемент ${\rm sel\_e}[i]$ містить кінцеву вершину цього найменшого ребра (це потрібно для виведення ребер в відповіді). Крім того, підтримується черга $q$ з усіх вершин в порядку збільшення їх міток ${\rm min\_e}$. Алгоритм робить $n$ кроків, на кожному з яких вибирає вершину $v$ з найменшою міткою ${\rm min\_e}$ (просто вилучаючи її з початку черги), і потім переглядає всі ребра з цієї вершини, перераховуючи їх мітки (при перерахунку ми видаляємо з черги стару величину, і потім кладемо назад нову).

### Аналогія з алгоритмом Дейкстри

У двох щойно описаних алгоритмах прослідковується чітка аналогія з [алгоритмом Дейкстри](dijkstra): він має таку ж структуру ($n-1$ фаза, на кожній з яких спочатку вибирається оптимальне ребро, додається в відповідь, а потім перераховуються значення для всіх ще не обраних вершин). Більше того, алгоритм Дейкстри також має два варіанти реалізації: за $O(n^2)$ і $O(m \log n)$ (ми, звісно, тут не беремо до уваги можливість використання складних структур даних для досягнення ще менших асимптотик).

Якщо придивитися до алгоритмів Пріма і Дейкстри більш формально, то виявляється, що вони є практично ідентичними один одному, за винятком **вагової функції** вершин: якщо в алгоритмі Дейкстри кожна вершина має довжину найкоротшого шляху (тобто суму ваг деяких ребер), то в алгоритмі Пріма кожній вершині надається тільки вага мінімального ребра, що веде до множини вже взятих вершин.

На рівні реалізації це означає, що після додавання чергової вершини $v$ до множини обраних вершин, коли ми починаємо переглядати всі ребра $(v,to)$ з цієї вершини, то в алгоритмі Прима вказівник $to$ оновлюється вагою ребра $(v,to)$, а в алгоритмі Дейкстри - мітка відстані $d[to]$ оновлюється сумою мітки $d[v]$ та ваги ребра $(v,to)$. В іншому випадку ці два алгоритми можна вважати ідентичними (незважаючи на те, що вони вирішують зовсім різні задачі).

## Властивості мінімальних кістяків

* Максимальний каркас також можна шукати алгоритмом Крускала (наприклад, замінивши всі ваги ребер на протилежні: алгоритм не вимагає неотрицательності ваг ребер).

* Мінімальний каркас **єдиний**, якщо ваги всіх ребер різні. У іншому випадку може існувати кілька мінімальних кістяків. Який саме буде обраний алгоритмом Пріма залежить від порядку перегляду ребер/вершин з однаковими вагами/індексами

* Мінімальний каркас також є каркасом, **мінімальним за добутком** всіх ребер (передбачається, що всі ваги додатні). Насправді, якщо ми замінимо ваги всіх ребер на їх логарифми, то легко помітимо, що в роботі алгоритму нічого не зміниться, і будуть знайдені ті ж самі ребра.

* Мінімальний каркас є каркасом з мінімальною вагою **найважчого ребра**. Це твердження найбільш зрозуміло, якщо розглянути роботу [алгоритму Крускала](mst_kruskal).

* **Критерій мінімальності** островів: каркас є мінімальним тоді і тільки тоді, коли для будь-якого ребра, що не належить каркасу, цикл, утворений цим ребром при додаванні до каркасу, не містить ребер важчих за це ребро. Насправді, якщо для якогось ребра виявляється, що воно легше за деякі ребра утвореного циклу, то можна отримати каркас з меншою вагою (додавши це ребро до каркасу і видаливши саме найважче ребро з циклу). Якщо ж ця умова не виконується ні для одного ребра, то всі ці ребра не покращують вагу острова при їх додаванні.