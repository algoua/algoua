# Розстановка слонів на шаховій дошці

Потрібно знайти кількість способів розставити $K$ слонів на дошці розміром $N\times N$.

## Алгоритм

Розв'язуватимемо задачу за допомогою **динамічного програмування**.

Нехай **D[i][j]** - кількість способів розставити j слонів на діагоналях до i-ї включно, причому тільки тих діагоналях, які мають той самий колір, що і i-та діагональ. Отже, i = 1..2N-1, j = 0..K.

Діагоналі занумеруємо наступним чином (приклад для дошки 5x5):

$$
чорні: білі:
1 _ 5 _ 9   _ 2 _ 6 _
_ 5 _ 9 _   2 _ 6 _ 8
5 _ 9 _ 7   _ 6 _ 8 _ 
_ 9 _ 7 _   6 _ 8 _ 4
9 _ 7 _ 3   _ 8 _ 4 _
$$

тобто, непарні номери відповідають чорним діагоналям, парні - білим; діагоналі нумеруємо в порядку зростання кількості елементів в них.

При такій нумерації ми можемо обчислити кожне D[i][], грунтуючись тільки на D[i-2][] (двійка віднімається, щоб ми розглядали діагональ того самого кольору).

Отже, нехай поточний елемент динаміки - D[i][j]. Маємо два переходи. Перший - D[i-2][j], тобто ставимо всіх j слонів на попередні діагоналі. Другий перехід - якщо ми ставимо одного слона на поточну діагональ, а інших j-1 слонів - на попередні; зауважимо, що кількість способів поставити слона на поточну діагональ дорівнює кількості клітин в ній мінус j-1. Тобто, коли слони стоять на попередніх діагоналях, деякі напрямки будуть перекриватись. Таким чином, маємо:

$$
D[i][j] = D[i-2][j] + D[i-2][j-1] (cells(i) - j + 1)
$$

де cells[i] - кількість клітин, що знаходяться на i-ій діагоналі. Наприклад, cells можна обчислювати наступним чином:
<!--- TODO: specify code snippet id -->
``` cpp
int cells(int i) {
    if (i & 1)
        return i / 4 * 2 + 1;
    else
        return (i - 1) / 4 * 2 + 2;
}
```
Залишилося визначити базу динаміки, тут немає жодних складнощів: D[i][0] = 1, D[i][1] = 1.

Нарешті, обчисливши динаміку, знайти власне **відповідь** до задачі нескладно. Перебираємо кількість i=0..K слонів, що стоять на чорних діагоналях (номер останньої чорної діагоналі - 2N-1), відповідно K-i слонів ставимо на білих діагоналях (номер останньої білої діагоналі - 2N-2), тобто до відповіді додаємо величину D[2N-1][i] * D[2N-2][K-i].

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
int n, k; // вхідні дані
if (k > 2 * n - 1) {
    cout << 0;
    return 0;
}

vector<vector<int>> d(n * 2, vector<int>(k + 2));
for (int i = 0; i < n * 2; ++i)
    d[i][0] = 1;
d[1][1] = 1;
for (int i = 2; i < n * 2; ++i)
    for (int j = 1; j <= k; ++j)
        d[i][j] = d[i - 2][j] + d[i - 2][j - 1] * (cells(i) - j + 1);

int ans = 0;
for (int i = 0; i <= k; ++i)
    ans += d[n * 2 - 1][i] * d[n * 2 - 2][k - i];
cout << ans;
```