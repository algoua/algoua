# Довжина з'єднання відрізків на прямій за O(N log N)

Дано N відрізків на прямій, тобто кожен відрізок задається парою координат (х1, х2). Розглянемо об'єднання цих відрізків і знайдемо його довжину.

Алгоритм був запропонований Клі (Klee) у 1977 році. Алгоритм працює за O(N log N). Було доведено, що цей алгоритм є найшвидшим (асимптотично).

## Опис

Покладемо всі координати кінців відрізків у масив X і відсортуємо його за значенням координати. Додаткова умова при сортуванні - при рівності координат першими повинні йти ліві кінці. Крім того, для кожного елемента масиву будемо зберігати, до якого кінця відрізка він належить - лівому або правому. Тепер пройдемося по всьому масиву, маючи лічильник C перекриваючихся відрізків. Якщо C відрізняється від нуля, то до результату додаємо різницю X<sub>i</sub> - X<sub>i-1</sub>. Якщо поточний елемент належить до лівого кінця, то збільшуємо лічильник C, інакше зменшуємо його.

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
unsigned segments_union_measure(const vector<pair<int, int>> &a) {
    unsigned n = a.size();
    vector<pair<int, bool>> x(n * 2);
    for (unsigned i = 0; i < n; i++) {
        x[i * 2] = make_pair(a[i].first, false);
        x[i * 2 + 1] = make_pair(a[i].second, true);
    }

    sort(x.begin(), x.end());

    unsigned result = 0;
    unsigned c = 0;
    for (unsigned i = 0; i < n * 2; i++) {
        if (c && i)
            result += unsigned(x[i].first - x[i - 1].first);
        if (x[i].second)
            ++c;
        else
            --c;
    }
    return result;
}
```