# Довга арифметика

Довга арифметика - це набір програмних засобів (структур даних і алгоритмів), які дозволяють працювати з числами набагато більших величин, ніж дозволяють стандартні типи даних.

## Види цілочисельної довгої арифметики

Взагалі кажучи, навіть у олімпіадних завданнях набір засобів досить великий, тому зробимо класифікацію різних видів довгої арифметики.

### Класична довга арифметика

Основна ідея полягає в тому, що число зберігається у вигляді масиву його цифр.

Цифри можуть використовуватися в тій чи іншій системі числення, зазвичай застосовуються десяткова система числення та її степені (десять тисяч, мільярд), або двійкова система числення.

Операції над числами у цьому вигляді довгої арифметики виконуються за допомогою "шкільних" алгоритмів складання, віднімання, множення та ділення стовпчиком. Однак до них також застосовні алгоритми швидкого множення: [Швидке перетворення Фур'є](fft_multiply) та Алгоритм Карацуби.

Тут описано роботу лише з не від'ємними довгими числами. Для підтримки від'ємних чисел необхідно ввести і підтримувати додатковий прапор "від'ємності" числа, або працювати в доповнюючих кодах.

#### Структура даних

Зберігатимемо довгі числа у вигляді вектора чисел $int$, де кожен елемент - це одна цифра числа.

<!--- TODO: specify code snippet id -->
``` cpp
typedef vector<int> lnum;
```

Для підвищення ефективності ми будемо працювати з системою на основі мільярда, тобто кожен елемент вектора $lnum$ міститиме не одну, а одразу $9$ цифр

<!--- TODO: specify code snippet id -->
``` cpp
const int base = 1000 * 1000 * 1000;
```

Цифри будуть зберігатися у векторі в такому порядку, що спочатку йдуть найменш значущі цифри (тобто одиниці, десятки, сотні і т.д.).

Крім того, всі операції будуть реалізовані таким чином, що після виконання будь-якої з них лідируючі нулі (тобто зайві нулі в початку числа) будуть відсутні (звісно, за умови, що перед кожною операцією лідируючі нулі також відсутні). Слід відзначити, що в даній реалізації для числа нуль правильно підтримуються зразу два уявлення: порожній вектор цифр і вектор цифр, що містить єдиний елемент - нуль.

#### Вывод

Найпростіше - це висновок з довгого числа.

Спочатку ми просто виводимо останній елемент вектора (або $0$, якщо вектор порожній), а потім виводимо всі решту елементів вектора, доповнюючи їх нулями до $9$ символів

<!--- TODO: specify code snippet id -->
``` cpp
printf("%d", a.empty() ? 0 : a.back());
for (int i = (int)a.size() - 2; i >= 0; --i)
    printf("	d", a[i]);
```

(Тут є декілька граматичних та стилістичних помилок, які можна виправити наступним чином:)

Отже, є невеликий тонкий момент: необхідно не забувати про приведення типу $(int)$, оскільки в іншому випадку число $a.size()$ буде беззнаковим, і якщо $a.size() \le 1$, то при відніманні відбудеться переповнення

#### Чтение

Зчитуємо рядок у $string$, а потім перетворюємо його у вектор:

<!--- TODO: specify code snippet id -->
``` cpp
for (int i = (int)s.length(); i > 0; i -= 9)
    if (i < 9)
        a.push_back(atoi(s.substr(0, i).c_str()));
    else
        a.push_back(atoi(s.substr(i - 9, 9).c_str()));
```

Якщо використати замість $string$ масив $char$'ів, то код буде ще компактнішим

<!--- TODO: specify code snippet id -->
``` cpp
for (int i = (int)strlen(s); i > 0; i -= 9) {
    s[i] = 0;
    a.push_back(atoi(i >= 9 ? s + i - 9 : s));
}
```

Якщо у вхідному числі можуть бути ведучі нулі, то їх можна вилучити після зчитування таким чином:

<!--- TODO: specify code snippet id -->
``` cpp
while (a.size() > 1 && a.back() == 0)
    a.pop_back();
```

#### Сложение

Додає до числа $a$ число $b$ і зберігає результат у змінну $a$

<!--- TODO: specify code snippet id -->
``` cpp
int carry = 0;
for (size_t i = 0; i < max(a.size(), b.size()) || carry; ++i) {
    if (i == a.size())
        a.push_back(0);
    a[i] += carry + (i < b.size() ? b[i] : 0);
    carry = a[i] >= base;
    if (carry)
        a[i] -= base;
}
```

#### Вычитание

Віднімаємо від числа $a$ число $b$ ($a \ge b$) і зберігаємо результат у $a$:

<!--- TODO: specify code snippet id -->
``` cpp
int carry = 0;
for (size_t i=0; i<b.size() || carry; ++i) {
    a[i] -= carry + (i < b.size() ? b[i] : 0);
    carry = a[i] < 0;
    if (carry)  a[i] += base;
}
while (a.size() > 1 && a.back() == 0)
    a.pop_back();
```

Тут після виконання обчислення видаляємо ведучі нулі, щоб підтримувати твердження про те, що їх немає.

#### Множення короткого на довге

Помножити довге $a$ на коротке $b$ ($b < {\rm base}$) і зберегти результат в $a$:

<!--- TODO: specify code snippet id -->
``` cpp
int carry = 0;
for (size_t i=0; i<a.size() || carry; ++i) {
    if (i == a.size())
        a.push_back (0);
    long long cur = carry + a[i] * 1ll * b;
    a[i] = int (cur % base);
    carry = int (cur / base);
}
while (a.size() > 1 && a.back() == 0)
    a.pop_back();
```

Тут після виконання ділення видаляються провідні нулі, щоб підтвердити твердження про їх відсутність.

(Зауваження: спосіб **додаткової оптимізації**. Якщо швидкість роботи надзвичайно важлива, то можна спробувати замінити два ділення одним: порахувати тільки цілу частину від ділення (в коді це змінна $carry$), а потім вже порахувати залишок від ділення (з допомогою однієї операції множення). Як правило, цей прийом дозволяє прискорити код, хоча і не дуже значно).

#### Множення двох довгих чисел

Помножувую $a$ на $b$ і результат зберігаю в $c$:

<!--- TODO: specify code snippet id -->
``` cpp
lnum c(a.size() + b.size());
for (size_t i = 0; i < a.size(); ++i)
    for (int j = 0, carry = 0; j < (int)b.size() || carry; ++j) {
        long long cur = c[i + j] + a[i] * 1ll * (j < (int)b.size() ? b[j] : 0) + carry;
        c[i + j] = int(cur % base);
        carry = int(cur / base);
    }
while (c.size() > 1 && c.back() == 0)
    c.pop_back();
```

#### Ділення довгого на короткий

Ділимо довге $a$ на коротке $b$ ($b < {\rm base}$). Частку зберігаємо в $a$, а залишок - в $carry$:

<!--- TODO: specify code snippet id -->
``` cpp
int carry = 0;
for (int i=(int)a.size()-1; i>=0; --i) {
    long long cur = a[i] + carry * 1ll * base;
    a[i] = int (cur / b);
    carry = int (cur % b);
}
while (a.size() > 1 && a.back() == 0)
    a.pop_back();
```

### Довга арифметика у факторизованому вигляді

Тут ідея полягає у збереженні не самого числа, а його факторизації, тобто ступенів кожного простого числа, що входить до нього.

Цей метод також дуже простий для реалізації, і в ньому дуже легко виконувати операції множення і ділення, проте неможливо виконати операції додавання або віднімання. З іншого боку, цей метод значно економить пам'ять порівняно з "класичним" підходом, і дозволяє виконувати множення і ділення значно (асимптотично) швидше.

Цей метод часто застосовується, коли потрібно виконувати ділення за складним модулем: тоді достатньо зберігати число у вигляді степенів за простими дільниками цього модуля, і ще одного числа - залишку від ділення на цей же модуль.

### Довга арифметика за системою простих модулів (Китайська теорема або схема Гарнера)

Суть полягає в тому, що обирається певна система модулів (зазвичай невеликих, що вміщуються в стандартні типи даних), і число зберігається у вигляді вектора з залишків від його ділення на кожен з цих модулів.

Як стверджує Китайська теорема про залишки, цього достатньо, щоб однозначно зберігати будь-яке число в діапазоні від 0 до добутку цих модулів мінус один. При цьому є [алгоритм Гарнера](https://uk.wikipedia.org/wiki/Алгоритм_Гарнера), який дозволяє провести це відновлення з модульного уявлення в звичайне, "класичне", формування числа.

Таким чином, цей метод дозволяє економити пам'ять порівняно з "класичною" довгою арифметикою (хоча в деяких випадках не настільки радикально, як метод факторизації). Крім того, у модульному вигляді можна дуже швидко виконувати додавання, віднімання і множення - всі вони мають асимптотично однаковий час, пропорційний кількості модулів системи.

Однак все це коштує вельми складного перекладу числа з цього модульного вигляду в звичайний вигляд, для чого, крім немалої витрати часу, також буде потрібна реалізація "класичної" довгої арифметики з множенням.

Крім того, виконання ділення чисел у такому поданні за системою простих модулів не є можливим.

## Виды дробової довгою арифметики

Операції над дробовими числами зустрічаються в олімпійських завданнях набагато рідше, а працювати з великими дробовими числами значно складніше. Тому в олімпіадах зустрічається лише специфічне підмножина дробової довгої арифметики.

### Довга арифметика в незвичайних дробах

Число представляється у вигляді неперервної дроби $\frac{a}{b}$, де $a$ і $b$ - цілі числа. Отже, всі операції над дробовими числами можна звести до операцій над чисельниками та знаменниками цих дробів.

Зазвичай для збереження чисельника і знаменника доводиться використовувати довгу арифметику. Найпростіший її варіант - "класична" довга арифметика, але іноді можна обійтися вбудованим 64-бітним числовим типом.

### Виділення позиції плаваючою точкою в окремий тип

Іноді в задачах потрібно проводити розрахунки з дуже великими або дуже малими числами, але при цьому не допускати їх переповнення. Вбудований $8-байтовий$ тип $double$, як відомо, допускає значення експоненти в діапазоні $[-308; 308]$, що іноді може виявитися недостатнім.

Прийом, власне, дуже простий - вводиться ще одна цілочисленна змінна, що відповідає за експоненту, а після виконання кожної операції дробове число "нормалізується", тобто повертається до відрізку $[0{,}1; 1)$, шляхом збільшення або зменшення експоненти.

При множенні або діленні двох таких чисел потрібно відповідно додати або відняти їх експоненти. При додаванні або відніманні перед виконанням цих операцій числа потрібно привести до однієї експоненти, для чого одне з них потрібно помножити на $10$ в степені різниці експонент.

Нарешті, зрозуміло, що не обов'язково вибирати $10$ як основу експоненти. Виходячи з устрою вбудованих типів з плаваючою точкою, найбільш вигідним є використовувати основу, рівну $2$.