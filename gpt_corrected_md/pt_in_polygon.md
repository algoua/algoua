# Перевірка точки на належність до выпуклого багатокутника

Даний опуклий багатокутник з N вершинами, координати всіх вершин цілочисельні (хоча це не змінює суті розв'язку); вершини задані в порядку обходу проти годинникової стрілки (в іншому випадку потрібно просто відсортувати їх). Надходять запити - точки, і потрібно для кожної точки визначити, чи лежить вона всередині цього багатокутника, чи ні (межі багатокутника включаються). На кожний запит будемо відповідати в режимі онлайн за O(log N). Попередня обробка багатокутника буде виконуватися за O(N).

## Алгоритм

Розв'язуватимемо **бінарним пошуком за допомогою розі**.

Один з варіантів розв'язку полягає в наступному. Обираємо точку з найменшою координатою X (якщо таких декілька, то обираємо саму нижню, тобто з найменшим Y). Відносно цієї точки, позначимо її нулем, всі інші вершини багатокутника лежать в правій півплощині. Далі, зауважимо, що всі вершини багатокутника вже впорядковані за розташуванням відносно точки нуль (це випливає з того, що багатокутник опуклий, і вже впорядкований проти годинникової стрілки), причому всі кути знаходяться в проміжку (-&pi;/2; &pi;/2].

Нехай поступает черговий запит - деяка точка P. Розглянемо її полярний кут щодо точки Zero. Знайдемо бінарним пошуком дві такі сусідні вершини L і R багатокутника, що полярний кут P лежить між полярными углами L і R. Тим самим ми знайшли той сектор багатокутника, в якому лежить точка P, і нам залишається тільки перевірити, лежить або точка P в треугольнике (Zero,L,R). Це можна зробити, наприклад, з допомогою [Ориентированной площі трикутника і Предиката "За годинний стрілкою"](oriented_area), достатньо подивитися, по годинний стрілкою або проти знаходиться трійка вершин (R,L,P).

Таким чином, ми за O(log N) знаходимо сектор багатокутника, а потім за O(1) перевіряємо належність точки трикутнику, і, отже, досягнена необхідна асимптотика. Попередня обробка багатокутника полягає тільки в тому, щоб попередньо обчислити полярні кути для всіх точок. Проте ці обчислення також можна перенести на етап бінарного пошуку.

## Зауваження щодо реалізації

Щоб визначити полярний кут, можна скористатися стандартною функцією atan2. Таким чином, ми отримаємо дуже короткий і простий розв'язок, однак можуть виникнути проблеми з точністю.

Враховуючи, що спочатку всі координати є цілими числами, можна отримати розв'язок, який взагалі не використовує дробову арифметику.

Зауважимо, що полярний кут точки (X,Y) щодо початку координат однозначно визначається дробом Y/X, за умови, що точка знаходиться в правій півплощині. Крім того, якщо у однієї точки полярний кут менший, ніж у іншої, то і дріб Y1/X1 буде менший за Y2/X2, і навпаки.

Таким чином, для порівняння полярних кутів двох точок нам достатньо порівняти дроби Y1/X1 та Y2/X2, що можна виконати в цілочисельній арифметиці.

## Реалізація

Ця реалізація передбачає, що в даному багатокутнику немає повторюваних вершин, а також площа багатокутника є ненульовою.

<!--- TODO: specify code snippet id -->
``` cpp
struct pt {
    int x, y;
};

struct ang {
    int a, b;
};

bool operator<(const ang &p, const ang &q) {
    if (p.b == 0 && q.b == 0)
        return p.a < q.a;
    return p.a * 1ll * q.b < p.b * 1ll * q.a;
}

long long sq(pt &a, pt &b, pt &c) { return a.x * 1ll * (b.y - c.y) + b.x * 1ll * (c.y - a.y) + c.x * 1ll * (a.y - b.y); }

int main() {
    int n;
    cin >> n;
    vector<pt> p(n);
    int zero_id = 0;
    for (int i = 0; i < n; ++i) {
        scanf("%d%d", &p[i].x, &p[i].y);
        if (p[i].x < p[zero_id].x || p[i].x == p[zero_id].x && p[i].y < p[zero_id].y)
            zero_id = i;
    }
    pt zero = p[zero_id];
    rotate(p.begin(), p.begin() + zero_id, p.end());
    p.erase(p.begin());
    --n;

    vector<ang> a(n);
    for (int i = 0; i < n; ++i) {
        a[i].a = p[i].y - zero.y;
        a[i].b = p[i].x - zero.x;
        if (a[i].a == 0)
            a[i].b = a[i].b < 0 ? -1 : 1;
    }

    for (;;) {
pt q; // черговий запит
        bool in = false;
        if (q.x >= zero.x)
            if (q.x == zero.x && q.y == zero.y)
                in = true;
            else {
                ang my = {q.y - zero.y, q.x - zero.x};
                if (my.a == 0)
                    my.b = my.b < 0 ? -1 : 1;
                vector<ang>::iterator it = upper_bound(a.begin(), a.end(), my);
                if (it == a.end() && my.a == a[n - 1].a && my.b == a[n - 1].b)
                    it = a.end() - 1;
                if (it != a.end() && it != a.begin()) {
                    int p1 = int(it - a.begin());
                    if (sq(p[p1], p[p1 - 1], q) <= 0)
                        in = true;
                }
            }
        puts(in ? "INSIDE" : "OUTSIDE");
    }
}
```