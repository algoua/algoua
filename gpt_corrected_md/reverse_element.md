# Обернений елемент в кільці за модулем

## Визначення

Нехай задано деякий натуральний модуль $m$, і розглянемо кільце, утворене за допомогою цього модуля (тобто чисел від $0$ до $m-1$). Тоді для деяких елементів цього кільця можна знайти **обернений елемент**.

Оберненим до числа $a$ за модулем $m$ називається таке число $b$, що:

$$
a \cdot b \equiv 1 \pmod m,
$$

його часто позначають як $a^{-1}$.

Зрозуміло, що для нуля зворотнього елементу не існує ніколи. Для інших елементів зворотний елемент може існувати або не існувати. Стверджується, що зворотний елемент існує тільки для тих елементів $a$, які є **взаємно простими** з модулем $m$.

Розглянемо нижче два способи знаходження оберненого елементу, які працюють за умови, що він існує.

В заключення, розглянемо алгоритм, який дозволяє знайти обернені до всіх чисел за деяким модулем за лінійний час.

## Знаходження за допомогою Розширеного алгоритму Євкліда

Розглянемо допоміжне рівняння (щодо невідомих $x$ і $y$):

$$
a \cdot x + m \cdot y = 1.
$$

Це [лінійне діофантове рівняння іншого порядку](diofant_2_equation). Як показано в відповідній статті, з умови ${\rm НСД}(a,m)=1$ випливає, що це рівняння має розв'язок, який можна знайти з допомогою [Розширеного алгоритму Євкліда](extended_euclid_algorithm) (звідси ж, до речі кажучи, випливає, що коли ${\rm НСД}(a,m) \ne 1$, розв'язку, а отже і зворотного елементу, не існує).

З іншої сторони, якщо ми візьмемо залишок від ділення обох частин рівняння на $m$, то отримаємо:

$$
a \cdot x = 1 \pmod m.
$$

Таким чином, знайдене $x$ буде зворотним до $a$.

Реалізація (з урахуванням того, що знайдене $x$ потрібно взяти за модулем $m$, а $x$ міг бути від'ємним):

<!--- TODO: specify code snippet id -->
``` cpp
int x, y;
int g = gcdex(a, m, x, y);
if (g != 1)
    cout << "no solution";
else {
    x = (x % m + m) % m;
    cout << x;
}
```

Асимптотика цього розв'язку складає $O(\log m)$.

## Знаходження за допомогою Бінарного піднесення до степеня

Скористаємося теоремою Ейлера:

$$
a ^ {\phi(m)} \equiv 1 \pmod m,
$$

яка вірна як раз для випадку взаємно простих $a$ і $m$.

До речі кажучи, у випадку простого модуля $m$ ми отримуємо ще більш просте твердження - малу теорему Ферма

$$
a^{m-1} \equiv 1 \pmod m.
$$

Помножимо обидві частини кожного з рівнянь на $a^{-1}$, отримаємо:

* Для будь-якого модуля $m$:

$$
a^{\phi(m)-1} \equiv a^{-1} \pmod m,
$$

* Для простого модуля $m$:

$$
a^{m-2} \equiv a^{-1} \pmod m.
$$

Таким чином, ми отримали формули для безпосереднього обчислення оберненої величини. Для практичного застосування зазвичай використовують ефективний [алгоритм бінарного піднесення до степеня](binary_pow), який в нашому випадку дозволить провести піднесення до степеня за $O(\log m)$.

Цей метод є дещо простішим у порівнянні з описаним у попередньому пункті, проте для його застосування потрібно знати значення функції Ейлера, що на практиці може виявитися досить складним завданням через необхідність факторизації модуля $m$.

Якщо факторизація числа відома, то цей метод також працює з асимптотикою $O(\log m)$.

## Знаходження всіх простих чисел за заданим модулем за лінійний час

Нехай дано простий модуль $m$. Потрібно для кожного числа в діапазоні $[1, m-1]$ знайти його обернене за модулем $m$.

Застосовуючи описані вище алгоритми, ми отримаємо лише розв'язок з асимптотикою $O(m \log m)$. Тут ми наведемо простий розв'язок з асимптотикою $O(m)$.

**Розв'язок** виглядає наступним чином. Позначимо через $r[i]$ шукане обернене до числа $i$ за модулем $m$. Отже, для $i > 1$ справедлива тотожність:

$$
r[i] = - \left\lfloor \frac{m}{i} \right\rfloor \cdot r[m {\rm~mod~} i]. \pmod m
$$

Реалізація цього дивовижно лаконічного розв'язку:

<!--- TODO: specify code snippet id -->
``` cpp
r[1] = 1;
for (int i = 2; i < m; ++i)
    r[i] = (m - (m / i) * r[m % i] % m) % m;
```

Доведення цього розв'язку представляє собою ланцюжок простих перетворень:

Розпишемо значення $m {\rm~mod~} i$:

$$
m {\rm~mod~} i = m - \left\lfloor \frac{m}{i} \right\rfloor \cdot i,
$$

звідки, беручи обидві частини за модулем $m$, отримуємо:

$$
m {\rm~mod~} i = - \left\lfloor \frac{m}{i} \right\rfloor \cdot i. \pmod m
$$

Помноживши обидві частини на зворотній до $i$ та зворотній до $(m {\rm~mod~} i)$, отримуємо шукану формулу:

$$
r[i] = - \left\lfloor \frac{m}{i} \right\rfloor \cdot r[m {\rm~mod~} i], \pmod m
$$

що потрібно довести?