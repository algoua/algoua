# Правильні дужкові послідовності

Правильною дужковою послідовністю називається рядок, що складається лише з символів "дужки" (зазвичай розглядаються тільки круглі дужки, але тут буде розглянуто загальний випадок декількох типів дужок), де кожній закриваючій дужці відповідає відповідна відкриваюча дужка (причому того ж типу).

Тут ми розглянемо класичні задачі на правильні дужкові послідовності (далі для стислості просто "послідовності"): перевірка на правильність, кількість послідовностей, генерація всіх послідовностей, знаходження лексикографічно наступної послідовності, знаходження $k$-ої послідовності в відсортованому списку всіх послідовностей, і, навпаки, визначення номера послідовності. Кожна з задач розглянута в двох випадках - коли дозволені дужки тільки одного типу, і коли дозволені дужки декількох типів.

## Перевірка на правильність

Нехай спочатку дозволені дужки лише одного типу, тоді перевірити послідовність на правильність можна дуже простим алгоритмом. Нехай $\mathrm{depth}$ - це поточний кількість відкритих дужок. Спочатку $\mathrm{depth} = 0$. Будемо рухатися по рядку ліворуч направо, якщо поточна дужка відкриває, то збільшимо $\mathrm{depth}$ на одиницю, інакше зменшимо. Якщо при цьому коли-небудь виходило від'ємне число, або в наприкінці роботи алгоритму $\mathrm{depth}$ відрізняється від нуля, то дано рядок не є правильною дужковою послідовністю, інакше є.

Якщо допустимі дужки декількох типів, то алгоритм потрібно змінити. Замість лічильника $\rm depth$ слід створити стек, в який будемо класти відкриваючі дужки по мірі надходження. Якщо поточний символ рядка - відкриваюча дужка, то кладемо її в стек, а якщо закриваюча - перевіряємо, що стек не порожній, і що на його вершині лежить дужка того ж типу, що й поточна, і потім видаляємо цю дужку зі стеку. Якщо якась з умов не виконалася, або в кінці роботи алгоритму стек залишився непорожнім, то послідовність не є правильною дужковою, інакше є.

Таким чином, обидві ці задачі ми навчилися розв'язувати за час $O(n)$.

## Кількість послідовностей

### Формула

Кількість правильних дужкових послідовностей з одним типом дужок можна обчислити як [число Каталана](https://uk.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%B0_%D0%9A%D0%B0%D1%82%D0%B0%D0%BB%D0%B0%D0%BD%D0%B0). Тобто, якщо є $n$ пар дужок (рядок довжини $2n$), то кількість буде рівна:

$$
\frac{1}{n+1} \cdot C^n_{2n}.
$$

Нехай тепер є не один, а $k$ типів дужок. Отже, кожну пару дужок можна незалежно від інших приймати один з $k$ типів. Таким чином, ми отримуємо таку формулу:

$$
\frac{1}{n+1} \cdot C^n_{2n} \cdot k^n.
$$

### Динамічне програмування

З іншого боку, до цієї задачі можна підійти із точки зору **динамічного програмування**. Нехай $d[n]$ - кількість правильних дужкових послідовностей з $n$ пар дужок. Зауважимо, що в першій позиції завжди буде стояти відкриваюча дужка. Зрозуміло, що всередині цієї пари дужок варто розмістити правильну скобочну послідовність; аналогічно, після цієї пари дужок також варто розмістити правильну скобочну послідовність. Тепер, щоб порахувати $d[n]$, переберемо, скільки пар дужок $i$ буде стояти всередині цієї першої пари, тоді, відповідно, $n-1-i$ пар дужок буде стояти після цієї першої пари. Отже, формула для $d[n]$ має вигляд:

$$
d[n] = \sum_{i=0}^{n-1} d[i] \cdot d[n-1-i].
$$

Початкове значення для цієї рекурентної формули - $d[0] = 1$.

## Знаходження всіх послідовностей

Іноді потрібно знайти та вивести всі правильні дужкові послідовності заданої довжини $n$ (у даному випадку $n$ - це довжина рядка).

Для цього можна почати з лексикографічно першої послідовності $((\ldots(())\ldots))$, а потім знаходити кожного разу лексикографічно наступну послідовність за допомогою алгоритму, описаного в наступному розділі.

Але якщо обмеження не дуже великі ($n$ до $10-12$), то можна використати більш простий підхід. Знайдемо всі можливі перестановки дужок (для цього зручно використовувати функцію std::next_permutation()), їх буде $C_{2n}^n$, і кожну перевіримо на правильність за вищеописаним алгоритмом. У випадку правильної послідовності виведемо її.

Також процес знаходження всіх послідовностей можна оформити у вигляді рекурсивного перебору з відсіченнями (що в ідеалі можна довести за швидкістю роботи порівняно з першим алгоритмом).

## Знаходження наступного елемента послідовності

Тут розглядається лише випадок одного типу дужок.

За заданої правильної дужкової послідовності потрібно знайти наступну правильну дужкову послідовність в лексикографічному порядку (або видати "No solution", якщо такої не існує).

Зрозуміло, що в цілому алгоритм виглядає наступним чином: знаходимо таку ж праву відкриваючу дужку, яку маємо право замінити на закриваючу (так, щоб правильність не порушувалась), а всю решту праворуч від цієї дужки замінюємо на лексикографічно мінімальну послідовність: тобто спочатку додаємо стільки ж відкриваючих дужок, а потім додаємо всі залишився закриваючі дужки. Іншими словами, ми намагаємося залишити якомога довший префікс вихідної послідовності без змін, а решту послідовності замінюємо на лексикографічно мінімальну.

Залишилося навчитися шукати цю саму позицію першої зміни. Для цього будемо йти по рядках справа наліво і підтримувати баланс $\rm depth$ відкритих і закритих дужок (при зустрічі відкривається дужка, будемо зменшувати $\rm depth$, а при закритті - збільшувати). Якщо в якийсь момент ми стоїмо на відкритій дужці, а баланс після обробки цього символу більше нуля, то ми знайшли саму праву позицію, від якої ми можемо почати змінювати послідовність (насправді, $\rm depth > 0$ означає, що ліворуч є ще незакрита дужка). Поставимо в поточну позицію закривну дужку, потім максимально можливу кількість відкриваючих дужок, а потім всі залишившіся закривні дужки - відповідь знайдена.

Якщо ми проглянули усю рядок і так і не знайшли підходящу позицію, то поточна послідовність є максимальною, і відповіді не існує.

Реалізація алгоритму:

<!--- TODO: specify code snippet id -->
``` cpp
string s;
cin >> s;
int n = (int)s.length();
string ans = "No solution";
for (int i = n - 1, depth = 0; i >= 0; --i) {
    if (s[i] == '(')
        --depth;
    else
        ++depth;
    if (s[i] == '(' && depth > 0) {
        --depth;
        int open = (n - i - 1 - depth) / 2;
        int close = n - i - 1 - open;
        ans = s.substr(0, i) + ')' + string(open, '(') + string(close, ')');
        break;
    }
}
cout << ans;
```

Таким чином, ми вирішили цю задачу за $O(n)$.

## Номер послідовності

Тут нехай $n$ є кількістю пар дужок у послідовності. Потрібно для заданої правильної дужкової послідовності знайти її номер у списку лексикографічно впорядкованих правильних дужкових послідовностей.

Навчимося враховувати допоміжну **динаміку** $d[i][j]$, де $i$ - довжина дужкової послідовності (вона "полуправильна": кожна закриваюча дужка має парну відкриваючу дужку, але не всі відкриваючі дужки мають закриваючі), $j$ - баланс (тобто різницю між кількістю відкриваючих і закриваючих дужок), $d[i][j]$ - кількість таких послідовностей. При підрахунку цієї динаміки ми припускаємо, що дужки можуть бути тільки одного типу.

Вважаючи цю динаміку можна наступним чином. Нехай $d[i][j]$ - величина, яку ми хочемо порахувати. Якщо $i=0$, то відповідь зрозуміла зразу: $d[0][0] = 1$, всі інші $d[0][j] = 0$. Нехай тепер $i > 0$. Тоді подумки переберемо, чему був рівний останній символ у цій послідовності. Якщо він був дорівнює '(', то до цього символу ми знаходилися в стані $(i-1,j-1)$. Якщо він був дорівнює ')', то попереднім був стан $(i-1,j+1)$. Таким чином, отримуємо формулу:

$$
d[i][j] = d[i-1][j-1] + d[i-1][j+1]
$$

(Вважається, що всі значення $d[i][j]$, де $j<0$, дорівнюють нулю). Таким чином, цю динаміку ми можемо порахувати за $O(n^2)$.

Перейдемо тепер до розв'язання самої задачі.

Спочатку допустимі лише дужки **одного** типу. Заведемо лічильник глибини вкладеності в дужки $\rm depth$, і будемо рухатися по послідовності зліва направо. Якщо поточний символ $s[i]$ ($i=0 \ldots 2n-1$) дорівнює '(', то ми збільшуємо $\rm depth$ на 1 і переходимо до наступного символу. Якщо ж поточний символ дорівнює ')', то ми повинні додати до відповіді $d[2n-i-1][\rm depth+1]$, тим самим враховуючи, що в цій позиції міг би стояти символ '(' (який би привів до лексикографічно меншої послідовності, ніж поточна); потім ми зменшуємо $\rm depth$ на одиниц

Нехай тепер дозволені дужки кількох $k$ типів. Значить, при розгляді поточного символу $s[i]$ перед перерахунком $\rm depth$ ми повинні перебирати всі дужки, які менше поточного символу, спробувати поставити цю дужку в поточну позицію (отримуючи тим самим новий баланс $\rm ndepth = \rm depth \pm 1$), і додати до відповіді кількість відповідних "хвостів" - закритих (які мають довжину $2n-i-1$, баланс $\rm ndepth$ і $k$ типів дужок). Стверджується, що формула для цього кількості має вигляд:

$$
d[2n-i-1][{\rm ndepth}] \cdot k^{ (2n-i-1 - {\rm ndepth})/2 }.
$$

Ця формула виводиться з таких міркувань. Спочатку ми "забуваємо", що дужки бувають декількох типів, і просто беремо відповідь з $d[2n-i-1][{\rm ndepth}]$. Тепер порахуємо, як зміниться відповідь через наявність $k$ типів дужок. У нас є $2n-i-1$ невизначених позицій, з яких $\rm ndepth$ є дужками, що закривають деякі з відкритих раніше, - отже, тип таких дужок ми не можемо змінювати. А ось всі інші дужки (а їх буде $(2n-i-1 - {\rm ndepth})/2$ пар) можуть бути будь-якого з $k$ типів, тому відповідь множиться на цю ступінь числа $k$.

## Знаходження $k$-ої послідовності

Тут нехай $n$ є кількістю пар дужок у послідовності. У даній задачі за заданим $k$ потрібно знайти $k$-ту правильну дужкову послідовність у списку лексикографічно впорядкованих послідовностей.

Як і в попередньому розділі, порахуємо **динаміку** $d[i][j]$ - кількість правильних дужкових послідовностей довжини $i$ з рівновагою $j$.

Нехай спочатку допустимі тільки дужки *одного* типу.

Будемо рухатися по символах шуканої рядка від $0$-го до $2n-1$-го. Як і в попередній задачі, будемо зберігати лічильник $\rm depth$ - поточну глибину вкладеності в дужки. На кожній поточній позиції будемо перебирати можливі символи - відкриваючу дужку або закриваючу. Нехай ми хочемо поставити тут відкриваючу дужку, тоді ми повинні подивитися на значення $d[i+1][\rm depth+1]$. Якщо воно $\ge k$, то ми ставимо в поточну позицію відкриваючу дужку, збільшуємо $\rm depth$ на одиницю і переходимо до наступного символу. Інакше ми віднімаємо від $k$ значення $d[i+1][\rm depth+1]$, ставимо закриваючу дужку і зменшуємо значення $\rm depth$. В кінці ми отримаємо шукану послідовність дужок.

Реалізація на мові Java з використанням довгої арифметики:

<!--- TODO: specify code snippet id -->
``` cpp
int n;
BigInteger k; // вхідні дані

BigInteger d[][] = new BigInteger[n * 2 + 1][n + 1];
for (int i = 0; i <= n * 2; ++i)
    for (int j = 0; j <= n; ++j)
        d[i][j] = BigInteger.ZERO;
d[0][0] = BigInteger.ONE;
for (int i = 0; i < n * 2; ++i)
    for (int j = 0; j <= n; ++j) {
        if (j + 1 <= n)
            d[i + 1][j + 1] = d[i + 1][j + 1].add(d[i][j]);
        if (j > 0)
            d[i + 1][j - 1] = d[i + 1][j - 1].add(d[i][j]);
    }

String ans = new String();
if (k.compareTo(d[n * 2][0]) > 0)
    ans = "No solution";
else {
    int depth = 0;
    for (int i = n * 2 - 1; i >= 0; --i)
        if (depth + 1 <= n && d[i][depth + 1].compareTo(k) >= 0) {
            ans += '(';
            ++depth;
        } else {
            ans += ')';
            if (depth + 1 <= n)
                k = k.subtract(d[i][depth + 1]);
            --depth;
        }
}
```

Нехай тепер дозволено не один, а **$k$ типів** дужок. Отже, алгоритм розв'язку буде відрізнятися від попереднього випадку тільки тим, що ми повинні домножити значення $D[i+1][\rm ndepth]$ на величину $k^{(2n-i-1- \rm ndepth)/2}$, щоб врахувати, що в цьому залишку можуть бути дужки різних типів, а парних дужок в цьому залишку буде тільки $2n-i-1- \rm ndepth$, оскільки $\rm ndepth$ дужок є закриваючими для відкриваючих дужок, що знаходяться поза цим залишком (а тому ми не можемо змінювати їх типи).

Реалізація на мові Java для випадку двох типів дужок - круглих і квадратних:

<!--- TODO: specify code snippet id -->
``` cpp
int n;
BigInteger k; // вхідні дані

BigInteger d[][] = new BigInteger[n * 2 + 1][n + 1];
for (int i = 0; i <= n * 2; ++i)
    for (int j = 0; j <= n; ++j)
        d[i][j] = BigInteger.ZERO;
d[0][0] = BigInteger.ONE;
for (int i = 0; i < n * 2; ++i)
    for (int j = 0; j <= n; ++j) {
        if (j + 1 <= n)
            d[i + 1][j + 1] = d[i + 1][j + 1].add(d[i][j]);
        if (j > 0)
            d[i + 1][j - 1] = d[i + 1][j - 1].add(d[i][j]);
    }

String ans = new String();
int depth = 0;
char[] stack = new char[n * 2];
int stacksz = 0;
for (int i = n * 2 - 1; i >= 0; --i) {
    BigInteger cur;
    // '('
    if (depth + 1 <= n)
        cur = d[i][depth + 1].shiftLeft((i - depth - 1) / 2);
    else
        cur = BigInteger.ZERO;
    if (cur.compareTo(k) >= 0) {
        ans += '(';
        stack[stacksz++] = '(';
        ++depth;
        continue;
    }
    k = k.subtract(cur);
    // ')'
    if (stacksz > 0 && stack[stacksz - 1] == '(' && depth - 1 >= 0)
        cur = d[i][depth - 1].shiftLeft((i - depth + 1) / 2);
    else
        cur = BigInteger.ZERO;
    if (cur.compareTo(k) >= 0) {
        ans += ')';
        --stacksz;
        --depth;
        continue;
    }
    k = k.subtract(cur);
    // '['
    if (depth + 1 <= n)
        cur = d[i][depth + 1].shiftLeft((i - depth - 1) / 2);
    else
        cur = BigInteger.ZERO;
    if (cur.compareTo(k) >= 0) {
        ans += '[';
        stack[stacksz++] = '[';
        ++depth;
        continue;
    }
    k = k.subtract(cur);
    // ']'
    ans += ']';
    --stacksz;
    --depth;
}
```