# Знаходження мінімального розрізу. Алгоритм Штейнера-Вагнера

## Постановка завдання

Даний неорієнтований зважений граф $G$ з $n$ вершинами та $m$ ребрами. Розрізом $C$ є деяке підмножина вершин (фактично, розріз - розбиття вершин на дві множини: належать $C$ та всі інші). Вагою розрізу є сума ваг ребер, що проходять через розріз, тобто ребер, в яких один кінець належить $C$

$$
w(C) = \sum_{(v,u) \in E, \atop u \in C, v \not\in C} c(v,u),
$$

де через $E$ позначено множину всіх ребер графа $G$, а через $c(v,u)$ - вагу ребра $(v,u)$.

Потрібно знайти **мінімальний розріз ваги**.

Іноді цю задачу називають "глобальним мінімальним розрізом" - на відміну від завдання, коли задані вершини-стік і джерело, і потрібно знайти мінімальний розріз $C$, який містить стік і не містить джерела. Глобальний мінімальний розріз дорівнює мінімуму серед усіх розрізів мінімальної вартості для всіх пар джерело-стік.

Хоча цю задачу можна вирішити за допомогою алгоритму знаходження максимального потоку (запустивши його $O(n^2)$ разів для всіх пар джерела і стоку), проте нижче описаний набагато простіший і швидший алгоритм, запропонований Матильдою Штор (Mechthild Stoer) і Франком Вагнером (Frank Wagner) у 1994 році.

Взагалі-то допускаються петлі та кратні ребра, проте очевидно, що петлі абсолютно не впливають на результат, а всі кратні ребра можна замінити одним ребром з їх сумарною вагою. Тому для спрощення ми будемо вважати, що вхідний граф не містить петель та кратних ребер.

## Опис алгоритму

**Базова ідея** алгоритму дуже проста. Будемо ітеративно повторювати наступний процес: знаходити мінімальний розріз між якою-небудь парою вершин $s$ і $t$, а потім об'єднувати ці дві вершини в одну (з'єднуючи списки суміжності). У кінці кінців, після $n-1$ ітерацій, граф стиснеться в єдину вершину і процес зупиниться. Після цього відповіддю буде мінімальний серед усіх $n-1$ знайдених розрізів. Дійсно, на кожній $i$-ій стадії знайдений мінімальний розріз $C_i$ між вершинами $s_i$ і $t_i$ або виявиться шуканим глобальним мінімальним розрізом, або ж, навпаки, вершини $s_i$ і $t_i$ не вигідно відносити до різних безлічей, тому ми нічого не погіршуємо, об'єднуючи ці дві вершини в одну.

Таким чином, ми зводимо задачу до наступного: для даного графа знайти **мінімальний розріз між будь-якою парою вершин** $s$ і $t$. Для розв'язку цієї задачі був запропонований наступний ітеративний процес. Вводиться деяка множина вершин $A$, яка спочатку містить єдину довільну вершину. На кожному кроці знаходиться вершина, **найбільш сильно зв'язана** з множиною $A$, тобто вершина $v \not\in A$, для якої наступна величина максимальна:

$$
w(v,A) = \sum_{(v,u) \in E, \atop u \in A} c(v,u)
$$

Тобто максимальна сума ваг ребер, один кінець яких $v$, а інший належить $A$.

Знову ж, цей процес завершиться після $n-1$ ітерацій, коли всі вершини перейдуть у множину $A$ (до речі, цей процес дуже нагадує [алгоритм Пріма](mst_prim)). Значить, як стверджує **теорема Штор-Вагнера**, якщо ми позначимо через $s$ і $t$ останні дві додані до $A$ вершини, то мінімальний розріз між вершинами $s$ і $t$ буде складатися з однієї вершини - $t$. Доведення цієї теореми буде наведено в наступному розділі (як це часто буває, саме по собі воно ніяк не сприяє розумінню алгоритму).

Таким чином, загальна **схема алгоритму** Штор-Вагнера така. Алгоритм складається з $n-1$ фаз. На кожній фазі множина $A$ спочатку складається з однієї вершини; обчислюються початкові ваги вершин $w(v,A)$. Потім відбувається $n-1$ ітерація, на кожній з яких вибирається вершина $u$ з найбільшим значенням $w(u,A)$ і додається до множини $A$, після чого перераховуються значення $w$ для залишених вершин (для чого, очевидно, треба пройтися по всіх ребрах списку суміжності обраної вершини $u$). Після виконання всіх ітерацій ми запам'ятовуємо в $s$ і $t$ номера останніх двох доданих вершин, а в якості вартості знайденого мінімального розрізу між $s$ і $t$ можна взяти значення $w(t,A \setminus \{t\})$. Потім треба порівняти знайдений мінімальний розріз з поточною відповіддю, якщо він менший, то оновити відповідь. Перейти до наступної фази.

Якщо не використовувати жодних складних структур даних, то найбільш критичною частиною буде знаходження вершини з найбільшою вагою $w$. Якщо зробити це за $O(n)$, то, враховуючи, що всього фаз $n-1$, і по $n-1$ ітерацій в кожній, підсумкова **асимптотична складність алгоритму** складе $O(n^3)$.

Якщо для знаходження вершини з найбільшою величиною $w$ використовувати **Фібоначчіві купи** (які дозволяють збільшувати значення ключа за $O(1)$ в середньому і витягувати максимум за $O(\log n)$ в середньому), то всі пов'язані з безліччю $A$ операції на одній фазі виконуються за $O(m + n \log n)$. Підсумкова асимптотика алгоритму в такому випадку складе $O(n m + n^2 \log n)$.

## Доведення теореми Штор-Вагнера

Нагадаємо умову цієї теореми. Якщо додати до множини $A$ по черзі всі вершини, кожного разу додаючи вершину, найбільш сильно зв'язану з цією множиною, то позначимо передостанню додану вершину як $s$, а останню - як $t$. Значить, мінімальний $s$-$t$ розріз складається з єдиної вершини - $t$.

Для доведення розглянемо довільний $s$-$t$ розріз $C$ і покажемо, що його вага не може бути меншою за вагу розрізу, що складається з єдиної вершини $t$

$$
w(\{t\}) \le w(C).
$$

Для цього доведемо наступний факт. Нехай $A_v$ - стан множини $A$ безпосередньо перед додаванням вершини $v$. Нехай $C_v$ - розріз множини $A_v \cup \{v\}$, індукований розрізом $C$ (простіше кажучи, $C_v$ дорівнює перетину цих двох множин вершин). Далі, вершина $v$ називається активною (щодо розрізу $C$), якщо вершина $v$ та попередньо додана до $A$ вершина належать різним частинам розрізу $C$. Отже, для будь-якої активної вершини $v$ виконується нерівність:

$$
w(v,A_v) \le w(C_v).
$$

Зокрема, $t$ є активною вершиною (тобто перед ним була додана вершина $s$), і при $v = t$ ця нерівність перетворюється на твердження теореми:

$$
w(t,A_t) = w(\{t\}) \le w(C_t) = w(C).
$$

Отже, ми будемо доводити нерівність, для чого скористаємось методом математичної індукції.

Для першої активної вершини $v$ ця нерівність вірна (більше того, вона перетворюється на рівність), оскільки всі вершини $A_v$ належать одній частині розрізу, а $v$ - іншій.

Нехай тепер ця нерівність виконана для всіх активних вершин аж до деякої вершини $v$, доведемо її для наступної активної вершини $u$. Для цього перетворимо ліву частину:

$$
w(u,A_u) \equiv w(u,A_v) + w(u,A_u \setminus A_v).
$$

По-перше, зауважимо, що:

$$
w(u,A_v) \le w(v,A_v),
$$

Це випливає з того, що коли множина $A$ була рівна $A_v$, до неї була додана саме вершина $v$, а не $u$, отже, вона мала найбільше значення $w$.

Далі, оскільки $w(v,A_v) \le w(C_v)$ за припущенням індукції, то отримуємо:

$$
w(u,A_v) \le w(C_v),
$$

звідки ми маємо?

$$
w(u,A_u) \le w(C_v) + w(u,A_u \setminus A_v).
$$

Тепер зауважимо, що вершина $u$ і всі вершини $A_u \setminus A_v$ знаходяться в інших частинах розрізу $C$. Тому величина $w(u,A_u \setminus A_v)$ позначає суму ваг ребер, які враховані в $w(C_u)$, але ще не враховані в $w(C_v)$. Отже, отримуємо:

$$
w(u,A_u) \le w(C_v) + w(u,A_u \setminus A_v) \le w(C_u),
$$

що потрібно довести?

Ми довели співвідношення $w(v,A_v) \le w(C_v)$, з якого, як вже зазначалося раніше, випливає вся теорема.

## Реалізація

Для найпростішої та зрозумілої реалізації (з асимптотикою $O(n^3)$) було обрано подання графа у вигляді матриці суміжності. Відповідь зберігається у змінних $\rm best\_cost$ та $\rm best\_cut$ (шукані вартість мінімального розрізу та самі вершини, які містяться в ньому).

Для кожної вершини в масиві $\mathrm{exist}$ зберігається, чи існує вона, чи вона була об'єднана з якоюсь іншою вершиною. У списку $\mathrm{v}[i]$ для кожної стислої вершини $i$ зберігаються номери вихідних вершин, які були стиснені в цю вершину $i$.

Алгоритм складається з $n-1$ фази (цикл по змінній $\rm ph$). На кожній фазі спочатку всі вершини знаходяться поза множиною $A$, для чого масив $\rm in\_a$ заповнюється нулями, а зв'язності $w$ всіх вершин ставляться рівними нулю. На кожній з $n-{\rm ph}$ ітерацій знаходиться вершина $\rm sel$ з найбільшою величиною $w$. Якщо це остання ітерація, то відповідь, якщо потрібно, оновлюється, а передостання $\rm prev$ і остання $\rm sel$ вибрані вершини об'єднуються в одну. Якщо ітерація не остання, то $\rm sel$ додається до множини $A$, після чого перераховуються ваги всіх інших вершин.

Слід зазначити, що алгоритм під час своєї роботи змінює граф $\rm g$, тому, якщо він ще знадобиться пізніше, потрібно зберегти його копію перед викликом функції.

<!--- TODO: specify code snippet id -->
``` cpp
const int MAXN = 500;
int n, g[MAXN][MAXN];
int best_cost = 1000000000;
vector<int> best_cut;

void mincut() {
    vector<int> v[MAXN];
    for (int i = 0; i < n; ++i)
        v[i].assign(1, i);
    int w[MAXN];
    bool exist[MAXN], in_a[MAXN];
    memset(exist, true, sizeof exist);
    for (int ph = 0; ph < n - 1; ++ph) {
        memset(in_a, false, sizeof in_a);
        memset(w, 0, sizeof w);
        for (int it = 0, prev; it < n - ph; ++it) {
            int sel = -1;
            for (int i = 0; i < n; ++i)
                if (exist[i] && !in_a[i] && (sel == -1 || w[i] > w[sel]))
                    sel = i;
            if (it == n - ph - 1) {
                if (w[sel] < best_cost)
                    best_cost = w[sel], best_cut = v[sel];
                v[prev].insert(v[prev].end(), v[sel].begin(), v[sel].end());
                for (int i = 0; i < n; ++i)
                    g[prev][i] = g[i][prev] += g[sel][i];
                exist[sel] = false;
            } else {
                in_a[sel] = true;
                for (int i = 0; i < n; ++i)
                    w[i] += g[sel][i];
                prev = sel;
            }
        }
    }
}
```

## Література

* \book{Mechthild Stoer, Frank Wagner}{A Simple Min-Cut Algorithm}{1997}{stoer_wagner_mincut.pdf}
* \book{Kurt Mehlhorn, Christian Uhrig}{The minimum cut algorithm of Stoer and Wagner}{1995}{mehlhorn_mincut_stoer_wagner.pdf}