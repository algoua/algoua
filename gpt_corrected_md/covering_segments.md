# Задача про покриття відрізків точками

Дано $N$ відрізків на прямій. Потрібно покрити їх найменшою кількістю точок, тобто знайти найменшу множину точок таку, що кожен відрізок містить хоча б одну точку.

Також розглянемо ускладнену різновид цієї задачі - коли додатково вказано "заборонену" множину відрізків, тобто жодна точка з відповіді не повинна належати жодному забороненому відрізку.

Слід також зазначити, що цю задачу можна розглядати як задачу в теорії розкладів - потрібно покрити набір завдань-відрізків найменшим числом точок.

Нижче буде описаний жадібний алгоритм, який вирішує обидві задачі за **O(N log N)**.

## Розв'язок першої задачі

Зауважимо спочатку, що можна розглядати лише ті розв'язки, в яких кожна точка знаходиться на правому кінці якої-небудь відрізка. Дійсно, нескладно зрозуміти, що будь-який розв'язок, якщо він не задовольняє цій властивості, можна привести до нього, зсуваючи його точки вправо настільки, наскільки це можливо.

Спробуємо тепер побудувати розв'язок, який задовольнятиме зазначені вимоги. Візьмемо точки - праві кінці відрізків, відсортуємо їх і будемо рухатися по них зліва направо. Якщо поточна точка є правим кінцем вже покритого відрізку, то ми пропускаємо її. Нехай тепер поточна точка є правим кінцем поточного відрізку, який ще не був покритий до цього. Отже, ми повинні додати поточну точку до відповіді та позначити всі відрізки, до яких належить ця точка, як покриті. Дійсно, якщо б ми пропустили поточну точку і не стали додавати її до відповіді, то, оскільки вона є правим кінцем поточного відрізку, який ще не був покритий, ми вже не змогли б покрити цей відрізок.

Однак при наївній реалізації цей метод буде працювати за O(N^2). Опишемо **ефективну реалізацію** цього методу.

Візьмемо всі точки-кінці відрізків (як ліві, так і праві) і відсортуємо їх. При цьому для кожної точки збережемо разом з нею номер відрізку, а також те, яким кінцем вона є (лівим або правим). Крім того, відсортуємо точки таким чином, що, якщо є декілька точок з однієї координатою, то спочатку будуть йти ліві кінці, і тільки потім - праві. Заведемо стек, в якому будуть зберігатися номера відрізків, розглянутих в даний момент; спочатку стек порожній. Будемо рухатися по точкам в відсортованому порядку. Якщо поточна точка - лівий кінець, то просто додаємо номер її відрізку в стек. Якщо ж вона є правим кінцем, то перевіряємо, чи не був відрізок, до якого вона належить, вже покритий (для цього можна просто завести масив булевих змінних). Якщо він вже був покритий, то нічого не робимо і переходимо до наступної точки (зазначимо, що в цьому випадку в стеці поточного відрізку вже немає). Якщо ж він ще не був покритий, то ми додаємо поточну точку в відповідь, і тепер ми хочемо відзначити для всіх поточних відрізків, що вони стають покритими. Оскільки в стеці зберігаються номери непокритих ще відрізків, то будемо доставати зі стеку по одному відрізку і відзначати, що він вже покритий, поки стек повністю не опустіє. Після закінчення роботи алгоритму всі відрізки будуть покриті, причому найменшою кількістю точок (повторимося, тут важлива вимога, що при рівності координат спочатку йдуть ліві кінці, а потім праві).

Таким чином, весь алгоритм виконується за O(N), не враховуючи сортування точок, а підсумкова складність алгоритму дорівнює **O(N log N)**.

## Розв'язок другої задачі

Тут вже з'являються заборонені відрізки, тому, по-перше, розв'язку взагалі може не існувати, а по-друге, вже не можна стверджувати, що відповідь можна скласти тільки з правих кінців відрізків. Однак описаний вище алгоритм можна відповідним чином модифікувати.

Знову візьмемо всі точки-кінці відрізків (як цільових відрізків, так і заборонених), відсортуємо їх, зберігши разом з кожною точкою її тип і відрізок, кінцем якого вона є. Також відсортуємо відрізки так, щоб при рівності координат ліві кінці йшли перед правими, а якщо типи кінців рівні, то ліві кінці заборонених повинні йти перед лівими кінцями цільових, а праві кінці заборонених - після цільових (щоб запрещені відрізки враховувалися як можна довше при рівності координат). Заведемо лічильник заборонених відрізків, який буде дорівнювати числу заборонених відрізків, що покривають поточну точку. Заведемо чергу (queue), в якій будуть зберігатися номери поточних цільових відрізків. Будемо перебирати точки в відсортованому порядку. Якщо поточна точка - лівий кінець цільового відрізку, то просто додаємо номер її відрізку в чергу. Якщо поточна точка - правий кінець цільового відрізку, то, якщо лічильник заборонених відрізків дорівнює нулю, то ми діємо аналогічно попередній задачі - ставимо точку в поточну точку і витягуємо всі відрізки з черги, позначаючи, що вони покриті. Якщо ж лічильник заборонених відрізків більше нуля, то в поточну точку ми не можемо стріляти, тому ми повинні знайти саму останню точку, вільну від заборонених відрізків; для цього треба підтримувати відповідний вказівник last_free, який буде оновлюватися при надходженні заборонених відрізків. Значить ми стріляємо в last_free-EPS (тому що прямо в неї не можна стріляти - ця точка належить запрещеному відрізку), і витягуємо відрізки з черги, поки точка last_free-EPS належить їм. А саме, якщо поточна точка - лівий кінець запрещеного відрізку, то ми збільшуємо лічильник, і якщо перед цим лічильник був дорівнював нулю, то присвоюємо last_free поточну ко