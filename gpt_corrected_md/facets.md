# Знаходження всіх граней та зовнішньої грані планарного графа

Даний планарний граф $G$ з $n$ вершинами, укладений на площині. Необхідно знайти всі його грані. Гранню називається частина площини, обмежена ребрами цього графа.

Одна з граней буде відрізнятися від інших тим, що матиме нескінченну площу, така грань називається зовнішньою гранню. У деяких завданнях потрібно знаходити тільки зовнішню грань, алгоритм знаходження якої, як ми побачимо, по суті не відрізняється від алгоритму для всіх граней.

## Теорема Ойлера

Наведемо тут теорему Ейлера і кілька наслідків з неї, з яких буде випливати, що кількість ребер і граней планарного простого (без петель і кратних ребер) графа є величинами порядку $O(n)$.

Нехай планарний граф $G$ є зв'язним. Позначимо через $n$ кількість вершин у графі, $m$ - число ребер, $f$ - число граней. Тоді справедлива **теорема Ейлера**:

$$
f + n - m = 2
$$

Довести цю формулу легко наступним чином. У випадку дерева ($m=n-1$) формула легко перевіряється. Якщо граф - не дерево, то видаляємо будь-яке ребро, яке належить якого-небудь циклу; при цьому величина $f+n-m$ не зміниться. Будемо повторювати цей процес, доки не прийдемо до дерева, для якого тотожність $f+n-m=2$ вже встановлена. Таким чином, теорема доведена.

**Слідство**. Для довільного планарного графа нехай $k$ - кількість компонент зв'язності. Значить виконується:

$$
f + n - m = 1 + k
$$

СЛІДСТВО. Кількість ребер $m$ простого планарного графа є величиною $O(n)$.

Доведення. Нехай граф $G$ є зв'язним і $n \ge 3$ (у випадку $n < 3$ твердження отримуємо автоматично). Значить, з одного боку, кожна грань обмежена як мінімум трьома ребрами. З іншого боку, кожне ребро обмежує максимум дві грані. Отже, $3f \le 2m$, звідки, підставляючи це в формулу Ойлера, отримуємо:

$$
f + n - m = 2\ \ \Leftrightarrow\ \ 3f = 6 - 3n + 3m\ \ \Leftrightarrow\ \ 6 - 3n + 3m \le 2m\ \ \Leftrightarrow\ \ m \le 3n - 6
$$

тобто. $m = O(n)$.

Якщо граф не є зв'язним, то, підсумовуючи отримані оцінки по його компонентах зв'язності, отримуємо $m = O(n)$, що потрібно довести.

СЛІДСТВО. Кількість ребер $f$ простого планарного графа є величиною $O(n)$.

Цей наслідок випливає з попереднього наслідку і зв'язку $f = 2 - n + m$.

## Обхід усіх ребер

Завжди будемо вважати, що граф, якщо він не є зв'язним, укладений на площині таким чином, що жодна компонента зв'язності не лежить всередині іншої (наприклад, квадрат з лежачим строго всередині нього відрізком - некоректний для нашого алгоритму тесту).

Зрозуміло, що граф правильно побудований на площині, тобто жодні дві вершини не співпадають, а ребра не перетинаються в "неправомірних" точках. Якщо вхідний граф містить такі перетинчасті ребра, то перед обробкою їх потрібно видалити, вводячи в кожну точку перетину додаткову вершину (варто зазначити, що в результаті цього процесу замість $n$ точок може бути створено близько $n^2$ точок). Детальніше про цей процес дивіться нижче в відповідному розділі.

Нехай для кожної вершини всі вихідні ребра впорядковані по полярному куту. Якщо цього не відбувається, їх потрібно упорядкувати, провівши сортування кожного списку суміжності (тобто $m = O(n)$). На це буде потрібно $O(n \log n)$ операцій.

Тепер оберемо довільне ребро $(а,b)$ і розпочнемо наступний обхід. Приходячи в деяку вершину $v$ через деяке ребро, ми обов'язково повинні вийти з цієї вершини через наступне ребро в порядку сортування.

Наприклад, на першому кроці ми знаходимося у вершині $b$, і маємо знайти вершину $a$ у списку сусідів вершини $b$. Позначимо через $c$ наступну вершину у списку сусідів $a$ (якщо $a$ була останньою, то в якості $c$ візьмемо першу вершину), і пройдемо по ребру $(b,c)$. Крім того, необхідно замінити "список суміжності" на "список сусідів", а "ребро" на "дугу".

Повторюючи цей процес багато разів, ми рано або пізно повернемося до стартової реберної точки $(a,b)$, після чого потрібно зупинитися. Не складно помітити, що при такому обході ми обійдемо лише одну грань. При цьому напрямок обходу буде проти годинникової стрілки для зовнішньої грані та за годинниковою стрілкою для внутрішніх граней. Іншими словами, при такому обході внутрішність грані завжди буде знаходитися з правого боку від поточного ребра.

Отже, ми навчилися обходити одну грань, стартуючи з будь-якого ребра на її кордоні. Залишилося навчитися вибирати стартові ребра таким чином, щоб одержувані грані не повторювалися. Зауважимо, що кожне ребро має два напрямки, в яких його можна обходити, при кожному з яких будуть виходити свої грані. З іншого боку, очевидно, що одне таке орієнтоване ребро належить тільки одній грані. Таким чином, якщо ми будемо позначати всі ребра кожної обнаруженої грані в деякому масиві $\rm used$ і не запускати обхід з вже позначених ребер, то ми обійдемо всі грані (включаючи зовнішню), причому рівно по одному разу.

Наведемо одразу **реалізацію** цього обходу. Будемо вважати, що в графі $G$ списки суміжності вже впорядковані за ребрама, а кратні ребра і петлі відсутні.

Перший вид реалізації - спрощений. Для пошуку наступної вершини в списку суміжності використовується простий пошук. Така реалізація теоретично має складність $O(n^2)$, хоча на практиці на багатьох тестах вона працює досить швидко (за рахунок прихованої константи, значно меншої за одиницю).

<!--- TODO: specify code snippet id -->
``` cpp
int n;                 // кількість вершин
vector<vector<int>> g; // граф

vector<vector<char>> used(n);
for (int i = 0; i < n; ++i)
    used[i].resize(g[i].size());
for (int i = 0; i < n; ++i)
    for (size_t j = 0; j < g[i].size(); ++j)
        if (!used[i][j]) {
            used[i][j] = true;
            int v = g[i][j], pv = i;
            vector<int> facet;
            for (;;) {
                facet.push_back(v);
                vector<int>::iterator it = find(g[v].begin(), g[v].end(), pv);
                if (++it == g[v].end())
                    it = g[v].begin();
                if (used[v][it - g[v].begin()])
                    break;
                used[v][it - g[v].begin()] = true;
                pv = v, v = *it;
            }
... висновок "фасет" - поточна грань...
        }
```

Інший, більш оптимізований варіант реалізації полягає у використанні того факту, що вершини в списку суміжності впорядковані за їхнім кутом. Якщо реалізувати функцію порівняння двох точок за їхнім кутом відносно третьої точки (наприклад, у вигляді класу, як показано нижче), то при пошуку точки в списку суміжності можна використовувати бінарний пошук. Це дозволяє отримати реалізацію з часовою складністю $O(n \log n)$.

<!--- TODO: specify code snippet id -->
``` cpp
class cmp_ang {
    int center;

  public:
    cmp_ang(int center) : center(center) {}
bool operator()(int a, int b) const { ... повинна повертати true, якщо точка a має менший полярний кут, ніж точка b щодо центру... }
};

int вершин;                 // кількість вершин
vector<vector<int>> g; // граф

vector<vector<char>> used(n);
for (int i = 0; i < n; ++i)
    used[i].resize(g[i].size());
for (int i = 0; i < n; ++i)
    for (size_t j = 0; j < g[i].size(); ++j)
        if (!used[i][j]) {
            used[i][j] = true;
            int v = g[i][j], pv = i;
            vector<int> facet;
            for (;;) {
                facet.push_back(v);
                vector<int>::iterator it = lower_bound(g[v].begin(), g[v].end(), pv, cmp_ang(v));
                if (++it == g[v].end())
                    it = g[v].begin();
                if (used[v][it - g[v].begin()])
                    break;
                used[v][it - g[v].begin()] = true;
                pv = v, v = *it;
            }
... висновок "фасет" - поточна грань...
        }
```

Можливий інший варіант, заснований на контейнері $vector$, оскільки нам потрібно лише швидко дізнаватися позиції чисел у масиві. Зрозуміло, така реалізація також буде працювати з складністю $O(n \log n)$.

Слід відзначити, що алгоритм не зовсім правильно працює з **ізольованими** вершинами - такі вершини він просто не виявить як окремі грані, хоча, з математичної точки зору, вони повинні представляти собою окремі компоненти зв'язності і грані.

Крім того, особливою гранню є **зовнішня грань**. Як її відрізнити від "звичайних" граней, описано в наступному розділі. Слід зауважити, що якщо граф є незв'язним, то зовнішня грань буде складатися з декількох контурів, і кожен з цих контурів буде знайдений алгоритмом окремо.

## Виділення зовнішньої грані

Поданий вище код виводить всі грани, не роблячи розрізнення між зовнішньою та внутрішніми гранями. На практиці, зазвичай, навпаки, потрібно знайти або лише зовнішню грань, або лише внутрішні грані. Існує кілька способів виділення зовнішньої грані.

Наприклад, її можна визначити за площею - зовнішня грань повинна мати найбільшу площу (слід зазначити, що внутрішня грань може мати таку ж площу, як і зовнішня). Цей метод не працюватиме, якщо даний планарний граф $G$ не є зв'язним.

Інший, більш надійний критерій - за напрямком обходу. Як вже зазначалося вище, всі грані, крім зовнішньої, обходяться за годинниковою стрілкою. Зовнішня грань, навіть якщо вона складається з декількох контурів, обходиться алгоритмом проти годинникової стрілки. Визначити напрямок обходу можна, просто вважаючи [знакову площу багатокутника](polygon_area). Площу можна вважати прямо за ходом внутрішнього циклу. Однак і у цього методу є своя тонкість - обробка граней нульової площі. Наприклад, якщо граф складається з єдиного ребра, то алгоритм знайде єдину грань, площа якої буде нульовою. Здається, якщо грань має нульову площу, то вона є зовнішньою гранню.

У деяких випадках можна застосувати такий критерій, як кількість вершин. Наприклад, якщо граф представляє собою опуклий багатокутник з проведеними в ньому неперетинними діагоналями, то його зовнішня грань буде містити всі вершини. Проте потрібно бути обережним у випадку, коли і зовнішня, і внутрішня грані мають однакову кількість вершин.

Нарешті є ще один метод знаходження зовнішньої грані: можна спеціально запуститися від такого ребра, щоб знайдена в результаті грань була зовнішньою. Наприклад, можна взяти саму ліву вершину (якщо таких декілька, то підійде будь-яка) і вибрати з її ребер те, яке йде першим за порядком сортування. У результаті обхід з цього ребра знайде зовнішню грань. Цей спосіб можна застосувати і до випадку незв'язного графа: потрібно для кожної компоненти зв'язності знайти саму ліву вершину і запускати обхід з першого ребра з її.

Наведемо реалізацію найпростішого методу, основаного на знаку площі (сам обхід я для прикладу взяв за $O(n^2)$, тут це неважливо). Якщо граф не є зв'язним, то код "... грань є зовнішньої ..." виконається окремо для кожного контуру, який складає зовнішню грань.

<!--- TODO: specify code snippet id -->
``` cpp
... звичайний код для виявлення ребер, що знаходиться безпосередньо після циклу, який виявляє наступну грань: ...

                                                                                                 // припустимо площа
                                                                                                 double area = 0;
додаємо фіктивну точку для спрощення обчислення площі
facet.push_back(facet[0]);
for (size_t k = 0; k + 1 < facet.size(); ++k)
    area += (p[facet[k]].first + p[facet[k + 1]].first) * (p[facet[k]].second - p[facet[k + 1]].second);
if (area < EPS)
...грань є зовнішньою...
}
```

## Побудова плоского графа

Для вищезгаданих алгоритмів суттєво, що вхідний граф є правильно укладеним планарним графом. Однак на практиці часто на вхід програмі подається набір відрізків, можливо, перетиняються між собою в "несанкціонованих" точках, і потрібно побудувати за цими відрізками планарний граф.

Реалізувати побудову планарного графа можна наступним чином. Зафіксуємо будь-який вхідний відрізок. Тепер перетнемо цей відрізок з усіма іншими відрізками. Знайдені точки перетину, а також кінці самого відрізку, покладемо в вектор, і його відсортуємо стандартним чином (тобто спочатку по одній координаті, при рівності - по іншій). Потім пройдемося по цьому вектору і будемо додавати ребра між сусідніми в цьому векторі точками (звісно, слідкуючи, щоб ми не додали петлі). Виконавши цей процес для всіх відрізків, тобто за $O(n^2 \log n)$, ми побудуємо відповідний планарний граф (в якому буде $O(n^2)$ точок).

Реалізація:

<!--- TODO: specify code snippet id -->
``` cpp
const double EPS = 1E-9;

struct point {
    double x, y;
    bool operator<(const point &p) const { return x < p.x - EPS || abs(x - p.x) < EPS && y < p.y - EPS; }
};

map<point, int> ids;
vector<point> p;
vector<vector<int>> g;

int get_point_id(point pt) {
    if (!ids.count(pt)) {
        ids[pt] = (int)p.size();
        p.push_back(pt);
        g.resize(g.size() + 1);
    }
    return ids[p];
}

void intersect(pair<point, point> a, pair<point, point> b, vector<point> &res) { ... стандартна процедура, яка перетинає два відрізки a і b і закидує результат в res...... якщо відрізки перетинаються, то закидує ті кінці, які потрапили всередину першого відрізку... }

int main() {
// Вхідні дані:
    int m;
    vector<pair<point, point>> a(m);
    ... читання...

// Побудова графу
        for (int i = 0; i < m; ++i) {
        vector<point> cur;
        for (int j = 0; j < m; ++j)
            intersect(a[i], a[j], cur);
        sort(cur.begin(), cur.end());
        for (size_t j = 0; j + 1 < cur.size(); ++j) {
            int x = get_id(cur[j]), y = get_id(cur[j + 1]);
            if (x != y) {
                g[x].push_back(y);
                g[y].push_back(x);
            }
        }
    }
    int n = (int)g.size();
Сортування за розами та видалення кратних ребер
    for (int i = 0; i < n; ++i) {
        sort(g[i].begin(), g[i].end(), cmp_ang(i));
        g[i].erase(unique(g[i].begin(), g[i].end()), g[i].end());
    }
}
```