# Модифікація методу Проталкивання передпотоку для знаходження максимального потоку за O(N^3)

Передбачається, що ви вже прочитали [Метод Проталкивання передпотоку знаходження максимального потоку за O(N^4)](preflow_push).

## Опис

Модифікація надзвичайно проста: на кожній ітерації серед усіх переповнених вершин ми вибираємо тільки ті вершини, які мають **найбільшу висоту**, і застосовуємо проштовхування/підняття тільки до цих вершин. Більше того, для вибору вершин з найбільшою висотою нам не знадобляться жодні структури даних, достатньо просто зберігати список вершин з найбільшою висотою і просто перераховувати його, якщо всі вершини з цього списку були оброблені (тоді до списку додадуться вершини з вже меншою висотою), а при появі нової переповненої вершини з більшою висотою, очищати список і додавати вершину до списку.

Незважаючи на його простоту, ця модифікація дозволяє знизити асимптотику на цілий порядок. Щоб бути точним, асимптотика отриманого алгоритму дорівнює **O(NM + N<sup>2</sup> sqrt(M))**, що в гіршому випадку становить **O(N<sup>3</sup>)**.

Ця модифікація була запропонована Черіяном (Cheriyan) та Махешварі (Maheshvari) у 1989 році.

## Реалізація

Тут наведено готову реалізацію цього алгоритму.

Відмінність від звичайного алгоритму проштовхування полягає тільки в наявності масиву maxh, в якому будуть зберігатися номери переповнених вершин з максимальною висотою. Розмір масиву вказано в змінній sz. Якщо на якійсь ітерації виявляється, що цей масив порожній (sz = 0), то ми заповнюємо його (просто проходячи по всім вершинам); якщо після цього масив як і раніше порожній, то переповнених вершин немає, і алгоритм зупиняється. Інакше ми проходимо по вершинах в цьому списку, застосовуючи до них проштовхування або піднімання. Після виконання операції проштовхування поточна вершина може перестати бути переповненою, в цьому випадку видаляємо її зі списку maxh. Якщо після якоїсь операції піднімання висота поточної вершини стає більшою за висоту вершин у списку maxh, то ми очищаємо список (sz = 0), і відразу переходимо до наступної ітерації алгоритму проштовхування (на якій буде побудований новий список maxh).

<!--- TODO: specify code snippet id -->
``` cpp
const int INF = 1000 * 1000 * 1000;

int main() {
    int n;
    vector<vector<int>> c(n, vector<int>(n));
    int s, t;
    ... читання n, c, s,
        t...

        vector<int>
            e(n);
    vector<int> h(n);
    h[s] = n - 1;
    vector<vector<int>> f(n, vector<int>(n));

    for (int i = 0; i < n; ++i) {
        f[s][i] = c[s][i];
        f[i][s] = -f[s][i];
        e[i] = c[s][i];
    }

    vector<int> maxh(n);
    int sz = 0;
    for (;;) {
        if (!sz)
            for (int i = 0; i < n; ++i)
                if (i != s && i != t && e[i] > 0) {
                    if (sz && h[i] > h[maxh[0]])
                        sz = 0;
                    if (!sz || h[i] == h[maxh[0]])
                        maxh[sz++] = i;
                }
        if (!sz)
            break;
        while (sz) {
            int i = maxh[sz - 1];
            bool pushed = false;
            for (int j = 0; j < n && e[i]; ++j)
                if (c[i][j] - f[i][j] > 0 && h[i] == h[j] + 1) {
                    pushed = true;
                    int addf = min(c[i][j] - f[i][j], e[i]);
                    f[i][j] += addf, f[j][i] -= addf;
                    e[i] -= addf, e[j] += addf;
                    if (e[i] == 0)
                        --sz;
                }
            if (!pushed) {
                h[i] = INF;
                for (int j = 0; j < n; ++j)
                    if (c[i][j] - f[i][j] > 0 && h[j] + 1 < h[i])
                        h[i] = h[j] + 1;
                if (h[i] > h[maxh[0]]) {
                    sz = 0;
                    break;
                }
            }
        }
    }

... висновок потоку $f$...
}
```