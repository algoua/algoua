# Найменший спільний предок. Знаходження за $O(1)$ в офлайн (алгоритм Тар'яна)

Дано дерево $G$ з $n$ вершинами і $m$ запитів у вигляді $(a_i, b_i)$. Для кожного запиту $(a_i, b_i)$ потрібно знайти найменшого загального предка вершин $a_i$ та $b_i$. Загальний предок - це вершина $c_i$, яка знаходиться на найбільшій відстані від кореня дерева і є предком як вершини $a_i$, так і вершини $b_i$.

Ми розглядаємо задачу в режимі офлайн, тобто вважаємо, що всі запити відомі заздалегідь. Описаний нижче алгоритм дозволяє відповісти на всі $m$ запитів за сумарний час $O(n+m)$, тобто при достатньо великому $m$ за $O(1)$ на запит.

## Алгоритм Тар'яна

Основою для алгоритму є структура даних ["Система неперетинних множин"](dsu), яка була винаходом Тар'яна (Tarjan).

Алгоритм фактично представляє собою обхід в глибину з кореня дерева, під час якого поступово знаходяться відповіді на запити. Зокрема, відповідь на запит $(v,u)$ знаходиться, коли обхід в глибину перебуває в вершині $u$, а вершина $v$ вже була оглянута, або навпаки.

Отже, нехай обхід в глибину знаходиться в вершині $v$ (і вже були виконані переходи до її синів), і виявилося, що для якогось запиту $(v,u)$ вершина $u$ вже була відвідана обходом в глибину. Навчимося тоді знаходити $\mathrm{LCA}$ цих двох вершин.

Зауважимо, що ${\rm LCA}(v,u)$ є або самою вершиною $v$, або одним з її предків. Отже, нам потрібно знайти найнижчу вершину серед предків $v$ (включаючи саму вершину $v$), для якої вершина $u$ є потомком. Також зауважимо, що при фіксованому $v$ за таким критерієм (тобто який є найменшим предком $v$, що є предком якоїсь вершини) вершини дерева розбиваються на неперетинаючіться класи. Для кожного предка $p \neq v$ вершини $v$ її клас містить саму цю вершину, а також всі піддерева з коренями в її синах, які знаходяться "ліворуч" від шляху до $v$ (тобто які були оброблені раніше, ніж було досягнуто $v$).

Нам потрібно навчитися ефективно підтримувати всі ці класи, для чого ми застосуємо структуру даних "Система, що не перетинається множин". Кожному класу буде відповідати в цій структурі множина, причому для представника цього множини ми визначимо величину $\rm ANCESTOR$ - ту вершину $p$, яка утворює цей клас.

Розглянемо детально реалізацію обходу в глибину. Нехай ми стоїмо в деякій вершині $v$. Помістимо її в окремий клас в структурі, що не перетинаються множин: ${\rm ANCESTOR}[v] = v$. Як зазвичай в обході в глибину, перебираємо всі вихідні ребра $(v, to)$. Для кожного такого $to$ ми спочатку повинні викликати обхід в глибину з цієї вершини, а потім додати цю вершину зі всім її піддеревом в клас вершини $v$. Це реалізується операцією $\rm Union$ структури даних "система що не перетинаються множин", з наступною установкою ${\rm ANCESTOR} = v$ для представника множини (тобто після злиття представник класу може змінитися). Нарешті, після обробки всіх ребер ми перебираємо всі запити у вигляді $(v,u)$, і якщо $u$ була позначена як відвідана обходом в глибину, то відповіддю на цей запит буде вершина ${\rm LCA}(v,u) = {\rm ANCESTOR}[{\rm FindSet}(u)]$. Неважко замітити, що для кожного запиту ця умова (що одна вершина запиту є поточною, а інша була переглянута раніше) виконається рівно один раз.

Оцінимо **асимптотику**. Вона складається з декількох частин. По-перше, це асимптотика обходу в глибину, яка в даному випадку становить $O(n)$. По-друге, це операції по об'єднанню множин, які в сумі для всіх розумних $n$ затрачають $O(n)$. По-третє, для кожного запиту потрібно перевірити умову (два рази на запит) і визначити результат (один раз на запит), кожне з цих дій для всіх розумних $n$ виконується за $O(1)$. Підсумкова асимптотика складає $O(n+m)$, що означає, що для достатньо великих $m$ ($n = O(m)$) відповідь на один запит можна отримати за $O(1)$.

## Реалізація

Наведемо повну реалізацію цього алгоритму, включаючи трохи змінену (з підтримкою $\rm ANCESTOR$) реалізацію системи перетинних множин (рандомізований варіант).

<!--- TODO: specify code snippet id -->
``` cpp
const int MAXN = максимальна кількість вершин у графі;
вектор <int> g[MAXN], q[MAXN]; // граф і всі запити
int dsu[MAXN], ancestor[MAXN];
bool u[MAXN];

int dsu_get(int v) { return v == dsu[v] ? v : dsu[v] = dsu_get(dsu[v]); }

void dsu_unite(int a, int b, int new_ancestor) {
    a = dsu_get(a), b = dsu_get(b);
    if (rand() & 1)
        swap(a, b);
    dsu[a] = b, ancestor[b] = new_ancestor;
}

void dfs(int v) {
    dsu[v] = v, ancestor[v] = v;
    u[v] = true;
    for (size_t i = 0; i < g[v].size(); ++i)
        if (!u[g[v][i]]) {
            dfs(g[v][i]);
            dsu_unite(v, g[v][i], v);
        }
    for (size_t i = 0; i < q[v].size(); ++i)
        if (u[q[v][i]]) {
            printf("%d %d -> %d\n", v + 1, q[v][i] + 1, ancestor[dsu_get(q[v][i])] + 1);
        }

    int main() {
...читання графу...

// Читання запитів
            for (;;) {
int a;
int b = ...; // черговий запит
            --a, --b;
            q[a].push_back(b);
            q[b].push_back(a);
        }

// Обхід у глибину та відповідь на запити
        dfs(0);
    }
```