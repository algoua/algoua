# Sqrt-декомпозиція

Sqrt-розбиття - це метод або структура даних, яка дозволяє виконувати деякі типові операції (сумування елементів підмасиву, знаходження мінімуму/максимуму тощо) за $O(\sqrt{n})$, що значно швидше, ніж $O(n)$ для тривіального алгоритму.

Спочатку ми опишемо структуру даних для одного з найпростіших застосувань цієї ідеї, потім покажемо, як узагальнювати її для вирішення деяких інших задач, і, нарешті, розглянемо кілька інших застосувань цієї ідеї: розбиття вхідних запитів на блоки з коренем з двох.

## Структура данних на основі sqrt-декомпозиції

Поставимо задачу. Даний масив $a[0 \ldots n-1]$. Потрібно реалізувати таку структуру даних, яка зможе знаходити суму елементів $a[l \ldots r]$ для довільних $l$ і $r$ за $O(\sqrt{n})$ операцій.

### Опис

Основна ідея декомпозиції на корені полягає в тому, що масив $a$ розбивається на блоки довжиною приблизно $\sqrt{n}$, і в кожному блоку $i$ заздалегідь підраховується сума $b[i]$ елементів в ньому.

Можна вважати, що довжина одного блоку та кількість блоків дорівнюють одному і тому ж числу - кореню з $n$, округленому вгору

$$
s = \left\lceil \sqrt{n} \right\rceil,
$$

тоді масив $a[]$ розбивається на блоки приблизно наступним чином:

$$
\underbrace{ a[0] ~ a[1] ~ \ldots ~ a[s-1] }_{b[0]} ~~~ \underbrace{ a[s] ~ a[s+1] ~ \ldots ~ a[2 \cdot s-1] }_{b[1]} ~~~ \ldots ~~~ \underbrace{ a[(s-1) \cdot s] ~ \ldots ~ a[n] }_{b[s-1]}.
$$

Хоча останній блок може містити менше, ніж $s$ елементів (якщо $n$ не ділиться на $s$), - це не принципово.

Таким чином, для кожного блоку $k$ ми знаємо суму на ньому $s[k]$:

$$
b[k] = \sum_{i=k \cdot s}^{\min (n-1, (k+1) \cdot s - 1)} a[i].
$$

Отже, нехай ці значення $b_k$ попередньо підраховані (для цього потрібно, очевидно, $O(n)$ операцій). Що вони можуть дати при обчисленні відповіді на наступний запит $(l,r)$? Зауважимо, що якщо відрізок $[l;r]$ довгий, то в ньому будуть міститися декілька блоків цілком, і на такі блоки ми можемо дізнатися суму в них за одну операцію. В результаті від усього відрізку $[l;r]$ залишиться лише два блоки, які попадають в нього лише частково, і на цих частинах нам доведеться провести підсумовування тривіальним алгоритмом.

Ілюстрація (тут через $k$ позначений номер блоку, в якому знаходиться $l$, а через $p$ - номер блоку, в якому знаходиться $r"):

$$
\ldots ~ \overbrace{ a[l] ~ \ldots ~ a[(k+1) \cdot s-1] ~ \underbrace{ a[(k+1) \cdot s] ~ \ldots ~ a[(k+2) \cdot s-1] }_{b[k+1]} ~ \ldots ~ \underbrace{ a[(p-1) \cdot s] ~ \ldots ~ a[p \cdot s-1] }_{b[p]}\ a[p \cdot s] ~ \ldots a_r }^{sum=?} ~ \ldots
$$

На цьому рисунку видно, що для того, щоб порахувати суму на відрізку $[l \ldots r]$, потрібно підсумувати елементи тільки в двох "хвостах": $[l \ldots (k+1) \cdot s-1]$ і $[p \cdot s \ldots r]$, а також підсумувати значення $b[i]$ у всіх блоках, починаючи з $k+1$ і закінчуючи $p-1$

$$
\sum_{i=l}^{r} a[i] = \sum_{i=l}^{(k+1) \cdot s-1} a[i] + \sum_{i=k+1}^{p-1} b[i] + \sum_{i=p \cdot s}^{r} a[i]
$$

(Примітка: ця формула невірна, коли $k=p$: у такому випадку деякі елементи будуть підсумовані двічі; в цьому випадку потрібно просто підсумувати елементи з $l$ по $r$)

Тим самим ми економимо значну кількість операцій. Дійсно, розмір кожного з "хвостів", очевидно, не перевищує довжини блоку $s$, і кількість блоків також не перевищує $s$. Оскільки $s$ ми вибирали $\approx \sqrt{n}$, то всього для обчислення суми на відрізку $[l \ldots r]$ нам знадобиться лише $O(\sqrt{n})$ операцій.

### Реалізація

Наведемо спочатку найпростішу реалізацію:

<!--- TODO: specify code snippet id -->
``` cpp
// вхідні дані
int n;
vector<int> a(n);

// предпосчёт
int len = (int)sqrt(n + 0.0) + 1; // і розмір блоку, і кількість блоків
vector<int> b(len);
for (int i = 0; i < n; ++i)
    b[i / len] += a[i];

Відповідь на запити
for (;;) {
int l, r; // зчитуємо вхідні дані - наступний запит
    int sum = 0;
    for (int i = l; i <= r;)
        if (i % len == 0 && i + len - 1 <= r) {
Якщо i вказує на початок блоку, який повністю знаходиться в [l;r]
            sum += b[i / len];
            i += len;
        } else {
            sum += a[i];
            ++i;
        }
}
```

Недоліком цієї реалізації є те, що в ній невиправдано багато операцій ділення (які, як відомо, виконуються значно повільніше інших операцій). Замість цього можна порахувати номери блоків $c_l$ і $c_r$, в яких лежать межі $l$ і $r$ відповідно, і потім зробити цикл по блоках з $c_l+1$ до $c_r-1$, окремо обробивши "хвости" в блоках $c_l$ і $c_r$. Крім того, при такій реалізації випадок $c_l = c_r$ стає особливим і вимагає окремої обробки

<!--- TODO: specify code snippet id -->
``` cpp
int sum = 0;
int c_l = l / len, c_r = r / len;
if (c_l == c_r)
    for (int i = l; i <= r; ++i)
        sum += a[i];
else {
    for (int i = l, end = (c_l + 1) * len - 1; i <= end; ++i)
        sum += a[i];
    for (int i = c_l + 1; i <= c_r - 1; ++i)
        sum += b[i];
    for (int i = c_r * len; i <= r; ++i)
        sum += a[i];
}
```

### Інші задачі

Ми розглядали задачу знаходження суми елементів масиву в його підвідрізку. Цю задачу можна трохи розширити: дозволимо **змінювати** окремі елементи масиву $A$. Дійсно, якщо змінюється якийсь елемент $a_i$, то достатньо оновити значення $b[k]$ в тому блоку, в якому цей елемент знаходиться ($k = i / len$):

$$
b[k] += a[i] - old\_a[i].
$$

З іншого боку, замість задачі про суму аналогічно можна розв'язувати задачі про **мінімальний** та **максимальний** елементи в відрізку. Якщо в цих завданнях допускати зміни окремих елементів, то також потрібно буде перераховувати значення $b_k$ того блоку, до якого належить змінюваний елемент. Але перераховувати потрібно вже повністю, проходячи по всім елементам блоку за $O(len) = O(\sqrt{n})$ операцій.

Аналогічним чином до sqrt-декомпозиції можна застосовувати і для множини **інших** подібних задач: знаходження кількості нульових елементів, першого ненульового елементу, підрахунку кількості певних елементів, тощо.

Є цілий клас задач, коли відбуваються **зміни елементів на певному підвідрізку**: додавання або вилучення елементів з якогось підвідрізку масиву $A$.

Наприклад, потрібно виконувати наступні два запити: додавати до всіх елементів деяку величину $\delta$ відразу на певному відрізку $[l;r]$, і дізнаватися значення окремого елементу $a_i$. Отже, якщо покласти у $b_k$ величину, яку потрібно додати до всіх елементів $k$-го блоку (наприклад, спочатку всі $b_k = 0$), то при виконанні запиту "додаток" потрібно буде спочатку додати до всіх елементів "хвостів" відрізків, а потім додати до всіх елементів $b_i$ для блоків, що повністю лежать в відрізку $[l \ldots r]$. А відповідь на другий запит очевидно буде просто $a_i + b_k$, де $k = i / len$. Таким чином, додавання на відрізку буде виконуватися за $O(\sqrt{n})$, а запит окремого елементу - за $O(1)$.

Нарешті, можна поєднувати обидві задачі: зміну елементів на відрізку і відповідь на запити також на відрізку. Обидві операції будуть виконуватися за $O(\sqrt{n})$. Для цього потрібно створити два "блокових" масиви $b$ і $c": один - для забезпечення змін на відрізку, інший - для відповіді на запити.

Можна навести приклади інших задач, до яких можна застосувати sqrt-декомпозицію. Наприклад, можна розв'язувати задачу про **підтримку множини чисел** з можливістю додавання/видалення чисел, перевірки числа на належність до множини, пошуку $k$-го за порядком числа. Для розв'язку цієї задачі потрібно зберігати числа в відсортованому порядку, розділені на декілька блоків по $\sqrt{n}$ чисел у кожному. При додаванні або видаленні числа потрібно буде виконувати "перебалансування" блоків, перенесення чисел з початку/кінця одних блоків на початок/кінець сусідніх блоків.

## Sqrt-декомпозиція вхідних запитів

Розглянемо тепер цілком інше застосування ідеї про декомпозицію sqrt.

Припустимо, що у нас є певна задача, в якій нам даються вхідні дані, а потім надходять $k$ команд/запитів, кожну з яких ми повинні обробити та відповісти. Ми розглядаємо випадок, коли запити можуть бути як запитуючими (не змінюють стану системи, а тільки запитують деяку інформацію), так і модифікуючими (тобто впливають на стан системи, спочатку заданий вхідними даними).

Конкретна задача може бути дуже складною, а "чесний" її розв'язок (який зчитує один запит, обробляє його, змінюючи стан системи, і повертає відповідь) може бути технічно складним або зовсім не під силу розв'язувача. З іншого боку, розв'язок "офлайнового" варіанту задачі, тобто коли відсутні модифікуючі операції, а є тільки запити - часто виявляється набагато простішим. Припустимо, що ми **вміємо розв'язувати "офлайновий" варіант** задачі, тобто будувати за деякий час $B(n)$ деяку структуру даних, яка може відповідати на запити, але не вміє обробляти модифікуючі запити.

Значить **розіб'ємо вхідні запити на блоки** (довжина яких - поки не уточнюється; позначимо цю довжину через $s$). На початку обробки кожного блоку будемо будувати структуру даних за допомогою $B(n)$ для "офлайнового" варіанту задачі на стані даних на момент початку цього блоку.

Тепер будемо по черзі брати запити з поточного блоку і обробляти кожний з них. Якщо поточний запит є модифікуючим, то пропустимо його. Якщо ж поточний запит є запитом на отримання даних, то звернемося до структури даних для офлайнового варіанту задачі, але перед цим **врахуємо всі модифікуючі запити у поточному блоку**. Таке врахування модифікуючих запитів може бути неможливим не завжди, і воно має відбуватися достатньо швидко - за час $O(s)$ або трохи гірше; позначимо цей час як $Q(s)$.

Таким чином, якщо у нас є $m$ запитів, то на їх обробку буде потрібно $B(m) \cdot \frac{m}{s} + m \cdot Q(s)$ часу. Величину $s$ слід вибирати, враховуючи конкретні функції $B()$ та $Q()$. Наприклад, якщо $B(m)=O(m)$ і $Q(s)=O(s)$, то оптимальним вибором буде $s \approx \sqrt{m}$, і підсумкова асимптотика становитиме $O(m \sqrt{m})$.

Оскільки наведені вище міркування є занадто абстрактними, наведемо декілька прикладів задач, до яких застосовна така sqrt-декомпозиція.

### Приклад виправленого тексту: додаток на відрізку

Умова задачі: дано масив чисел $a[1 \dots n]$, і надходять запити двох видів: дізнатися значення $i$-го елемента масиву, і додати деяке число $x$ до всіх елементів масиву в деякому відрізку $a[l \dots r]$.

Хоча цю задачу можна розв'язувати і без цього прийому з розбиттям запитів на блоки, ми наведемо її тут як найпростіше і найбільш наглядне застосування цього методу.

Отже, розіб'ємо вхідні запити на блоки по $\sqrt{m}$ (де $m$ - число запитів). На початку кожного блоку запитів будуємо структуру даних, що дозволяє виконувати запити для цього блоку. Для першого блоку це просто масив $a[]$. Потім обробляємо запити першого блоку. Якщо поточний запит - запит додавання, то додаємо відповідну величину до $a[i]$. Якщо ж поточний запит - запит читання значення в деякій позиції $i$, то відповідь буде $a[i]$. Після цього обробляємо всі пропущені запити додавання в цьому блоку, і для тих з них, в які потрапляє $i$, застосовуємо їх збільшення до поточної відповіді.

Таким чином, ми навчилися відповідати на запити за час $O(\sqrt{m})$.

Залишилося лише зазначити, що в кінці кожного блоку запитів ми повинні застосувати всі модифікуючі запити цього блоку до масиву $a[]$. Проте це легко зробити за $O(n)$ - достатньо для кожного запиту додавання $(l,r,x)$ відзначити в допоміжному масиві в точці $l$ число $x$, а в точці $r+1$ - число $-x$, і потім пройтися по цьому масиву, додаючи поточну суму до масиву $a[]$.

Таким чином, підсумкова асимптотика розв'язку складатиме $O(\sqrt{m} (n + m))$.

### Приклад задачі: disjoint-set-union з разделением

Є неорієнтований граф із $n$ вершинами та $m$ ребрами. Надходять запити трьох видів: додати ребро $(x_i,y_i)$, видалити ребро $(x_i,y_i)$ та перевірити, чи зв'язані вершини $x_i$ і $y_i$ шляхом.

Якщо б запити на видалення відсутні, то розв'язком задачі була б відома структура даних [диз'юнктивна множина (система, що не перетинаються множин)](dsu). Однак при наявності запитів на видалення задача значно ускладнюється.

Зробимо наступним чином. На початку кожного блоку запитів подивимося, які ребра в цьому блоку будуть видалятися, і одразу **видаляємо** їх з графа. Тепер побудуємо систему неперетинних множин (dsu) на отриманому графі.

Як ми повинні відповідати на наступний запит з поточного блоку? Наша система знає про всі ребра, крім тих, що додаються або видаляються в поточному блоку. Проте видалення з dsu вже не потрібно - ми заздалегідь видалили всі такі ребра з графа. Таким чином, все, що може бути, це додаткові ребра, яких може бути максимум $\sqrt{m}$ штук.

Отже, при відповіді на поточний запит ми можемо просто запустити обхід в ширину по компонентах зв'язності dsu, який відпрацює за $O(\sqrt{m})$, оскільки у нас в розгляді будуть тільки $O(\sqrt{m})$ ребра.

## Офлайнові задачі на запити на підвідрізках масиву та універсальна sqrt-евристика для них

Розглянемо ще одну цікаву варіацію ідеї декомпозиції за допомогою кореня sqrt.

Нехай у нас є задача, в якій є масив чисел, і надходять запити, які мають вигляд $(l,r)$ - дізнатися щось про підвідрізок $a[l \ldots r]$. Ми припускаємо, що запити не модифікують масив, і відомі заздалегідь, тобто задача є оффлайновою.

Нарешті, введемо останнє **обмеження**: ми припустимо, що вміємо швидко перераховувати відповідь на запит при зміні лівої або правої межі на одиницю. Тобто, якщо ми знали відповідь на запит $(l,r)$, то швидко зможемо порахувати відповідь на запит $(l+1,r)$ або $(l-1,r)$ або $(l,r+1)$ або $(l,r-1)$.

Опишемо тепер **універсальну евристику** для всіх таких задач. Відсортуємо запити за парами: $(\lfloor l / \sqrt{n} \rfloor, r)$. Тобто, ми відсортували запити за номером sqrt-блоку, в якому лежить лівий кінець, а при рівності - за правим кінцем.

Розглянемо тепер групу запитів з однаковим значенням $l ~ {\rm div} ~ \sqrt{n}$ і будемо обробляти всі запити цієї групи. Відповідь на перший запит порахуємо тривіальним чином. Кожен наступний запит будемо вважати на основі попередньої відповіді: тобто рухати ліву і праву межі попереднього запиту до границь наступного запиту, підтримуючи при цьому поточну відповідь. Оцінимо асимптотику: ліва межа кожного разу могла рухатися на не більше $\sqrt{n}$ раз, а права - не більше $n$ раз в сумі по всім запитам поточної групи. Разом, якщо поточна група складалася з $k$ запитів, то в сумі буде виконано не більше $n + k \cdot \sqrt{n}$ перерахунків. В сумі по всьому алгоритму вийде - $O((n + m) \cdot \sqrt{n})$ перерахунків.

Простим **прикладом** даної евристики є така задача: дізнатися кількість різних чисел у відрізку масиву $[l;r]$.

Чуть більш ускладненим варіантом цієї задачі є [задача з одного з раундів Codeforces](http://www.codeforces.com/contest/86/problem/D).