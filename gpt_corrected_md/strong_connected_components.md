# Пошук компонентів сильної зв'язності та побудова конденсації графа

## Означення та постановка задачі

Даний орієнтований граф $G$ з множиною вершин $V$ та множиною ребер $E$. Допускаються петлі та кратні ребра. Позначимо через $n$ кількість вершин у графі, а через $m$ - кількість ребер.

**Компонентою сильної зв'язності** (strongly connected component) називається така (максимальна за включенням) підмножина вершин $C$, що будь-які дві вершини цієї підмножини досяжні одна з одної, тобто для $\forall u,v \in C$:

$$
u \mapsto v, v \mapsto u
$$

де символом $\mapsto$ тут і далі ми будемо позначати досяжність, тобто існування шляху з першої вершини до другої.

Зрозуміло, що компоненти сильної зв'язності для даного графа не перетинаються, тобто фактично це розбиття всіх вершин графа. Звідси логічно визначення **конденсації** $G^{\rm SCC}$ як графа, що отримується з даного графа шляхом стиснення кожної компоненти сильної зв'язності в одну вершину. Кожній вершині графа конденсації відповідає компонента сильної зв'язності графа $G$, а орієнтоване ребро між двома вершинами $C_i$ і $C_j$ графа конденсації проводиться, якщо знайдеться пара вершин $u \in C_i, v \in C_j$, між якими існувало ребро в початковому графі, тобто $(u,v) \in E$.

Важливою властивістю графа конденсації є те, що він **ациклічний**. Дійсно, припустимо, що $C \mapsto C^\prime$, доведемо, що $C^\prime \not\mapsto C$. З визначення конденсації отримуємо, що знайдуться дві вершини $u \in C$ і $v \in C^\prime$, такі, що $u \mapsto v$. Доведемо від протилежного, тобто припустимо, що $C^\prime \mapsto C$, тоді знайдуться дві вершини $u^\prime \in C$ і $v^\prime \in C^\prime$, такі, що $v^\prime \mapsto u^\prime$. Але оскільки $u$ і $u^\prime$ знаходяться в одній компоненті сильної зв'язності, то між ними є шлях, аналогічно для $v$ і $v^\prime$. В результаті, об'єднавши шляхи, отримуємо, що $v \mapsto u$, і одночасно $u \mapsto v$. Отже, $u$ і $v$ повинні належати одній компоненті сильної зв'язності, тобто отримали протиріччя, що і потрібно довести.

Описаний нижче алгоритм виділяє в даному графі всі компоненти сильної зв'язності. Побудувати за ним граф конденсації не складе труднощів.

## Алгоритм

Описаний тут алгоритм був запропонований незалежно Косарюком (Косарай) і Шариром (Шарір) у 1979 році. Це дуже простий алгоритм, який базується на двох серіях [пошуків в глибину](dfs), і тому працює за час $O(n+m)$.

На першому кроці алгоритму виконується серія обходів в глибину, що відвідують весь граф. Для цього ми проходимося по всім вершинам графа і з кожної ще не відвіданої вершини викликаємо обхід в глибину. При цьому для кожної вершини $v$ запам'ятовується час виходу ${\rm tout}[v]$. Ці часи виходу відіграють ключову роль в алгоритмі, і ця роль виражена в наведеній нижче теоремі.

Спочатку введемо позначення: час виходу ${\rm tout}[C]$ з компоненти $C$ сильної зв'язності визначимо як максимум зі значень ${\rm tout}[v]$ для всіх $v \in C$. Крім того, у доведенні теореми будуть згадуватися часи входу в кожну вершину ${\rm tin}[v]$, і аналогічно визначимо часи входу ${\rm tin}[C]$ для кожної компоненти сильної зв'язності як мінімум зі значень ${\rm tin}[v]$ для всіх $v \in C$.

**Теорема**. Нехай $C$ і $C^\prime$ - дві різні компоненти сильної зв'язності, і нехай в графі конденсації між ними є ребро $(C,C^\prime)$. Тоді ${\rm tout}[C] > {\rm tout}[C^\prime]$.

При доведенні виникає два принципово різних випадки в залежності від того, в яку з компонент першої зайде обхід в глибину, тобто в залежності від співвідношення між ${\rm tin}(C)$ і ${\rm tin}(C^\prime)$:

* Першою була досягнута компонента $C$. Це означає, що в якийсь момент часу обхід в глибину заходить в деяку вершину $v$ компоненти $C$, при цьому всі інші вершини компонент $C$ і $C^\prime$ ще не відвідані. Але, згідно з умовою, в графі конденсації є ребро $(C,C^\prime)$, тому з вершини $v$ будуть досяжні не тільки всі вершини компоненти $C$, але й всі вершини компоненти $C^\prime$. Це означає, що при запуску з вершини $v$ обхід в глибину пройде по всім вершинам компонент $C$ і $C^\prime$, тому вони стануть нащадками відносно вершини $v$ в дереві обходу в глибину. Тобто для будь-якої вершини $u \in C \cup C^\prime$, $u \ne v$, буде виконано ${\rm tout}[v] > {\rm tout}[u]$, що і треба було довести.
* Першою була досягнута компонента $C'$. Знову ж таки, в якийсь момент часу обхід в глибину заходить у деяку вершину $v \in C'$, причому всі інші вершини компонент $C$ і $C'$ не відвідані. Оскільки за умовою в графі конденсації існувало ребро $(C,C')$, то, внаслідок ацикличності графа конденсацій, не існує зворотного шляху $C' \not\to C$, тобто обхід в глибину з вершини $v$ не досягне вершин $C$. Це означає, що вони будуть відвідані обходом в глибину пізніше, звідки й випливає ${\rm tout}[C] > {\rm tout}[C']$, що і треба було довести.

Доведена теорема є **основою алгоритму** пошуку компонент сильної зв'язності. З неї випливає, що будь-яке ребро $(C,C^\prime)$ в графі конденсації йде з компоненти з більшою величиною ${\rm tout}$ в компоненту з меншою величиною.

Якщо ми відсортуємо всі вершини $v \in V$ в порядку зменшення часу виходу ${\rm tout}[v]$, то першою виявиться деяка вершина $u$, що належить "кореневій" компоненті сильної зв'язності, тобто в яку не входить жодне ребро в графі конденсації. Тепер нам було б хотіло запустити такий обхід з цієї вершини $u$, що відвідає тільки цю компоненту сильної зв'язності і не зайде до жодної іншої; навчившись цього робити, ми зможемо поступово виділяти всі компоненти сильної зв'язності: видаливши з графа вершини першої виділеної компоненти, ми знову знайдемо серед залишилися вершину з найбільшою величиною ${\rm tout}$, знову запустимо з неї цей обхід, і т.д.

Щоб навчитися робити такий обхід, розглянемо **транспонований граф** $G^T$, тобто граф, отриманий з $G$ зміною напрямку кожного ребра на протилежний. Не складно зрозуміти, що в цьому графі будуть ті ж компоненти сильної зв'язності, що й у вихідному графі. Більше того, граф конденсації $(G^T)^{\rm SCC}$ для нього буде рівний транспонованому графу конденсації вихідного графа $G^{\rm SCC}$. Це означає, що тепер з розглянутої нами "кореневої" компоненти вже не будуть виходити ребра в інші компоненти.

Таким чином, щоб обійти усю "кореневу" компоненту сильної зв'язності, яка містить деяку вершину $v$, достатньо запустити обхід з вершини $v$ у графі $G^T$. Цей обхід відвідає всі вершини цієї компоненти сильної зв'язності і тільки їх. Як вже зазначалося, потім ми можемо вилучити ці вершини з графа, знайти чергову вершину з максимальним значенням ${\rm tout}[v]$ і запустити обхід на транспонованому графі з неї, і т.д.

Отже, ми побудували наступний алгоритм виділення компонент сильної зв'язності:

1 крок. Запустити послідовний обхід в глибину графа $G$, який повертає вершини в порядку збільшення часу виходу ${\rm tout}$, тобто деякий список $\rm order$.

2 крок. Побудувати транспонований граф $G^\intercal$. Запустити серію обходів у глибину/ширину цього графа в порядку, що визначається списком $\rm order$ (а саме, у зворотньому порядку, тобто в порядку зменшення часу виходу). Кожна множина вершин, досягнута в результаті чергового запуску обходу, буде черговою компонентою сильної зв'язності.

Асимптотика алгоритму, очевидно, дорівнює $O(n+m)$, оскільки він складається всього з двох обходів в глибину/ширину.

Нарешті, доцільно згадати про зв'язок з поняттям **[топологічного сортування](topological_sort)**. По-перше, крок 1 алгоритму є топологічним сортуванням графу $G$ (фактично, це означає сортування вершин за часом виходу). По-друге, сам алгоритм генерує компоненти сильної зв'язності в порядку зменшення їх часів виходу, тому він генерує компоненти - вершини графа конденсації в порядку топологічного сортування. Російське слово "конденсація" можна замінити на "скорочення".

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
vector<vector<int>> g, gr;
vector<char> used;
vector<int> order, component;

void dfs1(int v) {
    used[v] = true;
    for (size_t i = 0; i < g[v].size(); ++i)
        if (!used[g[v][i]])
            dfs1(g[v][i]);
    order.push_back(v);
}

void dfs2(int v) {
    used[v] = true;
    component.push_back(v);
    for (size_t i = 0; i < gr[v].size(); ++i)
        if (!used[gr[v][i]])
            dfs2(gr[v][i]);
}

int main() {
    int n;
    ... читання n... for (;;) {
        int a, b;
... читання наступного ребра (а, b)... g[a].push_back(b);
        gr[b].push_back(a);
    }

    used.assign(n, false);
    for (int i = 0; i < n; ++i)
        if (!used[i])
            dfs1(i);
    used.assign(n, false);
    for (int i = 0; i < n; ++i) {
        int v = order[n - 1 - i];
        if (!used[v]) {
            dfs2(v);
... наступний висновок компоненту... компонент.clear();
        }
    }
}
```

Тут у $\rm g$ зберігається сам граф, а $\rm gr$ - транспонований граф. Функція $\rm dfs1$ виконує обхід в глибину на графі $G$, функція $\rm dfs2$ - на транспонованому $G^T$. Функція $\rm dfs1$ заповнює список $\rm order$ вершинами в порядку збільшення часу виходу (фактично, робить топологічне сортування). Функція $\rm dfs2$ зберігає всі досягнуті вершини в списку $\rm component$, який після кожного запуску буде містити чергову компоненту сильної зв'язності.

## Література

* \book{Томас Кормен, Чарльз Лейзерсон, Рональд Рівест, Кліффорд Штайн}{Алгоритми: Побудова та аналіз}{2005}{cormen.djvu}
* \book{M. Sharir}{A strong-connectivity algorithm and its applications in data-flow
analysis}{1979}