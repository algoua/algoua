# Топологічне сортування

Даний орієнтований граф з $n$ вершинами та $m$ ребрами. Потрібно **перенумерувати** його вершини таким чином, щоб кожне ребро виходило з вершини з меншим номером до вершини з більшим.

Іншими словами, потрібно знайти перестановку вершин (**топологічний порядок**), яка відповідає порядку, заданому усіма ребрами графа.

Топологічне сортування може бути **не єдиним** (наприклад, якщо граф є порожнім; або якщо є три такі вершини $a$, $b$, $c$, що з $a$ є шлях до $b$ і до $c$, але ні з $b$ до $c$, ні з $c$ до $b$ дістатися не можна).

Топологічного сортування може **не існувати** зовсім - якщо граф містить цикли (оскільки тоді виникає протиріччя: є шлях із однієї вершини в іншу, і навпаки).

**Розповсюджена задача** на топологічне сортування - наступна. Є $n$ змінних, значення яких нам не відомі. Відомо лише про деякі пари змінних, що одна змінна менше іншої. Потрібно перевірити, чи не суперечливі ці нерівності, і якщо ні, вивести змінні в порядку їх зростання (якщо рішень декілька - вивести будь-яке). Легко помітити, що це в точності є задача про пошук топологічного сортування в графі з $n$ вершин.

## Алгоритм

Для розв'язання скористаємось [пошуком в глибину](dfs).

Припустимо, що граф є ациклічним, тобто розв'язок існує. Що робить обхід в глибину? При запуску з деякої вершини $v$ він намагається пройтися вздовж усіх ребер, що виходять з $v$. Вздовж тих ребер, кінці яких вже були відвідані раніше, він не проходить, а вздовж усіх інших - проходить і викликає собі від їх кінців.

Таким чином, до моменту виходу з виклику ${\rm dfs}(v)$ всі вершини, досяжні з $v$ як безпосередньо (через одне ребро), так і опосередковано (по шляхах) - всі такі вершини вже відвідані обходом. Отже, якщо ми будемо в момент виходу з ${\rm dfs}(v)$ додавати нашу вершину на початок якогось списку, то в кінці кінців у цьому списку вийде **топологічне сортування**.

Ці пояснення можна уявити і в декількох інших світах, з використанням поняття "часу виходу" при обході в глибину. Час виходу для кожної вершини $v$ - це момент часу, коли закінчився виклик ${\rm dfs}(v)$ під час обходу в глибину від неї (часи виходу можна занумерувати від $1$ до $n$). Легко зрозуміти, що під час обходу в глибину час виходу з будь-якої вершини $v$ завжди більший, ніж час виходу з усіх вершин, досяжних з неї (тобто вони були відвідані до виклику ${\rm dfs}(v)$ або під час нього). Таким чином, шукане топологічне сортування - це сортування в порядку зменшення часів виходу.

## Реалізація

Наведемо реалізацію, що передбачає, що граф є ациклічним, тобто шукане топологічне сортування існує. При необхідності перевірки графа на ациклічність легко вставити в обхід в глибину, як описано в [статті про обхід в глибину](dfs).

<!--- TODO: specify code snippet id -->
``` cpp
кількість вершин: int n;
vector<int> g[MAXN]; // граф
bool used[MAXN];
vector<int> ans;

void dfs(int v) {
    used[v] = true;
    for (size_t i = 0; i < g[v].size(); ++i) {
        int to = g[v][i];
        if (!used[to])
            dfs(to);
    }
    ans.push_back(v);
}

void topological_sort() {
    for (int i = 0; i < n; ++i)
        used[i] = false;
    ans.clear();
    for (int i = 0; i < n; ++i)
        if (!used[i])
            dfs(i);
    reverse(ans.begin(), ans.end());
}
```

Тут потрібно задати константу $\rm MAXN$, яка буде рівна максимально можливій кількості вершин у графі.

Основна функція розв'язку - це `topological_sort()`. Вона ініціалізує помітки обходу в глибину, запускає його, і відповідь в підсумку виходить у векторі `ans`.

## Завдання в онлайн-суддях

Список задач, в яких потрібно шукати топологічне сортування:

* [UVA #10305 **"Ordering Tasks"** [складність: низька]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1246)

* [UVA #124 **"Following Orders"** [складність: низька]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=60)

* [UVA #200 **"Rare Order"** [складність: низька]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=136)