# Алгоритм Едмондса призначений для знаходження найбільшого паросполука у довільних графах

Даний неорієнтований незважений граф $G$ з $n$ вершинами. Потрібно знайти в ньому найбільшу паросполучення, тобто таку найбільшу (за потужністю) множину $m$ його ребер, що жодні два ребра з обраної множини не є інцидентними одне до одного (тобто не мають спільних вершин).

На відміну від випадку двудольного графа (див. [Алгоритм Куна](https://uk.wikipedia.org/wiki/Алгоритм_Куна)), у графі $G$ можуть бути цикли непарної довжини, що значно ускладнює пошук збільшуючих шляхів.

Наведемо спочатку теорему Бержа, згідно з якою, так само як і в випадку двудольних графів, найбільшу паросполученість можна знайти за допомогою збільшення шляхів.

## Збільшуючі шляхи. Теорема Берґа

Нехай зафіксовано деякий паросполуcк $M$. Тоді простий ланцюг $P = (v_1, v_2, \ldots, v_k)$ називається чергуючим ланцюгом, якщо в ньому ребра по черзі належать - не належать паросполуcку $M$. Чергуючий ланцюг називається збільшуючим, якщо його перша і остання вершини не належать паросполуcку. Іншими словами, простий ланцюг $P$ є збільшуючим тоді і тільки тоді, коли вершина $v_1 \notin M$, ребро $(v_2,v_3) \notin M$, ребро $(v_4,v_5) \notin M$, ..., ребро $(v_{k-2},v_{k-1}) \notin M$, і вершина $v_k \notin M$.

\img{edmonds_1.png}

Теорема Бержа (Клод Берж, 1957 р.). Паросочетання $M$ є найбільшим тоді й тільки тоді, коли для нього не існує збільшуючих ланцюгів.

**Доведення необхідності**. Нехай для паросполучення $M$ існує збільшувальний ланцюг $P$. Покажемо, як перейти до паросполучення більшої потужності. Виконаємо чергування паросполучення $M$ уздовж цього ланцюга $P$, тобто включимо до паросполучення ребра $(v_1,v_2)$, $(v_3,v_4)$, ..., $(v_{k-1},v_k)$, і видалимо з паросполучення ребра $(v_2,v_3)$, $(v_4,v_5)$, ..., $(v_{k-2},v_{k-1})$. В результаті очевидно буде отримано коректне паросполучення, потужність якого буде на одиницю більшою, ніж у паросполучення $M$ (тобто ми додали $k/2$ ребер, а видалили $k/2-1$ ребро).

**Доведення достатності**. Нехай для паросполучення $M$ не існує збільшуючих ланцюгів, доведемо, що воно є найбільшим. Нехай $\overline{M}$ - найбільше паросполучення. Розглянемо симетричну різницю $\overline{G} = M \oplus \overline{M}$ (тобто множину ребер, що належать або $M$, або $\overline{M}$, але не обома одночасно). Покажемо, що $\overline{G}$ містить однакову кількість ребер з $M$ і $\overline{M}$ (тобто ми виключили з $\overline{G}$ тільки спільні для них ребра, тому звідси буде дотримуватися і $|M| = |\overline{M}|$). Зауважимо, що $\overline{G}$ складається тільки з простих ланцюгів і циклів (тобто інакше одній вершині були б інцидентні одразу два ребра якого-небудь паросполучення, що неможливо). Далі, цикли не можуть мати непарну довжину (з тієї ж причини). Ланцюг в $\overline{G}$ також не може мати непарну довжину (інакше він був би збільшуючим ланцюгом для $M$, що суперечить умові, або для $\overline{M}$, що суперечить його максимальності). Нарешті, в парних циклах і ланцюгах парної довжини в $\overline{G}$ ребра по черзі входять в $M$ і $\overline{M}$, що і означає, що в $\overline{G}$ входить однакова кількість ребер від $M$ і $\overline{M}$. Як вже згадувалося вище, звідси випливає, що $|M| = |\overline{M}|$, тобто $M$ є найбільшим паросполученням.

Теорема Бержа надає основу для алгоритму Едмондса - пошук збільшуючих ланцюгів і чергування уздовж них, доки знаходяться збільшуючі ланцюги.

## Алгоритм Едмондса. Стиснення квіток

Основна проблема полягає в тому, як знайти найкоротший шлях. Якщо в графі є цикли непарної довжини, то просто запускати обхід в глибину/ширину не можна.

Можна привести простий контрприклад, коли під час запуску з однієї з вершин алгоритм, який не обробляє особливо цикли непарної довжини (фактично, [Алгоритм Куна](https://uk.wikipedia.org/wiki/Алгоритм_Куна)) не знайде збільшуючий шлях, хоча повинен. Це цикл довжини 3 з висячим на ньому ребром, тобто граф 1-2, 2-3, 3-1, 2-4, і ребро 2-3 взято в паросполучення. Значить, при запуску з вершини 1, якщо обхід піде спочатку в вершину 2, то він "упрямиться" в вершину 3, замість того, щоб знайти збільшуючий ланцюг 1-3-2-4. Правда, на цьому прикладі при запуску з вершини 4 алгоритм Куна все ж знайде цей збільшуючий ланцюг.

\img{edmonds_2.png}

Тим не менш, можна побудувати граф, на якому при певному порядку в списках суміжності алгоритм Куна зайде в тупик. Наприклад, таким графом з 6 вершинами і 7 ребрами є: 1-2, 1-6, 2-6, 2-4, 4-3, 1-5, 4-5. Якщо застосувати тут алгоритм Куна, то він знайде паросполучення 1-6, 2-4, після чого він повинен буде знайти збільшуючий ланцюг 5-1-6-2-4-3, але можливо не знайде його (якщо з вершини 5 він спочатку піде в 4, а потім в 1, а при запуску з вершини 3 він з вершини 2 піде спочатку в 1, а потім в 6).

\img{edmonds_3.png}

Як ми бачимо з цього прикладу, проблема полягає в тому, що при потраплянні в цикл непарної довжини, обхід може піти в неправильному напрямку. Насправді, нас цікавлять лише "насичені" цикли, тобто ті, в яких є $k$ насичених ребер, де довжина циклу дорівнює $2k+1$. У такому циклі є рівно одна вершина, яка не має насичених ребер цього циклу. Ми називаємо її **базою** (base). До базової вершини підходить чергування шляхів парної (можливо, нульової) довжини, що починається в вільній (тобто не належить паросполученню) вершині. Цей шлях називається **стеблом** (stem). Нарешті, підграф, утворений "насиченим" непарним циклом, називається **квіткою** (blossom).

\img{edmonds_4.png}

Ідея алгоритму Едмондса (Джек Едмондс, 1965 р.) полягає в **стисненні квіток** (зменшенні бутона). Стиснення квітки передбачає зведення всіх непарних циклів до однієї псевдо-вершини (відповідно, всі ребра, що інцидентні вершинам цього циклу, стають інцидентними псевдо-вершині). Алгоритм Едмондса знаходить всі квіти в графі, зводить їх, після чого в графі не залишається "поганих" циклів непарної довжини, і на такому графі (називається "поверхневим" (surface) графом) можна вже шукати збільшувальні ланцюги простим обходом в глибину/ширину. Після знаходження збільшувальних ланцюгів в поверхневому графі необхідно "розгорнути" квіти, відновивши тим самим збільшувальний ланцюг в вихідному графі.

Однак неочевидно, що після стиснення квітки не порушиться структура графа, а саме, що якщо в графі $G$ існував збільшуючий ланцюг, то він існує і в графі $\overline{G}$, отриманому після стиснення квітки, і навпаки.

Теорема Едмондса. У графі $\overline G$ існує збільшуючий ланцюг тоді і лише тоді, коли існує збільшуючий ланцюг у $G$.

**Доведення**. Отже, нехай граф $\overline G$ був отриманий з графа $G$ стисненням однієї квітки (позначимо через $B$ цикл квітки, а через $\overline B$ відповідну стислу вершину). Доведемо твердження теореми. На початку зауважимо, що достатньо розглядати випадок, коли база квітки є вільною вершиною (не належить жодній парі вершин). Дійсно, в іншому випадку в базі квітки закінчується чергуючийся шлях парної довжини, що починається в вільній вершині. Помінявши місцями вершини в парах уздовж цього шляху, потужність паросполучення не зміниться, а база квітки стане вільною вершиною. Отже, при доведенні можна вважати, що база квітки є вільною вершиною.

**Доведення необхідності**. Нехай шлях $P$ збільшується в графі $G$. Якщо він не проходить через $B$, то очевидно, він буде збільшуватись і в графі $\overline G$. Нехай $P$ проходить через $B$. Тоді можна, не втрачаючи загальності, вважати, що шлях $P$ складається з деякого шляху $P_1$, який не проходить через вершину $B$, та деякого шляху $P_2$, який проходить через вершину $B$ і, можливо, інші вершини. Але тоді шлях $P_1 + \overline{B}$ буде збільшуватись як шлях в графі $\overline G$, що і потрібно довести.

**Доведення достатності**. Нехай шлях $\overline{P}$ збільшується в графі $\overline{G}$. Якщо шлях $\overline{P}$ не проходить через вершину $\overline{B}$, то шлях $\overline{P}$ без змін є збільшуємим шляхом в $G$, тому ми не будемо розглядати цей випадок.

Розглянемо окремо випадок, коли $\overline P$ починається зі скороченої квітки $\overline Б$, тобто має вигляд $(\overline Б, с, \ldots)$. Отже, в квітці $Б$ знайдеться відповідна вершина $v$, яка пов'язана (ненасиченим) ребром з $с$. Залишається тільки зауважити, що з бази квітки завжди знайдеться чергуючийся шлях парної довжини до вершини $v$. Беручи до уваги все вищезазначене, отримуємо, що шлях $P = (б, \ldots, v, с, ..)$ є збільшуючим шляхом в графі $G$.

Нехай тепер шлях $\overline P$ проходить через псевдовершину $\overline B$, але не починається і не закінчується в ній. Значить, в $\overline P$ є два ребра, що проходять через $\overline B$. Нехай це будуть $(a, \overline B)$ і $(\overline B, c)$. Одне з них обов'язково має належати паросполученню $M$. Однак, оскільки база квітки не насичена, а всі інші вершини циклу квітки $B$ насичені ребрами циклу, то ми приходимо до протиріччя. Таким чином, цей випадок просто неможливий.

Отже, ми розглянули всі випадки і в кожному з них довели справедливість теореми Едмондса.

Загальна схема алгоритму Едмондса має наступний вигляд:

<!--- TODO: specify code snippet id -->
``` cpp
void edmonds() {
    for (int i = 0; i < n; ++i)
Якщо (вершина i не належить до паросполуку) {
            int last_v = find_augment_path(i);
            if (last_v != -1)
Виконати чергування уздовж шляху з і в last_v;
        }
}

int find_augment_path(int root) {
Обхід у ширину: int v = поточна_вершина;
Перебрати всі ребра з вершини v. Якщо знайдено цикл непарної довжини, його потрібно стиснути. Якщо потрапили в вільну вершину, повернути результат. Якщо потрапили в зайняту вершину, додати в чергу суміжну з нею в паросполуці і повернути -1
}
```

## Ефективна реалізація

Відразу оцінимо асимптотику. Усього є $n$ ітерацій, на кожній з яких виконується обхід в ширину за $O(m)$, крім того, можуть відбуватися операції стиснення квітів - їх може бути $O(n)$. Таким чином, якщо ми навчимося стискати квітку за $O(n)$, то загальна асимптотика алгоритму складатиме $O(n \cdot (m + n^2)) = O(n^3)$.

Основною складністю є операції стиснення квіток. Якщо виконувати їх, об'єднавши списки суміжності в один і видаливши зайві вершини з графа, то асимптотика стиснення однієї квітки буде $O(m)$. Крім того, виникнуть складнощі при "розгортанні" квіток.

Замість цього, для кожної вершини графа $G$ ми будемо зберігати вказівник на базу квітки, до якої вона належить (або на собі, якщо вершина не належить жодній квітці). Нам потрібно вирішити дві задачі: стиснення квітки за $O(n)$ при її виявленні, а також зручне зберігання всієї інформації для подальшого чергування вздовж збільшуваних шляхів.

Отже, одна ітерація алгоритму Едмондса представляє собою обхід в ширину, що виконується з заданої вільної вершини $\rm root$. Поступово буде будуватися дерево обходу в ширину, причому шлях до будь-якої вершини в ньому буде бути чергуючимся шляхом, що починається зі вільної вершини $\rm root$. Для зручності програмування будемо класти до черги тільки ті вершини, відстань до яких в дереві шляхів парна (будемо називати такі вершини парними - тобто це корінь дерева, і другі кінці ребер у паросполученні). Саме дерево будемо зберігати у вигляді масиву предків $\rm p[]$, в якому для кожної непарної вершини (тобто до якої відстань в дереві шляхів непарна, тобто це перші кінці ребер у паросполученні) будемо зберігати предка - парну вершину. Таким чином, для відновлення шляху з дерева нам потрібно по черзі користуватися масивами $\rm p[]$ і $\rm match[]$, де $\rm match[]$ - для кожної вершини містить суміжну з нею в паросполученні, або $-1$, якщо такої немає.

Тепер стає зрозуміло, як виявляти цикли непарної довжини. Якщо ми з поточної вершини $v$ під час обходу в ширину приходимо в таку вершину $u$, що є коренем $\rm root$ або належить паросполуці та дереву шляхів (тобто $\rm p[match[]]$ від якої не дорівнює -1), то ми виявили квітку. Дійсно, при виконанні цих умов і вершини $v$ і $u$ є парними вершинами. Відстань від них до їх найменшого загального предка має одну парність, тому знайдений нами цикл має непарну довжину.

Навчимося **стискувати цикл**. Отже, ми виявили непарний цикл при розгляді ребра $(v,u)$, де $u$ і $v$ - парні вершини. Знайдемо їх найменшого спільного предка $b$, він і буде базою квітки. Неважко замітити, що база також є парною вершиною (оскільки у непарних вершин в дереві шляхів є тільки один нащадок). Однак треба замітити, що $b$ - це, можливо, псевдовершина, тому ми фактично знайдемо базу квітки, що є найменшим спільним предком вершин $v$ і $u$. Реалізуємо зразу знаходження найменшого спільного предка (нас цілком задовольняє асимптотика $O(n)$):

<!--- TODO: specify code snippet id -->
``` cpp
int lca(int a, int b) {
    bool used[MAXN] = {0};
// Піднімаємось від вершини a до кореня, позначаючи всі парні вершини
    for (;;) {
        a = base[a];
        used[a] = true;
        if (match[a] == -1)
break; // дійшли до кореня
        a = p[match[a]];
    }
Піднімаємось від вершини b, доки не знайдемо позначену вершину
    for (;;) {
        b = base[b];
        if (used[b])
            return b;
        b = p[match[b]];
    }
}
```

Тепер нам потрібно виявити сам цикл - пройтися від вершини $v$ і $u$ до бази $b$ квітки. Буде зручніше, якщо ми поки просто позначимо в якомусь спеціальному масиві (назвемо його $\rm blossom[]$) вершини, що належать поточній квітці. Після цього нам потрібно буде симулювати обхід в ширину з псевдовершини - для цього достатньо покласти в чергу обходу в ширину всі вершини, що лежать на циклі квітки. Тим самим ми уникнемо явного з'єднання списків суміжності.

Однак залишається ще одна проблема: коректне відновлення шляхів після закінчення обходу в ширину. Для цього ми зберігали масив предків $\rm p[]$. Але після стиснення квіток виникає єдина проблема: обхід в ширину продовжився зразу з усіх вершин циклу, в тому числі й непарних, а масив предків ми використовували для відновлення шляхів по парних вершинах. Більше того, коли в стислому графі знайдеться збільшуючий ланцюг, що проходить через квітку, вона взагалі буде проходити по цьому циклу в такому напрямку, що в дереві шляхів це буде представлено рухом вниз. Однак всі ці проблеми елегантно вирішуються таким маневром: при стисканні циклу, ми проставляємо предків для всіх його парних вершин (крім бази), щоб ці "предки" вказували на сусідню вершину в циклі. Для вершин $u$ і $v$, якщо вони також не база, направляємо вказівники предків один на одного. В результаті, якщо під час відновлення збільшуючих шляхів ми прийдемо в цикл квітки в непарну вершину, шлях по предкам буде відновлено правильно і приведе до бази квітки (з якої він вже далі буде відновлюватись нормально).

\img{edmonds_5.png}

Отже, ми готові реалізувати стиснення квітки:

<!--- TODO: specify code snippet id -->
``` cpp
int v; 
int u; // ребро (v,u), під час розгляду якого була знайдена квітка
int b = lca(v, u);
memset(blossom, 0, sizeof blossom);
mark_path(v, b, u);
mark_path(u, b, v);
```

де функція $\rm mark\_path()$ проходить по шляху від вершини до бази квітки, проставляє в спеціальному масиві $\rm blossom[]$ для них $\rm true$ і проставляє предків для парних вершин. Параметр $\rm children$ - син для самої вершини $v$ (за допомогою цього параметра ми замкнемо цикл в предках).

<!--- TODO: specify code snippet id -->
``` cpp
void mark_path(int v, int b, int children) {
    while (base[v] != b) {
        blossom[base[v]] = blossom[base[match[v]]] = true;
        p[v] = children;
        children = match[v];
        v = p[match[v]];
    }
}
```

Нарешті, реалізуємо основну функцію - $\rm find\_path~(int~root)$, яка буде шукати збільшуючий шлях з вільної вершини $\rm root$ і повертати останню вершину цього шляху, або $-1$, якщо збільшуючий шлях не знайдений.

На початку зробимо ініціалізацію:

<!--- TODO: specify code snippet id -->
``` cpp
int find_path(int root) {
    memset(used, 0, sizeof used);
    memset(p, -1, sizeof p);
    for (int i = 0; i < n; ++i)
        base[i] = i;
```

Далі йде обхід у ширину. Розглядаючи наступну ребро $(v, to)$, у нас є кілька варіантів:

* Ребро, якого не існує. Під цим ми розуміємо, що $v$ і $to$ належать одній стисненій псевдо-вершині (${\rm base}[v] == {\rm base}[to]$), тому в поточному поверхневому графі цього ребра немає. Крім цього випадку, є ще один: коли ребро $(v, to)$ вже належить поточному паросполученню; тобто ми припускаємо, що вершина $v$ є парною вершиною, тоді прохід по цьому ребру означає в дереві шляхів підйом до предка вершини $v$, що неприпустимо.

<!--- TODO: specify code snippet id -->
``` cpp
if (base[v] == base[to] || match[v] == to)
    continue;
```

* Ребро утворює цикл непарної довжини, тобто утворюється квітка. Як уже згадувалося вище, цикл непарної довжини виникає при виконанні умови:

<!--- TODO: specify code snippet id -->
``` cpp
if (to == root || match[to] != -1 && p[match[to]] != -1)```

У цьому випадку потрібно стиснути квітку. Раніше ми детально розглянули цей процес, тому тут наведемо його реалізацію:

<!--- TODO: specify code snippet id -->
``` cpp
int curbase = lca(v, to);
memset(blossom, 0, sizeof blossom);
mark_path(v, curbase, to);
mark_path(to, curbase, v);
for (int i = 0; i < n; ++i)
    if (blossom[base[i]]) {
        base[i] = curbase;
        if (!used[i]) {
            used[i] = true;
            q[qt++] = i;
        }
    }
```

* Інакше - це "звичайне" ребро, і ми діємо так само, як і в звичайному пошуку в ширину. Єдина тонкість полягає в тому, що при перевірці, чи відвідали ми цю вершину раніше, ми повинні перевіряти не масив $\rm used$, а масив $p$, оскільки саме він заповнюється для відвіданих непарних вершин. Якщо ми ще не відвідали вершину $to$, і вона ще не має пари, то ми знайшли збільшуючий ланцюг, що закінчується на вершині $to$, і повертаємо її.

<!--- TODO: specify code snippet id -->
``` cpp
if (p[to] == -1) {
    p[to] = v;
    if (match[to] == -1)
        return to;
    to = match[to];
    used[to] = true;
    q[qt++] = to;
}
```

Отже, повна реалізація функції $\rm знайти\_шлях()$:

<!--- TODO: specify code snippet id -->
``` cpp
int find_path(int root) {
    memset(used, 0, sizeof used);
    memset(p, -1, sizeof p);
    for (int i = 0; i < n; ++i)
        base[i] = i;

    used[root] = true;
    int qh=0, qt=0;
    q[qt++] = root;
    while (qh < qt) {
        int v = q[qh++];
        for (size_t i=0; i<g[v].size(); ++i) {
            int to = g[v][i];
            if (base[v] == base[to] || match[v] == to)
    continue;
            if (to == root || match[to] != -1 && p[match[to]] != -1){
                int curbase = lca (v, to);
                memset (blossom, 0, sizeof blossom);
                mark_path (v, curbase, to);
                mark_path (to, curbase, v);
                for (int i=0; i<n; ++i)
                    if (blossom[base[i]]) {
                        base[i] = curbase;
                        if (!used[i]) {
                            used[i] = true;
                            q[qt++] = i;
                        }
                    }
            }
            else if (p[to] == -1) {
                p[to] = v;
                if (match[to] == -1)
                    return to;
                to = match[to];
                used[to] = true;
                q[qt++] = to;
            }
        }
    }
    return -1;
}
```

Нарешті, наведемо визначення всіх глобальних масивів та реалізацію основної програми знаходження найбільшого паросполуку

<!--- TODO: specify code snippet id -->
``` cpp
константа int MAXN = ..., що відповідає за максимально можливу кількість вершин у вхідному графі

int n;
vector<int> g[MAXN];
int match[MAXN], p[MAXN], base[MAXN], q[MAXN];
bool used[MAXN], blossom[MAXN];

...

    int
    main() {
...читання графу...

        memset(match, -1, sizeof match);
    for (int i = 0; i < n; ++i)
        if (match[i] == -1) {
            int v = find_path(i);
            while (v != -1) {
                int pv = p[v], ppv = match[pv];
                match[v] = pv, match[pv] = v;
                v = ppv;
            }
        }
}
```

## Оптимізація: попередня побудова паросполуки

Як і у випадку [Алгоритму Куна](https://uk.wikipedia.org/wiki/Алгоритм_Куна), перед виконанням алгоритму Едмондса можна скористатися якимось простим алгоритмом для побудови початкового паросполучення. Наприклад, можна скористатися жадібним алгоритмом:
<!--- TODO: specify code snippet id -->
``` cpp
for (int i = 0; i < n; ++i)
    if (match[i] == -1)
        for (size_t j = 0; j < g[i].size(); ++j)
            if (match[g[i][j]] == -1) {
                match[g[i][j]] = i;
                match[i] = g[i][j];
                break;
            }
```

Така оптимізація значно (до декількох разів) прискорить роботу алгоритму на випадкових графах.

## Випадок двудольного графа

У двудольних графах відсутні цикли непарної довжини, тому код, що виконує стиснення квіток, ніколи не буде виконуватись. Якщо видалити всі частини коду, що обробляють стиснення квіток, то отримаємо [алгоритм Куна](kuhn_matching) практично в чистому вигляді. Таким чином, на двудольних графах алгоритм Едмондса дегенерується в [алгоритм Куна](kuhn_matching) і працює за $O(nm)$.

## Далішня оптимізація

У всіх описаних операціях з квітами легко помітити операції з неперетинними множинами, які можна виконувати набагато ефективніше (див. [Система неперетинних множин](dsu)). Якщо переписати алгоритм з використанням цієї структури, то асимптотика алгоритму зменшиться до $O(n m)$. Таким чином, для будь-яких графів ми отримали ту саму асимптотичну оцінку, що і в випадку двудольних графів (алгоритм Куна), але помітно більш складним алгоритмом.