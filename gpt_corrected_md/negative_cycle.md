# Знаходження від'ємного циклу в графі

Даний орієнтований зважений граф $G$ з $n$ вершинами і $m$ ребрами. Потрібно знайти в ньому будь-який **цикл з від'ємною вагою**, якщо такий існує.

При іншій постановці задачі потрібно знайти **усі пари вершин**, між якими існує шлях довільної довжини.

Ці дві варіанти задачі зручно розв'язувати за допомогою різних алгоритмів, тому нижче будуть розглянуті обидва з них.

Одна з поширених "життєвих" постановок цієї задачі - наступна: відомі **курси валют**, тобто курси обміну з однієї валюти на іншу. Потрібно дізнатися, чи можна за допомогою деякої послідовності обмінів отримати вигоду, тобто починаючи з однієї одиниці деякої валюти, отримати в підсумку більше, ніж одну одиницю цієї ж валюти.

## Розв'язок за допомогою алгоритму Форда-Беллмана

Алгоритм Форда-Беллмана (Ford-Bellman) дозволяє перевірити наявність або відсутність циклу з від'ємною вагою в графі, а при його наявності - знайти один з таких циклів.

Не будемо тут заходити у подробиці, описані в [статті про алгоритм Форда-Беллмана](ford_bellman), а наведемо лише підсумок – як працює алгоритм.

Робиться $n$ ітерацій алгоритму Форда-Беллмана, і якщо на останній ітерації не відбулося жодних змін – то негативного циклу в графі немає. У іншому випадку візьмемо вершину, відстань до якої змінилася, і будемо йти від неї по предкам, поки не зайдемо в цикл; цей цикл і буде шуканим негативним циклом.

**Реалізація**:

<!--- TODO: specify code snippet id -->
``` cpp
struct edge {
    int a, b, cost;
};

int n, m;
vector<edge> e;
const int INF = 1000000000;

void solve() {
    vector<int> d(n);
    vector<int> p(n, -1);
    int x;
    for (int i = 0; i < n; ++i) {
        x = -1;
        for (int j = 0; j < m; ++j)
            if (d[e[j].b] > d[e[j].a] + e[j].cost) {
                d[e[j].b] = max(-INF, d[e[j].a] + e[j].cost);
                p[e[j].b] = e[j].a;
                x = e[j].b;
            }
    }

    if (x == -1)
        cout << "No negative cycle found.";
    else {
        int y = x;
        for (int i = 0; i < n; ++i)
            y = p[y];

        vector<int> path;
        for (int cur = y;; cur = p[cur]) {
            path.push_back(cur);
            if (cur == y && path.size() > 1)
                break;
        }
        reverse(path.begin(), path.end());

        cout << "Negative cycle: ";
        for (size_t i = 0; i < path.size(); ++i)
            cout << path[i] << ' ';
    }
}
```

## Розв'язок за допомогою алгоритму Флойда-Уоршелла

Алгоритм Флойда-Уоршелла дозволяє розв'язувати одну постановку задачі - коли потрібно знайти всі пари вершин $(i,j)$, між якими немає найкоротшого шляху (тобто він має нескінченно велику величину).

Знову ж, більш детальні пояснення містяться в [описі алгоритму Флойда-Уоршелла](floyd_warshall_algorithm), а тут ми наведемо лише підсумок.

Після того, як алгоритм Флойда-Уоршелла відпрацює для вхідного графа, переберемо всі пари вершин $(i,j)$ і для кожної такої пари перевіримо, чи існує найкоротший шлях з $i$ в $j$, який є нескінченно малим. Для цього переберемо третю вершину $t$, і якщо для неї виявилося $d[t][t]<0$ (тобто вона лежить в циклі негативної ваги), а сама вона досяжна з $i$ і з неї досяжна $j$, то шлях $(i,j)$ може мати нескінченно малу довжину.

**Реалізація**:

<!--- TODO: specify code snippet id -->
``` cpp
for (int i = 0; i < n; ++i)
    for (int j = 0; j < n; ++j)
        for (int t = 0; t < n; ++t)
            if (d[i][t] < INF && d[t][t] < 0 && d[t][j] < INF)
                d[i][j] = -INF;
```

## Завдання в онлайн-суддях

Список задач, в яких потрібно шукати цикли від'ємної ваги:

* [UVA #499 **"Wormholes"** [складність: низька]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=499)

* [UVA #104 **"Arbitrage"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=40)

* [UVA #10557 **"XYZZY"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1498)