# Задача Йосипа

Умова задачі. Дано натуральні $n$ і $k$. За колом выписують всі натуральні числа від 1 до $n$. Спочатку відлічується $k$-е число, починаючи з першого, і воно видаляється. Потім від нього відлічується $k$ чисел і $k$-е видаляється, і т.д. Процес зупиняється, коли залишається одне число. Потрібно знайти це число.

Задача була поставлена **Йосифом Флавієм** ще в 1-му столітті (правда, у декілька більш конкретному формулюванні: при $k = 2$).

Розв'язувати цю задачу можна моделированием. Простейшее моделирование буде працювати $O(n^2)$. Використовуючи [Дерево відрізків](segment_tree), можна провести моделирование за $O(n \log n)$.

## Розв'язок з $O(n)$

Спробуємо знайти закономірність, яка виражає відповідь для задачі $J_{n,k}$ через розв'язок попередніх задач.

За допомогою моделювання побудуємо таблицю значень, наприклад, таку:

$$
\bordermatrix {
n \setminus k&1&2&3&4&5&6&7&8&9&10 \cr
1&1&1&1&1&1&1&1&1&1&1& \cr
2&2&1&2&1&2&1&2&1&2&1& \cr
3&3&3&2&2&1&1&3&3&2&2& \cr
4&4&1&1&2&2&3&2&3&3&4& \cr
5&5&3&4&1&2&4&4&1&2&4& \cr
6&6&5&1&5&1&4&5&3&5&2& \cr
7&7&7&4&2&6&3&5&4&7&5& \cr
8&8&1&7&6&3&1&4&4&8&7& \cr
9&9&3&1&1&8&7&2&3&8&8& \cr
10&10&5&4&5&3&3&9&1&7&8& \cr
}
$$

І тут досить чітко видна наступна **закономірність**:

$$
J_{n,k} = \left( J_{(n-1),k} + k - 1 \right)\ \%\ n + 1
$$

$$
J_{1,k} = 1
$$

Тут 0-індексація декілька покращує елегантність формули. Якщо нумерувати позиції з нуля, то вийде дуже зрозуміла формула:

$$
J_{n,k} = \left( J_{(n-1),k} + k \right)\ \%\ n = \sum_{i=1}^n k\ \%\ i
$$

Отже, ми знайшли розв'язок задачі Йосипа, який працює за $O(n)$ операцій.

Проста **рекурсивна реалізація** (з 1-індексацією):
<!--- TODO: specify code snippet id -->
``` cpp
int joseph(int n, int k) { return n > 1 ? (joseph(n - 1, k) + k - 1) % n + 1 : 1; }
```

**Нерекурсивная форма**:
<!--- TODO: specify code snippet id -->
``` cpp
int joseph(int n, int k) {
    int res = 0;
    for (int i = 1; i <= n; ++i)
        res = (res + k) % i;
    return res + 1;
}
```

## Розв'язок з $O(k \log n)$

Для порівняно невеликих $k$ можна придумати більш оптимальний розв'язок, ніж розглянутий вище рекурсивний розв'язок за $O(n)$. Якщо $k$ невелике, то навіть інтуїтивно зрозуміло, що той алгоритм робить багато зайвих дій: серйозні зміни відбуваються тільки тоді, коли відбувається взяття за модулем $n$, а до цього моменту алгоритм просто декілька разів додає до відповіді число $k$. Відповідно, можна позбутися цих непотрібних кроків

Невелика складність, що виникає при цьому, полягає в тому, що після видалення цих чисел у нас вийде задача з меншим $n$, але початковою позицією буде не перше число, а десь на другому місці. Тому, викликавши рекурсивно собі задачу з новим $n$, ми потім повинні аккуратно перевести результат в нашу систему нумерації з його власної.

Також окремо потрібно розглянути випадок, коли $n$ стане менше $k$, оскільки в цьому випадку описана оптимізація перетвориться на нескінченний цикл.

Реалізація (для зручності з 0-індексацією):
<!--- TODO: specify code snippet id -->
``` cpp
int joseph(int n, int k) {
    if (n == 1)
        return 0;
    if (k == 1)
        return n - 1;
    if (k > n)
        return (joseph(n - 1, k) + k) % n;
    int cnt = n / k;
    int res = joseph(n - cnt, k);
    res -= n % k;
    if (res < 0)
        res += n;
    else
        res += res / (k - 1);
    return res;
}
```

Оцінимо **асимптотику** цього алгоритму. Відразу зауважимо, що випадок $n < k$ розглядається старим розв'язком, який відпрацює в даному випадку за $O(k)$. Тепер розглянемо сам алгоритм. Фактично, на кожній його ітерації замість $n$ чисел ми отримуємо приблизно $n \left( 1 - \frac{1}{k} \right)$ чисел, тому загальне число $x$ ітерацій алгоритму приблизно можна знайти з рівняння:

$$
n \left( 1 - \frac{1}{k} \right) ^ x = 1,
$$

логарифмуючи його, отримуємо:

$$
\ln n + x \ln \left( 1 - \frac{1}{k} \right) = 0,
$$

$$
x = - \frac{ \ln n }{ \ln \left( 1 - \frac{1}{k} \right) },
$$

користуючись розкладом логарифма в ряд Тейлора, отримуємо наближену оцінку:

$$
x \approx k \ln n
$$

Таким чином, асимптотика алгоритму дійсно $\mathcal{O}(k \log n)$.

## Аналітичний розв'язок для $k=2$

У цьому приватному випадку (в якому і була поставлена ця задача Йосифом Флавієм) задача вирішується значно простіше.

У випадку парного $n$ отримуємо, що будуть викреслені всі парні числа, а потім залишиться задача для $\frac{n}{2}$. Тоді відповідь для $n$ буде отримана з відповіді для $\frac{n}{2}$ множенням на два та відніманням одиниці (за допомогою зсуву позицій)

$$
J_{2n,2} = 2 J_{n,2} - 1
$$

Аналогічно, в випадку непарного $n$ будуть викреслені всі парні числа, потім перше число, і залишиться задача для $\frac{n-1}{2}$, і з урахуванням зсуву позицій отримаємо одну формулу:

$$
J_{2n+1,2} = 2 J_{n,2} + 1
$$

При реалізації можна безпосередньо використовувати цю рекурентну залежність. Можна перевести цю закономірність в іншу форму: $J_{n,2}$ є послідовністю всіх непарних чисел, яка "перезапускається" з одиниці кожен раз, коли $n$ є степенем двійки. Це можна записати у вигляді однієї формули:

$$
J_{n,2} = 1 + 2 \left( n - 2^{\lfloor \log_2 n \rfloor} \right)
$$

## Аналітичний розв'язок для $k>2$

Незважаючи на просту формулювання задачі та велику кількість статей, присвячених їй та її варіаціям, простого аналітичного розв'язку задачі Йосипа до цього часу не знайдено. Для невеликих значень $k$ були отримані деякі формули, але, ймовірно, всі вони складно застосовні на практиці (наприклад, див. Halbeisen, Hungerbuhler "The Josephus Problem" і Odlyzko, Wilf "Functional iteration and the Josephus problem").