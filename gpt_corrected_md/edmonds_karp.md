# Максимальний потік можна знайти за допомогою алгоритму Едмондса-Карпа з складністю O(NM^2)

<p style="color:red">Увага: ця стаття застаріла і містить помилки, тому не рекомендується для читання. Незабаром вона буде повністю переписана.

Нехай маємо граф G, в якому виділені дві вершини: джерело S і стік T, а кожному ребру присвоєна пропускна здатність C<sub>u,v</sub>. Потік F можна уявити як потік речовини, який міг би пройти по мережі від джерела до стоку, якщо розглядати граф як мережу труб з деякими пропускними здібностями, тобто потік - функція F<sub>u,v</sub>, визначена на множині ребер графа.

&nbsp;

Задача полягає у знаходженні максимального потоку. Тут буде розглянуто метод Едмондса-Карпа, який працює за O(NM<sup>2</sup>) або (інша оцінка) O(FM), де F - величина шуканого потоку. Алгоритм був запропонований у 1972 році.

## Алгоритм

Остаточною пропускною здатністю називається пропускна здатність ребра за виключенням поточного потоку уздовж цього ребра. При цьому треба пам'ятати, що якщо деякий потік протікає по орієнтованому ребру, то виникає так зване зворотне ребро (направлене в зворотному напрямку), яке матиме нульову пропускну здатність, і по якому буде протікати той же потік за величиною, але зі знаком мінус. Якщо ж ребро було неорієнтованим, то воно розпадається на два орієнтованих ребра з однаковою пропускною здатністю, і кожне з цих ребер є зворотним для іншого (якщо по одному протікає потік F, то по іншому протікає -F).

Загальна схема **алгоритму Едмондса-Карпа** така. Спочатку вважаємо потік рівним нулі. Потім шукаємо доповнюючий шлях, тобто простий шлях з S в T по тим ребрам, у яких залишкова пропускна здатність строго позитивна. Якщо доповнюючий шлях був знайдений, то виготовляється збільшення поточного потоку уздовж цього шляху. Якщо ж шляху не було знайдено, то поточний потік є максимальним. Для пошуку доповнюючого шляху можна використовувати як [Обхід в ширину](bfs), так і [Обхід в глибину](dfs).

Розглянемо більш детально процедуру збільшення потоку. Припустимо, що ми знайшли деякий доповнюючий шлях. Нехай C - найменша з залишкових пропускних здібностей ребер цього шляху. Процедура збільшення потоку полягає в наступному: для кожного ребра (u, v) доповнюючого шляху ми збільшуємо потік на C, тобто F<sub>u, v</sub> += C, а потім зменшуємо потік на протилежному ребрі, тобто F<sub>v, u</sub> = - F<sub>u, v</sub> (або, що те ж саме, F<sub>v, u</sub> -= C).

Величина потоку буде сумою всіх невід'ємних величин $F_{S,v}$, де $v$ - будь-яка вершина, з'єднана з витоком.

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
const int inf = 1000 * 1000 * 1000;

typedef vector<int> graf_line;
typedef vector<graf_line> graf;

typedef vector<int> vint;
typedef vector<vint> vvint;

int main() {
    int n;
    cin >> n;
    vvint c(n, vint(n));
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            cin >> c[i][j];
Джерело - вершина 0, стік - вершина n-1

    vvint f(n, vint(n));
    for (;;) {
        vint from(n, -1);
        vint q(n);
        int h = 0, t = 0;
        q[t++] = 0;
        from[0] = 0;
        for (int cur; h < t;) {
            cur = q[h++];
            for (int v = 0; v < n; v++)
                if (from[v] == -1 && c[cur][v] - f[cur][v] > 0) {
                    q[t++] = v;
                    from[v] = cur;
                }
        }

        if (from[n - 1] == -1)
            break;
        int cf = inf;
        for (int cur = n - 1; cur != 0;) {
            int prev = from[cur];
            cf = min(cf, c[prev][cur] - f[prev][cur]);
            cur = prev;
        }

        for (int cur = n - 1; cur != 0;) {
            int prev = from[cur];
            f[prev][cur] += cf;
            f[cur][prev] -= cf;
            cur = prev;
        }
    }

    int flow = 0;
    for (int i = 0; i < n; i++)
        if (c[0][i])
            flow += f[0][i];

    cout << flow;
}
```