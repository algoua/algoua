# Пошук точок дотику

Нехай задано зв'язний неорієнтований граф. **Точкою зчеплення** (або точкою артикуляції, англ. "cut vertex" або "articulation point") називається вершина, видалення якої робить граф незв'язним.

Опишемо алгоритм, заснований на пошуку в глибину, який працює за $O(n+m)$, де $n$ - кількість вершин, а $m$ - кількість ребер.

## Алгоритм

Запустимо обхід у глибину з довільної вершини графа і позначимо її через $\rm root$. Зауважимо наступний **факт** (який нескладно довести):

* Нехай ми знаходимося в обході в глибину, переглядаючи зараз всі ребра з вершини $v \ne {\rm root}$. Отже, якщо поточне ребро $(v,to)$ таке, що з вершини $to$ і з будь-якого її нащадка в дереві обходу в глибину немає зворотного ребра в якогось предка вершини $v$, то вершина $v$ є точкою зчеплення. У іншому випадку, тобто якщо обхід в глибину переглянув всі ребра з вершини $v$ і не знайшов ребра, що задовольняє вищезазначеним умовам, то вершина $v$ не є точкою зчеплення. (Насправді, ми цією умовою перевіряємо наявність шляху з $v$ в $to$ або від $to$ до будь-якого предка $v$.)

* Розглянемо тепер залишилася ситуація: $v = {\rm root}$. Значить, ця вершина є точкою зчеплення тоді і тільки тоді, коли вона має більше одного сина в дереві обходу в глибину. (Насправді, це означає, що, пройшовши з $\rm root$ по безпідставному ребру, ми не змогли обійти весь граф, звідки зразу випливає, що $\rm root$ - точка зчеплення).

Порівняйте формулювання цього критерію з формулюванням критерію для алгоритму пошуку мостів (bridge_searching).

Тепер залишилося навчитися перевіряти цей факт для кожної вершини ефективно. Для цього скористаємося "часом входу в вершину", що обчислюється [алгоритмом обходу в глибину](dfs).

Отже, нехай $tin[v]$ - це час початку пошуку в глибину в вершині $v$. Тепер введемо масив $fup[v]$, який дозволить нам відповідати на вищеописані запити. Час $fup[v]$ дорівнює мінімуму з часу початку пошуку в самій вершині $tin[v]$, часів початку пошуку в кожній вершині $p$, що є кінцем деякого зворотного ребра $(v,p)$, а також з усіх значень $fup[to]$ для кожної вершини $to$, яка є безпосереднім сином $v$ в дереві пошуку

$$
fup[v] = \min \cases{
tin[v], & \cr
tin[p], & {\rm for all} (v,p){\rm\ - back edge } \cr
fup[to], & {\rm for all} (v,to){\rm\ - tree edge } \cr
}
$$

Тут "зворотнє ребро" - "зворотнє зв'язок", "ребро дерева" - "деревовидний зв'язок"

Значить, з вершини $v$ або її нащадка є зворотнє ребро в її предка тоді й тільки тоді, коли знайдеться такий син $to$, що $fup[to] < tin[v]$.

Таким чином, якщо для поточного ребра $(v,to)$ (що належить дереву пошуку) виконується $fup[to] \ge tin[v]$, то вершина $v$ є точкою зв'язку. Для початкової вершини $v = {\rm root}$ критерій інший: для цієї вершини потрібно порахувати кількість безпосередніх синів у дереві обходу в глибину.

## Реалізація

Якщо говорити про реалізацію, то тут потрібно вміти розрізняти три випадки: коли ми йдемо по ребру дерева пошуку в глибину, коли йдемо по зворотному ребру, і коли намагаємося піти по ребру дерева в зворотному напрямку. Це відповідно випадки $used[to]=false$, $used[to]=true ~ \&\& ~ to \ne parent$, і $to=parent$. Таким чином, нам потрібно передавати в функцію пошуку в глибину вершину-предка поточної вершини.

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> g[MAXN];
bool used[MAXN];
int timer, tin[MAXN], fup[MAXN];

void dfs(int v, int p = -1) {
    used[v] = true;
    tin[v] = fup[v] = timer++;
    int children = 0;
    for (size_t i = 0; i < g[v].size(); ++i) {
        int to = g[v][i];
        if (to == p)
            continue;
        if (used[to])
            fup[v] = min(fup[v], tin[to]);
        else {
            dfs(to, v);
            fup[v] = min(fup[v], fup[to]);
            if (fup[to] >= tin[v] && p != -1)
                IS_CUTPOINT(v);
            ++children;
        }
    }
    if (p == -1 && children > 1)
        IS_CUTPOINT(v);
}

int main() {
    int n;
...читання ен і ґ...

        timer = 0;
    for (int i = 0; i < n; ++i)
        used[i] = false;
    dfs(0);
}
```

Тут константа $\rm MAXN$ має бути задана значенням, рівним максимально можливій кількості вершин у вхідному графі.

Функція ${\rm IS\_CUTPOINT}(v)$ в коді - це якась функція, яка буде реагувати на те, що вершина $v$ є точкою зчеплення, наприклад, виводити цю вершину на екран (треба враховувати, що для однієї і тієї ж вершини ця функція може бути викликана декілька разів).

## Задачі на онлайн-суддівстві

Список задач, у яких потрібно шукати точки зчеплення:

* [UVA #10199 **"Tourist Guide"** [складність: низька]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=13&page=show_problem&problem=1140)

* [UVA #315 **"Network"** [складність: низька]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=5&page=show_problem&problem=251)