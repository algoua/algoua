# Задача Джонсона з двома верстатами

Є $n$ деталей і два верстати. Кожна деталь повинна спочатку пройти обробку на першому верстаті, потім - на другому. При цьому $i$-та деталь обробляється на першому верстаті протягом $a_i$ часу, а на другому - протягом $b_i$ часу. Кожен верстат в кожний момент часу може працювати тільки з однією деталлю.

Потрібно скласти такий порядок подачі деталей на станки, щоб загальний час обробки всіх деталей був мінімальним.

Цю задачу іноді називають завданням обслуговування двома процесорами, або завданням Джонсона (на честь S.M. Johnson, який у 1954 році запропонував алгоритм для її вирішення).

Варто відзначити, що коли кількість верстатів більше двох, ця задача стає NP-повною (як довів Гарі (Garey) у 1976 р.).

## Побудова алгоритму

Зауважимо на початку, що можна вважати, що порядок обробки деталей **на першому і другому станках повинен збігатися**. Насправді, для деталей, що призначені для другого верстата, стають доступними тільки після обробки на першому. При наявності декількох доступних для другого верстата деталей час їх обробки буде рівний сумі їх $b_i$ незалежно від їх порядку. Тому найвигідніше відправляти на другий верстат деталь, яка раніше за інші пройшла обробку на першому верстаті.

Розглянемо порядок подачі деталей на верстати, який збігається з їх вхідним порядком: $1, 2, \ldots, n$.

Позначимо через $x_i$ **час простою** іншого верстата безпосередньо перед обробкою $i$-ої деталі (після обробки $i-1$-ої деталі). Наша мета - **мінімізувати загальний простій**

$$
F(x) = \sum x_i \longrightarrow \min.
$$

Для першої деталі ми маємо:

$$
x_1 = a_1.
$$

Для другої - т.до. вона стає готовою до відправлення на другий верстат в момент часу $a_1+a_2$, а другий верстат звільняється в момент часу $x_1 + b_1$, тому маємо:

$$
x_2 = \max \Big( (a_1+a_2) - (x_1+b_1), 0 \Big).
$$

Третя деталь стає доступною для іншого верстата в момент $a_1+a_2+a_3$, а верстат звільняється в $x_1+b_1+x_2+b_2$, тому:

$$
x_3 = \max \Big( (a_1+a_2+a_3) - (x_1+b_1+x_2+b_2), 0 \Big).
$$

Отже, загальний вигляд для $x_i$ виглядає так:

$$
x_k = \max \left( \sum_{i=1}^{k} a_i - \sum_{i=1}^{k-1} b_i - \sum_{i=1}^{k-1} x_i, 0 \right).
$$

Порахуємо тепер **сумарно просте** $F(x)$. Твердиться, що він має вигляд:

$$
F(x) = \max_{k=1 \ldots n} K_i,
$$

де

$$
K_i = \sum_{i=1}^{k} a_i - \sum_{i=1}^{k-1} b_i.
$$

(Це можна переконатися за допомогою індукції або послідовного знаходження виразів для сум перших двох, трьох тощо $x_i$).

Скористаємося зараз **перестановним прийомом**: спробуємо обміняти будь-які два сусідні елементи $j$ і $j+1$ і подивимося, як при цьому зміниться загальна сума.

З урахуванням функцій виразів для $K_i$ зрозуміло, що зміняться лише $K_j$ та $K_{j+1}$; позначимо їх нові значення як $K_j^\prime$ та $K_{j+1}^\prime$.

Таким чином, щоб деталь $j$ переходила до деталі $j+1$, достатньо (хоча не обов'язково), щоб:

$$
\max \left( K_j, K_{j+1} \right) \le \max \left( K_j^\prime, K_{j+1}^\prime \right).
$$

(Тобто ми проігнорували інші, не змінившись, аргументи максимуму в виразі для $F(x)$, отримавши тим самим достатню, але не необхідну умову того, що старе $F(x)$ менше або дорівнює новому значенню.)

Віднімемо $ \sum_{i=1}^{j+1} a_i - \sum_{i=1}^{j-1} b_i $ від обох частин цієї нерівності, отримаємо:

$$
\max (-a_{j+1}, -b_j) \le \max (-b_{j+1}, -a_j),
$$

або, позбавляючись від від'ємних чисел, отримуємо:

$$
\min (a_j, b_{j+1}) \le \min (b_j, a_{j+1}).
$$

Тим самим ми отримали **компаратор**: відсортувавши деталі за його допомогою, ми, згідно з викладеним вище, прийдемо до оптимального порядку деталей, в якому не можна переставити місцями жодні дві деталі, поліпшивши кінцевий час.

Втім, можна ще більше **спростити** сортування, якщо подивитися на цей компаратор з іншої сторони. Фактично, він говорить нам про те, що якщо мінімум з чотирьох чисел $(a_j, a_{j+1}, b_{j}, b_{j+1})$ досягається на елементі з масиву $a$, то відповідна деталь повинна йти раніше, а якщо на елементі з масиву $b$ - то пізніше. Тим самим ми отримуємо іншу форму алгоритму: відсортувати деталі за мінімумом з $(a_i, b_i)$, і якщо у поточній деталі мінімум рівний $a_i$, то цю деталь треба обробити першою з залишилися, інакше - останньою з залишилися.

Так чи інакше, виходить, що задача Джонсона з двома верстатами сводиться до сортування деталей за певною функцією порівняння елементів. Таким чином, асимптотика розв'язку становить $O(n \log n)$.

## Реалізація

Реалізуємо другий вид описаного вище алгоритму, коли деталі упорядковано за мінімумом з $(a_i, b_i)$, і потім відправляються на початок або в кінець поточного списку.

<!--- TODO: specify code snippet id -->
``` cpp
struct item {
    int a, b, id;

    bool operator<(item p) const { return min(a, b) < min(p.a, p.b); }
};

sort(v.begin(), v.end());
vector<item> a, b;
for (int i = 0; i < n; ++i)
    (v[i].a <= v[i].b ? a : b).push_back(v[i]);
a.insert(a.end(), b.rbegin(), b.rend());

int t1 = 0, t2 = 0;
for (int i = 0; i < n; ++i) {
    t1 += a[i].a;
    t2 = max(t2, t1) + a[i].b;
}
```

Тут всі деталі зберігаються у вигляді структур $\rm item$, кожна з яких містить значення $a$ і $b$ та початковий номер деталі.

Деталі упорядковано, потім розподіляються по спискам $a$ (це ті деталі, які були відправлені на початок черги) і $b$ (ті, що були відправлені в кінець). Після цього два списки об'єднуються (причому другий список береться в зворотному порядку), і потім за знайденим порядком обчислюється шуканий мінімальний час: підтримуються дві змінні $t_1$ і $t_2$ - час звільнення першого і другого верстатів відповідно.

## Література

* [S.M. Johnson. **Optimal two- and three-stage production schedules with setup times included** [1954]](http://www.rand.org/pubs/papers/2008/P402.pdf)

* M.R. Garey. **The Complexity of Flowshop and Jobshop Scheduling** [1976]