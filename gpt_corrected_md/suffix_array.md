# Суфіксний масив

Дано рядок $s[0 \ldots n-1]$ довжини $n$.

$i$-ий **суфікс** рядка називається підрядок $s[i \ldots n-1]$, де $i=0 \ldots n-1$.

Значить **суфіксним масивом** рядка $s$ є перестановка індексів суфіксів $p[0 \ldots n-1]$, $p[i] \in [0;n-1]$, яка визначає порядок суфіксів у лексикографічному порядку. Іншими словами, необхідно відсортувати всі суфікси заданого рядка. Також слід замінити російські слова "лексикографической" та "сортування" на українські "лексикографічний" та "сортування".

Наприклад, для рядка $s=abaab$ суфіксний масив буде дорівнювати:

$$
(2,3,0,4,1)
$$

## Побудова за $O(n \log n)$

Строго кажучи, описаний нижче алгоритм буде виконувати сортування не суфіксів, а **циклічних зсувів** рядка. Однак з цього алгоритму легко отримати і алгоритм сортування суфіксів: достатньо додати в кінець рядка довільний символ, який свідомо менше будь-якого символу, з якого можливо складатися рядок (наприклад, це може бути долар або хеш; в мові C в цих цілях можна використовувати вже наявний нульовий символ).

Відразу зауважимо, що оскільки ми сортуємо циклічні зрушення, то і підрядки ми будемо розглядати **циклічні**: під підрядком $s[i \ldots j]$, коли $i > j$, розуміється підрядок $s[i \ldots n-1] + s[0 \ldots j]$. Крім того, перед початком алгоритму всі індекси беруться за модулем довжини рядка (в цілях спрощення формул я буду опускати явні взяття індексів за модулем).

Розглянутий нами алгоритм складається з приблизно $\log n$ фаз. На $k$-ій фазі ($k = 0 \ldots \lceil \log n \rceil$) упорядковуються циклічні підрядки довжини $2^k$. На останній, $\lceil \log n \rceil$-ій фазі, будуть сортуватися підрядки довжини $2^{\lceil \log n \rceil} > n$, що еквівалентно сортуванню циклічних зсувів.

На кожній фазі алгоритму, окрім перестановки $p[0 \ldots n-1]$ індексів циклічних підрядків, буде підтримувати для кожної циклічної підрядки, що починається в позиції $i$ з довжиною $2^k$, **номер $c[i]$ класу еквівалентності**, до якого ця підрядок належить. Насправді, серед підрядків можуть бути однакові, і алгоритму знадобиться інформація про це. Крім того, номера $c[i]$ класів еквівалентності будемо присвоювати таким чином, щоб вони зберігали інформацію про порядок: якщо один суфікс менший за інший, то його номер класу повинен бути меншим. Класи будемо нумерувати з нуля для зручності. Кількість класів еквівалентності будемо зберігати в змінній $\rm classes$.

Наведемо **приклад**. Розглянемо рядок $s=aaba$. Значення масивів $p[]$ і $c[]$ на кожній стадії від нуля до одного такі:

$$
\matrix{
0: & p=(0,1,3,2) & c=(0,0,1,0) \cr
1: & p=(0,3,1,2) & c=(0,1,2,0) \cr
2: & p=(3,0,1,2) & c=(1,2,3,0) \cr
}
$$

Варто відзначити, що в масиві $p[]$ можливі неоднозначності. Наприклад, на нульовій фазі масив міг дорівнювати: $p=(3,1,0,2)$. Те, який саме варіант вийде, залежить від конкретної реалізації алгоритму, але всі варіанти однаково правильні. У той же час, в масиві $c[]$ ніяких неоднозначностей бути не може.

Перейдемо тепер до побудови **алгоритму**. Вхідні дані:

<!--- TODO: specify code snippet id -->
``` cpp
char* s; // вхідний рядок
int довжина;   // довжина рядка

// константи
константа максимальної довжини рядка: 
```const int maxlen = ...;```
const int alphabet = 256; // розмір алфавіту, <= maxlen
```

На **нульовій фазі** ми повинні відсортувати циклічні підрядки довжини $1$, тобто окремі символи рядка, і розділити їх на класи еквівалентності (просто однакові символи повинні бути віднесені до одного класу еквівалентності). Це можна зробити тривіально, наприклад, сортуванням підрахунком. Для кожного символу порахуємо, скільки разів він зустрівся. Потім за цією інформацією відновлюємо масив $p[]$. Після цього, проходом по масиву $p[]$ і порівнянням символів будується масив $c[]$.

<!--- TODO: specify code snippet id -->
``` cpp
int p[maxlen], cnt[maxlen], c[maxlen];
memset(cnt, 0, alphabet * sizeof(int));
for (int i = 0; i < n; ++i)
    ++cnt[s[i]];
for (int i = 1; i < alphabet; ++i)
    cnt[i] += cnt[i - 1];
for (int i = 0; i < n; ++i)
    p[--cnt[s[i]]] = i;
c[p[0]] = 0;
int classes = 1;
for (int i = 1; i < n; ++i) {
    if (s[p[i]] != s[p[i - 1]])
        ++classes;
    c[p[i]] = classes - 1;
}
```

Далі, нехай ми виконали $(k-1)$-у фазу (тобто вирахували значення масивів $p[]$ і $c[]$ для неї), тепер навчимося за $O(n)$ виконувати **наступну, $k$-ту, фазу**. Оскільки фаз всього $O(\log n)$, це дозволить нам отримати необхідний алгоритм з часом $O(n \log n)$.

Для цього зауважимо, що циклічний підрядок довжини $2^k$ складається з двох підрядків довжини $2^{k-1}$, які ми можемо порівнювати між собою за $O(1)$, використовуючи інформацію з попередньої фази - номери $c[]$ класів еквівалентності. Таким чином, для підрядки довжини $2^k$, що починається в позиції $i$, вся необхідна інформація міститься в парі чисел $(c[i], c[i+2^{k-1}])$ (повторюємося, ми використовуємо масив $c[]$ з попередньої фази).

$$
\ldots \overbrace{ \underbrace{ s_i \ldots s_{i+2^{k-1}-1} }_{{\rm length}=2^{k-1},{\rm class}=c[i]}\ \ \underbrace{ s_{i+2^{k-1}} \ldots s_{i+2^k-1} }_{{\rm length}=2^{k-1},\ {\rm class}=c[i+2^{k-1}]} }^{{\rm length}=2^k} \ldots \overbrace{ \underbrace{ s_j \ldots s_{j+2^{k-1}-1} }_{{\rm length}=2^{k-1},{\rm class}=c[j]}\ \ \underbrace{ s_{j+2^{k-1}} \ldots s_{j+2^k-1} }_{{\rm length}=2^{k-1},{\rm class}=c[j+2^{k-1}]} }^{{\rm length}=2^k} \ldots
$$

Це дає нам дуже простий розв'язок: **відсортувати** підрядки довжини $2^k$ просто **за** цими **парами чисел**, це і дасть нам необхідний порядок, тобто масив $p[]$. Однак звичайне сортування, яке виконується за час $O(n \log n)$, нас не підходить - це дасть алгоритм побудови суфіксного масиву з часом $O(n \log^2 n)$ (зате цей алгоритм кілька простіший в написанні, ніж описаний нижче).

Як швидко виконати сортування пар? Оскільки елементи пар не перевищують $n$, то можна використати сортування підрахунком. Однак, щоб досягти кращої асимптотичної складності, замість сортування пар доцільніше відсортувати прості числа. Таким чином можна досягти зменшення константи в асимптотичній оцінці.

Скористаємося тут прийомом, на якому заснована так звана **цифрова сортування**: щоб відсортувати пари, відсортуємо їх спочатку за іншими елементами, а потім - за першими елементами (але вже обов'язково стабільним сортуванням, тобто не порушуючи відносного порядку елементів при рівності). Однак окремо другі елементи вже впорядковані - цей порядок задано в масиві $p[]$ з попередньої фази. Отже, щоб впорядкувати пари за іншими елементами, потрібно просто від кожного елемента масиву $p[]$ відняти $2^{k-1}$ - це дозволить нам встановити порядок сортування пар за іншими елементами (адже $p[]$ дає упорядкування підрядків довжини $2^{k-1}$, і при переході до рядка вдвічі більшої довжини ці підрядки стають їх другими половинками, тому від позиції другої половинки віднімається довжина першої половинки).

Таким чином, за допомогою лише віднімання елементів масиву $p[]$ ми виконуємо сортування за іншими елементами пар. Тепер потрібно відсортувати стійко перші елементи пар, що можна зробити за $O(n)$ за допомогою сортування підрахунком.

Залишилося лише перерахувати номери $c[]$ класів еквівалентності, але їх можна легко отримати, просто пройшовши по отриманій новій перестановці $p[]$ і порівнюючи сусідні елементи (знову ж, порівнюючи їх як пари двох чисел).

Наведемо **реалізацію** виконання всіх етапів алгоритму, крім нульового. Вводяться додаткові тимчасові масиви $pn$ і $cn$ ($pn$ - містить перестановку в порядку сортування за іншими елементами пар, $cn$ - нові номери класів еквівалентності).

<!--- TODO: specify code snippet id -->
``` cpp
int pn[maxlen], cn[maxlen];
for (int h = 0; (1 << h) < n; ++h) {
    for (int i = 0; i < n; ++i) {
        pn[i] = p[i] - (1 << h);
        if (pn[i] < 0)
            pn[i] += n;
    }
    memset(cnt, 0, classes * sizeof(int));
    for (int i = 0; i < n; ++i)
        ++cnt[c[pn[i]]];
    for (int i = 1; i < classes; ++i)
        cnt[i] += cnt[i - 1];
    for (int i = n - 1; i >= 0; --i)
        p[--cnt[c[pn[i]]]] = pn[i];
    cn[p[0]] = 0;
    classes = 1;
    for (int i = 1; i < n; ++i) {
        int mid1 = (p[i] + (1 << h)) % n, mid2 = (p[i - 1] + (1 << h)) % n;
        if (c[p[i]] != c[p[i - 1]] || c[mid1] != c[mid2])
            ++classes;
        cn[p[i]] = classes - 1;
    }
    memcpy(c, cn, n * sizeof(int));
}
```

Цей алгоритм потребує $O(n \log n)$ часу та $O(n)$ пам'яті. Проте, якщо врахувати розмір $k$ алфавіту, час роботи збільшується до $O((n+k) \log n)$, а розмір пам'яті - до $O(n+k)$. Також слід уникати використання російських слів та русизмів.

## Застосування

### Знаходження найменшого циклічного зсуву рядка

Вищезгаданий алгоритм виконує сортування циклічних зсувів (якщо до рядка не додавати долар), тому $p[0]$ дозволить знайти позицію найменшого циклічного зсуву. Час роботи - $O(n \log n)$.

### Пошук підрядка в рядку

Нехай потрібно в тексті $t$ шукати рядок $s$ в режимі онлайн (тобто заздалегідь рядок $s$ потрібно вважати невідомою). Побудуємо суфіксний масив для тексту $t$ за $O(|t| \log |t|)$. Тепер підрядок $s$ будемо шукати наступним чином: зауважимо, що шукане входження має бути префіксом якогось суфікса $t$. Оскільки суфікси у нас впорядковані (це дає нам суфіксний масив), то підрядок $s$ можна шукати бінарним пошуком по суфіксам рядка. Порівняння поточного суфікса і підрядки $s$ всередині бінарного пошуку можна виконувати тривіально, за $O(|s|)$. Отже, асимптотика пошуку підрядки в тексті стає $O(|s| \log |t|)$.

### Порівняння двох підрядків рядка

Потрібно за заданою рядком $s$ провести певний препроцесинг, щоб можна було відповідати на запити порівняння двох довільних підрядків за $O(1)$ (тобто перевіряти, чи перший підрядок дорівнює/менша/більша за другу).

Побудуємо суфіксний масив за $O(|s| \log |s|)$, при цьому збережемо проміжні результати: нам знадобляться масиви $c[]$ від кожної фази. Тому пам'яті буде потрібно також $O(|s| \log |s|)$.

Використовуючи цю інформацію, ми можемо порівнювати будь-які дві підрядки довжиною, що є степенем двійки, за $O(1)$: для цього достатньо порівняти номера класів еквівалентності з відповідної фази. Тепер потрібно узагальнити цей спосіб на підрядки довільної довжини.

Нехай тепер надійшов черговий запит порівняння двох підрядків довжини $l$ з початками в індексах $i$ і $j$. Знайдемо найбільшу довжину блоку, що поміщається всередині підрядки такої довжини, тобто найбільше $k$ таке, що $2^k \le l$. Отже, порівняння двох підрядків можна замінити порівнянням двох пар перекриваючихся блоків довжини $2^k$: спочатку потрібно порівняти два блоки, що починаються в позиціях $i$ і $j$, а при рівності - порівняти два блоки, що закінчуються в позиціях $i+l-1$ і $j+l-1$:

$$
\ldots \overbrace{ \underbrace{ s_i \ldots s_{i+l-2^k} \ldots s_{i+2^k-1} }_{2^k} \ldots s_{i+l-1} }^{\rm first} \ldots \overbrace{ \underbrace{ s_j \ldots s_{j+l-2^k} \ldots s_{j+2^k-1} }_{2^k} \ldots s_{j+l-1} }^{\rm second} \ldots
$$

$$
\ldots \overbrace{ s_i \ldots \underbrace{ s_{i+l-2^k} \ldots s_{i+2^k-1} \ldots s_{i+l-1} }_{2^k} }^{\rm first} \ldots \overbrace{ s_j \ldots \underbrace{ s_{j+l-2^k} \ldots s_{j+2^k-1} \ldots s_{j+l-1} }_{2^k} }^{\rm second} \ldots
$$

Таким чином, реалізація виглядає приблизно так (тут вважається, що викликаюча процедура сама обчислює $k$, оскільки зробити це за константний час не так легко (мабуть, швидше за все - передпідрахунком), але в будь-якому випадку це не має стосунку до застосування суфіксного масиву):

<!--- TODO: specify code snippet id -->
``` cpp
int compare(int i, int j, int l, int k) {
    pair<int, int> a = make_pair(c[k][i], c[k][i + l - (1 << k)]);
    pair<int, int> b = make_pair(c[k][j], c[k][j + l - (1 << k)]);
    return a == b ? 0 : a < b ? -1 : 1;
}
```

### Найбільший загальний префікс двох підрядків: спосіб з додаткової пам'яттю

Потрібно за заданою рядком $s$ провести її попередню обробку та навчитися відповідати на запити найбільшого спільного префіксу (longest common prefix, lcp) для довільних двох суфіксів з позиціями $i$ та $j$ за $O(\log |s|)$.

Спосіб, описаний тут, потребує $O(|s| \log |s|)$ додаткової пам'яті. Інший спосіб, що використовує лінійний об'єм пам'яті, але має неконстантний час відповіді на запит, описаний у наступному розділі.

Побудуємо суфіксний масив за $O(|s| \log |s|)$, при цьому збережемо проміжні результати: нам знадобляться масиви $c[]$ з кожної фази. Тому пам'яті також буде потрібно $O(|s| \log |s|)$.

Нехай тепер надійшов черговий запит: пара індексів $i$ та $j$. Скористаємося тим, що ми можемо за $O(1)$ порівнювати будь-які дві підрядки довжини, що є степенем двійки. Для цього будемо перебирати степінь двійки (від більшої до меншої), і для поточної степені будемо перевіряти: якщо підрядки такої довжини збігаються, то до відповіді додамо цю ступінь двійки, а найбільший загальний префікс продовжимо шукати справа від однакової частини, тобто до $i$ та $j$ треба додати поточну ступінь двійки.

Реалізація:

<!--- TODO: specify code snippet id -->
``` cpp
int lcp(int i, int j) {
    int ans = 0;
    for (int k = log_n; k >= 0; --k)
        if (c[k][i] == c[k][j]) {
            ans += 1 << k;
            i += 1 << k;
            j += 1 << k;
        }
    return ans;
}
```

Тут через $\log_n$ позначена константа, рівна логарифму $n$ по основі 2, округленому вниз.

### Найбільший загальний префікс двох підрядків: спосіб без додаткової пам'яті. Найбільший загальний префікс двох сусідніх суфіксів

Потрібно провести препроцесінг заданої рядка $s$ і навчитися відповідати на запити найбільшого загального префікса (longest common prefix, lcp) для двох довільних суфіксів з позиціями $i$ та $j$. Російський термін "префикс" слід замінити на український "передфікс".

На відміну від попереднього методу, описаного тут буде виконуватися препроцесінг рядка за $O(n \log n)$ часу з $O(n)$ пам'яті. Результатом цього препроцесінгу буде масив, який сам по собі є важливим джерелом інформації про рядка і, тому, використовується для розв'язання інших задач. Відповіді ж на запити будуть производитися як результат виконання запиту RMQ (мінімум на відрізку, range minimum query) в цьому масиві, тому при різних реалізаціях можна отримати як логарифмічні, так і константні часи роботи.

Базою для цього алгоритму є наступна ідея: знайдемо яким-небудь чином найбільші загальні префікси для кожної **пари сусідніх у порядку сортування суфіксів**. Іншими словами, побудуємо масив ${\rm lcp}[0 \ldots n-2]$, де ${\rm lcp}[i]$ дорівнює найбільшому загальному префіксу суфіксів $p[i]$ і $p[i+1]$. Цей масив дасть нам відповідь для будь-яких двох сусідніх суфіксів рядка. Отже, відповідь для будь-яких двох суфіксів, не обов'язково сусідніх, можна отримати за допомогою цього масиву. Нехай надійшов запит з деякими номерами суфіксів $i$ і $j$. Знайдемо ці індекси в суфіксному масиві, тобто нехай $k_1$ і $k_2$ - їх позиції в масиві $p[]$ (упорядкуємо їх, тобто нехай $k_1 < k_2$). Отже, відповіддю на даний запит буде мінімум в масиві $\rm lcp$, взятий на відрізку $[k_1; k_2-1]$. Насправді, перехід від суфікса $i$ до суфіксу $j$ можна замінити цілою ланцюжком переходів, що починається з суфікса $i$ і закінчується суфіксом $j$, але включає в себе всі проміжні суфікси, що знаходяться в порядку сортування між ними.

Таким чином, якщо у нас є масив $\rm lcp$, то відповідь на будь-який запит найбільшого загального префікса зводиться до запиту **мінімуму на відрізку** масиву $\rm lcp$. Ця класична задача мінімуму на відрізку (range minimum query, RMQ) має набір рішень з різними асимптотиками, описані [тут](rmq).

Отже, нашою основною задачею є **побудова** масиву $\rm lcp$. Ми будемо будувати його одночасно з побудовою суфіксного масиву, обчислюючи масив $\rm lcp$ для циклічних підрядків поточної довжини на кожній ітерації. Русизми та російські слова будуть замінені на українські.

Після нульової ітерації масив $\rm lcp$ очевидно повинен бути нульовим.

Нехай зараз ми виконали $k-1$-у ітерацію, отримали від неї масив $\rm lcp^\prime$, і маємо на поточній $k$-й ітерації перерахувати цей масив, отримавши нове значення $\rm lcp$. Як ми пам'ятаємо з алгоритму побудови суфіксного масиву, циклічні підрядки довжини $2^k$ розбиваються навпіл на дві підрядки довжини $2^{k-1}$. Ми скористаємось цим прийомом для побудови масиву $\rm lcp$.

Отже, нехай на поточній ітерації алгоритму обчислення суфіксного масиву виконав свою роботу та знайшов нове значення перестановки $p[]$ підрядків. Тепер ми будемо проходити по цьому масиві та дивитися на пари сусідніх підрядків: $p[i]$ та $p[i+1]$, де $i=0 \ldots n-2$. Розбиваючи кожну підрядок навпіл, ми отримуємо дві різні ситуації: 1) перші половинки підрядків в позиціях $p[i]$ та $p[i+1]$ відрізняються, і 2) перші половинки співпадають (нагадаємо, таке порівняння можна легко виконати, просто порівнюючи номери класів $c[]$ з попередньої ітерації). Розглянемо кожен з цих випадків окремо.

1) Перші половинки підрядків відрізнялися. Зауважимо, що на попередньому кроці ці перші половинки повинні були бути сусідніми. Насправді, класи еквівалентності не могли зникати (а можуть тільки з'являтися), тому всі різні підрядки довжини $2^{k-1}$ дадуть (як перші половинки) на поточній ітерації різні підрядки довжини $2^k$, і в тому ж порядку. Таким чином, для визначення ${\rm lcp}[i]$ у цьому випадку потрібно просто взяти відповідне значення з масиву $\rm lcp^\prime$.

Перші половини збігалися. Отже, другі половинки могли як збігатися, так і відрізнятися. При цьому, якщо вони розрізняються, то вони зовсім не обов'язково повинні були бути сусідніми на попередній ітерації. Тому в цьому випадку немає простого способу визначити ${\rm lcp}[i]$. Для його визначення потрібно ввести такий самий підхід, як ми й збираємося потім обчислювати найбільший загальний префікс для будь-яких двох суфіксів: потрібно виконати запит мінімуму (RMQ) на відповідному відрізку масиву $\rm lcp^\prime$.

Оцінимо **асимптотику** такого алгоритму. Як ми бачили при розборі цих двох випадків, тільки другий випадок дає збільшення числа класів еквівалентності. Іншими словами, можна говорити про те, що кожний новий клас еквівалентності з'являється разом з одним запитом RMQ. Оскільки всього можливо бути до $n$ класів еквівалентності, то і шукати мінімум ми повинні за асимптотику $O(\log n)$. А для цього треба використовувати вже якусь структуру даних для мінімуму на відрізку; цю структуру даних треба буде будувати заново на кожній ітерації (яких всього $O(\log n)$). Хорошим варіантом структури даних буде **[Дерево відрізків](segment_tree)**: його можна побудувати за $O(n)$, а потім виконувати запити за $O(\log n)$, що якраз і дає нам підсумкову асимптотику $O(n \log n)$.

**Реалізація:**

<!--- TODO: specify code snippet id -->
``` cpp
int lcp[maxlen], lcpn[maxlen], lpos[maxlen], rpos[maxlen];
memset(lcp, 0, sizeof lcp);
for (int h = 0; (1 << h) < n; ++h) {
    for (int i = 0; i < n; ++i)
        rpos[c[p[i]]] = i;
    for (int i = n - 1; i >= 0; --i)
        lpos[c[p[i]]] = i;

... всі дії щодо побудови суфіксного масиву, крім останнього рядка (memcpy)...

        rmq_build(lcp, n - 1);
    for (int i = 0; i < n - 1; ++i) {
        int a = p[i], b = p[i + 1];
        if (c[a] != c[b])
            lcpn[i] = lcp[rpos[c[a]]];
        else {
            int aa = (a + (1 << h)) % n, bb = (b + (1 << h)) % n;
            lcpn[i] = (1 << h) + rmq(lpos[c[aa]], rpos[c[bb]] - 1);
            lcpn[i] = min(n, lcpn[i]);
        }
    }
    memcpy(lcp, lcpn, (n - 1) * sizeof(int));

    memcpy(c, cn, n * sizeof(int));
}
```

Тут окрім масиву $\rm lcp[]$ вводиться тимчасовий масив $\rm lcpn[]$ з його новим значенням. Також підтримується масив $\rm pos[]$, який для кожної підрядки зберігає її позицію в перестановці $p[]$. Функція $\rm rmq\_build$ є деякою функцією, яка будує структуру даних для знаходження мінімуму по масиву-першому аргументу, його розмір передається другим аргументом. Функція $\rm rmq$ повертає мінімум на відрізку від першого аргументу до другого включно.

З самого алгоритму побудови суфіксного масиву довелося тільки винести копіювання масиву $c[]$, оскільки під час обчислення $\rm lcp$ нам знадобляться попередні значення цього масиву.

Варто відзначити, що наша реалізація знаходить довжину загального префікса для **циклічних підрядків**, тоді як на практиці частіше потрібна довжина загального префікса для суфіксів у їх звичайному розумінні. У цьому випадку достатньо просто обмежити значення $\rm lcp$ після завершення роботи алгоритму:

<!--- TODO: specify code snippet id -->
``` cpp
for (int i = 0; i < n - 1; ++i)
    lcp[i] = min(lcp[i], min(n - p[i], n - p[i + 1]));
```

Для **будь-яких** двох суфіксів довжину їх найбільшого загального префікса тепер можна знайти як мінімум на відповідному відрізку масиву $\rm LCP$

<!--- TODO: specify code snippet id -->
``` cpp
for (int i = 0; i < n; ++i)
    pos[p[i]] = i;
rmq_build(lcp, n - 1);

... надійшов запит (і, j)
на знаходження LCP... Змінна result присвоює значення rmq(min(i, j), max(i, j) - 1);
```

### Кількість різних підрядків

Виконаємо **препроцесінг**, описаний у попередньому розділі: за $O(n \log n)$ часу і $O(n)$ пам'яті ми для кожної пари сусідніх у порядку сортування суфіксів знайдемо довжину їх найбільшого загального префікса. Знайдемо тепер за цією інформацією кількість різних підрядків у рядку.

Для цього ми будемо розглядати, які нові підрядки починаються з позиції $p[0]$, потім з позиції $p[1]$, і т.д. Фактично, ми беремо черговий суфікс у порядку сортування та дивимося, які його префікси дають нові підрядки. Таким чином, ми, очевидно, не пропустимо жодної з підрядків.

Користуючись тим, що суфікси вже відсортовані, нескладно зрозуміти, що поточний суфікс $p[i]$ дасть в якості нових підрядків всі свої префікси, крім тих, що співпадають з префіксами суфікса $p[i-1]$. Тобто, всі його префікси, крім ${\rm lcp}[i-1]$ перших, стануть новими підрядокми. Оскільки довжина поточного суфікса дорівнює $n-p[i]$, то отримуємо, що поточний суфікс $p[i]$ дає $n-p[i]-{\rm lcp}[i-1]$ нових підрядків. Підсумовуючи це по всіх суфіксах (для самого першого, $p[0]$, віднімати нечого - просто додається $n-p[0]$), отримуємо **відповідь** на задачу:

$$
\sum_{i=0}^n (n - p[i]) - \sum_{i=0}^{n-1} {\rm lcp}[i]
$$

## Завдання в онлайн-суддях

Задачі, які можна розв'язати, використовуючи суфіксний масив:

* [UVA #10679 **"I Love Strings!!!"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1620)