# Суфіксний автомат

Суфіксний автомат (або орієнтований ациклічний граф слів) - це потужна структура даних, яка дозволяє вирішувати множину задач, пов'язаних із рядками.

Наприклад, за допомогою суфіксного автомату можна шукати всі входження однієї рядка в інший, або підраховувати кількість різних підрядків у даному рядку - обидві задачі він дозволяє розв'язувати за лінійний час.

На інтуїтивному рівні, суфіксний автомат можна розуміти як стислу інформацію про **усі підрядки** даного рядка. Вражаючим фактом є те, що суфіксний автомат містить всю необхідну інформацію в настільки стислому вигляді, що для рядка довжини $n$ він вимагає лише $O(n)$ пам'яті. Крім того, його можна побудувати за час $O(n)$ (якщо ми припустимо розмір алфавіту $k$ константою; в іншому випадку - за час $O(n \log k)$).

Історично, вперше лінійність розміру суфіксного автомата була відкрита в 1983 році Blumer та іншими, а в 1985-1986 роках були представлені перші алгоритми його побудови за лінійний час (Crochemore, Blumer та ін.). Докладніше - див. список літератури в кінці статті.

На англійській мові суфіксний автомат називається "suffix automaton" (у множинному числі - "suffix automata"), а орієнтований ациклічний граф слів - "directed acyclic word graph" (або просто "DAWG").

## Визначення суфіксного автомата

Визначення. **Суфіксним автоматом** для даної рядка $s$ називається такий мінімальний детермінований кінцевий автомат, який приймає всі суфікси рядка $s$.

Розшифруємо це визначення.

* Суфіксний автомат є орієнтованим ациклічним графом, в якому вершини називаються **станами**, а дуги - **переходами** між цими станами.

* Один із станів $t_0$ називається **початковим станом**, і він повинен бути коренем графа (тобто з нього досяжні всі інші стани).

* Кожен **перехід** в автоматі - це дуга, позначена деяким символом. Усі переходи, що виходять з якого-небудь стану, повинні мати **різні** мітки. (З іншого боку, зі стану може не бути переходів по деяким символам).

* Одне або кілька станів позначені як **кінцеві стани**. Якщо ми пройдемо з початкового стану $t_0$ по будь-якому шляху до якогось кінцевого стану і при цьому випишемо мітки всіх пройдених дуг, то вийде рядок, яка повинна бути одним з суфіксів рядка $s$.

* Суфіксний автомат містить мінімальну кількість вершин серед усіх автоматів, що задовольняють описаним вище умовам. (Мінімальність числа переходів не потрібна. За умови мінімальності числа станів в автоматі не може бути "зайвих" шляхів, інакше це порушило б попередню властивість).

### Простейшие властивості суфіксного автомата

Простою, але важливою властивістю суфіксного автомата є те, що він містить інформацію про всі підрядки рядка $s$. Зокрема, будь-який шлях зі стартового стану $t_0$, якщо ми візьмемо мітки дуг вздовж цього шляху, обов'язково утворить підрядок рядка $s$. Навпаки, будь-який підрядок рядка $s$ відповідає деякому шляху, що починається в стартовому стані $t_0$.

У цілях спрощення пояснень ми будемо говорити, що підрядку **відповідає** той шлях зі стартового стану, мітки вздовж якого утворюють цю підрядок. Навпаки, будь-якій рядку **відповідає** якийсь шлях, мітки дуг якого утворюють цю рядок.

Кожен стан суфіксного автомата має один або декілька шляхів з початкового стану. Можна сказати, що стан **відповідає** набору рядків, які відповідають усім цим шляхам.

### Приклади побудованих суфіксних автоматів

Наведемо приклади суфіксних автоматів, побудованих для декількох простих рядків.

Початковий стан ми будемо позначати тут через $t_0$, а кінцеві стани - позначати зірочкою.

Для рядка $s = ""$:

\img{suffix_automaton_sample_1.gif}

Для рядка $s = "а"$:

\img{suffix_automaton_sample_2.gif}

Для рядка $s = "aa"$:

\img{suffix_automaton_sample_3.gif}

Для рядка $s = "аб":$

\img{suffix_automaton_sample_4.gif}

Для рядка $s = "aba":$

\img{suffix_automaton_sample_5.gif}

Для рядка $s = "abb"$:

\img{suffix_automaton_sample_6.gif}

Для рядка $s = "аббб"$:

\img{suffix_automaton_sample_7.gif}

## Алгоритм побудови суфіксного автомата за лінійний час

Перед тим, як перейти безпосередньо до опису алгоритму побудови, потрібно ввести декілька нових понять і довести прості, але дуже важливі для розуміння суфіксного автомата леми.

### Позиції закінчень $endpos$, їх властивості та зв'язок із суфіксним автоматом

Розглянемо будь-яку непусту підрядок $t$ рядка $s$. Тоді назвемо **множину закінчень** $endpos(t)$ множину всіх позицій у рядку $s$, в яких закінчуються входження рядка $t$.

Ми будемо називати дві підрядки $t_1$ та $t_2$ еквівалентними за $endpos$, якщо їх множини закінчень збігаються: $endpos(t_1) = endpos(t_2)$. Таким чином, всі непусті підрядки рядка $s$ можна розбити на декілька **класів еквівалентності**, відповідно до їх кількості $endpos$.

Виявляється, що в суфіксному автоматі **$endpos$-еквівалентним підрядкам відповідає один і той самий стан**. Іншими словами, кількість станів в суфіксному автоматі дорівнює кількості класів $endpos$-еквівалентності серед всіх підрядків, плюс один початковий стан. Кожному стану суфіксного автомата відповідає один або кілька підрядків, які мають одне і те ж значення $endpos$.

Це твердження ми приймаємо як аксіому і описуємо алгоритм побудови суфіксного автомата, виходячи з цього припущення - як ми побачимо далі, всі необхідні властивості суфіксного автомата, крім мінімальності, будуть виконані. (А мінімальність випливає з теореми Нероде - див. список літератури).

Наведемо декілька простих, але важливих тверджень щодо значень $endpos$.

**Лема 1**. Дві непусті підрядки $u$ і $w$ ($\operatorname{length}(u) \leq \operatorname{length}(w)$) є еквівалентними за $endpos$ тоді й тільки тоді, коли рядок $u$ зустрічається в рядку $s$ тільки в вигляді суфікса рядка $w$.

Доведення практично очевидне. В одну сторону: якщо $u$ і $w$ мають однакові позиції закінчень входження, то $u$ є суфіксом $w$, і він присутній в $s$ тільки в вигляді суфікса $w$. У зворотному напрямку: якщо $u$ є суфіксом $w$ і входить тільки як цей суфікс, то їх значення $endpos$ рівні за визначенням.

**Лема 2**. Розгляньмо дві непусті підрядки $u$ і $w$ ($\operatorname{length}(u) \leq \operatorname{length}(w)$). Тоді їх множини $endpos$ або не перетинаються, або $endpos(w)$ цілком міститься в $endpos(u)$, причому це залежить від того, чи є $u$ суфіксом $w$ чи ні:

$$ \begin{cases}
endpos(w) \subset endpos(u) & \text{if $u$ - suffix $w$,}
\\
endpos(u) \cap endpos(w) = \emptyset & \text{otherwise.}
\end{cases} $$

Доведення. Припустимо, що множини $кінець(u)$ і $кінець(w)$ мають хоча б один спільний елемент. Це означає, що рядки $u$ і $w$ закінчуються в одному і тому ж місці, тобто $u$ - суфікс $w$. Але тоді кожне входження рядка $w$ містить на своєму кінці входження рядка $u$, що і означає, що його множина $кінець(w)$ цілком вкладається в множину $кінець(u)$.

**Лема 3**. Розглянемо деякий клас $endpos$-еквівалентності. Відсортуємо всі підрядки, що входять до цього класу, по невисхідній довжині. Отримана послідовність матиме кожну підрядок на одиницю коротшою за попередню і буде суфіксом попередньої. Іншими словами, **підрядки, що належать до одного класу еквівалентності, фактично є суфіксами один одного та можуть мати різну довжину в деякому відрізку $[x;y]$**.

Доведення.

Зафіксуємо деякий клас еквівалентності $endpos$. Якщо він містить лише один рядок, то коректність леми очевидна. Нехай тепер кількість рядків більша одного.

Згідно з лемою 1, дві різні рядка, які еквівалентні за $endpos$, завжди такі, що одна є суфіксом іншої. Отже, в одному класі $endpos$-еквівалентності не може бути стрічок однакової довжини.

Позначимо через $w$ довгу рядок, а через $u$ - найкоротшу рядок в даному класі еквівалентності. Згідно з лемою 1, рядок $u$ є власним суфіксом рядка $w$. Розглянемо тепер будь-який суфікс рядка $w$ з довжиною в діапазоні $[length(u); length(w)]$, і покажемо, що він міститься в цьому ж класі еквівалентності. Насправді, цей суфікс може входити в $w$ тільки в вигляді суфікса (оскільки більш короткий суфікс $u$ може входити тільки в вигляді суфікса $w$). Отже, згідно з лемою 1, цей суфікс є $endpos$-еквівалентний рядку $w$, що й потрібно довести.

### Суфіксні посилання

Розглянемо деякий стан автомата $v \ne t_0$. Як ми зараз знаємо, стан $v$ відповідає деякому класу рядків з однаковими значеннями $endpos$, причому якщо ми позначимо через $w$ найдовший з цих рядків, то всі інші будуть суфіксами $w$.

Також ми знаємо, що перші кілька суфіксів рядка $w$ (якщо ми розглядаємо суфікси в порядку зменшення їх довжини) містяться в тому ж самому класі еквівалентності, а всі інші суфікси (як мінімум, порожній суфікс) - в інших класах. Позначимо через $t$ перший такий суфікс - в нього ми і проведемо суфіксне посилання.

Іншими словами, **суфіксне посилання** $link(v)$ веде до такого стану, якому відповідає **найдовший суфікс** рядка $w$, що знаходиться в другому класі еквівалентності $endpos$.

Тут ми припускаємо, що початковому стану $t_0$ відповідає окремий клас еквівалентності (що містить лише порожній рядок), і вважаємо $endpos(t_0) = [-1 \ldots length(s)-1]$.

**Лема 4**. Суфіксні посилання утворюють **дерево**, коренем якого є початковий стан $t_0$.

Доведення. Розглянемо довільний стан $v \neq t_0$. Суфіксне посилання $link(v)$ веде з нього в стан, якому відповідають рядка строго меншої довжини (це випливає з визначення суфіксного посилання і з леми 3). Отже, рухаючись по суфіксним посиланням, ми рано або пізно прийдемо зі стану $v$ в початковий стан $t_0$, якому відповідає порожня рядок.

**Лема 5**. Якщо ми побудуємо з усіх наявних множин $endpos$ **дерево** (за принципом "множина-батько містить як підмножини всіх своїх дітей"), то воно буде співпадати за структурою з деревом суфіксних посилань.

Доведення.

Те, що з множин $endpos$ можна побудувати дерево, випливає з леми 2 (про те, що будь-які дві множини $endpos$ або не перетинаються, або одна міститься в іншій).

Розглянемо тепер довільний стан $v \ne t_0$ і його суфіксне посилання $link(v)$. З визначення суфіксного посилання і з леми 2 випливає:

$$
endpos(v) \subset endpos(link(v)),
$$

що разом з попередньою лемою доводить наше твердження: дерево суфіксних посилань по суті є деревом вкладених множин $endpos$.

Наведемо приклад дерева суфіксних посилань у суфіксному автоматі, побудованому для рядка "абцбц":

\img{suffix_automaton_link.gif}

### Проміжний підсумок

Перед тим, як приступити до самого алгоритму, систематизуємо накопичені вище знання і введемо кілька допоміжних позначень.

* Безліч підрядків рядка $s$ можна розбити на класи еквівалентності згідно їх кількості входжень в кінець рядка $endpos$.

* Суфіксний автомат складається з початкового стану $t_0$, а також з по одному станні на кожний клас $endpos$-еквівалентності.

* Кожному стану $v$ відповідає одна або кілька стрічок. Позначимо через $longest(v)$ найдовшу з таких стрічок, а через $len(v)$ її довжину. Позначимо через $shortest(v)$ найкоротшу з таких стрічок, а її довжину через $minlen(v)$.

Значить, всі рядки, що відповідають цьому стану, є різними суфіксами рядка $longest(v)$ та мають різні довжини в інтервалі $[minlen(v); len(v)]$.

* Для кожного стану $v \neq t_0$ визначена суфіксна посилання, що веде до стану, який відповідає суфіксу рядка $longest(v)$ довжини $minlen(v)-1$. Суфіксні посилання утворюють дерево з коренем у $t_0$, причому це дерево, по суті, є деревом включень між множинами $endpos$.

* Таким чином, $minlen(v)$ для $v \neq t_0$ виражається з допомогою суфіксного посилання $link(v)$ так:

$$
minlen(v) = len(link(v)) + 1.
$$

* Якщо ми стартуємо з будь-якого стану $v_0$ і будемо йти по суфіксним посиланням, то рано чи пізно дійдемо до початкового стану $t_0$. При цьому у нас вийде послідовність неперетинаючихся відрізків $[minlen(v_i); len(v_i)]$, які в об'єднанні дадуть один зв'язний відрізок.

### Алгоритм побудови суфіксного автомата за лінійний час

Приступимо до опису самого алгоритму. Алгоритм буде **онлайн**, тобто буде додавати по одному символу рядка $s$, перестраюючи відповідним чином поточний автомат.

Щоб досягти лінійного споживання пам'яті, ми будемо зберігати тільки значення $len$, $link$ та список переходів з кожного стану. Ми не будемо підтримувати мітки термінальних станів (ми покажемо, як розставити ці мітки після побудови суфіксного автомата, якщо є необхідність у них).

Спочатку автомат складається з єдиного стану $t_0$, який ми домовляємося вважати нульовим станом (інші стани будуть мати номери $1, 2, \ldots$). Присвоїмо цьому стану $len = 0$, а значенням $link$ для зручності надамо $-1$ (що означає посилання на фіктивний, неіснуючий стан).

Відповідно до цього, задача зводиться до того, щоб реалізувати обробку **додавання одного символу** $c$ в кінець поточного рядка. Опишемо цей процес:

* Нехай $last$ - це стан, що відповідає всій поточній рядку до додавання символу $c$. (Спочатку $last = 0$, а після додавання кожного символу ми будемо змінювати значення $last$).

* Створимо новий стан $cur$, присвоївши йому $len(cur) = len(last) + 1$. Значення $link(cur)$ наразі залишається невизначеним.

* Зробимо такий цикл: спочатку ми стоїмо в стані $last$; якщо з нього немає переходу по букві $c$, то додаємо цей перехід по букві $c$ в стан $cur$, і потім переходимо по суфіксному посиланню, знову перевіряючи - якщо немає переходу, то додаємо. Якщо в якийсь момент станеться, що такий перехід вже є, то зупиняємося - і позначимо через $p$ номер стану, на якому це сталося.

* Якщо ні разу не сталося того, що перехід за літерою $c$ вже був здійснений, і ми дійшли до фіктивного стану $-1$ (у який потрапили через суфіксне посилання зі стартового стану $t_0$), то ми можемо просто присвоїти $link(cur) = 0$ і вийти.

* Припустимо тепер, що ми зупинились на деякому стані $p$, з якого вже відбувся перехід за допомогою букви $c$. Позначимо через $q$ той стан, куди веде цей перехід.

* Тепер у нас є два випадки залежно від того, чи дорівнює довжина $q$ довжині $p$ плюс один, чи ні.

* Якщо $len(p) + 1 = len(q)$, то ми можемо просто присвоїти $зв'язок(cur) = q$ і вийти.

* У іншому випадку, все трохи складніше. Потрібно провести "клонування" стану $q$: створити новий стан $clone$, скопіювавши в нього всі дані з вершини $q$ (суфіксне посилання, переходи), за винятком значення $len$: треба присвоїти $len(clone) = len(p) + 1$.

Після клонування ми проводимо суфіксне посилання з $cur$ до цього стану $clone$, також перенаправляємо суфіксне посилання з $q$ до $clone$.

Нарешті, останнє, що ми повинні зробити - це пройтися від стану $p$ по суфіксних посиланнях і для кожного наступного стану перевірити: якщо був здійснений перехід по символу $c$ в стан $q$, то перенаправити його до стану $clone$ (а якщо ні, то зупинитися).

* В будь-якому випадку, як би не закінчилося виконання цієї процедури, ми в кінці оновлюємо значення $last$, присвоюючи йому $cur$.

Якщо нам також потрібно знати, які вершини є **термінальними**, а які - ні, то ми можемо знайти всі термінальні вершини після побудови суфіксного автомата для всієї рядка. Для цього розглянемо стан, відповідний всій рядку (воно, очевидно, у нас зберігається у змінній $last$), і будемо йти по його суфіксним посиланням, поки не дійдемо до початкового стану, і позначати кожен пройдений стан як термінальний. Легко зрозуміти, що тим самим ми позначимо стан, відповідний всім суфіксам рядка $s$, що нам і потрібно.

У наступному розділі ми детально розглянемо кожен крок алгоритму і продемонструємо його **правильність**.

Тут лише відзначимо, що з алгоритму видно, що додавання одного символу призводить до додавання одного або двох станів до автомата. Таким чином, **лінійність кількості станів** очевидна.

Лінійність числа переходів, а також лінійний час роботи алгоритму менш зрозумілі, і їх буде доведено нижче, після доведення коректності алгоритму.

### Доведення коректності алгоритму

* Назвемо перехід $(p,q)$ **цілим**, якщо $len(p) + 1 = len(q)$. У іншому випадку, тобто коли $len(p) + 1 < len(q)$, перехід будемо називати **неповним**.

Як можна бачити з опису алгоритму, цілі та неперервні переходи призводять до різних гілок алгоритму. Неперервні переходи називаються так, тому що вони, з'явившись вперше, більше ніколи не будуть змінюватися. На відміну від них, неперервні переходи можуть змінитися при додаванні нових символів до рядка (можливо змінити кінець дуги-переходу).

* Щоб уникнути неоднозначностей, під рядком $s$ ми будемо розуміти рядок, для якого був побудований суфіксний автомат до додавання поточного символу $c$.

* Алгоритм починається з того, що ми створюємо новий стан $cur$, якому буде відповідати вся рядок $s + c$. Зрозуміло, чому ми зобов'язані створити новий стан - при додаванні нового символу виникає новий клас еквівалентності - це клас стрічок, що закінчуються на доданий символ $c$.

* Після створення нового стану алгоритм проходиться по суфіксних посиланнях, починаючи зі стану, що відповідає всій рядку $s$, і намагається додати перехід за символом $c$ в стан $cur$. Таким чином, ми додаємо до кожного суфіксу рядка $s$ символ $c$. Але нові переходи можна додавати тільки в тому випадку, якщо вони не конфліктують з вже існуючими. Тому якщо ми зустрінемо вже наявний перехід за символом $c$, ми повинні зупинитися негайно.

* Найпростіший випадок - якщо ми дійшли до фіктивного стану $-1$, додавши всюди новий перехід уздовж символу $c$. Це означає, що символ $c$ у рядку $s$ раніше не зустрічався. Ми успішно додали всі переходи, залишилося лише проставити суфіксні посилання у стан $cur$. Вони повинні бути рівні $0$, оскільки стан $cur$ відповідає всім суфіксам рядка $s+c$.

* Другий випадок - коли ми натрапили на вже існуючий перехід $(p,q)$. Це означає, що ми намагалися додати до автомата рядок $x+c$ (де $x$ - деякий суфікс рядка $s$, має довжину $len(p)$), а ця рядок **вже була додана до автомата раніше** (тобто рядок $x+c$ вже є підрядком рядка $s$). Оскільки ми припускаємо, що автомат для рядка $s$ побудований правильно, то нові переходи більше додавати не потрібно.

Однак виникає складність з тим, куди вести суфіксне посилання зі стану $cur$. Нам потрібно провести суфіксне посилання в такий стан, в якому найдовшим рядком буде саме цей $x+c$, тобто $len$ для цього стану повинен бути дорівнювати $len(p) + 1$. Однак такого стану могло і не існувати: в такому випадку нам потрібно провести **"розщеплення"** стану.

* Отже, за одним з можливих сценаріїв, перехід $(p,q)$ виявився сплошним, тобто $|q| = |p| + 1$. У цьому випадку все просто, не потрібно робити розгалуження, і ми просто проводимо суфіксне посилання зі стану $cur$ до стану $q$.

* Інший, більш складний варіант - коли перехід не є сплошним, тобто $len(q) > len(p) + 1$. Це означає, що стан $q$ відповідає не тільки потрібній нам підрядку $w+c$ довжиною $len(p) + 1$, а також підрядокм більшої довжини. Нам не залишається нічого іншого, як провести **"розгалуження"** стану $q$: розбити відрізок стрічок, які їй відповідають, на два підвідрізки, так що перший буде закінчуватися саме довжиною $len(p) + 1$.

Як виготовляти це розщеплення? Ми **"клонуємо"** стан $q$, створюючи його копію $clone$ з параметром $len(clone) = len(p) + 1$. Ми копіюємо в $clone$ з $q$ всі переходи, оскільки ми не хочемо ніяким чином змінювати шляхи, які проходять через $q$. Суфіксне посилання з $clone$ ми ведемо туди, куди вело старе суфіксне посилання з $q$, а посилання з $q$ направляємо в $clone$.

Після клонування ми проводимо суфіксне посилання з $cur$ до $clone$ - саме для цього ми й проводили клонування.

Залишився останній крок - перенаправити деякі переходи, які входять у $q$, перенаправивши їх на $clone$. Які саме переходи, що входять, потрібно перенаправити? Достатньо перенаправити лише ті переходи, які відповідають всім суфіксам рядка $w+c$. Іншими словами, нам потрібно продовжувати рухатися по суфіксних посиланнях, починаючи з вершини $p$, і рухатися до тих пір, поки ми не дійдемо до фіктивного стану $-1$ або до стану, перехід з якого веде в стан, який відрізняється від $q$.

### Доведення лінійної складності операцій

По-перше, зразу зазначимо, що ми припускаємо розмір алфавіту **константою**. Якщо це не так, то говорити про лінійний час роботи не вийде: список переходів з однієї вершини потрібно зберігати у вигляді збалансованого дерева, що дозволяє швидко виконувати операції пошуку за ключем та додавання ключа. Отже, якщо ми позначимо через $k$ розмір алфавіту, то асимптотика алгоритму складатиме $O(n \log k)$ при $O(n)$ пам'яті. Однак, якщо алфавіт достатньо малий, то можна, пожертвувавши пам'яттю, уникнути збалансованих списків та зберігати переходи в кожній вершині у вигляді масиву довжини $k$ (для швидкого пошуку за ключем) та динамічного списку (для швидкого обходу всіх наявних ключів). Тим самим ми досягнемо $O(n)$ у часі роботи алгоритму, але ціною $O(n k)$ споживання пам'яті.

Отже, ми будемо вважати розмір алфавіту сталим, тобто кожна операція пошуку переходу за символом, додавання переходу та пошуку наступного переходу - всі ці операції ми припускаємо працюючими за $O(1)$.

Якщо ми розглянемо всі частини алгоритму, то він містить три місця, лінійна складність яких неочевидна:

* Перше місце - це прохід по суфіксним посиланням від стану $last$ з додаванням ребер за символом $c$.

* Друге місце - копіювання переходів при клонуванні стану $q$ в новий стан $clone$.

* Третє місце - перенаправлення переходів, що ведуть до $q$, на $clone$.

Скористаємося відомим фактом, що розмір суфіксного автомата (як по числу станів, так і по числу переходів) залежить лінійно. (Доведенням лінійності по числу станів є сам алгоритм, а доведення лінійності по числу переходів ми наведемо нижче, після реалізації алгоритму).

Значить, очевидна лінійна сумарна асимптотика **першого та другого порядку**: оскільки кожна операція додає в автомат один новий перехід.

Залишився оцінити сумарну асимптотику **у третьому місці** - тому, де ми перенаправляємо переходи, провідні в $q$, на $clone$. Позначимо $v = longest(p)$. Це суфікс рядка $s$, і з кожною ітерацією його довжина зменшується - а, значить, і позиція $v$ як суфікса рядка $s$ монотонно зростає з кожною ітерацією. При цьому, якщо перед першою ітерацією циклу відповідний рядок $v$ був на глибині $k$ ($k \ge 2$) від $last$ (якщо вважати глибиною число суфіксних посилань, які треба пройти), то після останньої ітерації рядок $v+c$ стане другою суфіксною посиланням на шляхи від $cur$ (яке стане новим значенням $last$).

Таким чином, кожна ітерація цього циклу призводить до того, що позиція рядка $longest(link(link(last)))$ як суфікса всієї поточної рядка буде монотонно збільшуватися. Отже, цей цикл не міг виконатися більше $n$ разів, що потрібно довести.

Варто зазначити, що аналогічні аргументи можна використовувати для доведення лінійності роботи першого множника, замість посилання на доведення лінійності кількості станів.

## Реалізація алгоритму

На початку опишемо структуру даних, яка буде зберігати всю інформацію про конкретний перехід ($len$, $link$, список переходів). При необхідності сюди можна додати прапорець термінальності, а також іншу необхідну інформацію. Список переходів ми зберігаємо у вигляді стандартного контейнера $unordered\_map$, що дозволяє досягти сумарно $O(n)$ пам'яті і $O(n \log k)$ часу на обробку всієї рядка.

<!--- TODO: specify code snippet id -->
``` cpp
struct state {
    int len, link;
    map<char, int> next;
};
```

Сам суфіксний автомат будемо зберігати у вигляді масиву структур $state$. Як доводиться в наступному розділі, якщо $MAXN$ - це максимально можлива довжина рядка в програмі, то достатньо виділити пам'ять під $2 \cdot MAXN - 1$ станів. Також ми зберігаємо змінну $last$ - стан, що відповідає всій рядку на даний момент.

<!--- TODO: specify code snippet id -->
``` cpp
const int MAXLEN = 100000;
state st[MAXLEN * 2];
int sz, last;
```

Наведемо функцію, яка ініціалізує суфіксний автомат (створює автомат з єдиним початковим станом):

<!--- TODO: specify code snippet id -->
``` cpp
void sa_init() {
    sz = last = 0;
    st[0].len = 0;
    st[0].link = -1;
    ++sz;
    /*
// Цей код потрібен тільки у випадку, якщо автомат будується багато разів для різних рядків:
    for (int i=0; i<MAXLEN*2; ++i)
        st[i].next.clear();
    */
}
```

Нарешті, наведемо реалізацію основної функції - яка додає черговий символ в кінець поточної рядка, перебудовуючи відповідним чином автомат:

<!--- TODO: specify code snippet id -->
``` cpp
void sa_extend(char c) {
    int cur = sz++;
    st[cur].len = st[last].len + 1;
    int p;
    for (p = last; p != -1 && !st[p].next.count(c); p = st[p].link)
        st[p].next[c] = cur;
    if (p == -1)
        st[cur].link = 0;
    else {
        int q = st[p].next[c];
        if (st[p].len + 1 == st[q].len)
            st[cur].link = q;
        else {
            int clone = sz++;
            st[clone].len = st[p].len + 1;
            st[clone].next = st[q].next;
            st[clone].link = st[q].link;
            for (; p != -1 && st[p].next[c] == q; p = st[p].link)
                st[p].next[c] = clone;
            st[q].link = st[cur].link = clone;
        }
    }
    last = cur;
}
```

Як вже згадувалося вище, якщо пожертвувати пам'яттю (до $O(nk)$, де $k$ - розмір алфавіту), то можна досягти часу побудови автомата $O(n)$ навіть для будь-яких $k$ - але для цього доведеться в кожному стані зберігати масив розміру $k$ (для швидкого пошуку переходу по потрібній букві) і список всіх переходів (для швидкого обходу або копіювання всіх переходів).

## Додаткові властивості суфіксного автомата

### Кількість станів

Число станів у суфіксному автоматі, побудованому для рядка $s$ довжини $n$, **не перевищує $2n-1$** (для $n \ge 3$).

Доказом цього є описаний вище алгоритм (оскільки спочатку автомат складається з одного початкового стану, на першому та другому кроках додається один стан, а на кожному з інших $n-2$ кроків може додаватися по дві вершини через розгалуження стану).

Однак цю оцінку **легко показати навіть без знання алгоритму**. Нагадаймо про те, що кількість станів дорівнює кількості різних значень множин $endpos$. Крім того, ці множини $endpos$ утворюють дерево за принципом "вершина-батько містить в собі як підмножини всіх дітей". Розглянемо це дерево, і трохи перетворимо його: доки в ньому є внутрішня вершина з одним сином, то це означає, що $endpos$ цього сина не містить як мінімум одне число з $endpos$ батька; тоді створимо віртуальну вершину з $endpos$, рівним цьому числу, і прикріпимо цього сина до батька. В результаті ми отримаємо дерево, в якому кожна внутрішня вершина має ступінь більше одиниці, а число листків не перевищує $n$. Отже, всього в такому дереві не більше $2n-1$ вершин.

Отже, ми показали цю оцінку незалежно, не знаючи алгоритму.

Цікаво зауважити, що ця оцінка непокращувана, тобто існує **тест, на якому її можна досягти**. Цей тест має наступний вигляд:

$$
" abbbb \ldots "
$$

При обробці цієї рядка на кожній ітерації, починаючи з третьої, відбуватиметься розщеплення стану, і, таким чином, буде досягатися оцінка $2n-1$.

### Кількість переходів

Число переходів у суфіксному автоматі, побудованому для рядка $s$ довжиною $n$, **не перевищує $3n-4$** (для $n \ge 3$).

**Доведемо** це.

Оцінимо число суцільних переходів. Розглянемо каркасне дерево з длиннейших шляхів в автоматі, починаються в стані $t_0$. Цей каркас буде складатися тільки з суцільних ребер, а, значить, їх кількість на одиницю менше числа станів, тобто не перевершує $2n-2$.

Оцінимо тепер кількість несплошних переходів. Розглянемо кожен несплошний перехід; нехай поточний перехід - це перехід $(p,q)$ за символом $c$. Поставимо йому відповідність рядок $u+c+w$, де рядок $u$ відповідає найдовшому шляху з початкового стану до $p$, а $w$ - найдовшому шляху з $q$ до будь-якого термінального стану. З одного боку, всі такі рядки $u+c+w$ для всіх несплошних переходів будуть різними (оскільки рядки $u$ і $w$ утворені тільки сплошними переходами). З іншого боку, кожен з таких рядків $u+c+w$, за визначенням термінального стану, буде суфіксом всього рядка $s$. Оскільки непустих суфіксів у рядку $s$ всього $n$ штук, і до того ж весь рядок $s$ серед цих рядків $u+c+w$ не міг міститися (адже весь рядок $s$ відповідає шляху з $n$ сплошних ребер), то загальна кількість несплошних переходів не перевищує $n-1$.

Складаючи ці дві оцінки, ми отримуємо оцінку $3n-3$. Однак, згадуючи, що максимальна кількість станів досягається тільки на тесті уваги $"abbbb \ldots "$, і на ньому оцінка $3n-3$ явно не досягається, отримуємо остаточну оцінку $3n-4$, що потрібно довести.

Цікаво зауважити, що також існує **тест, на якому досягається ця оцінка**:

$$
"abbb \ldots bbbc"
$$

### Зв'язок із суфіксним деревом. Побудова суфіксного дерева за допомогою суфіксного автомата та навпаки

Доведемо дві теореми, устанавливающие взаимную зв'язок між суфіксним автоматом і [суфіксним деревом](ukkonen).

Відразу узгодимо, що припустимо, що вхідний рядок такий, що кожний суфікс має свою власну вершину в суфіксному дереві (оскільки для довільних рядків це, загалом кажучи, невірно: наприклад, для рядка $"aaa \ldots"$). Зазвичай цього досягають шляхом додавання до кінця рядка якогось особливого символу (зазвичай позначається знаком долара).

Для зручності введемо позначення: $\overline{s}$ - це рядок $s$, записаний в зворотному порядку, $DAWG(s)$ - це суфіксний автомат, побудований для рядка $s$, $ST(s)$ - це [суфіксне дерево](https://uk.wikipedia.org/wiki/%D0%A1%D1%83%D1%84%D1%96%D0%BA%D1%81%D0%BD%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE) рядка $s$.

Введемо поняття **розширюючого посилання**: зафіксуємо вершину суфіксного дерева $v$ і символ $c$; тоді розширююче посилання $ext[c,v]$ веде в вершину дерева, відповідну рядку $c+v$ (якщо цей шлях $c+v$ закінчується посередині ребра, то проведемо посилання в нижній кінець цього ребра); якщо такого шляху $c+v$ немає взагалі в дереві, то розширююче посилання не визначене. В деякому сенсі, розширюючі посилання протилежні суфіксним посиланням.

**Теорема 1**. Дерево, що утворюється суфіксними посиланнями в $DAWG(s)$, є суфіксним деревом $ST(\overline{s})$.

**Теорема 2**. $DAWG(s)$ - це граф розширюючих посилань суфіксного дерева $ST(\overline{s})$. Крім того, цілі ребра в $DAWG(s)$ - це інвертовані суфіксні посилання в $ST(\overline{s})$.

Ці дві теореми дозволяють побудувати одну зі структур (суфіксне дерево або суфіксний автомат) за допомогою іншої за час $O(n)$ - ці два прості алгоритми будуть розглянуті нами далі в теоремах 3 і 4.

В цілях наочності наведемо суфіксний автомат з його деревом суфіксних посилань та відповідне суфіксне дерево для інвертованої рядка. На прикладі візьмемо рядок $s = "абцба"$.

$DAWG("абцбц")$ і його дерево суфіксних посилань (для наочності ми позначаємо кожен стан його $longest$-рядком):

\img{suffix_automaton_st_1.gif}

$ST("cbcba")$:

\img{suffix_automaton_st_2.gif}

**Лема**. Наступні три твердження еквівалентні для будь-яких двох підрядків $u$ та $w$:

* $endpos(u) = endpos(w)$ в рядках $s$
* $firstpos(\bar{u}) = firstpos(\bar{w})$ у рядках $\bar{s}$
* $\overline{u}$ та $\overline{w}$ лежать на одному і тому ж шляху з кореня до суфіксного дерева $ST(\overline{s})$.

Доведення її досить очевидне: якщо початки входжень двох рядків збігаються, то один рядок є префіксом іншого, а, отже, один рядок лежить у суфіксному дереві на шляху іншого рядка.

**Доведення теореми 1**. 

Стани суфіксного автомата відповідають вершинам суфіксного дерева.

Розглянемо довільне суфіксне посилання $y = посилання(x)$. Згідно визначення суфіксного посилання, $longest(y)$ є суфіксом $longest(x)$, причому серед усіх таких $y$ вибирається той, у якого $len(y)$ максимальне.

У термінах інвертованої рядка $\overline{s}$ це означає, що суфіксне посилання $link[x]$ веде до такого довгого префіксу рядка, що відповідає стану $x$, щоб цьому префіксу відповідало окремий стан $y$. Іншими словами, суфіксне посилання $link[x]$ веде до предка вершини $x$ в суфіксному дереві, що й потрібно довести.

**Доведення теореми 2**.

Стани суфіксного автомата відповідають вершинам суфіксного дерева.

Розглянемо довільний перехід $(x,y,c)$ у суфіксному автоматі $DAWG(s)$. Наявність цього переходу означає, що $y$ - це такий стан, клас еквівалентності якого містить підрядок $longest(x) + c$. У інвертованій рядку $\overline{s}$ це означає, що $y$ - це такий стан, якому відповідає підрядок, $firstpos$ від якої (в тексті $\overline{s}$) співпадає з $firstpos$ від підрядки $c + \overline{longest(x)}$.

Це саме означає, що:

$$
\overline{longest(y)} = ext[c, \overline{longest(x)}].
$$

Перша частина теореми доведена, залишилося довести ще одну частину: що всі цілі переходи в автоматі відповідають суфіксним посиланням в дереві. Цілі переходи відрізняються від неповних тим, що $length(y) = length(x) + 1$, тобто після додавання символу $c$ ми потрапили в стан з рядком, що має максимальну довжину в класі еквівалентності цього стану. Це означає, що при обчисленні відповідного розширюючого посилання $ext[c, \overline{longest(x)}]$ ми зразу потрапили в вершину дерева, а не спускалися вниз до найближчої вершини дерева. Таким чином, додавши один символ на початок, ми потрапили в іншу вершину дерева - отже, це і є інвертоване суфіксне посилання в дереві.

Теорема повністю доведена.

**Теорема 3**. Маючи суфіксний автомат $DAWG(s)$, можна за час $O(n)$ побудувати суфіксне дерево $ST(\overline{s})$.

**Теорема 4**. Маючи суфіксне дерево $ST(\overline{s})$, можна за час $O(n)$ побудувати суфіксний автомат $DAWG(s)$.

**Доведення теореми 3**.

Суфіксне дерево $ST(\overline{s})$ матиме стільки ж вершин, скільки станів у $DAWG(s)$, причому вершині дерева, що відповідає стану $v$ автомата, відповідатиме рядок довжини $len(v)$.

Згідно теореми 1, ребра в дереві утворюються як інвертовані суфіксні посилання, а дугові мітки можна знайти, виходячи з різниці довжин станів, додатково знаючи для кожного стану автомата один будь-який елемент його множини $endpos$ (цей один елемент множини $endpos$ можна підтримувати при побудові автомата).

Суфіксні посилання в дереві ми можемо побудувати згідно з теоремою 2: для цього достатньо переглянути всі цілі переходи в автоматі, і для кожного такого переходу $(x,y)$ додати посилання $link(y) = x$.

Таким чином, за час $O(n)$ ми можемо побудувати суфіксне дерево разом із суфіксними посиланнями в ньому.

Якщо ми припустимо, що розмір алфавіту $k$ не є константою, то на перебудовування буде потрібно час $O(n \log k)$.

**Доведення теореми 4**.

Суфіксний автомат $DAWG(s)$ буде містити стільки ж станів, скільки вершин у $ST(\overline{s})$. У кожного стану $v$ його найдовшо рядок $longest(v)$ буде відповідати інвертованому шляху з кореня дерева до вершини $v$.

Згідно теореми 2, щоб побудувати всі переходи у суфіксному автоматі, нам потрібно знайти всі розширюючі посилання $ext[c,v]$.

По-перше, зауважимо, що частина цих розширюючих посилань виходять безпосередньо з суфіксних посилань у дереві. Насправді, якщо для будь-якої вершини $x$ ми розглянемо її суфіксне посилання $y = link(x)$, то це означає, що треба провести розширююче посилання з $y$ в $x$ за першим символом рядка, відповідного вершині $x$.

Однак, так ми не знайдемо всі розширюючі посилання. Додатково потрібно пройтися по суфіксному дереву від листя до кореня і для кожної вершини $v$ переглянути всіх її синів. Для кожного сина потрібно переглянути всі розширюючі посилання $ext[c,w]$ і скопіювати це посилання в вершину $v`, якщо по цьому символу $c$ посилання з вершини $v`$ ще не було знайдене

$$ ext[c,v] = ext[c,w], \text{if $ext[c,w] = nil$.} $$

Цей процес відпрацює за час $O(n)$, якщо ми припустимо розмір алфавіту сталим.

Нарешті, залишилося побудувати суфіксні посилання в автоматі. Згідно з теоремою 1, ці посилання виходять як ребра суфіксного дерева $ST(\overline{s})$. Російське слово "автомат" можна замінити на українське "автоматон".

Таким чином, описаний алгоритм будує суфіксний автомат за час $O(n)$ для інвертованої рядка, використовуючи суфіксне дерево.

Якщо ми припустимо, що розмір $k$ алфавіту є змінною величиною, то асимптотика збільшиться до $O(n \log k)$.

## Застосування при вирішенні задач

Нижче ми розглянемо, які задачі можна вирішувати за допомогою суфіксного автомата.

Ми для простоти будемо вважати розмір алфавіту $k$ константою, що дозволить нам вважати асимптотику побудови суфіксного автомата та проходу по ньому константними.

### Перевірка входження

Умова. Даний текст $T$, і надходять запити у вигляді: задано рядок $P$, необхідно перевірити, чи входить рядок $P$ до тексту $T$ як підрядок.

**Асимптотика**. Препроцесінг на один запит займає $O(length(T))$ для тексту і $O(length(P))$ для патерну.

Розв'язок. Побудуємо суфіксний автомат за текстом $T$ за час $O(\text{length}(T))$.

Як тепер відповідати на запит. Нехай поточний стан - це змінна $v$, спочатку вона дорівнює початковому стану $t_0$. Будемо переходити з поточного стану $v$ в новий стан, відповідно до символів рядка $P$. Якщо в якийсь момент виявиться, що перехід за потрібним символом неможливий, то відповідь на запит буде "ні". Якщо ж ми зможемо обробити всю рядок $P$, то відповідь на запит буде "так".

Зрозуміло, що це буде працювати за час $O(\operatorname{length}(P))$. Крім того, алгоритм фактично шукає довжину найдовшого префікса $P$, що зустрічається в тексті. Якщо вхідні зразки такі, що ці довжини невеликі, то алгоритм буде працювати значно швидше, не обробляючи всю рядок цілком.

### Кількість різних підрядків

Умова: задано рядок $S$. Потрібно дізнатися кількість різних підрядків цього рядка.

**Асимптотика**. $O(length (S))$.

Розв'язок. Побудуємо суфіксний автомат для рядка $S$.

У суфіксному автоматі будь-якому підрядку рядка $S$ відповідає якийось шлях у автоматі. Оскільки повторювані рядка в автоматі бути не можуть, то відповідь на задачу - це **кількість різних шляхів** у автоматі, що починаються в початковій вершині $t_0$.

Враховуючи, що суфіксний автомат є ациклічним графом, кількість різних шляхів можна обчислити в ньому за допомогою динамічного програмування.

А саме, нехай $d[v]$ - це кількість різних шляхів, що починаються зі стану $v$ (включаючи шлях довжини нуль). Отже, правильно:

$$
d[v] = 1 + \sum_{w ~ : \atop (v,w,c) \in DAWG} d[w],
$$

тобто $d[v]$ можна виразити як суму відповідей за всіма переходами зі стану $v$.

Відповідь на задачу буде значення $d[t_0]-1$ (одиниця віднімається, щоб не враховувати порожню підрядок).

### Сумарна довжина різних підрядків

Умова: дана рядок $S$. Потрібно дізнатися сумарну довжину всіх різних підрядків цього рядка.

**Асимптотика**. $O(length (S))$.

Розв'язок. Розв'язок задачі аналогічний попередньому, тільки тепер треба враховувати в динаміці дві величини: кількість різних підрядків $d[v]$ і їх сумарну довжину $ans[v]$.

Як вважати $d[v]$, описано в попередній задачі, а величину $ans[v]$ можна обчислити таким чином:

$$
ans[v] = \sum_{w ~ : \atop (v,w,c) \in DAWG} d[w] + ans[w],
$$

тобто ми беремо відповідь для кожної вершини $w$, і додаємо до нього $d[w]$, тим самим приписуючи в початок кожної зі стрічок по одному символу.

### Лексикографічно k-тий підрядок

Умова. Дана рядок $S$. Надходять запити - числа $K_i$, і потрібно знайти $K_i$-ту в порядку сортування підрядок рядка $S$.

Асимптотика: $O(\text{length}(ans) \cdot \text{РозмірАлфавіту})$ на один запит (де $ans$ - це відповідь на цей запит).

**Розв'язок**. Розв'язок даної задачі базується на тій же ідеї, що й попередні дві задачі. Лексикографічною $k$-ою підрядком є лексикографічний $k$-ий шлях в суфіксному автоматі. Тому, вважаючи для кожного стану кількість шляхів з нього, ми зможемо легко знайти $k$-ий шлях, рухаючись від кореня автомата.

### Найменший циклічний зсув

**Умова**. Дана рядок $S$. Потрібно знайти лексикографічно найменший її циклічний зсув.

**Асимптотика**. $O(length (S))$.

Розв'язок. Побудуємо суфіксний автомат для рядка $S+S$. Отже, цей автомат буде містити всі циклічні зсуви рядка $S$ як шляхи.

Отже, задача полягає у тому, щоб знайти в автоматі лексикографічно найменший шлях довжини $length(S)$. Це можна зробити тривіальним чином: розпочинаємо зі стартового стану і на кожному кроці переходимо до наступного стану, вибираючи перехід з мінімальним символом. Російське слово "жадібно" можна замінити на "оптимально".

### Кількість входжень

Умова. Даний текст $T$, і надходять запити у вигляді: задано рядок $P$, потрібно дізнатися, скільки разів рядок $P$ входить у текст $T$ як підрядок (входження можуть перекриватися).

Асимптотика. Препроцесінг $O(\operatorname{length}(T))$ і $O(\operatorname{length}(P))$ на один запит.

Розв'язок. Побудуємо суфіксний автомат за текстом $T$

Далі нам потрібно зробити такий препроцесінг: для кожного стану $v$ автомата порахувати число $cnt[v]$, що дорівнює розміру множини $endpos(v)$. Насправді, всі рядки, що відповідають одному і тому ж стану, входять в $T$ однакову кількість разів, що дорівнює кількості позицій у множині $endpos$.

Однак ми не можемо явно підтримувати множини $endpos$ для всіх станів, тому навчимося вважати тільки їх розміри $cnt$.

Для цього зробимо наступне. Для кожного стану, якщо він не був отриманий шляхом клонування (і початковий стан $t_0$ також не враховується), спочатку встановимо $cnt = 1$. Потім будемо переходити по всім станам в порядку зменшення їх довжини $len$ і передавати поточне значення $cnt[v]$ через суфіксну посилання:

$$
cnt[link(v)] += cnt[v].
$$

Стверджується, що в кінці процесу ми правильно порахуємо значення $cnt$ для кожного стану.

Чому це правильно? Всього станів, отриманих не шляхом клонування, дорівнює $|S|+1$, і $i$-й з них з'являється, коли ми додаємо перші $i$ символів. Отже, кожному з цих станів ми ставимо у відповідність позицію, при обробці якої він з'явився. Тому спочатку у кожного такого стану $cnt = 1$, а у всіх інших станів $cnt = 0$.

Потім ми виконуємо для кожного $v$ таку операцію: $cnt[link(v)] += cnt[v]$. Сенс полягає в тому, що якщо рядок, що відповідає стану $v$, зустрічався $cnt[v]$ разів, то всі його суфікси будуть зустрічатися стільки ж.

Чому ми не можемо врахувати одну і ту ж позицію кілька разів? Тому що з кожного стану його значення передається тільки один раз, тому неможливо, щоб з одного стану його значення передавалося до іншого стану двічі різними шляхами.

Таким чином, ми навчилися обчислювати значення змінної $cnt$ для всіх станів автомата.

Після цього відповідь на запит буде тривіальною - потрібно просто повернути $cnt[t]$, де $t$ - стан, відповідний зразку $P$.

### Позиція першого входження

Умова. Даний текст $T$, і надходять запити у вигляді: задано рядок $P$, потрібно дізнатися позицію початку першого входження рядка $P$.

**Асимптотика**. Препроцесінг на один запит з складністю $O(length (T))$ і $O(length (P))$.

Розв'язок. Побудуємо суфіксний автомат за текстом $T$.

Для розв'язання задачі нам також потрібно додати до препроцесінгу знаходження позицій $firstpos$ для всіх станів автомата. Тобто для кожного стану $v$ ми хочемо знайти позицію $firstpos[v]$ початку першого входження. Іншими словами, ми хочемо заздалегідь знайти мінімальний елемент кожної з множин $endpos(v)$ (оскільки явно підтримувати всі множини $endpos$ ми не можемо).

Підтримувати ці позиції $firstpos$ найпростіше прямо під час побудови автомата: коли ми створюємо новий стан $cur$ під час виклику функції $sa\_extend()$, то встановлюємо йому:

$$
firstpos(cur) = len(cur) - 1
$$

(Якщо ми працюємо з $0$-індексацією).

При клонуванні вершини $q$ в $clone$ ми встановлюємо:

$$
firstpos(clone) = firstpos(q),
$$

(Оскільки інших різновидів значень тільки один - це $firstpos(cur)$, що явно більше).

Таким чином, відповідь на запит - це просто $firstpos(t)-\operatorname{length}(P)+1$, де $t$ - стан, відповідний зразку $P$.

### Позиції всіх входжень

Умова. Даний текст $T$, і надходять запити у вигляді: задано рядок $P$, потрібно вивести позиції всіх її входжень у рядок $T$ (входження можуть перекриватись).

**Асимптотика**. Препроцесування $O(\operatorname{length}(T))$. Відповідь на один запит за $O(\operatorname{length}(P) + \operatorname{answer}(P))$, де $\operatorname{answer}(P)$ - це розмір відповіді, тобто ми будемо розв'язувати задачу за час порядку розміру вводу і виводу.

Розв'язок. Побудуємо суфіксний автомат за текстом $T$. Аналогічно до попередньої задачі, порахуємо в процесі побудови автомата для кожного стану позицію $firstpos$ закінчення першого входження.

Нехай тепер надійшов запит - рядок $P$. Знайдемо, якому стану $t$ він відповідає.

Зрозуміло, що $firstpos(t)$ точно має бути включено до відповіді. Які ще позиції потрібно знайти? Ми врахували стан автомата, що містить рядок $P$, але не врахували інші стани, які відповідають рядкам, для яких $P$ є суфіксом.

Іншими словами, нам потрібно знайти всі стани, з яких можна досягти стану $t$ за допомогою суфіксних посилань.

Отже, для розв'язання задачі нам буде потрібно зберегти для кожного стану список суфіксних посилань, які ведуть до нього. Відповідь на запит тоді буде полягати в тому, щоб зробити **обхід в глибину/в ширину** по цих інвертованих суфіксних посиланнях, починаючи зі стану $t$.

Цей обхід буде працювати за час $O(\operatorname{answer}(P))$, оскільки ми не відвідаємо один і той же стан двічі (тому що з кожного стану суфіксне посилання виходить тільки одне, тому неможливо мати два шляхи, що ведуть в один і той же стан).

Правда, потрібно враховувати, що у двох станах їх значення $firstpos$ **можуть збігатися**: якщо один стан було отримано клонуванням іншого. Однак це не погіршує асимптотику, оскільки у кожної неклонованої вершини може бути максимум один клон.

Більше того, можна легко позбутися виведення повторюваних позицій, якщо ми не будемо додавати до відповіді $firstpos$ від станів-клонів. Насправді, будь-який стан-клон має суфіксне посилання на той первинний стан, який клонувався. Таким чином, якщо ми для кожного стану запам'ятаємо прапорець $is\_clon$ і не будемо додавати до відповіді $firstpos$ від станів, для яких $is\_clon = true$, то ми отримаємо всі необхідні $answer(P)$ позицій без повторень.

Наведемо наближені варіанти реалізації:

<!--- TODO: specify code snippet id -->
``` cpp
struct state {
    ... bool is_clon;
    int first_pos;
    vector<int> inv_link;
};

... після побудови автомата... для (int v = 1; v < sz; ++v) st[st[v].link].inv_link.push_back(v);
...

Відповідь на запит: висновок всіх входжень (можливо з повтореннями)
    void
    output_all_occurences(int v, int P_length) {
    if (!st[v].is_clon)
        cout << st[v].first_pos - P_length + 1 << endl;
    for (size_t i = 0; i < st[v].inv_link.size(); ++i)
        output_all_occurences(st[v].inv_link[i], P_length);
}
```

### Пошук найкоротшої рядка, що не входить до даної

Умова. Дано рядок $S$ та заданий алфавіт. Потрібно знайти найкоротшу рядок, яка не є підрядком $S$.

Асимптотика. Розв'язок з часовою складністю $O(\text{length}(S))$.

Розв'язок. Будемо розв'язувати задачу за допомогою динамічного програмування за автоматом, побудованим для рядка $S$.

Нехай $d[v]$ - це відповідь для вершини $v$, тобто ми вже набрали частину підрядки, опинившись в стані $v$, і хочемо знайти найменшу кількість символів, яку потрібно ще додати, щоб вийти за межі автомата, знайшовши неіснуючий перехід.

Вважається, що $d[v]$ дуже просто. Якщо з $v$ немає жодного переходу по символу з алфавіту, то $d[v] = 1$: ми можемо приписати будь-який символ і вийти за межі автомата, отримавши тим самим шукану рядок.

У іншому випадку, не вдасться обійтися одним символом, тому потрібно взяти мінімум з відповідей для всіх символів

$$
d[v] = 1 + \min_{w ~ : \atop (v,w,c) \in DAWG} d[w].
$$

Відповідь на задачу буде дорівнювати $d[t_0]$, а саму рядок можна відновити, відновивши, яким чином в динаміці вийшов цей мінімум.

### Найдовша загальний підрядок двох рядків

Умова. Дано дві рядки $S$ і $T$. Потрібно знайти їх найдовшу спільну підрядок, тобто таку рядок $X$, що вона є підрядком і $S$, і $T$.

**Асимптотика**. Розв'язок за $O(length(S) + length(T))$.

Розв'язок. Побудуємо суфіксний автомат для рядка $S$.

Будемо тепер проходити по рядку $T$ і для кожного префіксу шукатимемо найдовший суфікс цього префіксу, який зустрічається в $S$. Іншими словами, ми хочемо знайти найдовшу спільну підрядок $S$ і $T$, яка закінчується саме в цій позиції, для кожної позиції в рядку $T$.

Для цього треба підтримувати дві змінні: **поточний стан** $v$ і **поточну довжину** $l$. Ці дві змінні будуть описувати поточну збігаючуся частину: її довжину і стан, який відповідає їй (без зберігання довжини не можна обійтися, оскільки одному стану можливо відповідати зразу декілька рядків різної довжини).

Спочатку $p=t_0$, $l=0$, тобто збіг порожній.

Нехай тепер ми розглядаємо символ T[i] і хочемо перерахувати відповідь для нього.

* Якщо зі стану $v$ в автоматі є перехід за символом $T[i]$, то ми просто здійснюємо цей перехід і збільшуємо $l$ на одиницю.

* Якщо зі стану $v$ немає потрібного переходу, то ми повинні спробувати скоротити поточну збігається частину, для чого потрібно перейти по суфіксному посиланню

$$
v = link(v).
$$

При цьому потрібно скоротити поточну довжину, але залишити її максимально можливою. Очевидно, для цього потрібно присвоїти $l = довжина(v)$, оскільки після проходу по суфіксному посиланню ми можемо задовольнити будь-який підрядок довжини, що відповідає цьому стану:

$$
l = len(v).
$$

Якщо з нового стану знову не буде переходу за потрібним символом, то ми знову повинні пройти по суфіксному посиланню і зменшити $l$, і так далі, поки не знайдемо перехід (тоді перейдемо до пункту 1) або ми не потрапимо в фіктивний стан $-1$ (що означає, що символ $T[i]$ взагалі не зустрічається в $S$, тому присвоюємо $v=l=0$ і переходимо до наступного $i$).

Відповіддю на задачу буде максимум зі значень $l$ протягом усього часу обходу.

Асимптотика такого проходу становить $O(\operatorname{length}(T))$, оскільки за один хід ми можемо або збільшити на одиницю $l$, або зробити декілька проходів по суфіксному посиланню, кожний з яких буде строго зменшувати значення $l$. Отже, зменшень не могло бути більше, ніж $length(T)$, що і означає лінійну асимптотику.

Реалізація:

<!--- TODO: specify code snippet id -->
``` cpp
string lcs(string s, string t) {
    sa_init();
    for (int i = 0; i < (int)s.length(); ++i)
        sa_extend(s[i]);

    int v = 0, l = 0, best = 0, bestpos = 0;
    for (int i = 0; i < (int)t.length(); ++i) {
        while (v && !st[v].next.count(t[i])) {
            v = st[v].link;
            l = st[v].length;
        }
        if (st[v].next.count(t[i])) {
            v = st[v].next[t[i]];
            ++l;
        }
        if (l > best)
            best = l, bestpos = i;
    }
    return t.substr(bestpos - best + 1, best);
}
```

### Найбільша загальний підрядок кількох стрічок.

Умова. Дано $K$ рядків $S_i$. Потрібно знайти їх найбільшу спільну підрядок, тобто таку рядок $X$, що вона є підрядком всіх $S_i$.

**Асимптотика**. Розв'язок має складність $O(\sum\limits_{i=1}^{n} length(S_i) \cdot K)$.

**Розв'язок.** Зліпимо всі рядки $S_i$ в один рядок $T$, додаючи після кожного рядка $S_i$ свій власний символ-роздільник $D_i$ (тобто вводячи $K$ додаткових спеціальних символів $D_i$):

$$
T = S_1 ~ D_1 ~ S_2 ~ D_2 ~ \ldots ~ S_k D_k.
$$

Побудуємо для рядка $T$ суфіксний автомат.

Тепер нам потрібно знайти таку рядок в автоматі, яка міститься у всіх рядках $S_i$, і для цього нам допоможуть додані спецсимволи. Зауважимо, що якщо яка-небудь підрядок входить до деякої рядка $S_j$, то в суфіксному автоматі з цієї підрядки знайдеться шлях, що містить символ $D_j$, і не містить інших символів $D_1, \ldots, D_{j-1}, D_{j+1}, \ldots, D_k}$.

Таким чином, нам потрібно порахувати досяжність: для кожного стану автомата і кожного символу $D_i$ має бути або шлях, що містить роздільник $D_i$, і не містить інших роздільників. Це легко зробити обходом в глибину/ширину або ледачою динамікою. Після цього відповіддю на задачу буде рядок $longest(v)$ для стану $v$, з якого були знайдені шляхи по всім символам.

## Завдання на онлайн-суддях

Задачі, які можна вирішити за допомогою суфіксного автомата:

* [SPOJ #7258 SUBLEX **"Lexicographical Substring Search"** [складність: середня]](http://www.spoj.pl/problems/SUBLEX/)

## Література

Наведемо спочатку список перших робіт, пов'язаних із суфіксними автоматами:

* A. Blumer, J. Blumer, A. Ehrenfeucht, D. Haussler, R. McConnell. **Linear Size Finite Automata for the Set of All Subwords of a Word. An Outline of Results** [1983]

* A. Blumer, J. Blumer, A. Ehrenfeucht, D. Haussler. **The Smallest Automaton Recognizing the Subwords of a Text** [1984]

* Maxime Crochemore. **Optimal Factor Transducers** [1985]

* Maxime Crochemore. **Transducers and Repetitions** [1986]

* A. Nerode. **Linear automaton transformations** [1958]

Крім того, у більш сучасних джерелах ця тема згадується в багатьох книгах про рядкові алгоритми

* Maxime Crochemore, Wowjcieh Rytter. **Jewels of Stringology** [2002]

* Bill Smyth. **Computing Patterns in Strings** [2003]

* Біл Сміт. **Методи і алгоритми обчислень на рядках** [2006]