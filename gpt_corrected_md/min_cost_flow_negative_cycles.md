# Потік мінімальної вартості, циркуляція мінімальної вартості. Алгоритм видалення циклів з від'ємним вагою

## Постановка завдання

Нехай $G$ - мережа, тобто орієнтований граф, в якому обрані вершини-джерело $s$ і стік $t$. Множину вершин позначимо через $V$, множину ребер - через $E$. Кожному ребру $(i,j) \in E$ відповідають його пропускна здатність $u_{ij} \ge 0$ та вартість одиниці потоку $c_{ij}$. Якщо ребро $(i,j)$ відсутнє в графі, то передбачається, що $u_{ij} = c_{ij} = 0$.

**Потіком** (плином) в мережі $G$ називається така дійснозначна функція $f$, що ставить у відповідність кожній парі вершин $(i,j)$ плин $f_{ij}$ між ними, і задовольняє трьом умовам:

* Обмеження пропускної здатності (виконується для будь-яких $i, j \in V$):

$$
f_{ij} \le u_{ij}
$$

* Антисиметричність (виконується для будь-яких $i, j \in V$):

$$
f_{ij} = - f_{ji}
$$

* Збереження потоку виконується для будь-якого $i \in V$, крім $i=s$ та $i=t$:

$$
\sum_{j \in V} f_{ij} = 0
$$

Потік - це величина

$$
|f| = \sum_{i \in V} f_{si}
$$

Вартість потоку називається величина

$$
z(f) = \sum_{i,j \in V} c_{ij} f_{ij}
$$

Задача знаходження **потоку мінімальної вартості** полягає в тому, що при заданій величині потоку $|f|$ потрібно знайти потік, який має мінімальну вартість $z(f)$. Слід звернути увагу на те, що вартості $c_{ij}$, приписані ребрам, відповідають за вартість одиниці потоку вздовж цього ребра. Іноді зустрічається задача, коли ребрам приписуються вартості протікання потоку вздовж цього ребра (тобто якщо протікає потік будь-якої величини, то ця вартість стягується, незалежно від величини потоку). Ця задача не має нічого спільного з розглянутою тут задачею і, крім того, є NP-повною.

Задача знаходження **максимального потоку мінімальної вартості** полягає в тому, щоб знайти потік найбільшої величини, а серед усіх таких - з мінімальною вартістю. У приватному випадку, коли ваги всіх ребер однакові, ця задача стає еквівалентною звичайній задачі про максимальний потік.

Задача знаходження **циркуляції мінімальної вартості** полягає в тому, щоб знайти потік нульової величини з мінімальною вартістю. Якщо всі вартості невід'ємні, то відповіддю буде нульовий потік $f_{ij}=0$; якщо ж є ребра негативної ваги (а, точніше, цикли негативної ваги), то навіть при нульовому потоці можливо знайти потік негативної вартості. Завдання знаходження циркуляції мінімальної вартості можна, звісно, поставити і на мережі без джерела і стоку, оскільки вони не несуть жодної смислової нагрузки (втім, в такий граф можна додати джерело і стік у вигляді ізольованих вершин і отримати звичайну за формулюванням задачу). Іноді ставиться задача знаходження циркуляції максимальної вартості - зрозуміло, достатньо змінити вартості ребер на протилежні і отримати задачу знаходження циркуляції вже мінімальної вартості.

Усі ці завдання, звісно, можна перенести і на неорієнтовані графи. Проте, перехід від неорієнтованого графа до орієнтованого є простим: кожне неорієнтоване ребро $(i,j)$ з пропускною здатністю $u_{ij}$ та вартістю $c_{ij}$ можна замінити двома орієнтованими ребрами $(i,j)$ та $(j,i)$ з однаковими пропускними здібностями та вартостями.

## Залишкова мережа

Концепція **залишкової мережі** $G^f$ ґрунтується на простій ідеї. Нехай є деякий потік $f$, і уздовж кожного ребра $(i,j) \in E$ протікає деякий потік $f_{ij} \le u_{ij}$. Отже, уздовж цього ребра можна (теоретично) пропустити ще $u_{ij} - f_{ij}$ одиниць потоку. Цю величину і називаємо **залишковою пропускною здатністю**:

$$
r_{ij}^f = u_{ij} - f_{ij}
$$

Стоимість цих додаткових одиниць потоку буде такою ж:

$$
c_{ij}^f = c_{ij}
$$

Однак окрім цього, у залишковій мережі $G^f$ з'являється зворотне ребро $(j,i)$ до прямого ребра $(i,j)$. Інтуїтивний зміст цього ребра полягає в тому, що ми можемо в майбутньому скасувати частину потоку, який протікав по ребру $(i,j)$. Відповідно, пропускання потоку вздовж цього зворотного ребра $(j,i)$ фактично, і формально, означає зменшення потоку вздовж ребра $(i,j)$. Зворотне ребро має пропускну здатність, рівну нулю (наприклад, якщо $f_{ij}=0$, то неможливо пропустити потік по зворотньому ребру; якщо $f_{ij}>0$, то за властивістю антисиметрії $f_{ji}<0$, що менше $c_{ji}^f = 0$, тобто можна пропустити деякий потік вздовж зворотного ребра), залишкову пропускну здатність, рівну потоку вздовж прямого ребра, а вартість - протилежну (адже після скасування частини потоку ми повинні відповідно зменшити вартість)

$$
u_{ji}^f = 0
$$

$$
r_{ji}^f = f_{ij}
$$

$$
c_{ji}^f = -c_{ij}
$$

Таким чином, кожному орієнтованому ребру у $G$ відповідають два орієнтованих ребра у залишковій мережі $G^f$, і кожне ребро залишкової мережі має додаткову характеристику - залишкову пропускну здатність. Однак легко помітити, що вираз для залишкової пропускної здатності $r_{ij}^f$ по суті є однаковим для прямого та зворотного ребра, тому ми можемо записати для будь-якого ребра $(i,j)$ залишкової мережі:

$$
r_{ij}^f = u_{ij}^f - f_{ij}^f
$$

До речі, при реалізації ця властивість дозволяє не зберігати остаточні пропускні здатності, а просто обчислювати їх при необхідності для ребра.

Слід зазначити, що з залишкової мережі видаляються всі ребра, які мають нульову залишкову пропускну здатність. Залишкова мережа $G^f$ повинна містити **лише ребра з додатним значенням залишкової пропускної здатності $r_{ij}^f$**.

Тут варто звернути увагу на такий важний момент: якщо в мережі $G$ були одночасно обидва ребра $(i,j)$ і $(j,i)$, то в залишковій мережі у кожного з них з'явиться по зворотному ребру, і в підсумку з'являться **кратні ребра**. Наприклад, така ситуація часто виникає, коли мережа будується за неорієнтованим графом (і, виходить, кожне неорієнтоване ребро в підсумку приведе до появлення чотирьох ребер в залишковій мережі). Цю особливість потрібно завжди пам'ятати, вона призводить до невеликого ускладнення програмування, хоча в цілому нічого не змінює. Крім того, позначення ребра $(i,j)$ в такому випадку стає неоднозначним, тому нижче ми всюди будемо вважати, що такої ситуації в мережі немає (виключно в цілях простоти і коректності опису; на правильність ідей це ніяк не впливає).

## Критерій оптимальності за наявності циклів негативної ваги

**Теорема.** Деякий потік $f$ є оптимальним (тобто має найменшу вартість серед усіх потоків з такою ж величиною) тоді і тільки тоді, коли залишкова мережа $G^f$ не містить циклів від'ємної ваги.

Доведення: необхідність. Нехай потік $f$ є оптимальним. Припустимо, що залишкова мережа $G^f$ містить цикл від'ємної ваги. Візьмемо цей цикл від'ємної ваги і виберемо мінімум $k$ серед залишкових пропускних здібностей ребер цього циклу ($k$ буде більше нуля). Але тоді можна збільшити потік уздовж кожного ребра циклу на величину $k$, при цьому ніякі властивості потоку не порушаться, величина потоку не зміниться, однак вартість потоку зменшиться (зменшиться на вартість циклу, помножену на $k$). Таким чином, якщо є цикл від'ємної ваги, то $f$ не може бути оптимальним, що і треба було довести.

Доведення достатності. Для цього спочатку доведемо допоміжні факти.

**Лема 1** (про декомпозицію потоку): будь-який потік $f$ можна уявити у вигляді сукупності шляхів з джерела в стік та циклів, всі з яких мають позитивний потік. Доведемо цю лему конструктивно: покажемо, як розбити потік на сукупність шляхів та циклів. Якщо потік має ненульову величину, то очевидно, з джерела $s$ виходить хоча б одне ребро з позитивним потоком. Пройдемо по цьому ребру та опинимося в якійсь вершині $v_1$. Якщо ця вершина $v_1 = t$, то зупиняємося - знайшли шлях з $s$ в $t$. Інакше, за властивістю збереження потоку, з $v_1$ має виходити хоча б одне ребро з позитивним потоком. Пройдемо по ньому в якусь вершину $v_2$. Повторюючи цей процес, ми або прийдемо в стік $t$, або ж прийдемо в якусь вершину у другий раз. У першому випадку ми знайдемо шлях з $s$ в $t$, у другому - цикл. Знайдений шлях/цикл матиме позитивний потік $k$ (мінімум з потоків ребер цього шляху/циклу). Значить, зменшимо потік уздовж кожного ребра цього шляху/циклу на величину $k$. У результаті отримаємо потік, до якого знову застосуємо цей процес. Рано або пізно потік уздовж всіх ребер стане нульовим, і ми знайдемо його декомпозицію на шляхи та цикли.

**Лема 2** (про різниці потоків): для будь-яких двох потоків $f$ і $g$ однієї величини ($|f| = |g|$), потік $g$ можна уявити як потік $f$ плюс декілька циклів в залишковій мережі $G^f$. Дійсно, розглянемо різницю цих потоків $g-f$ (віднімання потоків - це почленне віднімання, тобто віднімання потоків уздовж кожного ребра). Неважко переконатися, що в результаті вийде деякий потік нульової величини, тобто циркуляція. Зробимо декомпозицію цієї циркуляції згідно з попередньою лемою. Очевидно, ця декомпозиція не може містити шляхів (тобто наявність $s$-$t$-шляху з позитивним потоком означає, що і величина потоку в мережі позитивна). Таким чином, різницю потоків $g$ і $f$ можна уявити у вигляді суми циклів в мережі $G$. Більше того, це будуть і цикли в залишковій мережі $G^f$, тобто $g_{ij} - f_{ij} \le u_{ij} - f_{ij} = r_{ij}^f$, що і треба було довести.

Тепер, озброєні цими лемами, ми легко можемо **довести достатність**. Отже, розглянемо довільний потік $f$, у залишковій мережі якого немає циклів з від'ємною вагою. Розглянемо також потік тієї ж величини, але мінімальної вартості $f^*$; доведемо, що $f$ і $f^*$ мають однакову вартість. Згідно з лемою 2, потік $f^*$ можна уявити у вигляді суми потоку $f$ і декількох циклів. Але оскільки вартості всіх циклів невід'ємні, то і вартість потоку $f^*$ не може бути меншою вартості потоку $f$: $z(f^*) \ge z(f)$. З іншого боку, оскільки потік $f^*$ є оптимальним, то його вартість не може бути вищою вартості потоку $f$. Таким чином, $z(f) = z(f^*)$, що і треба було довести.

## Алгоритм видалення циклів з від'ємним вагою

Тільки що доведена теорема дає нам простий **алгоритм**, який дозволяє знайти потік мінімальної вартості. Якщо у нас є якийсь потік $f$, то потрібно побудувати для нього залишкову мережу та перевірити, чи є в ній цикл негативної ваги. Якщо такого циклу немає, то потік $f$ є оптимальним (має найменшу вартість серед усіх потоків такої ж величини). Якщо ж знайдено цикл негативної ваги, то потрібно порахувати потік $k$, який можна додатково пропустити через цей цикл (це $k$ буде рівне мінімуму з залишкових пропускних здібностей ребер циклу). Збільшивши потік на $k$ уздовж кожного ребра циклу, ми не порушимо властивості потоку та не змінимо його величину, але зменшимо вартість цього потоку. Отримаємо новий потік $f^\prime$, для якого треба повторити весь процес.

Таким чином, щоб запустити процес покращення вартості потоку, нам потрібно перед тим знайти **будь-який потік потрібного розміру** (за допомогою стандартного алгоритму знаходження максимального потоку, див., наприклад, [алгоритм Едмондса-Карпа](edmonds_karp)). Зокрема, якщо потрібно знайти циркуляцію мінімальної вартості, можна почати з нульового потоку.

Оцінимо **асимптотику** алгоритму. Пошук циклу з від'ємною вагою в графі з $n$ вершинами і $m$ ребрами виконується за $O(nm)$ (див. [відповідну статтю](negative_cycle)). Якщо ми позначимо через $C$ найбільше зі значень ваг ребер, через $U$ - найбільшу з пропускних здатностей, то максимальне значення ваги потоку не перевищує $mCU$. Якщо всі ваги і пропускні здатності - цілі числа, то кожна ітерація алгоритму зменшує вагу потоку як мінімум на одиницю; отже, всього алгоритм виконає $O(mCU)$ ітерацій, а підсумкова асимптотика складе:

$$
O(nm^2CU)
$$

Ця асимптотика не є строго поліноміальною (strict polynomial), оскільки залежить від величин пропускних здібностей та вартостей.

Втім, якщо шукати не довільний негативний цикл, а застосувати більш чіткий підхід, то асимптотика може значно зменшитися. Наприклад, якщо кожен раз шукати цикл з мінімальною середньою вартістю (що також можна зробити за $O(nm)$), то час роботи всього алгоритму можна оцінити строго поліноміальною асимптотикою $O(n^2 m^3 \log n)$.

## Реалізація

Спочатку введемо структури даних і функції для зберігання графа. Кожне ребро зберігається в окремій структурі $\rm edge$, всі ребра лежать в загальному списку $\rm edges$, а для кожної вершини $i$ у векторі ${\rm g}[i]$ зберігаються номери ребер, що виходять з неї. Така організація дозволяє легко знаходити номер зворотнього ребра за номером прямого ребра - вони виявляються в списку $\rm edges$ сусідніми, і номер одного можна отримати за номером іншого операцією "^1" (вона інвертує молодший біт). Додавання орієнтованого ребра в граф здійснюється функцією $\rm add\_edge$, яка додає одразу пряме і зворотне ребра.

<!--- TODO: specify code snippet id -->
``` cpp
const int MAXN = 100 * 2;
int n;
struct edge {
    int v, to, u, f, c;
};
vector<edge> edges;
vector<int> g[MAXN];

void add_edge(int v, int to, int cap, int cost) {
    edge e1 = {v, to, cap, 0, cost};
    edge e2 = {to, v, 0, 0, -cost};
    g[v].push_back((int)edges.size());
    edges.push_back(e1);
    g[to].push_back((int)edges.size());
    edges.push_back(e2);
}
```

У основній програмі після зчитування графа запускається нескінченний цикл, всередині якого виконується алгоритм Форда-Беллмана. Якщо алгоритм виявляє цикл з від'ємною вагою, то потік збільшується вздовж цього циклу. Оскільки залишкова мережа може бути не зв'язним графом, алгоритм Форда-Беллмана запускається з кожної вершини, яка ще не була досягнута. Для оптимізації алгоритм використовує чергу (поточну чергу $\rm q$ та нову чергу $\rm nq$), щоб не перебирати на кожній ітерації всі ребра. Вздовж знайденого циклу кожного разу проталкується одиниця потоку, хоча для оптимізації можна визначати величину потоку як мінімум з залишкових пропускних здібностей.

<!--- TODO: specify code snippet id -->
``` cpp
const int INF = 1000000000;
for (;;) {
    bool found = false;

    vector<int> d(n, INF);
    vector<int> par(n, -1);
    for (int i = 0; i < n; ++i)
        if (d[i] == INF) {
            d[i] = 0;
            vector<int> q, nq;
            q.push_back(i);
            for (int it = 0; it < n && q.size(); ++it) {
                nq.clear();
                sort(q.begin(), q.end());
                q.erase(unique(q.begin(), q.end()), q.end());
                for (size_t j = 0; j < q.size(); ++j) {
                    int v = q[j];
                    for (size_t k = 0; k < g[v].size(); ++k) {
                        int id = g[v][k];
                        if (edges[id].f < edges[id].u)
                            if (d[v] + edges[id].c < d[edges[id].to]) {
                                d[edges[id].to] = d[v] + edges[id].c;
                                par[edges[id].to] = v;
                                nq.push_back(edges[id].to);
                            }
                    }
                }
                swap(q, nq);
            }
            if (q.size()) {
                int leaf = q[0];
                vector<int> path;
                for (int v = leaf; v != -1; v = par[v])
                    if (find(path.begin(), path.end(), v) == path.end())
                        path.push_back(v);
                    else {
                        path.erase(path.begin(), find(path.begin(), path.end(), v));
                        break;
                    }
                for (size_t j = 0; j < path.size(); ++j) {
                    int to = path[j], v = path[(j + 1) % path.size()];
                    for (size_t k = 0; k < g[v].size(); ++k)
                        if (edges[g[v][k]].to == to) {
                            int id = g[v][k];
                            edges[id].f += 1;
                            edges[id ^ 1].f -= 1;
                        }
                }
                found = true;
            }
        }

    if (!found)
        break;
}
```

## Література

* \book{Томас Кормен, Чарльз Лейзерсон, Рональд Рівест, Кліффорд Штайн}{Алгоритми: Побудова та аналіз}{2005}{cormen.djvu}
* \book{Ravindra Ahuja, Thomas Magnanti, James Orlin}{Network flows}{1993}{ahuja_flows.djvu}
* \book{Andrew Goldberg, Robert Tarjan}{Finding Minimum-Cost Circulations by Cancelling Negative Cycles}{1989}