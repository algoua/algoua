# Метод Гауса розв'язання системи лінійних рівнянь

Дана система $n$ лінійних алгебраїчних рівнянь (СЛАР) з $m$ невідомими. Потрібно розв'язати цю систему: визначити, скільки розв'язків вона має (нуль, один або нескінченно багато), а якщо вона має хоча б один розв'язок, то знайти будь-який з них.

Формулювання задачі повинно мати такий вигляд: розв'язати наступну систему:

$$
\cases{
a_{11} x_1 + a_{12} x_2 + \ldots + a_{1m} x_m = b_1, \cr
a_{21} x_1 + a_{22} x_2 + \ldots + a_{2m} x_m = b_2, \cr
\ldots \cr
a_{n1} x_1 + a_{n2} x_2 + \ldots + a_{nm} x_m = b_n,
}
$$

де коефіцієнти $a_{ij}$ $(i=1 \ldots n, j=1 \ldots m)$ і $b_i$ $(i = 1 \ldots n)$ відомі, а змінні $x_i$ $(i=1 \ldots m)$ - шукані невідомі.

Зручне матричне уявлення для цієї задачі:

$$
A x = b,
$$

де $A$ - матриця розміру $n \times m$, складена з коефіцієнтів $a_{ij}$, $x$ і $b$ - вектори-стовпці довжини $m$.

Варто відзначити, що СЛАР може бути не над полем дійсних чисел, а над полем **за модулем** якого-небудь числа $p$, тобто:

$$
\cases{
a_{11} x_1 + a_{12} x_2 + \ldots + a_{1m} x_m = b_1, \pmod p \cr
a_{21} x_1 + a_{22} x_2 + \ldots + a_{2m} x_m = b_2, \pmod p \cr
\ldots \cr
a_{n1} x_1 + a_{n2} x_2 + \ldots + a_{nm} x_m = b_n \pmod p
}
$$

Алгоритм Гауса працює і для таких систем також (але цей випадок буде розглянутий нижче в окремому розділі).

## Алгоритм Гауса

Строго кажучи, описаний нижче метод слід правильно називати методом "Гауса-Жордана" (елімінації Гауса-Жордана), оскільки він є варіацією методу Гауса. Цей метод був описаний геодезистом Вільгельмом Йорданом в 1887 році. Варто відзначити, що Вільгельм Йордан не є автором ні теореми Йордана про криві, ні йорданової алгебри - усе це три різних учені з однаковим прізвищем. Крім того, по всій видимості, більш правильною є транскрипція "Йордан", але написання "Жордан" вже закріпилось в російській літературі. Також цікаво зазначити, що цей алгоритм був придуманий Б.-І. Класеном одночасно з Йорданом (а за деякими даними навіть раніше, ніж у Йордана).

### Основна схема

Коротко кажучи, алгоритм полягає в **послідовному виключенні** змінних з кожного рівняння до того моменту, поки в кожному рівнянні не залишиться тільки по одній змінній. Якщо $n=m$, то можна стверджувати, що алгоритм Гауса-Жордана прагне привести матрицю $A$ системи до одиничної матриці - адже після того, як матриця стане одиничною, розв'язок системи очевидний - розв'язок єдиний і задається отриманими коефіцієнтами $b_i$.

При цьому алгоритм базується на двох простих еквівалентних перетвореннях системи: у першому випадку можна міняти місцями два рівняння, а у другому випадку будь-яке рівняння можна замінити лінійною комбінацією цієї рядка (з ненульовим коефіцієнтом) та інших стрічок (з довільними коефіцієнтами).

На першому кроці алгоритму Гауса-Жордана потрібно поділити перший рядок на коефіцієнт $a_{11}$. Потім до інших рядків додається перший рядок з такими коефіцієнтами, щоб їх коефіцієнти в першому стовпці стали рівні нулю. Для цього, очевидно, при додаванні першого рядка до $i$-того потрібно домножити перший рядок на $-a_{i1}$. При кожній операції з матрицею $A$ (поділ на число, додавання одного рядка до іншого) відповідні операції виконуються і з вектором $b$; в деякому сенсі, він поводиться так, ніби він є $m+1$-м стовпцем матриці $A$.

В результаті, після завершення першого кроку перший стовпчик матриці $A$ стане одиничним (тобто матиме одиницю в першому рядку та нулі в інших).

Аналогічно виготовляється другий крок алгоритму, тільки тепер розглядається другий стовпець і другий рядок: спочатку другий рядок ділиться на $a_{22}$, а потім віднімається від всіх інших рядків з такими коефіцієнтами, щоб обнулити другий стовпець матриці $A$.

І так далі, доки ми не обробимо всі рядки або всі стовпці матриці $A$. Якщо $n=m$, то за побудовою алгоритму очевидно, що матриця $A$ буде одиничною, що й потрібно.

### Пошук опорного елемента (півотування)

Зрозуміло, описана вище схема неповна. Вона працює тільки у випадку, якщо на кожному $i$-му кроці елемент $a_{ii}$ відмінний від нуля - інакше ми просто не зможемо досягти обнулення інших коефіцієнтів у поточному стовпці шляхом додавання до них $i$-ої рядка.

Щоб зробити алгоритм роботою в таких випадках, як цей, необхідно здійснити процес **вибору опорного елементу** (на англійській мові це називається одним словом "pivoting"). Він полягає в тому, що виконується перестановка рядків і/або стовпців матриці, щоб у необхідному елементі $a_{ii}$ з'явилось ненульове число.

Зауважимо, що перестановка рядків значно простіше реалізується на комп'ютері, ніж перестановка стовпців: адже при обміні місцями двох якихось стовпців потрібно запам'ятати, що ці дві змінні обмінялися місцями, щоб потім, при відновленні відповіді, правильно відновити, який відповідь відноситься до якої змінної. При перестановці рядків ніяких таких додаткових дій виробляти не потрібно.

Для коректності методу достатньо лише обміну стрічок (т.н. "partial pivoting"), а не обміну і стовпців (т.н. "full pivoting"). Але яку саме рядок вибирати для обміну? І чи правда, що пошук опорного елементу потрібно робити тільки у випадку, коли поточний елемент $a_{ii}$ є нульовим?

Загальної відповіді на це питання не існує. Є різноманітні евристики, однак найбільш ефективною з них (за співвідношенням простоти та вигоди) є така евристика: як опорний елемент слід брати найбільший за модулем елемент, причому пошук опорного елементу та обмін з ним потрібно робити завжди, а не тільки тоді, коли $a_{ii}=0$.

Іншими словами, перед виконанням $i$-ої фази алгоритму Гауса-Жордана з евристикою partial pivoting необхідно знайти в $i$-му стовпці серед елементів з індексами від $i$ до $n$ максимальний за модулем, і обміняти рядок з цим елементом з $i$-им рядком.

По-перше, ця евристика дозволить розв'язати СЛАР навіть у випадку, якщо під час розв'язання станеться так, що елемент $a_{ii}=0$. По-друге, що є дуже важливим, ця евристика покращує **числову стійкість** алгоритму Гауса-Жордана.

Без цієї евристики, навіть якщо система така, що для кожного $i$-го етапу $a_{ii} \ne 0$ - алгоритм Гауса-Жордана працюватиме, але в підсумку наявна похибка може бути настільки великою, що навіть для матриць розміру близько $20$ похибка перевищить саму відповідь.

### Випадки виродження

Отже, якщо зупинятися на алгоритмі Гауса-Жордана з частковою перестановкою, то, якщо $m=n$ і система невироджена (тобто має ненульовий визначник, що означає, що вона має єдиний розв'язок), то описаний вище алгоритм повністю відпрацює і дійде до одиничної матриці $A$ (доведення цього, тобто того, що ненульовий опорний елемент завжди буде присутній, тут не наводиться).

Розглянемо тепер **загальний випадок** - коли $n$ і $m$ не обов'язково рівні. Припустимо, що опорний елемент на $i$-му кроці не знайшовся. Це означає, що в $i$-му стовпці всі рядки, починаючи з поточного, містять нулі. Стверджується, що в цьому випадку ця $i$-та змінна не може бути визначена і є **вільною змінною** (може приймати довільне значення). Щоб алгоритм Гауса-Жордана продовжив свою роботу для всіх наступних змінних, в такій ситуації потрібно просто пропустити поточний $i$-ий стовпець, не збільшуючи при цьому номер поточного рядка (можна сказати, що ми віртуально видаляємо $i$-ий стовпець матриці).

Отже, деякі змінні в процесі роботи алгоритму можуть бути незалежними. Зрозуміло, що коли кількість $n$ рівнянь менша за кількість $m$ змінних, то як мінімум $m-n$ змінних будуть незалежними.

В цілому, якщо знайдеться хоча б одна незалежна змінна, то її можна приймати довільним значенням, тоді як інші (залежні) змінні будуть виражатись через неї. Це означає, що, працюючи в полі дійсних чисел, система має **необмежену кількість розв'язків** (якщо ми розглядаємо СЛАР за модулем, то кількість розв'язків буде дорівнювати цьому модулю в степені кількості незалежних змінних). Проте потрібно бути обережним: слід пам'ятати, що навіть якщо були знайдені незалежні змінні, СЛАР **може не мати розв'язків зовсім**. Це стається, коли в невирішених рівняннях (тех, до яких алгоритм Гауса-Жордана не дійшов, тобто рівняннях, в яких залишилися тільки незалежні змінні) є хоча б один ненульовий вільний член.

Втім, простіше перевірити це явною підстановкою знайденого розв'язку: всім незалежним змінним присвоїти нульові значення, залежним змінним присвоїти знайдені значення і підставити цей розв'язок у поточну СЛАР.

## Реалізація

Наведемо тут реалізацію алгоритму Гауса-Жордана з евристикою часткового вибору опорного елементу (як максимуму по стовпцю).

На вхід функції $\rm gauss()$ передається матриця системи $A$. Останній стовпець матриці $A$ є стовпцем вільних членів $b$ (так зроблено для зручності програмування - в самому алгоритмі всі операції з вільними членами $b$ повторюють операції з матрицею $A$).

Функція повертає кількість розв'язків системи ($0$, $1$ або $\infty$) (нескінченність позначена в коді спеціальною константою $\rm INF$, якій можна задати будь-яке велике значення). Якщо хоча б один розв'язок існує, то він повертається в векторі $\rm ans$.

<!--- TODO: specify code snippet id -->
``` cpp
int gauss(vector<vector<double>> a, vector<double> &ans) {
    int n = (int)a.size();
    int m = (int)a[0].size() - 1;

    vector<int> where(m, -1);
    for (int col = 0, row = 0; col < m && row < n; ++col) {
        int sel = row;
        for (int i = row; i < n; ++i)
            if (abs(a[i][col]) > abs(a[sel][col]))
                sel = i;
        if (abs(a[sel][col]) < EPS)
            continue;
        for (int i = col; i <= m; ++i)
            swap(a[sel][i], a[row][i]);
        where[col] = row;

        for (int i = 0; i < n; ++i)
            if (i != row) {
                double c = a[i][col] / a[row][col];
                for (int j = col; j <= m; ++j)
                    a[i][j] -= a[row][j] * c;
            }
        ++row;
    }

    ans.assign(m, 0);
    for (int i = 0; i < m; ++i)
        if (where[i] != -1)
            ans[i] = a[where[i]][m] / a[where[i]][i];
    for (int i = 0; i < n; ++i) {
        double sum = 0;
        for (int j = 0; j < m; ++j)
            sum += ans[j] * a[i][j];
        if (abs(sum - a[i][m]) > EPS)
            return 0;
    }

    for (int i = 0; i < m; ++i)
        if (where[i] == -1)
            return INF;
    return 1;
}
```

У функції підтримуються два вказівники - на поточний стовпець $\rm col$ та поточний рядок $\rm row$.

Також створюється вектор $\rm where$, в якому для кожної змінної записано, в якому рядку вона повинна з'явитися (іншими словами, для кожного стовпця записаний номер рядка, в якому цей стовпець відмінний від нуля). Цей вектор необхідний, оскільки деякі змінні можуть не "визначитися" під час розв'язання (тобто це незалежні змінні, яким можна присвоїти довільне значення - наприклад, у наведеній реалізації це нулі).

Реалізація використовує техніку часткового вибору, шукаючи рядок з максимальним за модулем елементом і переставляючи потім цей рядок на позицію $\rm row$ (хоча явну перестановку рядків можна замінити обміном двох індексів у деякому масиві, на практиці це не дає реальної вигоди, оскільки на обміни витрачається $O(n^2)$ операцій).

У реалізації з метою простоти поточно рядок не ділиться на опорний елемент, тому після закінчення роботи алгоритму матриця стає не одиничною, а діагональною. Однак, можливо, поділ рядка на ведучий елемент дозволить зменшити похибки. Також слід замінити російські слова "ведущий" та "виникают".

Після знаходження розв'язку його потрібно підставити назад у матрицю, щоб перевірити, чи має система хоча б один розв'язок. Якщо перевірка знайденого розв'язку пройшла успішно, то функція повертає $1$ або $0$ - залежно від того, чи є хоча б одна незалежна змінна. Русизми у тексті виправлені.

## Асимптотика

Оцінимо асимптотику отриманого алгоритму. Алгоритм складається з $m$ фаз, на кожній з яких відбувається:

* Пошук та перестановка опорного елементу займає час $O(n+m)$ при використанні евристики "часткового вибору" (пошук максимуму в стовпці)
* Якщо опорний елемент у поточному стовпці був знайдений, то додавання додатку поточного рівняння до всіх інших рівнянь займе час $O(nm)$

Очевидно, перший пункт має меншу асимптотику, ніж другий. Зауважимо також, що другий пункт виконується не більше ніж $\min(n,m)$ разів - стільки, скільки можливо бути залежних змінних в СЛАР.

Таким чином, **асимптотична складність** алгоритму приймає вид $O(\min(n,m) \cdot n m)$.

При $n = m$ ця оцінка перетворюється на $O(n^3)$.

Зауважимо, що коли СЛАР розглядається не в полі дійсних чисел, а в полі за модулем два, то систему можна розв'язувати набагато швидше - про це див. нижче в розділі "Розв'язок СЛАР за модулем".

### Більш точна оцінка кількості дій

Для простоти викладок будемо вважати, що $n = m$.

Як ми вже знаємо, час роботи всього алгоритму фактично визначається часом, що витрачається на виключення поточного рівняння з інших.

Це можливо відбуватися на кожному з $n$ кроків, при цьому поточне рівняння додається до всіх $n-1$ інших. При додаванні робот виконується тільки зі стовпцями, починаючи з поточного. Таким чином, в сумі виходить $n^3 / 2$ операцій.

## Дополнения

### Прискорення алгоритму: розбиття його на прямий та зворотній хід

Досягти подвійного прискорення алгоритму можна, розглянувши іншу його версію, більш класичну, коли алгоритм розбивається на фази прямого і зворотного ходу.

В цілому, на відміну від описаного вище алгоритму, можна приводити матрицю не до діагонального вигляду, а до **трикутного вигляду** - коли всі елементи строго нижче головної діагоналі рівні нулю.

Система з трикутною матрицею вирішується тривіально - спочатку з останнього рівняння одразу знаходиться значення останньої змінної, потім знайдене значення підставляється в передостаннє рівняння і знаходиться значення передостанньої змінної, і так далі. Цей процес і називається **зворотним ходом** алгоритму Гауса.

**Прямий хід** алгоритму Гауса - це алгоритм, аналогічний описаному вище алгоритму Гауса-Жордана, за одним винятком: поточна змінна виключається не з усіх рівнянь, а лише з рівнянь після поточного. В результаті цього отримується не діагональна, а трикутна матриця.

Різниця полягає в тому, що прямий хід працює **швидше**, ніж алгоритм Гауса-Жордана, оскільки в середньому він робить в два рази менше операцій додавання одного рівняння до іншого. Обернений хід працює за $O(nm)$, що в будь-якому випадку є асимптотично швидшим, ніж прямий хід.

Таким чином, якщо $n=m$, то даний алгоритм буде виконувати лише $n^3/4$ операцій - що вдвічі менше, ніж алгоритм Гауса-Жордана.

### Розв'язання СЛАР за модулем

Для розв'язання СЛАР за модулем можна застосувати описаний вище алгоритм, він зберігає свою коректність.

Зрозуміло, тепер непотрібно використовувати якісь хитрі техніки вибору опорного елемента - досить знайти будь-який ненульовий елемент у поточному стовпці.

Якщо модуль є простим, то жодних складнощів взагалі не виникає - поділ, що відбувається під час роботи алгоритму Гауса, не створює особливих проблем.

Особливо помітний **модуль, рівний двом**: для нього всі операції з матрицею можна виконувати дуже ефективно. Наприклад, віднімання одного рядка від іншого за модулем два - це насправді їх симетрична різниця ("xor"). Таким чином, весь алгоритм можна значно прискорити, стиснувши всю матрицю в бітові маски і працюючи тільки з ними. Наведемо нову реалізацію основної частини алгоритму Гауса-Жордана, використовуючи стандартний контейнер C++ "bitset":

<!--- TODO: specify code snippet id -->
``` cpp
int gauss(vector<bitset<N>> a, int n, int m, bitset<N> &ans) {
    vector<int> where(m, -1);
    for (int col = 0, row = 0; col < m && row < n; ++col) {
        for (int i = row; i < n; ++i)
            if (a[i][col]) {
                swap(a[i], a[row]);
                break;
            }
        if (!a[row][col])
            continue;
        where[col] = row;

        for (int i = 0; i < n; ++i)
            if (i != row && a[i][col])
                a[i] ^= a[row];
        ++row;
    }
```

Як можна помітити, реалізація стала ще коротшою, при тому, що вона значно швидша за стару реалізацію - а саме, швидша в $32$ рази завдяки бітовому стисненню. Також варто зазначити, що розв'язання систем за модулем два на практиці працює дуже швидко, оскільки випадки, коли потрібно віднімати одну рядок від іншої, відбуваються досить рідко (на розріджених матрицях цей алгоритм може працювати швидше ніж за куб від розміру, близько до квадрата).

Якщо модуль **довільний** (не обов'язково простий), то все стає дещо складніше. Зрозуміло, що, користуючись [Китайською теоремою про залишки](https://uk.wikipedia.org/wiki/%D0%9A%D0%B8%D1%82%D0%B0%D0%B9%D1%81%D1%8C%D0%BA%D0%B0_%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%BF%D1%80%D0%BE_%D0%B7%D0%B0%D0%BB%D0%B8%D1%88%D0%BA%D0%B8), ми сводимо задачу з довільним модулем лише до модулів, що є ступенем простого числа. Проте детальний спосіб розв'язку такої задачі потребує окремого вивчення

Нарешті, розглянемо питання **кількості рішень СЛАР за модулем**. Відповідь на нього досить проста: кількість розв'язків дорівнює $p^k$, де $p$ - модуль, $k$ - кількість незалежних змінних.

### Трохи про різні способи вибору опорного елемента

Як вже зазначалося вище, однозначної відповіді на це питання немає.

Евристика "часткового вибору" (partial pivoting), яка полягає в пошуку максимального елемента в поточному стовпці, працює на практиці досить добре. Крім того, виявляється, що вона дає практично той самий результат, що і "повний вибір" (full pivoting) - коли опорний елемент шукається серед елементів всієї підматриці, що починається з поточного рядка і поточного стовпця.

Але цікаво відзначити, що обидві ці евристики з пошуком максимального елементу фактично дуже залежать від того, наскільки були масштабовані початкові рівняння. Наприклад, якщо одне з рівнянь системи помножити на мільйон, то це рівняння майже навряд чи буде вибрано в якості провідного на першому ж кроці. Це здається досить дивним, тому логічним є перехід до трохи складнішої евристики - так званого "implicit pivoting".

Евристика implicit pivoting полягає в тому, що елементи різних рядків порівнюються так, ніби обидві рядки були нормалізовані таким чином, що максимальний за модулем елемент в них був би рівний одиниці. Для реалізації цієї техніки потрібно просто підтримувати поточний максимум в кожному рядку (або підтримувати кожен рядок так, щоб максимум в ньому був рівний одиниці за модулем, але це може призвести до збільшення накопичуваної похибки).

### Поліпшення знайденої відповіді

Оскільки, незважаючи на різні евристики, алгоритм Гауса-Жордана все ж може призвести до значних похибок на спеціальних матрицях навіть розмірів порядку $50$-$100$.

У зв'язку з цим, отриманий алгоритмом Гауса-Жордана розв'язок можна покращити, застосувавши до нього який-небудь простий числовий метод - наприклад, метод простої ітерації.

Таким чином, розв'язок перетворюється на двохетапний: спочатку застосовується алгоритм Гауса-Жордана, а потім - будь-який числовий метод, що використовує розв'язок, отриманий на першому етапі як початкові дані.

Такий прийом дозволяє дещо розширити множину задач, що вирішуються алгоритмом Гауса-Жордана з прийнятною точністю.

## Література

* \book{William H. Press, Saul A. Teukolsky, William T. Vetterling, Brian P. Flannery}{Numerical Recipes: The Art of Scientific Computing}{2007}{numerical_recipes.pdf}
* \book{Anthony Ralston, Philip Rabinowitz}{A first course in numerical analysis}{2001}