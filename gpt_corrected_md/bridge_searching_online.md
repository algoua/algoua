# Пошук мостів в режимі онлайн

Нехай заданий неорієнтований граф. Мостом називається ребро, видалення якого робить граф незв'язним (або, точніше, збільшує число компонент зв'язності). Потрібно знайти всі мости в даному графі.

Неформально ця задача ставиться наступним чином: потрібно знайти на заданій мапі доріг всі "важливі" дороги, тобто такі дороги, що видалення будь-якої з них призведе до зникнення шляху між якоюсь парою міст.

Описаний тут алгоритм є **онлайн**, що означає, що вхідний граф не є відомим заздалегідь, а ребра в нього додаються по одному, і після кожного такого додавання алгоритм перераховує всі мости в поточному графі. Іншими словами, алгоритм призначений для ефективної роботи на динамічному, змінюючомуся графі.

Більш строго, **постановка задачі** наступна. Спочатку граф порожній і складається з $n$ вершин. Потім надходять запити, кожен з яких - це пара вершин $(a,b)$, які позначають ребро, що додається в граф. Потрібно після кожного запиту, тобто після додавання кожного ребра, виводити поточну кількість мостів в графі. (За бажання можна підтримувати і список всіх ребер-мостів, а також явно підтримувати компоненти реберної двоїзності).

Описаний нижче алгоритм працює за час $O(n \log n + m)$, де $m$ - число запитів. Алгоритм заснований на структурі даних "система неперетинних множин".

Наведена реалізація алгоритму, проте працює за час $O(n \log n + m \log n)$, оскільки використовує спрощену версію [системи неперетинних множин](dsu) без застосування рангової евристики. В алгоритмі використовуються російські слова, які потрібно замінити на українські.

## Алгоритм

Відомо, що ребра-мости розбивають вершини графа на компоненти, які називаються компонентами реберної двохзв'язності. Якщо кожну компоненту реберної двохзв'язності стиснути в одну вершину і залишити тільки ребра-мости між цими компонентами, то вийде ациклічний граф, тобто ліс.

Описаний нижче алгоритм підтримує у явному вигляді ліс компонент реберної двохзв'язності.

Зрозуміло, що спочатку, коли граф порожній, він містить $n$ компонент реберної двохзв'язності, які не пов'язані між собою ніяким чином.

При додаванні наступного ребра $(a,b)$ можуть виникнути три ситуації:

* Обидва кінці $a$ і $b$ знаходяться в одній і тій же компоненті реберної двохзв'язності - отже, це ребро не є мостом і не змінює структури лісу, тому ми просто пропускаємо його.

Таким чином, у цьому випадку кількість мостів не змінюється.

* Вершини $a$ та $b$ знаходяться в різних компонентах зв'язності, тобто з'єднують два дерева. У цьому випадку ребро $(a,b)$ стає новим мостом, а ці два дерева об'єднуються в одне (а всі попередні мости залишаються).

Таким чином, у цьому випадку кількість мостів збільшується на одиницю.

* Вершини $а$ і $b$ знаходяться в одній компоненті зв'язності, але в різних компонентах реберної двохзв'язності. У цьому випадку ребро утворює цикл разом із деякими зі старих мостів. Усі ці мости перестають бути мостами, а утворений цикл потрібно об'єднати в нову компоненту реберної двохзв'язності.

Таким чином, у цьому випадку кількість мостів зменшується на два або більше.

Отже, задача полягає у ефективній реалізації всіх цих операцій над лісом компонент.

### Структури даних для зберігання лісів

Все, що нам знадобиться зі структур даних, - це [система неперетинних множин](dsu). Насправді, нам знадобиться робити два екземпляри цієї структури: один буде для підтримки **компонент зв'язності**, інший - для підтримки **компонент реберної двохзв'язності**.

Крім того, для збереження структури дерев у лісі компонент двоїстості для кожної вершини будемо зберігати вказівник ${\rm parent}[]$ на її батька в дереві.

Будемо тепер послідовно розбирати кожну операцію, яку нам потрібно навчитися виконувати:

* Перевірка, чи лежать дві зазначені вершини в одній компоненті зв'язності/двохзв'язності, виконується звичайним запитом до структури "система неперетинних множин".

* З'єднання двох дерев у одне за допомогою ребра $(a,b)`. Оскільки може статися так, що ні вершина $a$, ні вершина $b$ не є коренями своїх дерев, то єдиний спосіб з'єднати ці два дерева - перепідвісити одне з них. Наприклад, можна перепідвісити одне дерево за вершину $a$, а потім долучити його до іншого дерева, зробивши вершину $a$ дочірньою до $b`.

Однак виникає питання про ефективність операції перепідвішування: щоб перепідвісити дерево з коренем в $r$ за вершину $v$, потрібно пройти по шляхах з $v$ в $r$, перенаправляючи вказівники ${\rm par}[]$ в зворотному напрямку, а також змінюючи посилання на предка в системі неперетинаючихся множин, що відповідає за компоненти зв'язності.

Таким чином, вартість операції перепідвішування є $O(h)$, де $h$ - висота дерева. Можна оцінити її ще вище, сказавши, що це є величина $O(\text{розмір})$, де розмір - кількість вершин у дереві.

Застосуємо зараз стандартний прийом: припустимо, що з двох дерев **ми перепідвішуємо те, в якому менше вершин**. Таким чином, інтуїтивно зрозуміло, що найгірший випадок настає, коли об'єднуються два дерева приблизно однакового розміру. Однак, в цьому випадку отримується дерево розміру, що вдвічі більший, що не дозволяє такій ситуації відбуватися багато разів. Формально це можна записати у вигляді рекурентного співвідношення:

$$
T(n) = \max_{k = 1 \ldots n-1} \left\{ ~ T(k) + T(n-k) + O(n) ~ \right\},
$$

де через $T(n)$ ми позначили кількість операцій, необхідних для отримання дерева з $n$ вершин за допомогою операцій перепідвішування та з'єднання дерев. Це відоме рекурентне співвідношення, і воно має розв'язок $T(n) = O(n \log n)$.

Таким чином, сумарний час, витрачений на всі перепідвішування, складе $O(n \log n)$, якщо ми завжди будемо перепідвішувати менше з двох піддерев.

Нам доведеться підтримувати розміри кожної компоненти зв'язності, але структура даних "система неперетинних множин" дозволяє зробити це без зайвих зусиль.

* Пошук циклу, утвореного додаванням нового ребра $(a,b)$ у яке-небудь дерево. Фактично це означає, що нам потрібно знайти найменшого загального предка (LCA) вершин $a$ і $b$.

Зауважимо, що потім ми стиснемо всі вершини виявленого циклу в одну вершину, тому нас підійде будь-який алгоритм пошуку Найменшого спільного предка (LCA), що працює за час порядку довжини циклу.

Оскільки вся інформація про структуру дерева, яка є у нас, - це посилання $par[]$ на батьків, то єдиним можливим алгоритмом пошуку LCA є наступний: ми позначаємо вершини $a$ і $b$ як відвідані, потім переходимо до їх батьків ${\rm par}[a]$ і ${\rm par}[b]$ і позначаємо їх, потім до їх батьків, і так далі, доки не станеться так, що хоча б одна з двох поточних вершин вже позначена. Це означатиме, що поточна вершина - шуканий LCA, і ми повинні знову пройти шлях до неї від вершини $a$ і від вершини $b$ - тим самим ми знайдемо шуканий цикл.

Очевидно, що цей алгоритм працює за час порядку довжини шуканого циклу, оскільки кожен з двох вказівників не міг пройти відстань, більше за цю довжину.

* Стиснення циклу, утвореного додаванням нового ребра $(a,b)$ до якогось дерева.

Нам потрібно створити нову компоненту реберної двохзв'язності, яка буде складатися з усіх вершин виявленого циклу (зрозуміло, що знайдений цикл сам може складатися з деяких компонент двохзв'язності, але це нічого не змінює). Крім того, потрібно провести стиснення таким чином, щоб не порушувалась структура дерева, і всі вказівники ${\rm par}[]$ і дві системи, що не перетинаються, були коректними.

Найпростіший спосіб досягнути цього - **стиснути всі вершини знайденого циклу в їх LCA**. Насправді, вершина-LCA - це сама висока зі стиснутих вершин, тобто її ${\rm par}$ залишається без змін. Для всіх інших стиснутих вершин оновлювати також нічого не потрібно, оскільки ці вершини просто перестають існувати - в системі, що не перетинається множин для компонент двохзв'язності, всі ці вершини будуть просто вказувати на вершину-LCA.

Але тоді вийде, що система, яка не перетинається з множин для компонент двохзв'язності, працює без евристики про'єднання за рангом: якщо ми завжди приєднуємо вершини циклу до їх LCA, то ця евристика не потрібна. У цьому випадку в асимптотиці виникне $O(\log n)$, оскільки без евристики за рангом будь-яка операція з системою, яка не перетинається з множин, працює саме за такий час.

Для досягнення асимптотики $O(1)$ на один запит необхідно об'єднувати вершини кола згідно з ранговою евристикою, а потім присвоїти ${\rm par}$ нового лідера у ${\rm par}[{\rm LCA}]$.

## Реалізація

Наведемо тут підсумкову реалізацію алгоритму.

У цілях простоти система, що не перетинається з множинами для компонент двохзв'язності, написана **без рангової евристики**, тому підсумкова асимптотика складе $O(\log n)$ на запит в середньому. (Про те, як досягти асимптотики $O(1)$, написано вище в пункті "Стиснення циклу").

Також у даній реалізації не зберігаються самі ребра-мости, а зберігається тільки їх кількість - див. змінна $\rm bridges$. Однак, при бажанні, не складе жодних проблем створити ${\rm set}$

Спочатку потрібно викликати функцію ${\rm init}(), яка ініціалізує дві неперетинаючі множини (виділяючи кожну вершину в окрему множину та проставляючи розмір, рівний одиниці), а також проставляє предків ${\rm par}$.

Основна функція - це ${\rm додати\_ребро}(a,b)$, яка обробляє запит на додавання нового ребра.

Константу $\rm MAXN$ потрібно задати зі значенням, що дорівнює максимально можливій кількості вершин у вхідному графі.

Більш детальні пояснення щодо цієї реалізації можна знайти нижче.

<!--- TODO: specify code snippet id -->
``` cpp
const int MAXN = ...;

int n, bridges, par[MAXN], bl[MAXN], comp[MAXN], size[MAXN];

void init() {
    for (int i = 0; i < n; ++i) {
        bl[i] = comp[i] = i;
        size[i] = 1;
        par[i] = -1;
    }
    bridges = 0;
}

int get(int v) {
    if (v == -1)
        return -1;
    return bl[v] == v ? v : bl[v] = get(bl[v]);
}

int get_comp(int v) {
    v = get(v);
    return comp[v] == v ? v : comp[v] = get_comp(comp[v]);
}

void make_root(int v) {
    v = get(v);
    int root = v, child = -1;
    while (v != -1) {
        int p = get(par[v]);
        par[v] = child;
        comp[v] = root;
        child = v;
        v = p;
    }
    size[root] = size[child];
}

int cu, u[MAXN];

void merge_path(int a, int b) {
    ++cu;

    vector<int> va, vb;
    int lca = -1;
    for (;;) {
        if (a != -1) {
            a = get(a);
            va.pb(a);

            if (u[a] == cu) {
                lca = a;
                break;
            }
            u[a] = cu;

            a = par[a];
        }

        if (b != -1) {
            b = get(b);
            vb.pb(b);

            if (u[b] == cu) {
                lca = b;
                break;
            }
            u[b] = cu;

            b = par[b];
        }
    }

    for (size_t i = 0; i < va.size(); ++i) {
        bl[va[i]] = lca;
        if (va[i] == lca)
            break;
        --bridges;
    }
    for (size_t i = 0; i < vb.size(); ++i) {
        bl[vb[i]] = lca;
        if (vb[i] == lca)
            break;
        --bridges;
    }
}

void add_edge(int a, int b) {
    a = get(a);
    b = get(b);
    if (a == b)
        return;

    int ca = get_comp(a), cb = get_comp(b);
    if (ca != cb) {
        ++bridges;
        if (size[ca] > size[cb]) {
            swap(a, b);
            swap(ca, cb);
        }
        make_root(a);
        par[a] = comp[a] = b;
        size[cb] += size[a];
    } else
        merge_path(a, b);
}
```

Прокоментуємо код детальніше.

**Система множин, що не перетинаються для компонент двохзв'язності**, зберігається в масиві ${\rm bl}[]$, а функція, що повертає лідера компоненти двохзв'язності - це ${\rm get}(v)$. Цю функцію використовують багато разів в іншому коді, оскільки потрібно пам'ятати про те, що після стиснення кількох вершин в одну всі ці вершини перестають існувати, а замість них існує тільки їх лідер, у якого і зберігаються коректні дані (предок ${\rm par}$, предок в системі множин, що не перетинаються для компонент зв'язності, тощо).

Система, що не перетинається множин для компонент зв'язності, зберігається в масиві ${\rm comp}[]$. Також є додатковий масив ${\rm size}[]$, що зберігає розміри компонент. Функція ${\rm get\_comp}(v)$ повертає лідера компоненти зв'язності (який є коренем дерева).

**Функція перепідвішування дерева** ${\rm make\_root}(v)$ працює так, як було описано вище: вона йде від вершини $v$ по батьківським вузлам до кореня, кожного разу перенаправляючи батька $\rm par$ в зворотньому напрямку (вниз, до вершини $v$). Також оновлюється вказівник ${\rm comp}$ в системі неперетинних множин для компонент зв'язності, щоб він вказував на новий корінь. Після перепідвішування у нового кореня проставляється розмір ${\rm size}$ компоненти зв'язності. Звернімо увагу, що при реалізації ми кожного разу викликаємо функцію ${\rm get}()$, щоб отримати доступ саме до лідера компоненти сильної зв'язності, а не до якоїсь вершини, яка можливо вже була стиснута.

**Функція виявлення та стиснення шляху** ${\rm merge\_path}(a,b)$, як описано вище, шукає LCA вершин $a$ і $b$, для чого піднімається від них паралельно вгору, доки якась вершина не зустріне їх повторно. У цілях ефективності пройдені вершини маркуються з допомогою техніки "числового used", що працює за $O(1)$ замість застосування $\rm set$. Пройдені шляхи зберігаються в векторах $\rm va$ і $\rm vb$, щоб потім пройтися по ним другий раз до LCA, отримавши тим самим всі вершини циклу. Усі вершини циклу стискаються, приєднуючись до LCA (тут виникає асимптотика $O(\log n)$, оскільки при стисканні ми не використовуємо рангову евристику). Попутно рахується кількість пройдених ребер, яка дорівнює кількості мостів у виявленому циклі (це число віднімається від $\rm bridges$).

Нарешті, **функція обробки запитів** ${\rm add\_edge}(a,b)$ визначає компоненти зв'язності, у яких знаходяться вершини $a$ і $b$, і якщо вони знаходяться у різних компонентах зв'язності, то менше дерево перепідвішується за новий корінь і потім приєднується до більшого дерева. Інакше, якщо вершини $a$ і $b$ знаходяться в одному дереві, але в різних компонентах двохзв'язності, то викликається функція ${\rm merge\_path}(a,b)$, яка виявить цикл і стисне його в одну компоненту двохзв'язності.