# Перевірка перетину двох відрізків

Дано дві відрізки $AB$ і $CD$ (вони можуть звести до точок). Потрібно перевірити, чи перетинаються вони.

Якщо потрібно знайти точку (точки) перетину, дивіться [відповідну статтю](intersection_of_segments).

## Перший спосіб: орієнтована площа трикутника

Скористаємося [Орієнтованою площею трикутника і предикатом 'За годинниковою стрілкою'](oriented_area). Дійсно, щоб відрізки $AB$ і $CD$ перетиналися, необхідно і достатньо, щоб точки $A$ і $B$ знаходилися по різні боки від прямої $CD$, і, аналогічно, точки $C$ і $D$ - по різні боки від прямої $AB$. Перевірити це можна, обчислюючи орієнтовані площі відповідних трикутників і порівнюючи їх знаки.

Єдине, на що потрібно звернути увагу - граничні випадки, коли деякі точки попадають на саму пряму. При цьому виникає єдиний особливий випадок, коли вищеописані перевірки нічого не дають - випадок, коли обидва відрізки лежать **на одній прямій**. Цей випадок потрібно розглянути окремо. Для цього достатньо перевірити, що проекції цих двох відрізків на осі $X$ і $Y$ перетинаються (часто цю перевірку називають "перевіркою на обмежувальну рамку").

В цілому, цей спосіб є простішим, ніж той, що буде наведений нижче (здійснюючий перетин двох прямих), і має менше особливих випадків. Однак його головний недолік полягає в тому, що він не знаходить точку перетину.

**Реалізація**:
<!--- TODO: specify code snippet id -->
``` cpp
struct pt {
    int x, y;
};

inline int area(pt a, pt b, pt c) { return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x); }

inline bool intersect_1(int a, int b, int c, int d) {
    if (a > b)
        swap(a, b);
    if (c > d)
        swap(c, d);
    return max(a, c) <= min(b, d);
}

bool intersect(pt a, pt b, pt c, pt d) { return intersect_1(a.x, b.x, c.x, d.x) && intersect_1(a.y, b.y, c.y, d.y) && area(a, b, c) * area(a, b, d) <= 0 && area(c, d, a) * area(c, d, b) <= 0; }
```

У цілях оптимізації перевірка на обмежувальну рамку (bounding box) була перенесена на початок, перед обчисленням площі, оскільки це менш "важка" перевірка.

Звичайно, цей код можна використовувати і для випадку координат об'єктів, просто всі порівняння з нулем потрібно робити з точністю до епсилону (і уникати множення двох дійсних значень $\rm area()$, замість цього множити їх знаки).

## Другий спосіб: перетин двох прямих

Замість перетину відрізків виконаємо [перетин двох прямих](lines_intersection), в результаті, якщо прямі не паралельні, отримаємо одну точку, яку потрібно перевірити на належність обом відрізкам; для цього достатньо перевірити, що ця точка належить обом відрізкам у проекції на вісь $X$ та на вісь $Y$.

Якщо прямі виявилися паралельними, і якщо вони не збігаються, то відрізки точно не перетинаються. Якщо прямі збіглися, то відрізки лежать на одній прямій, і для перевірки їх перетину достатньо перевірити, що їх проекції на вісі $X$ і $Y$ перетинаються.

Остається ще особливий випадок, коли одна або обидві відрізки **дегенеруються** у точки: в такому випадку говорити про прямі некоректно, і цей метод не буде застосовуватися (цей випадок треба буде розбирати окремо).

Реалізація (без обліку випадку вироджених відрізків):

<!--- TODO: specify code snippet id -->
``` cpp
struct pt {
    int x, y;
};

const double EPS = 1E-9;

inline int det(int a, int b, int c, int d) { return a * d - b * c; }

inline bool between(int a, int b, double c) { return min(a, b) <= c + EPS && c <= max(a, b) + EPS; }

inline bool intersect_1(int a, int b, int c, int d) {
    if (a > b)
        swap(a, b);
    if (c > d)
        swap(c, d);
    return max(a, c) <= min(b, d);
}

bool intersect(pt a, pt b, pt c, pt d) {
    int A1 = a.y - b.y, B1 = b.x - a.x, C1 = -A1 * a.x - B1 * a.y;
    int A2 = c.y - d.y, B2 = d.x - c.x, C2 = -A2 * c.x - B2 * c.y;
    int zn = det(A1, B1, A2, B2);
    if (zn != 0) {
        double x = -det(C1, B1, C2, B2) * 1. / zn;
        double y = -det(A1, C1, A2, C2) * 1. / zn;
        return between(a.x, b.x, x) && between(a.y, b.y, y) && between(c.x, d.x, x) && between(c.y, d.y, y);
    } else
        return det(A1, C1, A2, C2) == 0 && det(B1, C1, B2, C2) == 0 && intersect_1(a.x, b.x, c.x, d.x) && intersect_1(a.y, b.y, c.y, d.y);
}
```

Тут спочатку обчислюється знаменник $\rm zn$ у формулі Крамера. Якщо ${\rm zn} = 0$, то коефіцієнти $A$ і $B$ є прямими пропорційними, і прямі паралельні або збігаються. У цьому випадку потрібно перевірити, чи збігаються вони, для чого необхідно перевірити, що коефіцієнти $C$ є пропорційні з тим самим коефіцієнтом. Для цього достатньо обчислити два наступних визначники, якщо вони обидва рівні нулю, то прямі збігаються:

$$
\left|\matrix{ A_1 & C_1 \cr A_2 & C_2 }\right|, \left|\matrix{ B_1 & C_1 \cr B_2 & C_2 }\right|
$$

Якщо ${\rm zn} \ne 0$, то прямі перетинаються, і за допомогою формули Крамера знаходимо точку перетину $(x,y)$ та перевіряємо її належність обом відрізкам.

Слід зазначити, що якщо вихідні координати точок вже були дійсними, то необхідно нормалізувати прямі (тобто привести їх до такого стану, що сума квадратів коефіцієнтів $a$ і $b$ дорівнює одиниці), інакше похибки при порівнянні прямих на паралельність і збіг можуть виявитися занадто великими.