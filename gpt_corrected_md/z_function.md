# Z-функція рядка та її обчислення

Нехай дана стрічка $s$ довжини $n$. Значення **Z-функції** ("зет-функції") для цієї стрічки - це масив довжини $n$, $i$-й елемент якого дорівнює найбільшій кількості символів, починаючи з позиції $i$, які збігаються з першими символами стрічки $s$.

Іншими словами, $z[i]$ - це найбільший загальний префікс рядка $s$ та його $i$-го суфікса.

Зауваження. У даній статті, для уникнення неоднозначностей, ми будемо вважати рядок індексованим з нуля - тобто перший символ рядка матиме індекс $0$, а останній - $n-1$.

Перший елемент Z-функції, $z[0]$, зазвичай вважають не визначеним. У даній статті ми будемо вважати, що він дорівнює нулю (хоча це не змінює нічого в алгоритмі або в наведеній реалізації).

У даній статті наводиться алгоритм обчислення Z-функції за час $O(n)$, а також різні застосування цього алгоритму.

## Приклади

Наведемо на приклад обчислену Z-функцію для кількох рядків:

* $"aaaaa"$:

$$
z[0] = 0,
$$

$$
z[1] = 4,
$$

$$
z[2] = 3,
$$

$$
z[3] = 2,
$$

$$
z[4] = 1.
$$

* $"aaabaab"$:

$$
z[0] = 0,
$$

$$
z[1] = 2,
$$

$$
z[2] = 1,
$$

$$
z[3] = 0,
$$

$$
z[4] = 2,
$$

$$
z[5] = 1,
$$

$$
z[6] = 0.
$$

* $"abacaba"$:

$$
z[0] = 0,
$$

$$
z[1] = 0,
$$

$$
z[2] = 1,
$$

$$
z[3] = 0,
$$

$$
z[4] = 3,
$$

$$
z[5] = 0,
$$

$$
z[6] = 1.
$$

## Тривалий алгоритм

Формальне визначення можна уявити у вигляді наступної елементарної реалізації за $O(n^2)$

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> z_function_trivial(string s) {
    int n = (int)s.length();
    vector<int> z(n);
    for (int i = 1; i < n; ++i)
        while (i + z[i] < n && s[z[i]] == s[i + z[i]])
            ++z[i];
    return z;
}
```

Ми просто для кожної позиції $i$ перебираємо відповідь для її $z[i]$, починаючи з нуля, і доти, поки ми не виявимо несумісність або не дійдемо до кінця рядка.

Зрозуміло, ця реалізація є недостатньо ефективною, перейдемо тепер до побудови ефективного алгоритму.

## Ефективний алгоритм обчислення Z-функції

Щоб отримати ефективний алгоритм, будемо обчислювати значення $z[i]$ послідовно - від $i=1$ до $n-1$, і при цьому постараємося максимально використовувати вже обчислені значення при обчисленні наступного значення $z[i]$.

Назвемо для стислості підстрічку, що збігається з префіксом стрічки $s$, **відрізком збігу**. Наприклад, значення шуканої Z-функції $z[i]$ - це довгий відрізок збігу, що починається в позиції $i$ (і закінчується в позиції $i + z[i] - 1$).

Для цього будемо підтримувати **координати $[l;r]$ найправішого відрізку збігу**, тобто з усіх виявлених відрізків будемо зберігати той, який закінчується правіше за всіх. В деякому сенсі, індекс $r$ - це така межа, до якої наша стрічка вже була просканована алгоритмом, а все інше - поки що не відомо.

Якщо поточний індекс, для якого ми хочемо порахувати чергове значення Z-функції, дорівнює $i$, маємо один з двох варіантів:

* $i > r$ - тобто поточна позиція лежить **поза межами** того, що ми вже успішно обробили.

Значить, ми будемо шукати $z[i]$ **наївним алгоритмом**, тобто просто перебираючи значення $z[i]=0$, $z[i]=1$, і т.д. Зауважимо, що в кінці, якщо $z[i]$ виявиться $>0$, то ми будемо зобов'язані оновити координати самого правого підрядка $[l;r]$ - тобто $i + z[i] - 1$ гарантовано виявиться більше $r$.

* $i \le r$ - це означає, що поточна позиція знаходиться всередині відрізку збігу $[l;r]$.

Значить, ми можемо використовувати вже підраховані **попередні** значення Z-функції, щоб ініціалізувати значення $z[i]$ не нулем, а, можливо, більшим числом.

Для цього зауважимо, що підстрічки $s[l \ldots r]$ і $s[0 \ldots r-l]$ **співпадають**. Це означає, що в якості початкового наближення для $z[i]$ можна взяти відповідне йому значення з рядка $s[0 \ldots r-l]$, а саме, значення $z[i-l]$.

Однак значення $z[i-l]$ могло виявитися занадто великим, таким, що при застосуванні його до позиції $i$ воно "виходитиме" за межі $r$. Цього допустити не можна, оскільки про символи правіше $r$ ми нічого не знаємо, і вони можуть відрізнятися від потрібних.

Наведемо **приклад** такої ситуації, на прикладі рядка:

$$
"aaaabaa"
$$

Коли ми дійдемо до останньої позиції ($i=6$), поточним самим правим відрізком буде $[5;6]$. Позиції $6$ з урахуванням цього відрізку буде відповідати позиція $6-5=1$, відповідь в якій дорівнює $z[1] = 3$. Очевидно, що таким значенням ініціалізувати $z[6]$ не можна, воно цілком некоректне. Максимум, яким значенням ми могли ініціалізувати - це $1$, оскільки це найбільше значення, яке не виходить за межі відрізку $[l;r]$.

Таким чином, як початкове наближення для $z[i]$ безпечно брати лише такий вираз:

$$
z_0[i] = \min (r-i+1, z[i-l]).
$$

Проініціалізувавши $z[i]$ таким значенням $z_0[i]$, ми знову застосовуємо **тривіальний алгоритм** - через те, що після межі $r$, загалом кажучи, може з'явитися продовження відповідної послідовності збігів, передбачити яку за допомогою лише попередніх значень Z-функції не можна.

Таким чином, весь алгоритм представляє собою два випадки, які фактично розрізняються тільки **початковим значенням** $z[i]$: в першому випадку воно покладається рівним нулю, а в другому - визначається за попередніми значеннями за зазначеною формулою. Після цього обидві гілки алгоритму зводяться до виконання **тривіального алгоритму**, що стартує зразу з зазначеного початкового значення.

Алгоритм вийшов дуже простим. Незважаючи на те, що при кожному $i$ в ньому так чи інакше виконується тривіальний алгоритм, ми досягли суттєвого прогресу, отримавши алгоритм, який працює за лінійний час. Чому це так, розглянемо нижче, після того, як наведемо реалізацію алгоритму.

## Реалізація

Реалізація виходить дуже лаконічною

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> z_function(string s) {
    int n = (int)s.length();
    vector<int> z(n);
    for (int i = 1, l = 0, r = 0; i < n; ++i) {
        if (i <= r)
            z[i] = min(r - i + 1, z[i - l]);
        while (i + z[i] < n && s[z[i]] == s[i + z[i]])
            ++z[i];
        if (i + z[i] - 1 > r)
            l = i, r = i + z[i] - 1;
    }
    return z;
}
```

Прокоментуємо цю реалізацію.

Усі розв'язки оформлені у вигляді функцій, які приймають рядок і повертають масив довжини $n$ - обчислену Z-функцію.

Масив $z[]$ спочатку заповнюється нулями. Поточний найбільший правий відрізок встановлюється як $[0;0]$, тобто це свідомо малий відрізок, в який не потрапить жодне $i$.

Усередині циклу з $i = 1$ до $n-1$ ми спочатку застосовуємо описаний вище алгоритм для визначення початкового значення $z[i]$. Воно може залишитися нулем або обчислитися на основі наведеної формули.

Після цього виконується простий алгоритм, який намагається збільшити значення $z[i]$ настільки, наскільки це можливо.

В кінці виконується оновлення поточного найправіших підрядків збігу $[l;r]$, якщо, звичайно, це оновлення потрібно - тобто якщо $i+z[i]-1 > r$.

## Асимптотика алгоритму

Доведемо, що наведений вище алгоритм працює за лінійний час щодо довжини стрічки, тобто за $O(n)$.

Доведення дуже просте.

Нас цікавить вкладений цикл $\rm while$ - то є, все інше - лише константні операції, що виконуються $O(n)$ разів.

Покажемо, що **кожна ітерація** цього циклу $\rm while$ призведе до збільшення правої межі $r$ на одиницю.

Для цього розглянемо обидві гілки алгоритму:

* $i > r$

У цьому випадку або цикл $\rm while$ не зробить жодної ітерації (якщо $s[0] \ne s[i]$), або зробить кілька ітерацій, продвигаючись кожен раз на один символ вправо, починаючи з позиції $i$, після чого права межа $r$ обов'язково оновиться.

Оскільки $i>r$, то ми отримуємо, що кожна ітерація цього циклу дійсно збільшує нове значення $r$ на одиницю.

* $i \le r$

У цьому випадку ми за допомогою наведеної формули ініціалізуємо значення $z[i]$ деяким числом $z_0$. Порівняємо це початкове значення $z_0$ з величиною $r-i+1$ і отримаємо три варіанти:

* $z_0 < r-i+1$

Доведемо, що в цьому випадку жодної ітерації циклу $\rm while$ не буде виконано.

Це легко довести, наприклад, за допомогою протиріччя: якщо б цикл $\rm while$ виконав хоча б одну ітерацію, це б означало, що певне значення $z_0$, яке ми використали, було неточним та меншим за фактичну довжину збігу. Оскільки стрічки $s[l \ldots r]$ і $s[0 \ldots r-l]$ збігаються, то це означає, що в позиції $z[i-l]$ потрібно використовувати неправильне значення, яке менше за фактичну довжину збігу.

Таким чином, у цьому варіанті з коректності значення $z[i-l]$ і з того, що воно менше $r-i+1$, випливає, що це значення співпадає з шуканим значенням $z[i]$.

* $z_0 = r-i+1$

У цьому випадку цикл $\rm while$ може виконатись кілька разів, але кожен раз нове значення $r$ збільшуватиметься на одиницю, оскільки першим порівнюваним символом буде $s[r+1]$, який виходить за межі діапазону $[l;r]$.

* $z_0 > r-i+1$

Цей варіант принципово неможливий через визначення $z_0$.

Таким чином, ми довели, що кожна ітерація вкладеного циклу призводить до продвиження покажчика $r$ вправо. Тобто $r$ не може виявитися більше $n-1$. Це означає, що всього цей цикл виконає не більше $n-1$ ітерацій.

Оскільки вся інша частина алгоритму, очевидно, працює за $O(n)$, то ми довели, що весь алгоритм обчислення Z-функції виконується за лінійний час.

## Застосування

Розглянемо кілька застосувань функції Z при рішенні конкретних задач.

Застосування цих будуть у багатьох випадках аналогічними застосуванням [функції префіксів](функція_префіксів).

### Пошук підрядка в рядку

Уникаймо плутанини і назвімо один рядок **текстом** $t$, інший - **зразком** $p$. Таким чином, задача полягає в тому, щоб знайти всі входження зразка $p$ в текст $t$.

Для розв'язання цієї задачі утворимо стрічку $s = p + \text{\#} + t$, тобто до зразків додаємо текст через символ-роздільник (який не зустрічається ніде в самому тексті).

Порахуймо для отриманої стрічки Z-функцію. Отже, для будь-якого $i$ в діапазоні $[0; length(t)-1]$ за відповідними значеннями $z[i + length(p) + 1]$ можна зрозуміти, чи входить образець $p$ в текст $t$, починаючи з позиції $i$: якщо значення Z-функції дорівнює $length(p)$, то так, входить, інакше - ні.

Таким чином, асимптотика розв'язку складає $O(\operatorname{length}(t) + \operatorname{length}(p))$. Використання пам'яті також має ту ж асимптотику.

### Кількість різних підстрічок у стрічці

Дана рядок $s$ довжини $n$. Потрібно порахувати кількість його різних підрядків.

Будемо розв'язувати цю задачу ітеративно. Зокрема, навчимося, знаючи поточну кількість різних підрядків, перераховувати їх кількість при додаванні в кінець одного символу.

Отже, нехай $k$ - поточна кількість різних підстрічок рядка $s$, і ми додаємо в кінець символ $c$. Очевидно, в результаті можуть з'явитися деякі нові підстрічки, які закінчуються на цьому новому символі $c$ (а саме, всі підстрічки, які закінчуються на цей символ, але не зустрічалися раніше).

Візьмемо рядок $t=s+c$ і інвертуємо його (запишемо символи у зворотньому порядку). Наше завдання полягає в тому, щоб порахувати, скільки у рядку $t$ таких префіксів, які не зустрічаються в ньому більше ніде. Але якщо ми порахуємо для рядка $t$ Z-функцію і знайдемо її максимальне значення $z_{\rm max}$, то очевидно, що в рядку $t$ зустрічається (не на початку) її префікс довжини $z_{\rm max}$, але не більшої довжини. Зрозуміло, що префікси меншої довжини вже точно зустрічаються в ньому.

Отже, ми отримали, що кількість нових підстрічок, які з'являються при додаванні символу $c$, дорівнює $len - z_{\rm max}$, де $len$ - поточна довжина стрічки після додавання символу $c$.

Отже, асимптотика розв'язку для рядка довжини $n$ становить $O(n^2)$.

Варто зазначити, що можна повністю аналогічно перераховувати кількість різних підстрічок за $O(n)$ при додаванні символу в початок, а також при видаленні символу з кінця або з початку. Російське слово "повинен" слід замінити на "має".

### Стиснення стрічки

Дана рядок $s$ довжиною $n$. Потрібно знайти найкоротший спосіб її стиснення, тобто знайти найменший рядок $t$, такий що $s$ можна представити як конкатенацію однієї або кількох копій $t$.

Для розв'язання порахуємо Z-функцію рядка $s$, і знайдемо першу позицію $i$ таку, що $i + z[i] = n$, і при цьому $n$ ділиться на $i$. Отже, рядок $s$ можна стиснути до рядка довжини $i$.

Доведення такого розв'язку практично не відрізняється від доведення розв'язку з використанням префікс-функції.

## Завдання в онлайн-суддях

Список задач, які можна вирішити, використовуючи Z-функцію:

* [UVA #455 **"Periodic Strings"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=396)

* [UVA #11022 **"String Factoring"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1963=)