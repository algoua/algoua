# Декартове дерево (також відоме як treap чи дераміда)

Декартове дерево - це структура даних, що об'єднує в собі бінарне дерево пошуку та бінарну купу (звідси й друга її назва: дерапт (дерево+heap) та дераміда (дерево+піраміда)).

Більш строго, це структура даних, яка зберігає пари (X,Y) у вигляді бінарного дерева таким чином, що вона є бінарним деревом пошуку за X і бінарною пірамідою за Y. Припускаючи, що всі X і всі Y є різними, отримуємо, що якщо деякий елемент дерева містить (X<sub>0</sub>,Y<sub>0</sub>), то у всіх елементах в лівому піддереві X < X<sub>0</sub>, у всіх елементах в правому піддереві X > X<sub>0</sub>, а також і в лівому, і в правому піддереві маємо: Y < Y<sub>0</sub>.

Дераміди були запропоновані Сіделем (Siedel) та Арагоном (Aragon) у 1989 році.

## Переваги такої організації даних

У тому застосуванні, якe ми розглядаємо (ми будемо розглядати дераміди, оскільки декартове дерево - це фактично більш загальна структура даних), X-и є ключами (і одночасно значеннями, що зберігаються в структурі даних), а Y-і - називаються **пріоритетами**. Якщо б не було пріоритетів, то було б звичайне бінарне дерево пошуку по X, і заданому набору X-ів могло б відповідати багато дерев, деякі з яких є виродженими (наприклад, у вигляді ланцюжка), а тому надзвичайно повільними (основні операції виконувалися б за O(N)).

В той же час, **пріоритети** дозволяють **однозначно** вказати дерево, яке буде побудоване (звісно, не залежне від порядку додавання елементів) (це доводиться відповідною теоремою). Тепер очевидно, що якщо **вибирати пріоритети випадково**, то цим ми досягнемо побудови **невироджених** дерев у середньому, що забезпечить асимптотику O(log N) у середньому. Звідси і зрозуміла ще одна назва цій структурі даних - **рандомізоване бінарне дерево пошуку**.

## Операції

Отже, treap надає наступні операції:

* **Вставка (X, Y)** - за O(log N) в середньому
Виконує додавання нового елемента до дерева.
Можливий варіант полягає у тому, що значення пріоритету Y не передається функції, а вибирається випадковим чином. Проте слід пам'ятати, що воно не повинно збігатися з будь-яким іншим значенням Y у дереві.
* "Пошук (X)" - за O(log N) у середньому
Шукається елемент з вказаним значенням ключа X. Реалізується абсолютно так само, як і для звичайного бінарного дерева пошуку.
* "Erase (X)" - за O(log N) в середньому
Шукає елемент і видаляє його з дерева.
* **Build (X<sub>1</sub>, ..., X<sub>N</sub>)** - за O (N)
Будує дерево зі списку значень. Цю операцію можна реалізувати за лінійний час (в припущенні, що значення X<sub>1</sub>, ..., X<sub>N</sub> відсортовані), але тут цю реалізацію розглядати не будемо.
Тут буде використовуватися тільки простіша реалізація - у вигляді послідовних викликів Insert, тобто за O(N log N).
* **Об'єднання (T<sub>1</sub>, T<sub>2</sub>)** - за O(M log(N/M)) у середньому
Об'єднує два дерева, вважаючи, що всі елементи є різними (проте цю операцію можна реалізувати з такою ж асимптотичною складністю, якщо при об'єднанні необхідно видаляти повторювані елементи).
* **Перетин (T<sub>1</sub>, T<sub>2</sub>)** - за O(M log(N/M)) у середньому
Знаходь перетин двох дерев (тобто їх спільні елементи). Тут реалізація цієї операції не буде розглядатися.

Крім того, завдяки тому, що декартове дерево є бінарним деревом пошуку за своїми значеннями, до нього можна застосовувати операції знаходження K-го елементу за величиною і, навпаки, визначення номера елементу.

## Опис реалізації

З точки зору реалізації, кожен елемент містить у собі X та Y координати та вказівники на лівого L та правого R нащадка.

Для реалізації операцій потрібно реалізувати дві допоміжні функції: Розділення та Об'єднання.

**Split (T, X)** - розділяє дерево T на два дерева L і R (які є повертаємим значенням) таким чином, що L містить всі елементи, менші за ключ X, а R містить всі елементи, більші за X. Ця операція виконується за O(log N). Реалізація її досить проста - очевидна рекурсія.

**Merge (T<sub>1</sub>, T<sub>2</sub>)** - об'єднує два піддерева T<sub>1</sub> і T<sub>2</sub> і повертає нове дерево. Ця операція також реалізується за O(log N). Вона працює з припущенням, що T<sub>1</sub> і T<sub>2</sub> мають відповідний порядок (всі значення X в першому менше значень X у другому). Таким чином, нам потрібно об'єднати їх так, щоб не порушити порядок за пріоритетом Y. Для цього просто вибираємо в якості кореня те дерево, у якому Y в корені більше, і рекурсивно викликаємо себе від іншого дерева і відповідного сина вибраного дерева.

Тепер очевидна реалізація **Вставити (X, Y)**. Спочатку спускаємося по дереву (як у звичайному бінарному дереві пошуку за X), але зупиняємося на першому елементі, в якому значення пріоритету менше Y. Ми знайшли позицію, куди будемо вставляти наш елемент. Тепер викликаємо Split (X) від знайденого елементу (від елементу разом з усім його піддеревом), і отримані L і R записуємо як лівого і правого нащадка додаваного елементу.

Також зрозуміла і реалізація **Видалення (X)**. Спускаємося по дереву (як у звичайному бінарному дереві пошуку за X), шукаючи елемент, який треба видалити. Знайшовши елемент, просто викликаємо Merge від його лівого та правого синів, і значення, яке повертається, ставимо на місце видаляємого елемента.

Операцію **Build** реалізуємо за O(N log N) просто з допомогою послідовних викликів Вставка.

Нарешті, операція **Об'єднання (T<sub>1</sub>, T<sub>2</sub>)**. Теоретично її асимптотика O(M log(N/M)), проте на практиці вона працює дуже добре, імовірно, з вельми малою прихованою константою. Нехай, не втрачаючи загальності, T<sub>1</sub>->Y > T<sub>2</sub>->Y, тобто корінь T<sub>1</sub> буде коренем результату. Щоб отримати результат, нам потрібно об'єднати дерева T<sub>1</sub>->L, T<sub>1</sub>->R і T<sub>2</sub> в два такі дерева, щоб їх можна було зробити синами T<sub>1</sub>. Для цього викличемо Split (T<sub>2</sub>, T<sub>1</sub>->X), тим самим ми розіб'ємо T<sub>2</sub> на дві половинки L і R, які потім рекурсивно об'єднаємо з синами T<sub>1</sub>: Об'єднання (T<sub>1</sub>->L, L) і Об'єднання (T<sub>1</sub>->R, R), тим самим ми побудуємо ліве і праве піддерева результату.

## Реалізація

Реалізовуємо всі описані вище операції. Тут для зручності введені інші позначення - пріоритет позначається як prior, значення - як key.

<!--- TODO: specify code snippet id -->
``` cpp
struct item {
    int key, prior;
    item *l, *r;
    item() {}
    item(int key, int prior) : key(key), prior(prior), l(NULL), r(NULL) {}
};
typedef item *pitem;

void split(pitem t, int key, pitem &l, pitem &r) {
    if (!t)
        l = r = NULL;
    else if (key < t->key)
        split(t->l, key, l, t->l), r = t;
    else
        split(t->r, key, t->r, r), l = t;
}

void insert(pitem &t, pitem it) {
    if (!t)
        t = it;
    else if (it->prior > t->prior)
        split(t, it->key, it->l, it->r), t = it;
    else
        insert(it->key < t->key ? t->l : t->r, it);
}

void merge(pitem &t, pitem l, pitem r) {
    if (!l || !r)
        t = l ? l : r;
    else if (l->prior > r->prior)
        merge(l->r, l->r, r), t = l;
    else
        merge(r->l, l, r->l), t = r;
}

void erase(pitem &t, int key) {
    if (t->key == key)
        merge(t, t->l, t->r);
    else
        erase(key < t->key ? t->l : t->r, key);
}

pitem unite(pitem l, pitem r) {
    if (!l || !r)
        return l ? l : r;
    if (l->prior < r->prior)
        swap(l, r);
    pitem lt, rt;
    split(r, l->key, lt, rt);
    l->l = unite(l->l, lt);
    l->r = unite(l->r, rt);
    return l;
}
```

## Підтримка розмірів поддеревьев

Щоб розширити функціональність декартового дерева, дуже часто необхідно для кожної вершини зберігати кількість вершин у її піддереві - певне поле int cnt у структурі item. Наприклад, з його допомогою легко буде знайти за O(log N) K-ий за величиною елемент дерева, або, навпаки, за ту ж асимптотику дізнатися номер елементу в відсортованому списку (реалізація цих операцій нічим не буде відрізнятися від їх реалізації для звичайних бінарних дерев пошуку).

При зміні дерева (додаванні або видаленні елементу тощо) повинні відповідним чином змінюватися cnt деяких вершин. Реалізуємо дві функції: функція cnt() буде повертати поточне значення cnt або 0, якщо вершина не існує, а функція upd_cnt() буде оновлювати значення cnt для зазначеної вершини за умови, що для її синів l і r ці cnt вже правильно оновлені. Значить, зрозуміло, достатньо додати виклики функції upd_cnt() в кінець кожної з функцій insert, erase, split, merge, щоб постійно підтримувати коректні значення cnt.

<!--- TODO: specify code snippet id -->
``` cpp
int cnt(pitem t) { return t ? t->cnt : 0; }

void upd_cnt(pitem t) {
    if (t)
        t->cnt = 1 + cnt(t->l) + cnt(t->r);
}
```

## Побудова декартового дерева за $O(N)$ в офлайн

TODO

## Неявні декартові дерева

Неявне декартове дерево - це проста модифікація звичайного декартового дерева, яка, тим не менш, виявляється дуже потужною структурою даних. Фактично, неявне декартове дерево можна сприймати як масив, над яким можна реалізувати наступні операції (усі за O(log N) в режимі онлайн):

* Вставка елемента в масив у будь-яку позицію
* Видалення будь-якого елементу
* Сума, мінімум/максимум на будь-якому відрізку тощо.
* Додаток: покраска відрізка
* Перевернення (перестановка елементів у зворотному порядку) на відрізку

Ключова ідея полягає в тому, що в якості ключів key випливає використовувати **індекси** елементів у масиві. Однак явно зберігати ці значення key ми не будемо (інакше, наприклад, при вставці елементу довелося б змінювати key в O(N) вершинах дерева).

Зауважимо, що фактично у даному випадку ключ для будь-якої вершини - це кількість вершин, менших за неї. Слід зазначити, що вершини, менші за дану, знаходяться не тільки в її лівому піддереві, але й, можливо, в лівих піддеревах її предків. Більш точно, **неявний ключ** для певної вершини t дорівнює кількості вершин cnt(t->l) в лівому піддереві цієї вершини, доданій до аналогічних величин cnt(p->l)+1 для кожного предка p цієї вершини, за умови, що t знаходиться в правому піддереві для p.

Ясно, як тепер швидко обчислити для поточної вершини її неявний ключ. Оскільки у всіх операціях ми приходимо в яку-небудь вершину, спускаючись по дереву, ми можемо просто накопичувати цю суму, передаючи її функції. Якщо ми йдемо в ліве піддерево - накопичувана сума не змінюється, а якщо йдемо в праве - збільшується на cnt(t->l)+1.

Наведемо нові реалізації функцій розділення та злиття:

<!--- TODO: specify code snippet id -->
``` cpp
void merge(pitem &t, pitem l, pitem r) {
    if (!l || !r)
        t = l ? l : r;
    else if (l->prior > r->prior)
        merge(l->r, l->r, r), t = l;
    else
        merge(r->l, l, r->l), t = r;
    upd_cnt(t);
}

void split(pitem t, pitem &l, pitem &r, int key, int add = 0) {
    if (!t)
        return void(l = r = 0);
    int cur_key = add + cnt(t->l); // обчислюємо неявний ключ
    if (key <= cur_key)
        split(t->l, l, t->l, key, add), r = t;
    else
        split(t->r, t->r, r, key, add + 1 + cnt(t->l)), l = t;
    upd_cnt(t);
}
```
Тепер перейдемо до реалізації різних додаткових операцій на неявних декартових деревах:

* **Вставка** елементу.
Нехай нам потрібно вставити елемент на позицію pos. Розіб'ємо декартове дерево на дві частини: відповідну масиву [0..pos-1] і масиву [pos..sz]. Для цього достатньо викликати split (t, t1, t2, pos). Після цього ми можемо об'єднати дерево t1 з новою вершиною, для цього достатньо викликати merge (t1, t1, new_item) (легко переконатися, що всі передумови для merge виконані). Нарешті, об'єднаємо два дерева t1 і t2 назад в дерево t, викликавши merge (t, t1, t2).
* **Видалення** елементу.
Тут все ще простіше: достатньо знайти елемент, який потрібно видалити, а потім виконати злиття для його синів l і r, і поставити результат злиття на місце вершини t. Фактично, видалення з неявного декартового дерева не відрізняється від видалення з звичайного декартового дерева.
* Сума/мінімум тощо на відрізку.
По-перше, для кожної вершини створимо додаткове поле f в структурі item, в якому буде зберігатися значення цільової функції для піддерева цієї вершини. Таке поле легко підтримувати, для цього потрібно ввести аналогічно підтримці розмірів cnt (створити функцію, яка обчислює значення цього поля, користуючись його значеннями для синів, і вставити виклики цієї функції в кінці всіх функцій, що змінюють дерево).
По-друге, нам потрібно навчитися відповідати на запит на довільному відрізку [A;B]. Навчимося виділяти з дерева його частину, відповідну відрізку [A;B]. Неважко зрозуміти, що для цього достатньо спочатку викликати split (t, t1, t2, A), а потім split (t2, t2, t3, B-A+1). В результаті дерево t2 і буде складатися з усіх елементів у відрізку [A;B], і тільки їх. Отже, відповідь на запит буде перебувати в полі f вершини t2. Після відповіді на запит дерево потрібно відновити викликами merge (t, t1, t2) і merge (t, t, t3).
* Покраска відрізка.
Тут ми діємо аналогічно до попереднього пункту, але замість поля f ми будемо зберігати поле add, яке і міститиме прибавлювану величину (або величину, в яку фарбують усі піддерево цієї вершини). Перед виконанням будь-якої операції цю величину add треба "протолкнути" - тобто відповідним чином змінити t-l->add і t->r->add, а у собі значення add зняти. Тим самим ми досягнемо того, що при будь-яких змінах дерева інформація не буде втрачена.
* Перевертання на відрізку.
Цей пункт майже аналогічний до попереднього - потрібно ввести поле bool з іменем rev, яке встановлювати в true, коли потрібно провести переворот у піддереві поточної вершини. "Проталкивання" поля rev полягає в тому, що ми міняємо місцями сині поточної вершини і встановлюємо цей прапор для них.

**Реалізація**. Наведемо на приклад повну реалізацію неявного декартового дерева з обертанням на відрізку. Тут для кожної вершини також зберігається поле значення - власне значення елементу, що стоїть у масиві на поточній позиції. Надано також реалізацію функції виведення output(), яка виводить масив, що відповідає поточному стану неявного декартового дерева.

<!--- TODO: specify code snippet id -->
``` cpp
typedef struct item *pitem;
struct item {
    int prior, value, cnt;
    bool rev;
    pitem l, r;
};

int cnt(pitem it) { return it ? it->cnt : 0; }

void upd_cnt(pitem it) {
    if (it)
        it->cnt = cnt(it->l) + cnt(it->r) + 1;
}

void push(pitem it) {
    if (it && it->rev) {
        it->rev = false;
        swap(it->l, it->r);
        if (it->l)
            it->l->rev ^= true;
        if (it->r)
            it->r->rev ^= true;
    }
}

void merge(pitem &t, pitem l, pitem r) {
    push(l);
    push(r);
    if (!l || !r)
        t = l ? l : r;
    else if (l->prior > r->prior)
        merge(l->r, l->r, r), t = l;
    else
        merge(r->l, l, r->l), t = r;
    upd_cnt(t);
}

void split(pitem t, pitem &l, pitem &r, int key, int add = 0) {
    if (!t)
        return void(l = r = 0);
    push(t);
    int cur_key = add + cnt(t->l);
    if (key <= cur_key)
        split(t->l, l, t->l, key, add), r = t;
    else
        split(t->r, t->r, r, key, add + 1 + cnt(t->l)), l = t;
    upd_cnt(t);
}

void reverse(pitem t, int l, int r) {
    pitem t1, t2, t3;
    split(t, t1, t2, l);
    split(t2, t2, t3, r - l + 1);
    t2->rev ^= true;
    merge(t, t1, t2);
    merge(t, t, t3);
}

void output(pitem t) {
    if (!t)
        return;
    push(t);
    output(t->l);
    printf("%d ", t->value);
    output(t->r);
}
```