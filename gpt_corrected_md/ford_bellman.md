# Алгоритм Форда-Беллмана

Нехай дано орієнтований зважений граф $G$ з $n$ вершинами та $m$ ребрами, та вказана деяка вершина $v$. Потрібно знайти **довжини найкоротших шляхів** від вершини $v$ до всіх інших вершин.

У відміну від [алгоритму Дейкстри](dijkstra), цей алгоритм можна застосувати і до графів, що містять ребра з від'ємною вагою. Однак, якщо граф містить цикл з від'ємною вагою, то, очевидно, найкоротших шляхів до деяких вершин може не існувати (тому що вага найкоротшого шляху повинна бути рівна мінус нескінченності); проте цей алгоритм можна модифікувати, щоб він сигналізував про наявність циклу з від'ємною вагою або навіть вивів сам цей цикл.

Алгоритм носить ім'я двох американських вчених: Річарда **Беллмана** (Richard Bellman) і Лестера **Форда** (Lester Ford). Форд фактично винайшов цей алгоритм у 1956 році під час вивчення іншої математичної задачі, підзадача якої полягала у пошуку найкоротшого шляху в графі, і Форд намалював набросок алгоритму для її вирішення. Беллман у 1958 році опублікував статтю, присвячену конкретно задачі знаходження найкоротшого шляху, і в цій статті він чітко сформулював алгоритм у тому вигляді, в якому він відомий нам зараз.

## Опис алгоритму

Ми припускаємо, що граф не містить циклів з від'ємною вагою. Випадок наявності циклу з від'ємною вагою буде розглянуто нижче в окремому розділі.

Заведемо масив відстаней $d[0 \ldots n-1]$, який після виконання алгоритму буде містити відповідь на задачу. На початку роботи ми заповнюємо його наступним чином: $d[v] = 0$, а всі інші елементи $d[]$ дорівнюють нескінченності $\infty$.

Сам алгоритм Форда-Беллмана складається з кількох фаз. На кожній фазі проглядаються всі ребра графа, і алгоритм намагається провести **релаксацію** (ослаблення) вздовж кожного ребра $(a,b)$ ваги $c$. Релаксація вздовж ребра - це спроба покращити значення $d[b]$ значенням $d[a] + c$. Фактично це означає, що ми намагаємося покращити відповідь для вершини $b$, користуючись ребром $(a,b)$ та поточним значенням для вершини $a$.

Стверджується, що достатньо $n-1$ фаз алгоритму, щоб правильно порахувати довжини всіх найкоротших шляхів у графі (повторюємося, ми припускаємо, що цикли негативного ваги відсутні). Для недосяжних вершин відстань $d[]$ залишиться рівною нескінченності $\infty$.

## Реалізація

Для алгоритму Форда-Беллмана, на відміну від багатьох інших графових алгоритмів, зручніше представляти граф у вигляді одного списку всіх ребер (а не $n$ списків ребер - ребер з кожної вершини). У наведеній реалізації створюється структура даних $\rm edge$ для ребра. Вхідними даними для алгоритму є числа $n, m$, список $e$ ребер, і номер стартової вершини $v$. Усі номера вершин нумеруються з $0$ по $n-1$.

### Найпростіша реалізація

Константа $\rm INF$ позначає поняття "нескінченність" - її потрібно вибрати таким чином, щоб вона свідомо перевищувала всі можливі довжини шляхів.

<!--- TODO: specify code snippet id -->
``` cpp
struct edge {
    int a, b, cost;
};

int n, m, v;
vector<edge> e;
const int INF = 1000000000;

void solve() {
    vector<int> d(n, INF);
    d[v] = 0;
    for (int i = 0; i < n - 1; ++i)
        for (int j = 0; j < m; ++j)
            if (d[e[j].a] < INF)
                d[e[j].b] = min(d[e[j].b], d[e[j].a] + e[j].cost);
Виведення змінної d на екран, наприклад, можна зробити так:
}
```

Перевірка "if (d[e[j].a] < INF)" потрібна тільки у разі наявності ребер негативної ваги в графі. Без такої перевірки можуть відбуватися релаксації з вершин, до яких ще не знайдено шляхи, і в результаті можуть виникнути некоректні значення відстаней, такі як $\infty - 1$, $\infty - 2$ і т.д.

### Покращена реалізація

Цей алгоритм можна дещо прискорити: найчастіше відповідь знаходиться вже за кілька фаз, а залишилися фази, на яких не відбувається жодної корисної роботи, а лише проглядаються всі ребра марно. Тому будемо зберігати прапорець того, чи змінилося щось на поточній фазі, і якщо на якійсь фазі нічого не відбулося, то алгоритм можна зупиняти. (Ця оптимізація не покращує асимптотику, тобто на деяких графах як і раніше будуть потрібні всі $n-1$ фаз, але значно прискорює поведінку алгоритму "в середньому", тобто на випадкових графах).

З такою оптимізацією стає взагалі непотрібним обмежувати вручну кількість фаз алгоритму числом $n-1$ - він сам зупиниться після потрібної кількості фаз.

<!--- TODO: specify code snippet id -->
``` cpp
void solve() {
    vector<int> d(n, INF);
    d[v] = 0;
    for (;;) {
        bool any = false;
        for (int j = 0; j < m; ++j)
            if (d[e[j].a] < INF)
                if (d[e[j].b] > d[e[j].a] + e[j].cost) {
                    d[e[j].b] = d[e[j].a] + e[j].cost;
                    any = true;
                }
        if (!any)
            break;
    }
    // висновок d, наприклад, на екран
}
```

### Відновлення доріг

Розглянемо тепер, як можна модифікувати алгоритм Форда-Беллмана так, щоб він не тільки знаходив довжини найкоротших шляхів, але й дозволяв відновлювати самі найкоротші шляхи.

Для цього створимо ще один масив $p[0 \ldots n-1]$, в якому для кожної вершини будемо зберігати її "попередника", тобто попередню вершину в найкоротшому шляху, що веде до неї. Насправді, найкоротший шлях до деякої вершини $a$ є найкоротшим шляхом до деякої вершини $p[a]$, до якого приєднали вершину $a$.

Зауважимо, що алгоритм Форда-Беллмана працює за такою ж логікою: він, припускаючи, що найкоротшу відстань до однієї вершини вже пораховано, намагається покращити найкоротшу відстань до іншої вершини. Отже, в момент поліпшення нам потрібно просто запам'ятовувати в $p[]$, з якої вершини це поліпшення відбулося.

Наведемо реалізацію алгоритму Форда-Беллмана з відновленням шляху до заданої вершини $t$:

<!--- TODO: specify code snippet id -->
``` cpp
void solve() {
    vector<int> d(n, INF);
    d[v] = 0;
    vector<int> p(n, -1);
    for (;;) {
        bool any = false;
        for (int j = 0; j < m; ++j)
            if (d[e[j].a] < INF)
                if (d[e[j].b] > d[e[j].a] + e[j].cost) {
                    d[e[j].b] = d[e[j].a] + e[j].cost;
                    p[e[j].b] = e[j].a;
                    any = true;
                }
        if (!any)
            break;
    }

    if (d[t] == INF)
        cout << "No path from " << v << " to " << t << ".";
    else {
        vector<int> path;
        for (int cur = t; cur != -1; cur = p[cur])
            path.push_back(cur);
        reverse(path.begin(), path.end());

        cout << "Path from " << v << " to " << t << ": ";
        for (size_t i = 0; i < path.size(); ++i)
            cout << path[i] << ' ';
    }
}
```

Тут ми спочатку проходимось по предкам, починаючи з вершини $t$, і зберігаємо весь пройдений шлях у списку $\rm path$. У цьому списку вийде найкоротший шлях від $v$ до $t$, але у зворотному порядку, тому ми викликаємо $\rm reverse$ від нього і потім виводимо.

## Доведення алгоритму

По-перше, зауважимо, що для недосяжних з $v$ вершин алгоритм відпрацює правильно: для них мітка $d[]$ залишиться рівною нескінченності (тобто алгоритм Форда-Беллмана знайде якісь шляхи до всіх досяжних з $s$ вершин, а релаксація у всіх інших вершинах не відбудеться жодного разу).

Доведемо тепер твердження: після виконання $i$ фаз алгоритму Форда-Беллмана правильно знаходиться всі найкоротші шляхи, довжина яких (за кількістю ребер) не перевищує $i$.

Іншими словами, для будь-якої вершини $a$ позначимо через $k$ число ребер у найкоротшому шляху до неї (якщо таких шляхів декілька, можна взяти будь-який). Отже, це твердження стверджує, що після $k$ фаз найкоротший шлях буде знайдений гарантовано

**Доведення**. Розглянемо довільну вершину $a$, до якої існує шлях зі стартової вершини $v$, і розглянемо найкоротший шлях до неї: $(p_0=v, p_1, \ldots, p_k=a)$. Перед першою фазою найкоротший шлях до вершини $p_0=v$ знайдений правильно. У час першої фази ребро $(p_0,p_1)$ було переглянуто алгоритмом Дейкстри, отже, відстань до вершини $p_1$ було правильно пораховано після першої фази. Повторюючи ці затвердження $k$ разів, отримуємо, що після $k$-ої фази відстань до вершини $p_k=a$ пораховано правильно, що і потрібно довести.

Останнє, що потрібно зазначити, це те, що будь-який найкоротший шлях не може мати більше, ніж $n-1$ ребер. Отже, алгоритму достатньо провести лише $n-1$ фазу. Після цього жодна релаксація гарантовано не може закінчитися поліпшенням відстані до будь-якої вершини.

## Випадок негативного циклу

Вище ми скрізь зазначали, що у графі не існує негативного циклу (уточнимо, нас цікавить негативний цикл, досяжний зі стартової вершини $v$, а недосяжні цикли не впливають на вищезазначений алгоритм). Однак, якщо такий цикл існує, то виникають додаткові складності, пов'язані з тим, що відстані до всіх вершин на цьому циклі, а також відстані до досяжних з цього циклу вершин не визначені - вони повинні бути рівні мінус нескінченності.

Не складно зрозуміти, що алгоритм Форда-Беллмана може **безкінечно робити релаксації** серед всіх вершин цього циклу та вершин, досяжних з нього. Отже, якщо не обмежувати кількість фаз числом $n-1$, то алгоритм буде працювати безкінечно, постійно поліпшуючи відстані до цих вершин.

Звідси ми отримуємо **критерій наявності досяжного циклу від'ємної ваги**: якщо після $n-1$ фази ми виконаємо ще одну фазу, і на ній відбудеться хоча б одна релаксація, то граф містить цикл від'ємної ваги, досяжний з $v$; в іншому випадку, такого циклу немає.

Більше того, якщо такий цикл виявився, то алгоритм Форда-Беллмана можна модифікувати таким чином, щоб він виводив сам цей цикл у вигляді послідовності вершин, що входять в нього. Для цього досить запам'ятати номер вершини $x$, в якій відбулася релаксація на $n$-ій фазі. Ця вершина буде або лежати на циклі негативної ваги, або вона досяжна з нього. Щоб отримати вершину, яка гарантовано лежить на циклі, досить, наприклад, $n$ разів пройти по предкам, починаючи з вершини $x$. Отримавши номер $y$ вершини, що лежить на циклі, треба пройтися від цієї вершини по предкам, поки ми не повернемося в цю ж вершину $y$ (а це обов'язково станеться, тому що релаксації в циклі негативної ваги відбуваються по колу).

Реалізація:

<!--- TODO: specify code snippet id -->
``` cpp
void solve() {
    vector<int> d(n, INF);
    d[v] = 0;
    vector<int> p(n, -1);
    int x;
    for (int i = 0; i < n; ++i) {
        x = -1;
        for (int j = 0; j < m; ++j)
            if (d[e[j].a] < INF)
                if (d[e[j].b] > d[e[j].a] + e[j].cost) {
                    d[e[j].b] = max(-INF, d[e[j].a] + e[j].cost);
                    p[e[j].b] = e[j].a;
                    x = e[j].b;
                }
    }

    if (x == -1)
        cout << "No negative cycle from " << v;
    else {
        int y = x;
        for (int i = 0; i < n; ++i)
            y = p[y];

        vector<int> path;
        for (int cur = y;; cur = p[cur]) {
            path.push_back(cur);
            if (cur == y && path.size() > 1)
                break;
        }
        reverse(path.begin(), path.end());

        cout << "Negative cycle: ";
        for (size_t i = 0; i < path.size(); ++i)
            cout << path[i] << ' ';
    }
}
```

Оскільки при наявності негативного циклу під час $n$ ітерацій алгоритму відстані можуть стати дуже від'ємними (можливо, до чисел порядку $-2^n$), у коді прийняті додаткові заходи проти такого переповнення цілих чисел

<!--- TODO: specify code snippet id -->
``` cpp
d[e[j].b] = max(-INF, d[e[j].a] + e[j].cost);
```

У наведеній вище реалізації шукається негативний цикл, досяжний з деякої стартової вершини $v$. Однак алгоритм можна модифікувати, щоб він шукав будь-який негативний цикл в графі. Для цього потрібно встановити всі відстані $d[i]$ рівними нулю, а не нескінченності - так, ніби ми шукаємо найкоротший шлях з усіх вершин одночасно. Це не вплине на коректність виявлення негативного циклу.

Додатково щодо цієї задачі - див. окрему статтю [**"Пошук від'ємного циклу в графі"**](negative_cycle).

## Завдання на онлайн-суддях

Список задач, які можна вирішити за допомогою алгоритму Форда-Беллмана:

* [E-OLIMP #1453 **"Форд-Беллман"** [складність: низька]](http://www.e-olimp.com.ua/problems/1453)

* [UVA #423 **"MPI Maelstrom"** [складність: низька]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=364)

* [UVA #534 **"Frogger"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=7&page=show_problem&problem=475)

* [UVA #10099 **"The Tourist Guide"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=12&page=show_problem&problem=1040)

* [UVA #515 **"King"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=456)

Дивись також список задач у статті [**"Пошук від'ємного циклу"**](negative_cycle).