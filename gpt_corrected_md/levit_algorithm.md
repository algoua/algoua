# Алгоритм Левіта знаходження найкоротших шляхів від заданої вершини до всіх інших вершин

Нехай задано граф з N вершинами та M ребрами, для кожного з яких вказано його вага L<sub>i</sub>. Також задано стартову вершину V<sub>0</sub>. Потрібно знайти найкоротші шляхи від вершини V<sub>0</sub> до всіх інших вершин.

Алгоритм Левіта вирішує цю задачу дуже ефективно (щодо асимптотики і швидкості роботи див. нижче).

## Опис

Нехай масив D[1..N] містить поточні найкоротші довжини шляхів, тобто D<sub>i</sub> - це поточна довжина найкоротшого шляху від вершини V<sub>0</sub> до вершини i. Спочатку масив D заповнений значеннями "нескінченність", крім D<sub>V<sub>0</sub></sub> = 0. Після закінчення роботи алгоритму цей масив буде містити остаточні найкоротші відстані.

Нехай масив P[1..N] містить поточних предків, тобто P<sub>i</sub> - це вершина, що передує вершині i в найкоротшому шляху від вершини V<sub>0</sub> до i. Так само як і масив D, масив P змінюється поступово під час виконання алгоритму і до кінця його приймає остаточні значення.

&nbsp;

Тепер сам алгоритм Левіта. На кожному кроці підтримуються три множини вершин:

* M<sub>0</sub> - вершини, до відстані до яких вже обчислено (але, можливо, не остаточно);
* M$_{1}$ -- вершини, відстань до яких обчислюється;
* M$_{2}$ - вершини, до яких ще не обчислено відстань.

Вершини в множині M<sub>1</sub> зберігаються у вигляді двосторонньої черги (deque).

&nbsp;

Спочатку всі вершини поміщаються в множину M<sub>2</sub>, крім вершини V<sub>0</sub>, яка поміщається в множину M<sub>1</sub>.

На кожному кроці алгоритму ми беремо вершину з множини M₁ (дістаємо верхній елемент з черги). Нехай V - це обрана вершина. Переводимо цю вершину у множину M₀. Потім переглядаємо всі ребра, що виходять з цієї вершини. Нехай T - це другий кінець поточного ребра (тобто не дорівнює V), а L - це довжина поточного ребра.

* Якщо Т належить М<sub>2</sub>, то Т переносимо в множину М<sub>1</sub> в кінець черги. D<sub>T</sub> вважаємо рівним D<sub>В</sub> + L.
* Якщо T належить до M<sub>1</sub>, то ми намагаємося покращити значення D<sub>T</sub>: D<sub>T</sub> = min (D<sub>T</sub>, D<sub>V</sub> + L). Сама вершина T не переміщується в черзі.
* Якщо T належить до M<sub>0</sub>, і якщо можна покращити D<sub>T</sub> (D<sub>T</sub> > D<sub>V</sub> + L), то покращуємо D<sub>T</sub>, а вершину T повертаємо до множини M<sub>1</sub>, помістивши її на початок черги.

Зрозуміло, що при кожному оновленні масиву D потрібно також оновлювати значення в масиві P.

## Подробиці реалізації

Створимо масив ID[1..N], в якому для кожної вершини будемо зберігати, до якого множини вона належить: 0 - якщо M<sub>2</sub> (тобто відстань дорівнює нескінченності), 1 - якщо M<sub>1</sub> (тобто вершина знаходиться в черзі), і 2 - якщо M<sub>0</sub> (деякий шлях вже був знайдений, відстань менше нескінченності).

Чергу обробки можна реалізувати за допомогою стандартної структури даних deque. Однак, є більш ефективний спосіб. По-перше, очевидно, що черга буде зберігати максимум N елементів у будь-який момент часу. А по-друге, ми можемо додавати елементи як до початку, так і до кінця черги. Отже, ми можемо організувати чергу на масиві розміру N, але потрібно зациклити його. Тобто, створюємо масив Q[1..N] і вказівники (int) на перший елемент QH та на елемент після останнього QT. Черга порожня, коли QH == QT. Додавання в кінець - це просто запис в Q[QT] і збільшення QT на 1; якщо QT після цього виходить за межі черги (QT == N), то робимо QT = 0. Додавання в початок черги - зменшуємо QH на 1, якщо вона виходить за межі черги (QH == -1), то робимо QH = N-1.

Ми реалізуємо сам алгоритм точно за описом вище.

## Асимптотика

Мені не відома більш-менш точна асимптотична оцінка цього алгоритму. Я зустрічав лише оцінку O(NM) для схожого алгоритму.

Однак на практиці алгоритм зарекомендував собі дуже добре: час його роботи я оцінюю як **O(M log N)**, хоча, повторююся, це виключно **експериментальна** оцінка.

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
typedef pair<int, int> rib;
typedef vector<vector<rib>> graph;

const int inf = 1000 * 1000 * 1000;

int main() {
    int n, v1, v2;
    graph g(n);

...читання графу...

        vector<int>
            d(n, inf);
    d[v1] = 0;
    vector<int> id(n);
    deque<int> q;
    q.push_back(v1);
    vector<int> p(n, -1);

    while (!q.empty()) {
        int v = q.front(), q.pop_front();
        id[v] = 1;
        for (size_t i = 0; i < g[v].size(); ++i) {
            int to = g[v][i].first, len = g[v][i].second;
            if (d[to] > d[v] + len) {
                d[to] = d[v] + len;
                if (id[to] == 0)
                    q.push_back(to);
                else if (id[to] == 1)
                    q.push_front(to);
                p[to] = v;
                id[to] = 1;
            }
        }
    }

...висновок щодо результату...
}
```