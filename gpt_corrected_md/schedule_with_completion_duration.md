# Оптимальний вибір завдань при відомих часах завершення та тривалостях виконання

Нехай задано набір завдань, у кожного з яких відомий момент часу, до якого це завдання потрібно завершити, та тривалість виконання. Процес виконання будь-якого завдання не можна переривати до його завершення. Потрібно скласти такий розклад, щоб виконати найбільшу кількість завдань.

## Розв'язок

Алгоритм розв'язку - **жадібний**. Відсортуємо всі завдання за їх крайнім терміном та будемо розглядати їх по черзі в порядку зменшення крайнього терміну. Також створимо чергу $q$, в яку ми будемо поступово поміщати завдання, і витягувати з черги завдання з найменшим часом виконання (наприклад, можна використовувати set або priority_queue). Спочатку $q$ є порожньою.

Нехай ми розглядаємо $i$-те завдання. Спочатку помістимо його в $q$. Розглянемо відрізок часу між сроком завершення $i$-го завдання та сроком завершення $(i-1)$-го завдання - це відрізок довжини $T$. Будемо витягувати з $q$ завдання (в порядку збільшення часу їх виконання, що залишився) та поміщати їх на виконання в цьому відрізку, доки не заповнимо весь відрізок $T$. Важливий момент - якщо в якийсь момент часу чергове витягнуте зі структури завдання можна встигнути частково виконати протягом відрізка $T$, то ми виконуємо це завдання частково - саме настільки, наскільки це можливо, тобто протягом $T$ одиниць часу, а залишок завдання повертаємо назад в $q$.

Після завершення цього алгоритму ми оберемо оптимальний розв'язок (або, в крайньому випадку, одне з кількох рішень). Асимптотика розв'язку - $O(n \log n)$.

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
int n;
вектор пар <int, int> a; // завдання у вигляді пар (крайній термін, тривалість)
...читання чисел n і a...

    sort(a.begin(), a.end());

typedef set<pair<int, int>> t_s;
t_s s;
vector<int> result;
for (int i = n - 1; i >= 0; --i) {
    int t = a[i].first - (i ? a[i - 1].first : 0);
    s.insert(make_pair(a[i].second, i));
    while (t && !s.empty()) {
        t_s::iterator it = s.begin();
        if (it->first <= t) {
            t -= it->first;
            result.push_back(it->second);
        } else {
            s.insert(make_pair(it->first - t, it->second));
            t = 0;
        }
        s.erase(it);
    }
}

for (size_t i = 0; i < result.size(); ++i)
    cout << result[i] << ' ';
```