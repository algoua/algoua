# Знаходження найкоротших шляхів від заданої вершини до всіх інших вершин у розріджених графах можна здійснити за допомогою алгоритму Дейкстри

Постановку задачі, алгоритм і його доведення див. у [статті про алгоритм Дейкстри](dijkstra), що стосується загального випадку.

## Алгоритм

Нагадаємо, що складність алгоритму Дейкстри складається з двох основних операцій: час знаходження вершини з найменшою відстанню $d[v]$, і час здійснення релаксації, тобто час зміни величини $d[to]$.

При найпростішій реалізації цих операцій потрібно відповідно $O(n)$ та $O(1)$ часу. Зважаючи на те, що перша операція виконується всього $O(n)$ разів, а друга - $O(m)$, отримуємо асимптотику найпростішої реалізації алгоритму Дейкстри: $O(n^2+m)$.

Зрозуміло, що ця асимптотика є оптимальною для щільних графів, тобто коли $m \approx n^2$. Чим рідше граф (тобто менше $m$ порівняно з максимальною кількістю ребер $n^2$), тим менш оптимальною стає ця оцінка, особливо через перший доданок. Таким чином, потрібно покращувати час виконання операцій першого типу, не дуже погіршуючи час виконання операцій іншого типу.

Для цього потрібно використовувати різні допоміжні структури даних. Найбільш привабливими є **Фібоначчіві купи**, які дозволяють виконувати операцію першого взяття за $O(\log n)$, а іншого - за $O(1)$. Тому при використанні Фібоначчівих куп час роботи алгоритму Дейкстри складає $O(n \log n + m)$, що є практично теоретичним мінімумом для алгоритму пошуку найкоротшого шляху. До речі, ця оцінка є оптимальною для алгоритмів, що базуються на алгоритмі Дейкстри, тобто Фібоначчіві купи є оптимальними з цієї точки зору (це твердження про оптимальність насправді базується на неможливості існування такої "ідеальної" структури даних - якби вона існувала, то можна було б виконувати сортування за лінійний час, що, як відомо, загалом неможливо; проте цікаво, що існує алгоритм Торупа (Thorup), який шукає найкоротший шлях з оптимальною, лінійною, асимптотикою, але він базується на зовсім іншій ідеї, ніж алгоритм Дейкстри, тому тут немає протиріччя). Однак Фібоначчіві купи досить складні у реалізації (і, слід відзначити, мають немалу константу, яка прихована в асимптотиці).

В якості компромісу можна використовувати структури даних, які дозволяють виконувати **обидві операції** (фактично, це вилучення мінімуму та оновлення елементу) за $O(\log n)$. Отже, час роботи алгоритму Дейкстри складе:

$$
O(n \log n + m \log n) = O (m \log n)
$$

В якості такої структури даних програмістам на C++ зручно взяти стандартний контейнер $\rm set$ або $\rm priority\_queue$. Перший заснований на червоно-чорному дереві, другий - на бінарній купі. Тому $\rm priority\_queue$ має меншу константу, яка прихована в асимптотиці, проте у нього є й недолік: він не підтримує операцію видалення елементу, через що доводиться робити "обхідний маневр", який фактично призводить до заміни в асимптотиці $\log n$ на $\log m$ (з точки зору асимптотики це насправді нічого не змінює, але збільшує приховану константу).

## Реалізація

### set

Почнемо з контейнера $\rm set$. Оскільки в контейнері нам потрібно зберігати вершини, впорядковані за їхніми значеннями $d[]$, то зручно в контейнер помістити пари: перший елемент пари - відстань, а другий - номер вершини. В результаті в $\rm set$ будуть зберігатися пари, автоматично впорядковані за відстанями, що нам і потрібно.

<!--- TODO: specify code snippet id -->
``` cpp
const int INF = 1000000000;

int main() {
    int n;
    ... читання n... vector<vector<pair<int, int>>> g(n);
... читання графу... int s = ...; // стартова вершина

    vector<int> d(n, INF), p(n);
    d[s] = 0;
    set<pair<int, int>> q;
    q.insert(make_pair(d[s], s));
    while (!q.empty()) {
        int v = q.begin()->second;
        q.erase(q.begin());

        for (size_t j = 0; j < g[v].size(); ++j) {
            int to = g[v][j].first, len = g[v][j].second;
            if (d[v] + len < d[to]) {
                q.erase(make_pair(d[to], to));
                d[to] = d[v] + len;
                p[to] = v;
                q.insert(make_pair(d[to], to));
            }
        }
    }
}
```

У відміну від звичайного алгоритму Дейкстри, не потрібний масив $u[]$. Його роль, так само як і функцію знаходження вершини з найменшою відстанню, виконує $\rm set$. Спочатку до нього додається стартова вершина $s$ з її відстанню. Основний цикл алгоритму виконується, поки в черзі є хоча б одна вершина. З черги вилучається вершина з найменшою відстанню, і потім з неї виконуються релаксації. Перед виконанням кожної успішної релаксації ми спочатку видаляємо з $\rm set$ стару пару, а потім, після виконання релаксації, додаємо назад нову пару (з новою відстанню $d[to]$).

### priority_queue

Принципіально тут немає відмінностей від $\rm set$, окрім того, що видалення довільних елементів з $\rm priority\_queue$ неможливе (хоча теоретично купи підтримують таку операцію, у стандартній бібліотеці вона не реалізована). Тому доводиться здійснювати "обхідний маневр": при релаксації просто не будемо видаляти старі пари з черги. В результаті в черзі можуть перебувати одночасно декілька пар для однієї і тієї ж вершини (але з різними відстанями). Серед цих пар нас цікавить тільки одна, для якої елемент $\rm first$ дорівнює $d[v]$, а всі інші є фіктивними. Тому треба зробити невелику модифікацію: на початку кожної ітерації, коли ми вилучаємо з черги наступну пару, будемо перевіряти, чи є вона фіктивною чи ні (для цього достатньо порівняти $\rm first$ і $d[v]$). Слід зазначити, що це важлива модифікація: якщо її не зробити, то це призведе до значного погіршення асимптотики (до $O(nm)$).

Ще потрібно пам'ятати про те, що $\rm priority\_queue$ упорядковує елементи за спаданням, а не за зростанням, як зазвичай. Найпростіше подолати цю особливість, не вказуючи свій оператор порівняння, а просто поміщаючи в якості елементів $\rm first$ відстані зі знаком мінус. В результаті в корені купи будуть елементи з найменшою відстанню, що нам і потрібно.

<!--- TODO: specify code snippet id -->
``` cpp
const int INF = 1000000000;

int main() {
    int n;
    ... читання n... vector<vector<pair<int, int>>> g(n);
... читання графу... int s = ...; // стартова вершина

    vector<int> d(n, INF), p(n);
    d[s] = 0;
    priority_queue<pair<int, int>> q;
    q.push(make_pair(0, s));
    while (!q.empty()) {
        int v = q.top().second, cur_d = -q.top().first;
        q.pop();
        if (cur_d > d[v])
            continue;

        for (size_t j = 0; j < g[v].size(); ++j) {
            int to = g[v][j].first, len = g[v][j].second;
            if (d[v] + len < d[to]) {
                d[to] = d[v] + len;
                p[to] = v;
                q.push(make_pair(-d[to], to));
            }
        }
    }
}
```

Як правило, на практиці версія з $\rm priority\_queue$ виявляється дещо швидшою, ніж версія з $\rm set$.

### Позбавлення від пари

Можна ще трохи покращити продуктивність, якщо в контейнерах зберігати не пари, а тільки номера вершин. При цьому, зрозуміло, треба перевизначити оператор порівняння для вершин: порівнювати дві вершини треба за відстанню до них $d[]$.

Оскільки під час релаксації відстань до деякої вершини змінюється, потрібно розуміти, що сама структура даних не перебудується. Тому, хоча може здатися, що в процесі релаксації не потрібно додавати або видаляти елементи з контейнера, це може призвести до руйнування структури даних. Як і раніше, перед релаксацією потрібно видалити вершину $\rm to$ зі структури даних, а після релаксації вставити її назад - тоді жодні зв'язки між елементами структури даних не будуть порушені.

А оскільки видаляти елементи можна зі $\rm set$, але не можна з $\rm priority\_queue$, то виходить, що цей прийом застосовуємо тільки до $\rm set$. На практиці він помітно збільшує продуктивність, особливо коли для зберігання відстаней використовуються великі типи даних (як $\rm long\ long$ або $\rm double$).