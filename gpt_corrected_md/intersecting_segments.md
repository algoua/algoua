# Пошук пари перетинних відрізків алгоритмом замітної прямої за O(N log N)

Дано $n$ відрізків на площині. Потрібно перевірити, чи перетинаються хоча б два з них. Якщо відповідь позитивна, то потрібно вивести ці відрізки. (Якщо є декілька відповідей, можна вивести будь-яку з них.)

Наївний алгоритм розв'язку полягає у переборі за $O(n^2)$ всіх пар відрізків та перевірці для кожної пари, чи перетинаються вони. У цій статті описується алгоритм з часом роботи $O(n \log n)$, що ґрунтується на принципі **скануючої (заметающої) прямої** (англ. "sweep line").

## Алгоритм

Подумки проведемо вертикальну пряму $x = -\infty$ і почнемо рухати цю пряму вправо. Під час руху ця пряма зустрічатиметься з відрізками, причому в будь-який момент часу кожен відрізок буде перетинатися з нашою прямою у одній точці (ми поки що будемо вважати, що немає вертикальних відрізків).

\img{sweep_line_1.png}

Таким чином, для кожного відрізку в певний момент часу його кінцева точка з'явиться на скануючій прямій, потім разом з рухом прямої будуть рухатися як ця точка, так і початкова точка відрізка, і, нарешті, в якийсь момент відрізок зникне з прямої.

Нас цікавить **відносний порядок відрізків** за вертикалою. Зокрема, ми будемо зберігати список відрізків, які перетинають скануючу пряму в даний момент часу, де відрізки будуть відсортовані за їх $y$-координатою на скануючій прямій.

\img{sweep_line_2.png}

Цей порядок цікавий тим, що середні відрізки матимуть однакову координату $y$ принаймні в один момент часу:

\img{sweep_line_3.png}

Сформулюймо ключові твердження:

* Для пошуку перетину пари достатньо розглядати при кожному фіксованому положенні скануючої прямої **лише сусідні відрізки**.

* Досить розглядати скануючу пряму не в усіх можливих дійсних позиціях $(-\infty \ldots +\infty)$, а **лише в тих позиціях, коли з'являються нові відрізки або зникають старі**. Іншими словами, достатньо обмежитися лише позиціями, рівними абсцисам точок-кінців відрізків.

* При появі нового відрізка достатньо **вставити** його на потрібне місце у список, отриманий для попередньої скануючої прямої. Перевіряти на перетин потрібно **лише додаваний відрізок з його безпосередніми сусідами у списку зверху і знизу**.

* При зникненні відступу достатньо **видалити** його з поточного списку. Після цього треба **перевірити на перетин з попереднім та наступним елементами** в списку.

* Інших змін у порядку слідування відрізків у списку, окрім описаних, не існує. Інших перевірок на перетин не потрібно виконувати.

Для розуміння правильності цих тверджень достатньо наступних зауважень:

* Дві відрізки, що не перетинаються, ніколи не змінюють свого **відносного порядку**.

Насправді, якщо один відрізок спочатку перебував вище за інший, а потім опустився нижче, то між цими двома моментами відбувся перетин цих двох відрізків.

* Два відрізки з однаковими $y$-координатами, які не перетинаються, також не можуть мати спільних точок.

* З цього випливає, що в момент появи відправлення ми можемо знайти в чергах позицію для цього відправлення, і більше цей відрізок переставлять в чергах не доведеться: його **порядок щодо інших відрізків в чергах змінюватися не буде**.

* Дві перетинутих відрізка в момент їх перетину стануть сусідами один одного в черзі.

* Отже, для знаходження пари пересічних відрізків достатньо перевірити на перетин всі ті пари відрізків, які коли-небудь за час руху скануючої прямої були сусідніми.

Легко помітити, що достатньо перевіряти лише вставлений відрізок з його верхнім та нижнім сусідами, а також при видаленні відрізку - його верхнього та нижнього сусідів (які після видалення стануть сусідами один для одного).

* Слід звернути увагу, що при фіксованому положенні скануючої прямої ми **спочатку** повинні провести **додавання** всіх з'являються тут відрізків, і лише **після цього** - **видалення** всіх зникнутих тут відрізків.

Тим самим, ми уникнемо перетину відрізків у вершині: тобто такі випадки, коли два відрізки мають спільну точку.

* Зауважимо, що **вертикальні відрізки** насправді ніяк не впливають на правильність алгоритму.

Ці відрізки виділяються тим, що вони з'являються і зникають в один і той же момент часу. Однак, з урахуванням попереднього зауваження, ми знаємо, що спочатку всі відрізки будуть додані до черги, а потім видалені. Тому якщо вертикальний відрізок перетинається з якимось іншим відкритим у цей момент відрізком (в тому числі вертикальним), то це буде виявлено.

У яке місце черги потрібно поміщати вертикальні відрізки? Ведь вертикальний відрізок не має однієї певної $y$-координати, він простягається на цілий відрізок по $y$-координаті. Однак легко зрозуміти, що як $y$-координату можна взяти будь-яку координату з цього відрізку.

Таким чином, весь алгоритм здійснює не більше $2n$ тестів на перетин пари відрізків та виконує $O(n)$ операцій з чергою відрізків (за $O(1)$ операцій в моменти появи та зникнення кожного відрізку).

Підсумкова **асимптотика** алгоритму становить $O(n \log n)$.

## Реалізація

Наведемо повну реалізацію описаного алгоритму:

<!--- TODO: specify code snippet id -->
``` cpp
const double EPS = 1E-9;

struct pt {
    double x, y;
};

struct seg {
    pt p, q;
    int id;

    double get_y(double x) const {
        if (abs(p.x - q.x) < EPS)
            return p.y;
        return p.y + (q.y - p.y) * (x - p.x) / (q.x - p.x);
    }
};

inline bool intersect1d(double l1, double r1, double l2, double r2) {
    if (l1 > r1)
        swap(l1, r1);
    if (l2 > r2)
        swap(l2, r2);
    return max(l1, l2) <= min(r1, r2) + EPS;
}

inline int vec(const pt &a, const pt &b, const pt &c) {
    double s = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
    return abs(s) < EPS ? 0 : s > 0 ? +1 : -1;
}

bool intersect(const seg &a, const seg &b) { return intersect1d(a.p.x, a.q.x, b.p.x, b.q.x) && intersect1d(a.p.y, a.q.y, b.p.y, b.q.y) && vec(a.p, a.q, b.p) * vec(a.p, a.q, b.q) <= 0 && vec(b.p, b.q, a.p) * vec(b.p, b.q, a.q) <= 0; }

bool operator<(const seg &a, const seg &b) {
    double x = max(min(a.p.x, a.q.x), min(b.p.x, b.q.x));
    return a.get_y(x) < b.get_y(x) - EPS;
}

struct event {
    double x;
    int tp, id;

    event() {}
    event(double x, int tp, int id) : x(x), tp(tp), id(id) {}

    bool operator<(const event &e) const {
        if (abs(x - e.x) > EPS)
            return x < e.x;
        return tp > e.tp;
    }
};

set<seg> s;
vector<set<seg>::iterator> where;

inline set<seg>::iterator prev(set<seg>::iterator it) { return it == s.begin() ? s.end() : --it; }

inline set<seg>::iterator next(set<seg>::iterator it) { return ++it; }

pair<int, int> solve(const vector<seg> &a) {
    int n = (int)a.size();
    vector<event> e;
    for (int i = 0; i < n; ++i) {
        e.push_back(event(min(a[i].p.x, a[i].q.x), +1, i));
        e.push_back(event(max(a[i].p.x, a[i].q.x), -1, i));
    }
    sort(e.begin(), e.end());

    s.clear();
    where.resize(a.size());
    for (size_t i = 0; i < e.size(); ++i) {
        int id = e[i].id;
        if (e[i].tp == +1) {
            set<seg>::iterator nxt = s.lower_bound(a[id]), prv = prev(nxt);
            if (nxt != s.end() && intersect(*nxt, a[id]))
                return make_pair(nxt->id, id);
            if (prv != s.end() && intersect(*prv, a[id]))
                return make_pair(prv->id, id);
            where[id] = s.insert(nxt, a[id]);
        } else {
            set<seg>::iterator nxt = next(where[id]), prv = prev(where[id]);
            if (nxt != s.end() && prv != s.end() && intersect(*nxt, *prv))
                return make_pair(prv->id, nxt->id);
            s.erase(where[id]);
        }
    }

    return make_pair(-1, -1);
}
```

Основна функція тут - $\mathrm{solve()}$, яка повертає номери знайдених перетинних відрізків, або $(-1, -1)$, якщо перетину немає.

Перевірка на перетин двох відрізків здійснюється функцією $\rm intersect()$, за допомогою [алгоритму на основі орієнтованої площі трикутника](segments_intersection_checking).

Черга відрізків зберігається в глобальній змінній $s$ типу $\rm set<event>$. Ітератори, що вказують на положення кожного відрізку у черзі (для зручного видалення відрізків з черги), зберігаються в глобальному масиві $\rm where$. Російське слово "становище" краще замінити на слово "положення".

Введено також дві допоміжні функції $\rm prev()$ і $\rm next()$, які повертають ітератори на попередній і наступний елементи (або $\rm end()$, якщо такого не існує).

Константа $\rm EPS$ позначає похибку порівняння двох дійсних чисел (зазвичай вона використовується при перевірці перетину двох відрізків).