# Перевірка графа на двудольність та його розбиття на дві частини

Нехай задано неорієнтований граф. Потрібно перевірити, чи є він двудольним, тобто чи можна розбити його вершини на дві частини так, щоб кожне ребро мало кінці в різних частиних. Якщо граф є двудольним, то вивести самі частини.

Вирішимо цю задачу з допомогою [пошуку в ширину](bfs) за O (M).

## Признак двудольності

Теорема. Граф є двудольним тоді і лише тоді, коли всі його прості цикли мають парну довжину.

Проте з практичної точки зору пошуку всіх простих циклів це не дуже зручно. Набагато простіше перевіряти граф на двудольність за допомогою наступного алгоритму:

## Алгоритм

Зробимо серію пошуків у ширину. Тобто, будемо запускати пошук у ширину з кожної невідвіданої вершини. Ту вершину, з якої ми починаємо йти, ми поміщаємо в першу долю. У процесі пошуку у ширину, якщо ми йдемо в якусь нову вершину, то ми поміщаємо її в долю, відмінну від частки поточної вершини. Якщо ж ми намагаємося пройти по ребру до вершини, яку вже перевірили, то ми перевіряємо, чи знаходяться ці вершини в різних частках. У іншому випадку граф не є двудольним.

Після закінчення роботи алгоритму ми або виявимо, що граф не є двудольним, або знайдемо розбиття вершин графа на дві частини.

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
int n;
vector<vector<int>> g;
...читання графу...

    vector<char>
        part(n, -1);
bool ok = true;
vector<int> q(n);
for (int st = 0; st < n; ++st)
    if (part[st] == -1) {
        int h = 0, t = 0;
        q[t++] = st;
        part[st] = 0;
        while (h < t) {
            int v = q[h++];
            for (size_t i = 0; i < g[v].size(); ++i) {
                int to = g[v][i];
                if (part[to] == -1)
                    part[to] = !part[v], q[t++] = to;
                else
                    ok &= part[to] != part[v];
            }
        }
    }

puts(ok ? "YES" : "NO");
```