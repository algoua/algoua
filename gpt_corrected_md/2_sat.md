# Задача 2-SAT

Задача 2-SAT (2-задоволення) - це задача розподілу значень булевим змінним таким чином, щоб вони задовольняли всі накладені обмеження.

Задачу 2-SAT можна уявити у вигляді кон'юнктивної нормальної форми, де в кожному виразі у дужках повинно бути рівно дві змінні; така форма називається 2-CNF (2-кон'юнктивна нормальна форма). Наприклад:

$$
(a || c) && (a || !d) && (b || !d) && (b || !e) && (c || d)
$$

## Додатки

Алгоритм для розв'язування 2-SAT може бути застосований у всіх завданнях, де є набір величин, кожна з яких може приймати 2 можливі значення, і є зв'язок між цими величинами:

* Розташування текстових міток на мапі або діаграмі.
Мається на увазі знаходження такого розташування міток, при якому жодні дві не перетинаються.
Варто зазначити, що в загальному випадку, коли кожна мітка може займати кілька різних позицій, ми отримуємо задачу загального задоволення, яка є NP-повною. Однак, якщо обмежитися тільки двома можливими позиціями, то отримана задача буде задачею 2-SAT. Крім того, слід уникати використання російських слів та русизмів у тексті.
* Розташування ребер при малюванні графа.
Аналогічно до попереднього пункту, якщо обмежитися лише двома можливими способами провести ребро, то ми прийдемо до задачі 2-SAT.
* Складання розкладу ігор.
Є на увазі така система, коли кожна команда повинна зіграти з кожною по одному разу, а потрібно розподілити гри за типом господар-гість з деякими обмеженнями.
* і т.д. (без крапки в кінці)

## Алгоритм

Спочатку перетворимо задачу до імплікативної форми - так званої імплікаційної форми. Зауважимо, що вираз уваги a || b еквівалентний !a => b або !b => a. Це можна сприймати наступним чином: якщо є вираз a || b, і нам потрібно зробити його істинним, то, якщо a = false, то необхідно b = true, і навпаки, якщо b = false, то необхідно a = true.

Побудуємо тепер так званий **граф імплікацій**: для кожної змінної в графі буде по дві вершини, позначимо їх через x<sub>i</sub> та !x<sub>i</sub>. Ребра в графі будуть відповідати імплікативним зв'язкам.

Наприклад, для форми 2-КНФ:

$$
(a || b) && (b || !c)
$$

Граф імплікацій міститиме наступні ребра (орієнтовані):

$$
!a => b
!b => a
!b => !c
c => b
$$

Варто звернути увагу на таку властивість графа імплікації, що якщо є ребро a → b, то є і ребро ¬b → ¬a.

Тепер звернімо увагу на те, що якщо для змінної x виконується, що з x досяжно !x, а з !x досяжно x, то задача розв'язку неможлива. Дійсно, яке б значення для змінної x ми не вибирали, ми завжди прийдемо до протиріччя - що має бути вибрано і його протилежне значення. Виявляється, що ця умова є не тільки достатньою, але й необхідною (доказом цього факту буде описаний нижче алгоритм). Переформулюємо цей критерій в термінах теорії графів. Нагадаємо, що якщо з однієї вершини досяжна інша, а з тієї вершини досяжна перша, то ці дві вершини знаходяться в одній сильно зв'язній компоненті. Отже, ми можемо сформулювати **критерій існування розв'язку** наступним чином:

Для того, щоб дана задача 2-SAT **мала розв'язок**, необхідно і достатньо, щоб для будь-якої змінної x вершини x і !x знаходилися **в різних компонентах сильної зв'язності** графа імплікацій.

Цей критерій можна перевірити за час O(N + M) з допомогою [алгоритму пошуку сильно зв'язаних компонент](https://uk.wikipedia.org/wiki/Алгоритм_Косарайю).

Тепер побудуємо власний **алгоритм** знаходження розв'язку задачі 2-СНА в припущенні, що розв'язок існує.

Зауважимо, що незважаючи на те, що розв'язок існує, для деяких змінних можливо виконуватися умова, що з x досяжно !x, або (але не одночасно) з !x досяжно x. У такому випадку вибір одного зі значень змінної x призведе до протиріччя, тоді як вибір іншого - ні. Навчимося вибирати з двох значень те, яке не призводить до виникнення протиріч. Відразу зауважимо, що після вибору якогось значення, потрібно запустити з нього обхід в глибину/ширину і позначити всі значення, які слідують з нього, тобто досяжні в графі імплікацій. Для вже позначених вершин не потрібно робити жодного вибору між x і !x, оскільки для них значення вже вибрано і зафіксовано. Описане правило застосовується тільки до непозначених вершин.

Стверджується, що comp[v] відповідає номеру компоненти сильної зв'язності, до якої належить вершина v. При цьому, номера впорядковані в порядку топологічного сортування компонент сильної зв'язності в графі компонентів. Іншими словами, більш ранній компоненті в порядку топологічного сортування відповідає більший номер. Якщо існує шлях з вершини v до вершини w, то comp[v] <= comp[w]. Таким чином, якщо comp[x] < comp[!x], то вибирається значення !x. У випадку, якщо comp[x] > comp[!x], то вибирається x.

Доведемо, що при такому виборі значень ми не потрапимо у протиріччя. Нехай, для визначеності, обрана вершина x (у випадку, коли обрана вершина !x, доведеться симетрично).

По-перше, доведемо, що з x не досяжно !x. Дійсно, так як номер компоненти сильної зв'язності comp[x] більший за номер компоненти comp[!x], то це означає, що компонента зв'язності, що містить x, розташована лівіше компоненти зв'язності, що містить !x, і з першою ніяк не можливо бути досяжна останню.

По-друге, доведемо, що жодна вершина y, досяжна з x, не є "поганою", тобто невірно, що з y досяжно !y. Доведемо це від протилежного. Припустимо, що з x досяжна y, а з y досяжна !y. Оскільки з x досяжна y, то, згідно з властивістю графа імплікацій, з !y буде досяжна !x. Проте, згідно з припущенням, з y досяжна !y. Отже, ми отримуємо, що з x досяжна !x, що суперечить умові, яку потрібно довести.

Отже, ми побудували алгоритм, який знаходить шукані значення змінних за умови, що для будь-якої змінної x вершини x і !x знаходяться в різних компонентах сильної зв'язності. Вище ми продемонстрували коректність цього алгоритму. Отже, ми одночасно довели зазначений вище критерій існування розв'язку.

Тепер ми можемо зібрати **весь алгоритм** разом:

* Побудуємо граф імплікацій.
* Знайдемо в цьому графі компоненти сильної зв'язності за час O(N + M), нехай comp[v] - це номер компоненти сильної зв'язності, до якої належить вершина v.
* Перевіримо, чи для кожної змінної x вершини x і !x лежать в різних компонентах, тобто comp[x] ≠ comp[!x]. Якщо ця умова не виконується, то повернути "розв'язок не існує".
* Якщо comp[x] більше, ніж comp[!x], то змінній x присвоюється значення true, в іншому випадку - false.

## Реалізація

Нижче наведено реалізацію розв'язку задачі 2-SAT для вже побудованого графу імплікацій g і зворотнього йому графу gt (тобто в якому напрямок кожного ребра змінено на протилежний).

Програма виводить номери обраних вершин або фразу "НЕМА РІШЕННЯ", якщо розв'язку не існує.

<!--- TODO: specify code snippet id -->
``` cpp
int n;
vector<vector<int>> g, gt;
vector<bool> used;
vector<int> order, comp;

void dfs1(int v) {
    used[v] = true;
    for (size_t i = 0; i < g[v].size(); ++i) {
        int to = g[v][i];
        if (!used[to])
            dfs1(to);
    }
    order.push_back(v);
}

void dfs2(int v, int cl) {
    comp[v] = cl;
    for (size_t i = 0; i < gt[v].size(); ++i) {
        int to = gt[v][i];
        if (comp[to] == -1)
            dfs2(to, cl);
    }
}

int main() {
... читання n, графу g,
Побудова графа $G_t$...

        used.assign(n, false);
    for (int i = 0; i < n; ++i)
        if (!used[i])
            dfs1(i);

    comp.assign(n, -1);
    for (int i = 0, j = 0; i < n; ++i) {
        int v = order[n - i - 1];
        if (comp[v] == -1)
            dfs2(v, j++);
    }

    for (int i = 0; i < n; ++i)
        if (comp[i] == comp[i ^ 1]) {
            puts("NO SOLUTION");
            return 0;
        }
    for (int i = 0; i < n; ++i) {
        int ans = comp[i] > comp[i ^ 1] ? i : i ^ 1;
        printf("%d ", ans);
    }
}
```