# Знаходження пари найближчих точок

## Постановка завдання

Дано $n$ точок $p_i$ на площині, заданих своїми координатами $(x_i,y_i)$. Потрібно знайти дві такі точки серед них, відстань між якими є мінімальною

$$
\min_{\scriptstyle i,j=0 \ldots n-1, \atop \scriptstyle i \ne j} \rho (p_i,p_j).
$$

Розстояння ми беремо звичайні євклідові:

$$
\rho(p_i,p_j) = \sqrt{ (x_i-x_j)^2 + (y_i-y_j)^2 }.
$$

Тривіальний алгоритм - перебір усіх пар і обчислення відстані для кожної - працює за $O(n^2)$. Нижче описується алгоритм, який працює за час $O(n \log n)$. Цей алгоритм був запропонований Препаратою (Preparata) в 1975 році. Препарата і Шамос також показали, що в моделі дерева рішень цей алгоритм є асимптотично оптимальним.

## Алгоритм

Побудуємо алгоритм за загальною схемою алгоритмів **"розділяй і володарюй"**: алгоритм оформляємо у вигляді рекурсивної функції, якій передається множина точок. Ця рекурсивна функція розбиває цю множину навпіл, викликає собі рекурсивно від кожної половини, а потім виконує деякі операції з об'єднання відповідей. Операція об'єднання полягає в тому, щоб знайти випадки, коли одна точка оптимального розв'язку потрапила в одну половину, а інша точка - в іншу (у цьому випадку рекурсивні виклики від кожної з половинок окремо знайти цю пару, звісно, не зможуть). Основна складність, як завжди, полягає в ефективній реалізації цієї стадії об'єднання. Якщо рекурсивній функції передається множина з $n$ точок, то стадія об'єднання повинна працювати не більше, ніж $O(n)$, тоді асимптотика всього алгоритму $T(n)$ буде мати рівняння:

$$
T(n) = 2 T(n/2) + O(n).
$$

Розв'язанням цього рівняння, як відомо, є $T(n) = O(n \log n)$.

Отже, перейдемо до побудови алгоритму. Щоб у майбутньому досягти ефективної реалізації стадії злиття, множину точок будемо розбивати на дві підмножини згідно їх $x$-координат: фактично ми проводимо вертикальну пряму, яка розбиває множину точок на дві приблизно рівні частини. Таке розбиття можна провести наступним чином: відсортуємо точки стандартним чином як пари чисел, тобто:

$$
p_i < p_j \Longleftrightarrow (x_i < x_j) \lor \Bigl( (x_i = x_j) \land (y_i < y_j) \Bigr).
$$

Значить, візьмемо середню точку $p_m$ після сортування ($m = \lfloor n/2 \rfloor$), і всі точки до неї, включаючи $p_m$, віднесемо до першої половини, а всі точки після неї - до другої половини

$$
A_1 = \{ p_i\ |\ i = 0 \ldots m \},
$$

$$
A_2 = \{ p_i\ |\ i = m+1 \ldots n-1 \}.
$$

Тепер, запустивши рекурсивно для кожної з множин $A_1$ і $A_2$, ми знайдемо відповіді $h_1$ і $h_2$ для кожної з половинок. Візьмемо кращий з них: $h = \min(h_1, h_2)$.

Тепер нам потрібно провести **етап об'єднання**, тобто спробувати виявити такі пари точок, відстань між якими менше $h$, причому одна точка лежить в $A_1$, а інша - в $A_2$. Очевидно, що для цього достатньо розглядати тільки ті точки, які знаходяться від вертикальної прямої розділу на відстань, менше $h$, тобто множина $B$ розглянутих на цьому етапі точок дорівнює:

$$
B = \{ p_i\ |\ | x_i - x_m | < h \}.
$$

Для кожної точки з множини $B$ потрібно спробувати знайти точки, які знаходяться до неї ближче, ніж $h$. Наприклад, достатньо розглядати лише ті точки, у яких координата $y$ відрізняється не більше ніж на $h$. Крім того, не має сенсу розглядати ті точки, у яких $y$-координата більша за $y$-координату поточної точки. Таким чином, для кожної точки $p_i$ визначимо множину розглянутих точок $C(p_i)$ наступним чином:

$$
C(p_i) = \{ p_j\ |\ p_j \in B,\ \ y_i - h < y_j \le y_i \}.
$$

Якщо ми відсортуємо точки множини $B$ за $y$-координатою, то знаходження $C(p_i)$ буде дуже легко: це декілька точок поспіль перед точкою $p_i$.

Отже, у нових позначеннях **стадія об'єднання** виглядає наступним чином: будуємо множину $B$, сортуємо в ній точки за $y$-координатою, потім для кожної точки $p_i \in B$ розглядаємо всі точки $p_j \in C(p_i)$, і для кожної пари $(p_i,p_j)$ розраховуємо відстань і порівнюємо з поточним найкращим значенням відстані.

На перший погляд, це, як і раніше, неоптимальний алгоритм: здається, що розміри множин $C(p_i)$ будуть порядку $n$, і необхідна асимптотика ніяк не вийде. Однак, як це не дивно, можна довести, що розмір кожного з множин $C(p_i)$ є величина $O(1)$, тобто не перевищує деякої малої константи поза залежністю від самих точок. Доведення цього факту наведено в наступному розділі.

Нарешті, звернемо увагу на сортування, які містить описаний алгоритм. Є два види сортування: перше - за парами ($x$,$y$), друге - за $y$ для елементів множини $B$. Насправді, обидва ці сортування можна позбутися всередині рекурсивної функції (інакше б не досягли оцінки $O(n)$ для стадії злиття, і загальна складність алгоритму була б $O(n \log^2 n)$). Від першого сортування можна легко позбутися - достатньо виконати його перед запуском рекурсії, адже всередині рекурсії елементи не змінюються. Тому немає необхідності виконувати сортування заново. Друге сортування трохи складніше, його не можна виконати перед рекурсією. Але можна використати сортування злиттям (merge sort), яке також працює за принципом "розділяй і володарюй". Можна просто вбудувати це сортування в нашу рекурсію. Нехай рекурсія приймає множину точок (упорядковану за парами $(x,y)$) і повертає цю ж множину, але вже відсортовану за координатою $y$. Для цього достатньо просто злити (за $O(n)$) два результати, які повернулися з рекурсивних викликів. Таким чином, отримаємо множину, відсортовану за $y$.

## Оцінка асимптотики

Щоб показати, що вищеописаний алгоритм дійсно виконується за $O(n \log n)$, мені залишилося довести наступний факт: $|C(p_i)| = O(1)$.

Отже, нехай ми розглядаємо деяку точку $p_i$; нагадаємо, що множина $C(p_i)$ - це множина точок, $y$-координата яких лежить в відрізку $[y_i-h; y_i]$, а крім того, за координатою $x$ сама точка $p_i$, і всі точки множини $C(p_i)$ лежать в полосі шириною $2h$. Іншими словами, розглянуті нами точки $p_i$ і $C(p_i)$ лежать в прямокутнику розміру $2h \times h$.

Наше завдання - оцінити максимальну кількість точок, яка може лежати в цьому прямокутнику розміром $2h \times h$; таким чином, ми також оцінимо максимальний розмір множини $C(p_i)$. При оцінці потрібно пам'ятати, що можуть зустрічатися повторювані точки. Крім того, текст може містити російські слова, які потрібно замінити на українські.

Згадаймо, що $h$ визначалося як мінімум з двох результатів рекурсивних викликів - від множин $A_1$ і $A_2$, причому $A_1$ містить точки ліворуч від лінії розділу і частково на ній, а $A_2$ - залишилися точки праворуч від лінії розділу і точки на ній. Для будь-якої пари точок з $A_1$, такої ж як і з $A_2$, відстань не може бути меншою за $h$ - інакше це означало б некоректність роботи рекурсивної функції.

Для оцінки максимальної кількості точок в прямокутнику $2h \times h$ розіб'ємо його на два квадрати $h \times h$. До першого квадрату віднесемо всі точки $C(p_i)$, що належать до $A_1$, а до другого - всі інші, тобто $C(p_i)$, що належать до $A_2$. З приведених вище міркувань випливає, що в кожному з цих квадратів відстань між будь-якими двома точками не менше $h$.

Покажемо, що в кожному квадраті **не більше ніж чотири** точки. Наприклад, це можна зробити наступним чином: розіб'ємо квадрат на 4 підквадрати зі сторонами $h/2$. Отже, в кожному з цих підквадратів не може бути більше ніж одна точка (т.до. навіть діагональ рівна $h / \sqrt{2}$, що менше $h$). Отже, у всьому квадраті не може бути більше ніж 4 точки.

Отже, ми довели, що в прямокутнику $2h \times h$ не може бути більше $4 \cdot 2 = 8$ точок, отже, розмір множини $C(p_i)$ не може перевищувати $7$, що потрібно довести.

## Реалізація

Введемо структуру даних для зберігання точки (її координат та якийсь номер) та оператори порівняння, необхідні для двох видів сортування:

<!--- TODO: specify code snippet id -->
``` cpp
struct pt {
    int x, y, id;
};

inline bool cmp_x(const pt &a, const pt &b) { return a.x < b.x || a.x == b.x && a.y < b.y; }

inline bool cmp_y(const pt &a, const pt &b) { return a.y < b.y; }

pt a[MAXN];
```

Для зручної реалізації рекурсії введемо допоміжну функцію $upd\_ans()$, яка буде обчислювати відстань між двома точками і перевіряти, чи не краще вона поточної відповіді:

<!--- TODO: specify code snippet id -->
``` cpp
double mindist;
int ansa, ansb;

inline void upd_ans(const pt &a, const pt &b) {
    double dist = sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) + .0);
    if (dist < mindist)
        mindist = dist, ansa = a.id, ansb = b.id;
}
```

Нарешті, реалізація самої рекурсії. Передбачається, що перед її викликом масив $a[]$ вже відсортований за $x$-координатою. Рекурсії передається просто два вказівника $l$ та $r$, які вказують, що вона повинна шукати відповідь для $a[l \ldots r]$. Якщо відстань між $r$ та $l$ занадто мала, то рекурсію треба зупинити, виконати тривіальний алгоритм пошуку найближчої пари, а потім відсортувати підмасив за $y$-координатою.

Для об'єднання двох множин точок, отриманих від рекурсивних викликів, у одну (упорядковану за $y$-координатою), ми використовуємо стандартну функцію STL $merge()$ та створюємо допоміжний буфер $t[]$ (один на всі рекурсивні виклики). (Використання $inplace\_merge()$ недоцільне, оскільки вона загалом працює не за лінійний час).

Нарешті, множина $B$ зберігається в тому ж масиві $t$.

<!--- TODO: specify code snippet id -->
``` cpp
void rec(int l, int r) {
    if (r - l <= 3) {
        for (int i = l; i <= r; ++i)
            for (int j = i + 1; j <= r; ++j)
                upd_ans(a[i], a[j]);
        sort(a + l, a + r + 1, &cmp_y);
        return;
    }

    int m = (l + r) >> 1;
    int midx = a[m].x;
    rec(l, m), rec(m + 1, r);
    static pt t[MAXN];
    merge(a + l, a + m + 1, a + m + 1, a + r + 1, t, &cmp_y);
    copy(t, t + r - l + 1, a + l);

    int tsz = 0;
    for (int i = l; i <= r; ++i)
        if (abs(a[i].x - midx) < mindist) {
            for (int j = tsz - 1; j >= 0 && a[i].y - t[j].y < mindist; --j)
                upd_ans(a[i], t[j]);
            t[tsz++] = a[i];
        }
}
```

До речі, якщо всі координати є цілими, то під час роботи рекурсії можна уникнути переходу до дробових значень і зберігати квадрат мінімальної відстані в змінній $mindist$.

У основній програмі виклик рекурсії здійснюється так:

<!--- TODO: specify code snippet id -->
``` cpp
sort(a, a + n, &cmp_x);
mindist = 1E20;
rec(0, n - 1);
```

## Узагальнення: пошук трикутника з мінімальною довжиною периметру

Описаний вище алгоритм цікаво узагальнюється на цю задачу: потрібно вибрати три різні точки з заданої множини точок так, щоб сума відстаней між ними була найменшою. Російське слово "узагальнюється" можна замінити на українське "застосовується".

За суті, для розв'язку цієї задачі алгоритм залишається незмінним: ми ділимо поле на дві половинки вертикальною прямою, викликаємо розв'язок рекурсивно від обох половинок, вибираємо мінімум $minper$ зі знайдених периметрів, будуємо смужку товщиною $minper / 2$, і в ній перебираємо всі трикутники, які можуть покращити відповідь. (Зауважимо, що у трикутника з периметром $\le minper$ найдовша сторона $\le minper/2$).

## Завдання в онлайн-суддівстві

Список задач, які зводяться до пошуку двох найближчих точок:

* [ UVA 10245 **"The Closest Pair Problem"** ~~~~~~ [складність: низька] ](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1186)

* [ SPOJ #8725 CLOPPAIR **"Closest Point Pair"** ~~~~~~ [складність: низька] ](http://www.spoj.pl/problems/CLOPPAIR/)

* [Командна олімпіада школярів Саратова - 2011 **"Мінімальна сума"** ~~~~~~ [складність: середня]](http://codeforces.com/contest/120/problem/J)

* [ Google CodeJam 2009 Final **"Min Perimeter"** ~~~~~~ [складність: середня] ](http://code.google.com/codejam/contest/311101/dashboard#s=a&a=1)

* [ SPOJ #7029 CLOSEST **"Closest Triple"** ~~~~~~ [складність: середня] ](https://www.spoj.pl/problems/CLOSEST/)