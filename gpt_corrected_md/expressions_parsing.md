# Розбір виразів. Обернена польська нотація

Дана стрічка, що представляє математичний вираз, який містить числа, змінні та різні операції. Потрібно обчислити його значення за $O(n)$, де $n$ - довжина стрічки.

Тут описаний алгоритм, який перетворює цей вираз у так звану **зворотню польську нотацію** (явним або неявним чином), і вже в ній обчислює вираз.

## Зворотня польська нотація

Зворотня польська нотація - це форма запису математичних виразів, у якій оператори розташовуються після своїх операндів.

Наприклад, отримуємо вираз:

$$
a + b * c * d + (e - f) * (g * h + i)
$$

у зворотній польській нотації записується наступним чином:

$$
a b c * d * + e f - g h * i + * +
$$

Зворотня польська нотація була розроблена австралійським філософом і фахівцем у галузі теорії обчислювальних машин Чарльзом Хембліном у середині 1950-х на основі польської нотації, яка була запропонована в 1920 році польським математиком Яном Лук'яневичем.

Удобство зворотної польської нотації полягає в тому, що вирази, представлені в такій формі, дуже **легко обчислювати**, причому за лінійний час. Заведемо стек, спочатку він порожній. Будемо рухатися ліворуч направо по виразу в зворотній польській нотації; якщо поточний елемент - число або змінна, то кладемо на вершину стека її значення; якщо ж поточний елемент - операція, то дістаємо зі стека два верхніх елементи (або один, якщо операція унарна), застосовуємо до них операцію, і результат кладемо назад в стек. В кінці в стеці залишиться рівно один елемент - значення виразу.

Очевидно, цей простий алгоритм виконується у $O(n)$, тобто порядку довжини виразу.

## Розбір найпростіших виразів

Поки що ми розглядаємо лише найпростіший випадок: всі операції є бінарними (тобто мають два аргументи), і всі є лівоасоціативними (тобто при рівності пріоритетів виконуються зліва направо). Дозволене використання дужок.

Заведемо два стеки: один для чисел, інший для операцій та дужок (тобто стек символів). Спочатку обидва стеки порожні. Для другого стеку будемо підтримувати передумову, що всі операції впорядковані в ньому за строгим зменшенням пріоритету, якщо рухатися від вершини стеку. Якщо в стеці є відкриваючі дужки, то впорядкований кожен блок операцій, що знаходиться між дужками, а весь стек в такому випадку не обов'язково впорядкований.

Будемо йти зліва направо. Якщо поточний елемент є цифрою або змінною, то покладемо її значення в стек. Якщо поточний елемент є відкриваючою дужкою, то покладемо її в стек. Якщо поточний елемент є закриваючою дужкою, то виштовхуємо елементи зі стеку та виконуємо операції до тих пір, поки не зустрінемо відкриваючу дужку (тобто, коли зустрічаємо закриваючу дужку, виконуємо всі операції, що знаходяться всередині цієї дужки). Якщо поточний елемент є операцією, то доти, поки на вершині стеку знаходиться операція з таким же або вищим пріоритетом, виштовхуємо її та виконуємо.

Після того, як ми обробимо усю послідовність в стеці операцій, можуть залишитись деякі операції, які ще не були обчислені, і потрібно виконати їх всі (тобто діємо аналогічно випадку, коли зустрічаємо закривну дужку).

Ось реалізація цього методу на прикладі звичайних операцій $+,-,*,/,\%$:

<!--- TODO: specify code snippet id -->
``` cpp
bool delim(char c) { return c == ' '; }

bool is_op(char c) { return c == '+' || c == '-' || c == '*' || c == '/' || c == '%'; }

int priority(char op) { return op == '+' || op == '-' ? 1 : op == '*' || op == '/' || op == '%' ? 2 : -1; }

void process_op(vector<int> &st, char op) {
    int r = st.back();
    st.pop_back();
    int l = st.back();
    st.pop_back();
    switch (op) {
    case '+':
        st.push_back(l + r);
        break;
    case '-':
        st.push_back(l - r);
        break;
    case '*':
        st.push_back(l * r);
        break;
    case '/':
        st.push_back(l / r);
        break;
    case '%':
        st.push_back(l % r);
        break;
    }
}

int calc(string &s) {
    vector<int> st;
    vector<char> op;
    for (size_t i = 0; i < s.length(); ++i)
        if (!delim(s[i]))
            if (s[i] == '(')
                op.push_back('(');
            else if (s[i] == ')') {
                while (op.back() != '(')
                    process_op(st, op.back()), op.pop_back();
                op.pop_back();
            } else if (is_op(s[i])) {
                char curop = s[i];
                while (!op.empty() && priority(op.back()) >= priority(s[i]))
                    process_op(st, op.back()), op.pop_back();
                op.push_back(curop);
            } else {
                string operand;
                while (i < s.length() && isalnum(s[i])))
                    operand += s[i++];
                --i;
                if (isdigit(operand[0]))
                    st.push_back(atoi(operand.c_str()));
                else
                    st.push_back(get_variable_val(operand));
            }
    while (!op.empty())
        process_op(st, op.back()), op.pop_back();
    return st.back();
}
```

Таким чином, ми навчилися обчислювати значення виразу за $O(n)$, і при цьому ми неявно скористалися зворотньою польською нотацією: ми розмістили операції в такому порядку, коли до моменту обчислення чергової операції обидва її операнди вже обчислені. Злегка модифікувавши вищеописаний алгоритм, можна отримати вираз у зворотній польській нотації і в явному вигляді.

## Унарні операції

Тепер припустимо, що вираз містить унарні операції (тобто з одним аргументом). Наприклад, особливо часто зустрічаються унарний плюс і мінус.

Одна з відмінностей у цьому випадку полягає в необхідності визначення того, чи є поточна операція унарною чи бінарною.

Можна помітити, що перед унарною операцією завжди варто мати або іншу операцію, або відкривати дужку, або взагалі нічого (якщо вона зустрічається на початку рядка). Перед бінарною операцією, навпаки, завжди варто мати або операнд (число/змінну), або закривати дужку. Таким чином, достатньо ввести який-небудь прапорець для вказівки того, чи може наступна операція бути унарною, чи ні.

Ще чисто реалізаційна тонкість - як розрізняти унарні та бінарні операції при добуванні зі стеку та обчисленні. Тут можна, наприклад, для унарних операцій замість символу $s[i]$ класти в стек $-s[i]$.

Приоритет для унарних операцій потрібно вибирати таким чином, щоб він був вищий за пріоритет всіх бінарних операцій.

Крім того, слід зазначити, що унарні операції фактично є правоасоціативними - якщо підряд йдуть декілька унарних операцій, то вони повинні оброблятись зправа наліво (для опису цього випадку див. нижче; наведений тут код вже враховує правоасоціативність).

Реалізація для бінарних операцій $+,-,*,/$ і унарної операції $+$-$:$

<!--- TODO: specify code snippet id -->
``` cpp
bool delim(char c) { return c == ' '; }

bool is_op(char c) { return c == '+' || c == '-' || c == '*' || c == '/' || c == '%'; }

int priority(char op) {
    if (op < 0)
        return 4; // op == -'+' || op == -'-'
    return op == '+' || op == '-' ? 1 : op == '*' || op == '/' || op == '%' ? 2 : -1;
}

void process_op(vector<int> &st, char op) {
    if (op < 0) {
        int l = st.back();
        st.pop_back();
        switch (-op) {
        case '+':
            st.push_back(l);
            break;
        case '-':
            st.push_back(-l);
            break;
        }
    } else {
        int r = st.back();
        st.pop_back();
        int l = st.back();
        st.pop_back();
        switch (op) {
        case '+':
            st.push_back(l + r);
            break;
        case '-':
            st.push_back(l - r);
            break;
        case '*':
            st.push_back(l * r);
            break;
        case '/':
            st.push_back(l / r);
            break;
        case '%':
            st.push_back(l % r);
            break;
        }
    }
}

int calc(string &s) {
    bool may_unary = true;
    vector<int> st;
    vector<char> op;
    for (size_t i = 0; i < s.length(); ++i)
        if (!delim(s[i]))
            if (s[i] == '(') {
                op.push_back('(');
                may_unary = true;
            } else if (s[i] == ')') {
                while (op.back() != '(')
                    process_op(st, op.back()), op.pop_back();
                op.pop_back();
                may_unary = false;
            } else if (is_op(s[i])) {
                char curop = s[i];
                if (may_unary && isunary(curop))
                    curop = -curop;
                while (!op.empty() && (curop >= 0 && priority(op.back()) >= priority(curop) || curop < 0 && priority(op.back()) > priority(curop)))
                    process_op(st, op.back()), op.pop_back();
                op.push_back(curop);
                may_unary = true;
            } else {
                string operand;
                while (i < s.length() && isalnum(s[i])))
                    operand += s[i++];
                --i;
                if (isdigit(operand[0]))
                    st.push_back(atoi(operand.c_str()));
                else
                    st.push_back(get_variable_val(operand));
                may_unary = false;
            }
    while (!op.empty())
        process_op(st, op.back()), op.pop_back();
    return st.back();
}
```

Варто зазначити, що в найпростіших випадках, наприклад, коли дозволені тільки унарні операції $+$ і $-$, правоассоціативність не відіграє жодної ролі, тому в таких ситуаціях не потрібно вводити жодних ускладнень у схему. Тобто, цикл:

<!--- TODO: specify code snippet id -->
``` cpp
while (!op.empty() && (curop >= 0 && priority(op.back()) >= priority(curop) || curop < 0 && priority(op.back()) > priority(curop)))
    process_op(st, op.back()), op.pop_back();
```

Можна замінити на:

<!--- TODO: specify code snippet id -->
``` cpp
while (!op.empty() && priority(op.back()) >= priority(curop))
    process_op(st, op.back()), op.pop_back();
```

## Правоассоциативность

Правоассоціативність оператора означає, що при рівності пріоритетів оператори обчислюються справа наліво (відповідно, лівоассоціативність - коли зліва направо).

Як вже було зазначено вище, унарні оператори зазвичай є правоасоціативними. Інший приклад - зазвичай операція піднесення до степеня вважається правоасоціативною (дійсно, $a^b^c$ зазвичай сприймається як $a^{b^c}$, а не $(a^b)^c$).

Які зміни потрібно внести в алгоритм, щоб правильно обробляти правоассоціативність? Насправді, зміни потрібні дуже мінімальні. Єдина відмінність буде проявлятися тільки при рівності пріоритетів і полягатиме в тому, що операції з рівним пріоритетом, що знаходяться на вершині стека, не повинні виконуватися раніше поточної операції.

Таким чином, єдиною відмінністю, яку потрібно внести в функцію calc:

<!--- TODO: specify code snippet id -->
``` cpp
int calc(string &s) { ... while (!op.empty() && (left_assoc(curop) && priority(op.back()) >= priority(curop) || !left_assoc(curop) && priority(op.back()) > priority(curop)))... }
```