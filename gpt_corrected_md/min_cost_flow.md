# Потік мінімальної вартості (мінімальної витрати) (min-cost-flow). Алгоритм збільшення потоків по шляхах

Дана мережа G, що складається з $N$ вершин і $M$ ребер. У кожного ребра (взагалі кажучи, орієнтованого, але щодо цього див. нижче) вказана пропускна здатність (ціле невід'ємне число) і вартість одиниці потоку вздовж цього ребра (деяке ціле число). У графі вказано джерело $S$ і стік $T$. Дано деяку величину $K$ потоку, потрібно знайти потік цієї величини, причому серед всіх потоків цієї величини потрібно вибрати потік з найменшою вартістю ("задача min-cost-flow").

Іноді задачу ставлять трохи інакше: потрібно знайти максимальний потік найменшої вартості ("задача мінімальної вартості максимального потоку").

Обидві ці задачі достатньо ефективно розв'язуються описаним нижче алгоритмом збільшення шляхів.

## Опис

Алгоритм дуже схожий на [алгоритм Едмондса-Карпа для обчислення максимального потоку](https://uk.wikipedia.org/wiki/Алгоритм_Едмондса_—_Карпа).

### Найпростіший випадок

Розглянемо спочатку найпростіший випадок, коли граф є орієнтованим, і між будь-якою парою вершин не більше одного ребра (якщо є ребро (i,j), то ребра (j,i) не може бути).

Нехай U<sub>ій</sub> - пропускна здатність ребра (і,й), якщо це ребро існує. Нехай C<sub>ій</sub> - вартість одиниці потоку вздовж ребра (і,й). Нехай F<sub>ій</sub> - величина потоку вздовж ребра (і,й), спочатку всі величини потоків рівні нулю.

Модифікуємо мережу наступним чином: для кожного ребра (i,j) додамо в мережу так зване зворотне ребро (j,i) з пропускною здатністю U<sub>ji</sub> = 0 і вартістю C<sub>ji</sub> = - C<sub>ij</sub>. Оскільки, за нашим припущенням, ребра (j,i) до цього в мережі не було, то модифікована таким чином мережа, як і раніше, не буде мультиграфом. Крім того, на усьому протязі роботи алгоритму будемо підтримувати умову: F<sub>ji</sub> = - F<sub>ij</sub>.

Визначимо **залишкову мережу** для деякого зафіксованого потоку F наступним чином (власне, так само, як і в алгоритмі Форда-Фалкерсона): до залишкової мережі належать тільки ненасичені ребра (тобто ті, у яких F<sub>ij</sub> < U<sub>ij</sub>), а залишкова пропускна здатність кожного такого ребра дорівнює UPI<sub>ij</sub> = U<sub>ij</sub> - F<sub>ij</sub>.

Власне **алгоритм** мінімального потоку з мінімальною вартістю полягає в наступному. На кожній ітерації алгоритму знаходимо найкоротший шлях в залишковій мережі з S до T (найкоротший щодо вартостей C<sub>ij</sub>). Якщо шлях не був знайдений, то алгоритм завершується, потік F - шуканий. Якщо ж шлях був знайдений, то ми збільшуємо потік уздовж нього настільки, наскільки це можливо (тобто проходимо уздовж цього шляху, знаходимо мінімальну залишкову пропускну здатність MIN_UPI серед ребер цього шляху, і потім збільшуємо потік уздовж кожного ребра шляху на величину MIN_UPI, не забуваючи зменшувати на таку ж величину потік уздовж зворотних ребер). Якщо в якийсь момент величина потоку досягла величини K (дана в умові величина потоку), то ми також зупиняємо алгоритм (варто врахувати, що тоді на останній ітерації алгоритму при збільшенні потоку уздовж шляху потрібно збільшувати потік на таку величину, щоб підсумковий потік не перевищував K, але це легко виконати).

Неважко помітити, що якщо покласти K рівним нескінченності, то алгоритм знайде максимальний потік мінімальної вартості, тобто один і той же алгоритм без змін вирішує обидві задачі: min-cost-flow і min-cost-max-flow.

### Випадок неорієнтованих графів та мультиграфів

Випадок неорієнтованих графів та мультиграфів у концептуальному плані нічим не відрізняється від вищезгаданого, тому сам алгоритм буде працювати і на таких графах. Однак, виникають деякі складності в реалізації, на які потрібно звернути увагу.

Неорієнтоване ребро (i,j) - це фактично два орієнтованих ребра (i,j) і (j,i) з однаковими пропускними здібностями та вартостями. Оскільки вищеописаний алгоритм min-cost-flow потребує для кожного неорієнтованого ребра створити зворотне ребро, то в підсумку виходить, що неорієнтоване ребро розщеплюється на 4 орієнтовані ребра, і ми фактично отримуємо випадок мультиграфа.

Які проблеми викликають **кратні ребра**? По-перше, потік по кожному з кратних ребер має бути збережений окремо. По-друге, при пошуку найкоротшого шляху потрібно враховувати, яке саме з кратних ребер вибрати при відновленні шляху за допомогою предків. Тобто, замість звичайного масиву предків для кожної вершини ми повинні зберігати вершину-предка і номер ребра, по якому ми до неї прийшли. По-третє, при збільшенні потоку вздовж деякого ребра потрібно, згідно алгоритму, зменшити потік вздовж зворотного ребра. Оскільки у нас можуть бути кратні ребра, то доведеться для кожного ребра зберігати номер зворотного ребра.

Інших складнощів з неорієнтованими графами та мультиграфами немає.

### Аналіз тривалості роботи

За аналогією з аналізом алгоритму Едмондса-Карпа ми отримуємо таку оцінку: O(NM) * T(N, M), де T(N, M) - час, необхідний для знаходження найкоротшого шляху в графі з N вершинами і M ребрами. Якщо це реалізувати з допомогою [найпростішого варіанту алгоритму Дейкстри](https://uk.wikipedia.org/wiki/Алгоритм_Дейкстри), то для всього алгоритму min-cost-flow вийде оцінка **O(N^3 M)**. Проте алгоритм Дейкстри доведеться модифікувати, щоб він працював на графах з від'ємними вагами (це називається алгоритм Дейкстри з потенціалами).

Замість цього можна використовувати [алгоритм Левіта](https://uk.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9B%D0%B5%D0%B2%D1%96%D1%82%D0%B0), який, хоча і асимптотично значно гірше, але на практиці працює дуже швидко (приблизно за той самий час, що і алгоритм Дейкстри).

## Реалізація

Тут наведено реалізацію алгоритму мінімального потоку з мінімальною вартістю, яка базується на [алгоритмі Левіта](https://uk.wikipedia.org/wiki/Алгоритм_Левіта).

На вхід алгоритму надходить мережа (неорієнтований мультиграф) з N вершинами та M ребрами, а також K - величина потоку, який потрібно знайти. Алгоритм знаходить потік мінімальної вартості величини K, якщо такий існує. Інакше він знаходить потік мінімальної вартості максимальної величини. Русизми в тексті відсутні.

У програмі є спеціальна функція для додавання орієнтованого ребра. Якщо потрібно додати неорієнтоване ребро, то цю функцію потрібно викликати для кожної пари вершин (i,j) двічі: від (i,j) і від (j,i).

<!--- TODO: specify code snippet id -->
``` cpp
const int INF = 1000 * 1000 * 1000;

struct rib {
    int b, u, c, f;
    size_t back;
};

void add_rib(vector<vector<rib>> &g, int a, int b, int u, int c) {
    rib r1 = {b, u, c, 0, g[b].size()};
    rib r2 = {a, 0, -c, 0, g[a].size()};
    g[a].push_back(r1);
    g[b].push_back(r2);
}

int main() {
    int n, m, k;
    vector<vector<rib>> g(n);
    int s, t;
...читання графу...

        int flow = 0,
            cost = 0;
    while (flow < k) {
        vector<int> id(n, 0);
        vector<int> d(n, INF);
        vector<int> q(n);
        vector<int> p(n);
        vector<size_t> p_rib(n);
        int qh = 0, qt = 0;
        q[qt++] = s;
        d[s] = 0;
        while (qh != qt) {
            int v = q[qh++];
            id[v] = 2;
            if (qh == n)
                qh = 0;
            for (size_t i = 0; i < g[v].size(); ++i) {
                rib &r = g[v][i];
                if (r.f < r.u && d[v] + r.c < d[r.b]) {
                    d[r.b] = d[v] + r.c;
                    if (id[r.b] == 0) {
                        q[qt++] = r.b;
                        if (qt == n)
                            qt = 0;
                    } else if (id[r.b] == 2) {
                        if (--qh == -1)
                            qh = n - 1;
                        q[qh] = r.b;
                    }
                    id[r.b] = 1;
                    p[r.b] = v;
                    p_rib[r.b] = i;
                }
            }
        }
        if (d[t] == INF)
            break;
        int addflow = k - flow;
        for (int v = t; v != s; v = p[v]) {
            int pv = p[v];
            size_t pr = p_rib[v];
            addflow = min(addflow, g[pv][pr].u - g[pv][pr].f);
        }
        for (int v = t; v != s; v = p[v]) {
            int pv = p[v];
            size_t pr = p_rib[v], r = g[pv][pr].back;
            g[pv][pr].f += addflow;
            g[v][r].f -= addflow;
            cost += g[pv][pr].c * addflow;
        }
        flow += addflow;
    }

...висновок щодо результату...
}
```