# Китайська теорема про залишки

## Формулювання

У своєму сучасному формулюванні теорема звучить так:

Нехай $p = p_1 \cdot p_2 \cdot \ldots \cdot p_k$, де $p_i$ є попарно взаємно простими числами.

Поставимо у відповідність безпідставному числу $a$ $(0 \le a < p)$ кортеж $(a_1, \ldots, a_k)$, де $a_i \equiv a \pmod {p_i}$

$$
a \Longleftrightarrow (a_1, \ldots, a_k).
$$

Значить, ця відповідність (між числами та кортежами) буде **взаємно однозначною**. Більше того, операції, що виконуються над числом $a$, можна еквівалентно виконувати над відповідними елементами кортежів - шляхом незалежного виконання операцій над кожним компонентом.

тобто, якщо

$$
a \Longleftrightarrow \Big( a_1, \ldots, a_k \Big),
$$

$$
b \Longleftrightarrow \Big( b_1, \ldots, b_k \Big),
$$

то справедливо:

$$
{(a+b) \pmod p} \Longleftrightarrow \Big( {(a_1+b_1) \pmod {p_1}}, \ldots, {(a_k+b_k) \pmod {p_k}} \Big),
$$

$$
{(a-b) \pmod p} \Longleftrightarrow \Big( {(a_1-b_1) \pmod {p_1}}, \ldots, {(a_k-b_k) \pmod {p_k}} \Big),
$$

$$
{(a \cdot b) \pmod p} \Longleftrightarrow \Big( {(a_1 \cdot b_1) \pmod {p_1}}, \ldots, {(a_k \cdot b_k) \pmod {p_k}} \Big).
$$

У своєму початковому формулюванні ця теорема була доведена китайським математиком Сунь-Цзи приблизно в 100 р. н.е. А саме, він показав у приватному випадку еквівалентність розв'язку системи модулярних рівнянь і розв'язку одного модулярного рівняння (див. наслідок 2 нижче).

### Слідство 1

Система модульованих рівнянь:

$$
\cases{
{x \equiv a_1 \pmod {p_1}}, \cr
\ldots, \cr
{x \equiv a_k \pmod {p_k}} \cr
}
$$

має лише один розв'язок за модулем $p$.

(як і вище, $p = p_1 \cdot \ldots \cdot p_k$, де числа $p_i$ є попарно взаємно простими, а набір $a_1, \ldots, a_k$ - довільний набір цілих чисел)

### Слідство 2

Наслідком є зв'язок між системою модулярних рівнянь та відповідним модулярним рівнянням:

Уравнение:

$$
x \equiv a \pmod p
$$

еквівалентно системі рівнянь:

$$
\cases{
{x \equiv a \pmod {p_1}}, \cr
\ldots, \cr
{x \equiv a \pmod {p_k}} \cr
}
$$

(як і вище, передбачається, що $p = p_1 \cdot \ldots \cdot p_k$, де числа $p_i$ є попарно взаємно простими, а $a$ - довільне ціле число)

## Алгоритм Гарнера

З китайської теореми про залишки випливає, що можна замінювати операції над числами операціями над кортежами. Нагадаємо, кожному числу $a$ ставиться у відповідність кортеж $(a_1, \ldots, a_k)$, де:

$$
{ a_i \equiv a \pmod {p_i} } .
$$

Це можливо знайти широке застосування на практиці (окрім безпосереднього застосування для відновлення числа за його остатками за різними модулями), оскільки таким чином ми можемо замінювати операції в довгій арифметиці операціями з масивом "коротких" чисел. Наприклад, масиву з $1000$ елементів "достатньо" на числа приблизно з $3000$ знаками (якщо вибрати в якості $p_i$ перші $1000$ простих); а якщо вибирати в якості $p_i$ прості близько мільярда, то тоді вистачить на число з приблизно $9000$ знаками. Але, звісно, тоді потрібно навчитися **відновлювати** число $a$ за цим кортежем. З наслідку 1 видно, що таке відновлення можливе, і притому єдине (за умови $0 \le a < p_1 \cdot p_2 \cdot \ldots \cdot p_k$). **Алгоритм Гарнера** є алгоритмом, який дозволяє виконати це відновлення, причому достатньо ефективно.

Будемо шукати розв'язок у вигляді:

$$
a = x_1 + x_2 \cdot p_1 + x_3 \cdot p_1 \cdot p_2 + \ldots + x_k \cdot p_1 \cdot \ldots \cdot p_{k-1},
$$

тобто в змішаній системі числення з вагами розрядів $p_1, p_2, \ldots, p_k$.

Позначимо через $r_{ij}$ ($i=1,\ldots,k-1$, $j=i+1,\ldots,k$) число, яке є зворотним для $p_i$ за модулем $p_j$ (знаходження зворотних елементів в кільці за модулем описано [тут](https://uk.wikipedia.org/wiki/Зворотній_елемент_за_модулем))

$$
r_{ij} = (p_i) ^ {-1} \pmod {p_j} .
$$

Підставивши значення $a$ в змішаній системі числення у перше рівняння системи, отримаємо:

$$
a_1 \equiv x_1.
$$

Підставами тепер вираз у друге рівняння:

$$
a_2 \equiv x_1 + x_2 \cdot p_1 \pmod {p_2}.
$$

Перетворимо цей вираз, віднявши від обох частин $x_1$ і розділивши на $p_1$:

$$
a_2 - x_1 \equiv x_2 \cdot p_1 \pmod {p_2};
$$

$$
(a_2 - x_1) \cdot r_{12} \equiv x_2 \pmod {p_2};
$$

$$
x_2 \equiv (a_2 - x_1) \cdot r_{12} \pmod {p_2}.
$$

Підставляючи у третє рівняння, аналогічним чином отримуємо:

$$
a_3 \equiv { x_1 + x_2 \cdot p_1 + x_3 \cdot p_1 \cdot p_2 \pmod {p_3} };
$$

$$
(a_3 - x_1) \cdot r_{13} \equiv x_2 + x_3 \cdot p_2 \pmod {p_3};
$$

$$
((a_3 - x_1) \cdot r_{13} - x_2) \cdot r_{23} \equiv x_3 \pmod {p_3};
$$

$$
x_3 \equiv ((a_3 - x_1) \cdot r_{13} - x_2) \cdot r_{23} \pmod {p_3}.
$$

Вже достатньо ясно видна закономірність, яку простіше за все виразити кодом:

<!--- TODO: specify code snippet id -->
``` cpp
for (int i = 0; i < k; ++i) {
    x[i] = a[i];
    for (int j = 0; j < i; ++j) {
        x[i] = r[j][i] * (x[i] - x[j]);

        x[i] = x[i] % p[i];
        if (x[i] < 0)
            x[i] += p[i];
    }
}
```

Отже, ми навчилися обчислювати коефіцієнти $x_i$ за час $O(k^2)$. Сама відповідь - число $a$ - може бути відновлена за допомогою формули:

$$
a = x_1 + x_2 \cdot p_1 + x_3 \cdot p_1 \cdot p_2 + \ldots + x_k \cdot p_1 \cdot \ldots \cdot p_{k-1}.
$$

Варто зазначити, що на практиці майже завжди потрібно обчислювати відповідь з допомогою [Довгої арифметики](big_integer), але при цьому самі коефіцієнти $x_i$ як і раніше обчислюються на вбудованих типах, тому весь алгоритм Гарнера є дуже ефективним.

## Реалізація алгоритму Гарнера

Найзручніше реалізувати цей алгоритм на мові Java, оскільки вона містить стандартну довгу арифметику, тому не виникає жодних проблем з переведенням числа з модульної системи в звичайне число (використовується стандартний клас BigInteger).

Наведена нижче реалізація алгоритму Гарнера підтримує додавання, віднімання та множення, при цьому передбачає роботу з від'ємними числами (див. пояснення після коду). Реалізовано перетворення чисел звичайного десяткового представлення в модулярну систему та навпаки.

У даному прикладі беруться $100$ простих чисел після $10^9$, що дозволяє працювати з числами до приблизно $10^{900}$.

\javacode
final int SZ = 100;
int pr[] = new int[SZ];
int r[][] = new int[SZ][SZ];

void init() {
    for (int x=1000*1000*1000, i=0; i<SZ; ++x)
        if (BigInteger.valueOf(x).isProbablePrime(100))
            pr[i++] = x;
    
    for (int i=0; i<SZ; ++i)
        for (int j=i+1; j<SZ; ++j)
            r[i][j] = BigInteger.valueOf( pr[i] ).modInverse(
                    BigInteger.valueOf( pr[j] ) ).intValue();
}

class Number {
    
    int a[] = new int[SZ];
    
    public Number() {
    }
    
    public Number (int n) {
        for (int i=0; i<SZ; ++i)
            a[i] = n % pr[i];
    }
    
    public Number (BigInteger n) {
        for (int i=0; i<SZ; ++i)
            a[i] = n.mod( BigInteger.valueOf( pr[i] ) ).intValue();
    }
    
    public Number add (Number n) {
        Number result = new Number();
        for (int i=0; i<SZ; ++i)
            result.a[i] = (a[i] + n.a[i]) % pr[i];
        return result;
    }
    
    public Number subtract (Number n) {
        Number result = new Number();
        for (int i=0; i<SZ; ++i)
            result.a[i] = (a[i] - n.a[i] + pr[i]) % pr[i];
        return result;
    }
    
    public Number multiply (Number n) {
        Number result = new Number();
        for (int i=0; i<SZ; ++i)
            result.a[i] = (int)( (a[i] * 1l * n.a[i]) % pr[i] );
        return result;
    }
    
    public BigInteger bigIntegerValue (boolean can_be_negative) {
        BigInteger result = BigInteger.ZERO,
            mult = BigInteger.ONE;
        int x[] = new int[SZ];
        for (int i=0; i<SZ; ++i) {
            x[i] = a[i];
            for (int j=0; j<i; ++j) {
                long cur = (x[i] - x[j]) * 1l * r[j][i];
                x[i] = (int)( (cur % pr[i] + pr[i]) % pr[i] );                    
            }
            result = result.add( mult.multiply( BigInteger.valueOf( x[i] ) ) );
            mult = mult.multiply( BigInteger.valueOf( pr[i] ) );
        }
        
        if (can_be_negative)
            if (result.compareTo( mult.shiftRight(1) ) >= 0)
                result = result.subtract( mult );
            
        return result;
    }
}
\endcode

Про підтримку **від'ємних** чисел варто сказати особливо (прапорець $\rm can\_be\_negative$ функції ${\rm bigIntegerValue}()$). Сама модульна схема не передбачає різниці між додатніми та від'ємними числами. Однак можна зауважити, що якщо в конкретній задачі відповідь за модулем не перевищує половини від добутку всіх простих, то додатні числа будуть відрізнятися від від'ємних тим, що додатні числа будуть менші за цю середину, а від'ємні - більші. Тому після класичного алгоритму Гарнера ми порівнюємо результат з серединою і, якщо він більший, то виводимо мінус, і інвертуємо результат (тобто віднімаємо його від добутку всіх простих, і виводимо вже його).