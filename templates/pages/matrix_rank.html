<h1>Нахождение ранга матрицы</h1>
<p><b>Ранг матрицы</b> - это наибольшее число линейно независимых строк/столбцов матрицы. Ранг определён не только для квадратных матриц; пусть матрица прямоугольна и имеет размер NxM.</p>
<p>Также ранг матрицы можно определить как наибольший из порядков миноров матрицы, отличных от нуля.</p>
<p>Заметим, что если матрица квадратная и её определитель отличен от нуля, то ранг равен N(=M), иначе он будет меньше. В общем случае, ранг матрицы не превосходит min(N,M).</p>



<h2>Алгоритм</h2>
<p>Искать ранг можно с помощью модифицированного <algohref=linear_systems_gauss>метода Гаусса</algohref>. Будем выполнять абсолютно те же самые операции, что и при решении системы или нахождении её определителя, но если на каком-либо шаге в i-ом столбце среди невыбранных до этого строк нет ненулевых, то мы этот шаг пропускаем, а ранг уменьшаем на единицу (изначально ранг полагаем равным max(N,M)). Иначе, если мы нашли на i-ом шаге строку с ненулевым элементом в i-ом столбце, то помечаем эту строку как выбранную, и выполняем обычные операции отнимания этой строки от остальных.</p>



<h2>Реализация</h2>
<code>const double EPS = 1E-9;

int rank = max(n,m);
vector&lt;char> line_used (n);
for (int i=0; i&lt;m; ++i) {
    int j;
    for (j=0; j&lt;n; ++j)
        if (!line_used[j] && abs(a[j][i]) > EPS)
            break;
    if (j == n)
        --rank;
    else {
        line_used[j] = true;
        for (int p=i+1; p&lt;m; ++p)
            a[j][p] /= a[j][i];
        for (int k=0; k&lt;n; ++k)
            if (k != j && abs (a[k][i]) > EPS)
                for (int p=i+1; p&lt;m; ++p)
                    a[k][p] -= a[j][p] * a[k][i];
    }
}</code>