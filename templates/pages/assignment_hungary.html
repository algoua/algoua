<h1>Венгерский алгоритм решения задачи о назначениях</h1>



<h2>Постановка задачи о назначениях</h2>

<p>Задача о назначениях ставится весьма естественно.</p>

<p>Приведём несколько <b>вариантов постановки</b> (как легко видеть, все они эквивалентны друг другу):</p>

<ul>

<li>Есть $n$ рабочих и $n$ заданий. Для каждого рабочего известно, сколько денег он запросит за выполнение того или иного задания. Каждый рабочий может взять себе только одно задание. Требуется распределить задания по рабочим так, чтобы минимизировать суммарные расходы.</li>

<li>Дана матрица $a$ размера $n \times n$. Требуется в каждой её строке выбрать по одному числу так, чтобы в любом столбце также было выбрано ровно по одному числу, и при этом сумма выбранных чисел была бы минимальной.</li>

<li>Дана матрица $a$ размера $n \times n$. Требуется найти такую перестановку $p$ длины $n$, что величина $\sum a[i][p[i]]$ - минимальна.</li>

<li>Дан полный двудольный граф с $n$ вершинами; каждому ребру приписан некоторый вес. Требуется найти совершенное паросочетание минимального веса.</li>

</ul>

<p>Отметим, что все приведённые выше постановки "<b>квадратны</b>": в них обе размерности всегда совпадают (и равны $n$). На практике часто встречаются аналогичные "<b>прямоугольные</b>" постановки, когда $n \ne m$, и надо выбрать $\min(n,m)$ элементов. Впрочем, как легко заметить, от "прямоугольной" задачи всегда можно перейти к "квадратной", добавив строки/столбцы с нулевыми/бесконечными значениями соответственно.</p>

<p>Также заметим, что по аналогии с поиском <b>минимального</b> решения также можно ставить задачу поиска <b>максимального</b> решения. Впрочем, эти две задачи эквивалентны друг другу: достаточно все веса умножить на $-1$.</p>



<h2>Венгерский алгоритм</h2>


<h3>Историческая справка</h3>

<p>Алгоритм был разработан и опубликован Гарольдом <b>Куном</b> (Harold Kuhn) в 1955 г. Сам Кун дал алгоритму название "венгерский", потому что он был в значительной степени основан на более ранних работах двух венгерских математиков: Денеша <b>Кёнига</b> (Dénes Kőnig) и Эйгена <b>Эгервари</b> (Jenő Egerváry).</p>

<p>В 1957 г. Джеймс <b>Манкрес</b> (James Munkres) показал, что этот алгоритм работает за (строго) полиномиальное время (т.е. за время порядка полинома от $n$, не зависящего от величины стоимостей).</p>

<p>Поэтому в литературе данный алгоритм известен не только как "венгерский", но и как "алгоритм Куна-Манкреса" или "алгоритм Манкреса".</p>

<p>Впрочем, недавно (в 2006 г). выяснилось, что точно такой же алгоритм был изобретён <b>за век до Куна</b> немецким математиком Карлом Густавом <b>Якоби</b> (Carl Gustav Jacobi). Дело в том, что его работа "About the research of the order of a system of arbitrary ordinary differential equations", напечатанная посмертно в 1890 г., содержавшая помимо прочих результатов и полиномиальный алгоритм решения задачи о назначениях, была написана на латыни, а её публикация <b>прошла незамеченной</b> среди математиков.</p>

<p>Также стоит отметить, что первоначальный алгоритм Куна имел асимптотику $O(n^4)$, и лишь позже Джек <b>Эдмондс</b> (Jack Edmonds) и Ричард <b>Карп</b> (Richard Karp) (и независимо от них <b>Томидзава</b> (Tomizawa)) показали, каким образом улучшить его до асимптотики $O(n^3)$.</p>


<h3>Построение алгоритма за $O(n^4)$</h3>

<p>Сразу отметим во избежание неоднозначностей, что мы в основном рассматриваем здесь задачу о назначениях в матричной постановке (т.е. дана матрица $a$, и надо выбрать из неё $n$ ячеек, находящихся в разных строках и столбцах). Индексацию массивов мы начинаем с единицы, т.е., например, матрица $a$ имеет индексы $a[1 \ldots n][1 \ldots n]$.</p>

<p>Также мы будем считать, что все числа в матрице $a[][]$ <b>неотрицательны</b> (если это не так, то всегда можно перейти к неотрицательной матрице, прибавив ко всем числам некоторое число).</p>

<p>Назовём <b>потенциалом</b> два произвольных массива чисел $u[1 \ldots n]$ и $v[1 \ldots n]$ таких, что выполняется условие:</p>

$$ u[i] + v[j] \le a[i][j] (i = 1 \ldots n, ~~ j = 1 \ldots n). $$

<p>(Как видно, числа $u[i]$ соответствуют строкам, а числа $v[j]$ - столбцам матрицы).</p>

<p>Назовём <b>значением $f$ потенциала</b> сумму его чисел:</p>

$$ f = \sum_{i=1}^n u[i] + \sum_{i=1}^n v[i]. $$

<p>С одной стороны, легко заметить, что стоимость искомого решения $sol$ <b>не меньше</b> значения любого потенциала:</p>

$$ sol \ge f. $$

<p>(Доказательство. Искомое решение задачи представляет из себя $n$ ячеек матрицы, и для каждой из них выполняется условие $u[i] + v[j] \le a[i][j]$. Поскольку все элементы находятся в разных строках и столбцах, то, суммируя эти неравенства по всем выбранным $a[i][j]$, в левой части неравенства получаем $f$, а в правой - $sol$, что и требовалось доказать).</p>

<p>С другой стороны, оказывается, что всегда существует решение и потенциал, на которых это неравенство <b>обращается в равенство</b>. Венгерский алгоритм, описанный ниже, будет конструктивным доказательством этого факта. Пока же лишь обратим внимание на то, что если какое-либо решение имеет стоимость, равную по величине какому-либо потенциалу, то это решение - <b>оптимально</b>.</p>

<p>Зафиксируем некоторый потенциал. Назовём ребро $(i,j)$ <b>жёстким</b>, если выполняется:</p>

$$ u[i] + v[j] = a[i][j]. $$

<p>Вспомним об альтернативной постановке задачи о назначениях, с помощью двудольного графа. Обозначим через $H$ двудольный граф, составленный только из жёстких рёбер. Фактически, венгерский алгоритм поддерживает для текущего потенциала <b>максимальное по количеству рёбер паросочетание $M$</b> графа $H$: и как только это паросочетание станет содержать $n$ рёбер, рёбра этого паросочетания и будут являться искомым оптимальным решением (ведь это будет решение, стоимость которого совпадает с величиной потенциала).</p>

<p>Перейдём непосредственно к <b>описанию алгоритма</b>.</p>

<ul>

<li>В начале алгоритма потенциал полагается равным нулю $u[i] = v[i] = 0$, и паросочетание $M$ полагается пустым.</li>

<li>Далее, на каждом шаге алгоритма мы пытаемся, не меняя потенциала, увеличить мощность текущего паросочетания $M$ на единицу (напоминаем, паросочетание ищется в графе жёстких рёбер $H$).</li>

<p>Для этого фактически используется обычный <a href="kuhn_matching">алгоритм Куна поиска максимального паросочетания в двудольных графах</a>. Напомним здесь этот алгоритм.</p>

<p>Все рёбра паросочетания $M$ ориентируются по направлению от второй доли к первой, все остальные рёбра графа $H$ ориентируются в противоположную сторону.</p>

<p>Напомним (из терминологии поиска паросочетаний), что вершина называется насыщенной, если ей смежно ребро из текущего паросочетания. Вершина, которой не смежно ни одно ребро из текущего паросочетания, называется ненасыщенной. Путь нечётной длины, в котором первое ребро не принадлежит паросочетанию, а для всех последующих рёбер происходит чередование (принадлежит/не принадлежит) - называется увеличивающим путём.</p>

<p>Из всех ненасыщенных вершин первой доли запускается обход <a href="dfs">в глубину</a>/<a href="bfs">в ширину</a>. Если в результате обхода удалось достигнуть ненасыщенной вершины второй доли, то это означает, что мы нашли увеличивающий путь из первой доли во вторую. Если прочередовать рёбра вдоль этого пути (т.е. первое ребро включить в паросочетание, второе исключить, третье включить, и т.д)., то тем самым мы увеличим мощность паросочетания на единицу.</p>

<p>Если же увеличивающего пути не было, то это означает, что текущее паросочетание $M$ - максимально в графе $H$, поэтому в таком случае переходим к следующему пункту.</p>

<li>Если на текущем шаге не удалось увеличить мощность текущего паросочетания, то производится некий пересчёт потенциала таким образом, чтобы на следующих шагах появилось больше возможностей для увеличения паросочетания.</li>

<p>Обозначим через $Z_1$ множество вершин первой доли, которые были посещены обходом алгоритма Куна при попытке поиска увеличивающей цепи; через $Z_2$ - множество посещённых вершин второй доли.</p>

<p>Посчитаем величину $\Delta$:</p>

$$ \Delta = \min_{i \in Z_1, j \notin Z_2} \{ a[i][j] - u[i] - v[j] \}. $$

<p>Эта величина строго положительна.</p>

<p>(Доказательство. Предположим, что $\Delta = 0$. Тогда существует жёсткое ребро $(i,j)$, причём $i \in Z_1$ и $j \notin Z_2$. Из этого следует, что ребро $(i,j)$ должно было быть ориентированным от второй доли к первой, т.е. это жёсткое ребро $(i,j)$ должно входить в паросочетание $M$. Однако это невозможно, т.к. мы не могли попасть в насыщенную вершину $i$, кроме как пройдя по ребру из $j$ в $i$. Пришли к противоречию, значит, $\Delta > 0$).</p>

<p>Теперь <b>пересчитаем потенциал</b> таким образом: для всех вершин $i \in Z_1$ сделаем $u[i] += \Delta$, а для всех вершин $j \in Z_2$ - сделаем $v[j] -= \Delta$. Получившийся потенциал по-прежнему останется корректным потенциалом.</p>

<p>(Доказательство. Для этого надо показать, что по-прежнему для всех $i$ и $j$ выполняется: $u[i] + v[j] \le a[i][j]$. Для случаев, когда $i \in Z_1 \& j \in Z_2$ или $i \notin Z_1 \& j \notin Z_2$ - это так, поскольку для них сумма $u[i]$ и $v[j]$ не изменилась. Когда $i \notin Z_1 \& j \in Z_2$ - неравенство только усилилось. Наконец, для случая $i \in Z_1 \& j \notin Z_2$ - хотя левая часть неравенства и увеличивается, неравенство всё равно сохраняется, поскольку величина $\Delta$, как видно по её определению - это как раз максимальное увеличение, не приводящее к нарушению неравенства).</p>

<p>Кроме того, старое паросочетание $M$ из жёстких рёбер можно будет оставить, т.е. все рёбра паросочетания останутся жёсткими.</p>

<p>(Доказательство. Чтобы некоторое жёсткое ребро $(i,j)$ перестало быть жёстким в результате изменения потенциала, надо, чтобы равенство $u[i] + v[j] = a[i][j]$ превратилось в неравенство $u[i] + v[j] < a[i][j]$. Однако левая часть могла уменьшиться только в одном случае: когда $i \notin Z_1 \& j \in Z_2$. Но раз $i \notin Z_1$, то это означает, что ребро $(i,j)$ не могло быть ребром паросочетания, что и требовалось доказать).</p>

<p>Наконец, чтобы показать, что изменения потенциала <b>не могут происходить бесконечно</b>, заметим, что при каждом таком изменении потенциала количество вершин, достижимых обходом, т.е. $|Z_1|+|Z_2|$, строго увеличивается. (При этом нельзя утверждать, что увеличивается количество жёстких рёбер).</p>

<p>(Доказательство. Во-первых, любая вершина, которая была достижимой, достижимой и останется. В самом деле, если некоторая вершина достижима, то до неё есть некоторый путь из достижимых вершин, начинающийся в ненасыщенной вершине первой доли; а поскольку для рёбер вида $(i,j), i \in Z_1 \& j \in Z_2$ сумма $u[i] + v[j]$ не меняется, то весь этот путь сохранится и после изменения потенциала, что и требовалось доказать. Во-вторых, покажем, что в результате пересчёта потенциала появилась хотя бы одна новая достижимая вершина. Но это почти очевидно, если вернуться к определению $\Delta$: то ребро $(i,j)$, на котором был достигнут минимум, теперь станет жёстким, а, значит, вершина $j$ станет достижимой благодаря этому ребру и вершине $i$).</p>

<p>Таким образом, всего может происходить не более $n$ пересчётов потенциала, прежде чем обнаружится увеличивающая цепочка и мощность паросочетания $M$ будет увеличена.</p>

</ul>

<p>Таким образом, рано или поздно будет найден потенциал, которому соответствует совершенное паросочетание $M$, являющееся ответом на задачу.</p>

<p>Если говорить об <b>асимптотике</b> алгоритма, то она составляет $O(n^4)$, поскольку всего должно произойти $n$ увеличений паросочетания, перед каждым из которых происходит не более $n$ пересчётов потенциала, каждый из которых выполняется за время $O(n^2)$.</p>

<p>Реализацию за $O(n^4)$ мы здесь приводить не будем, поскольку она всё равно получится не короче, чем описанная ниже реализация за $O(n^3)$.</p>


<h3>Построение алгоритма за $O(n^3)$ ($O(n^2 m)$)</h3>

<p>Научимся теперь реализовывать тот же алгоритм за асимптотику $O(n^3)$ (для прямоугольных задач $n \times m$ - $O(n^2 m)$).</p>

<p>Ключевая идея: теперь мы будем <b>добавлять в рассмотрение строки матрицы одну за одной</b>, а не рассматривать их все сразу. Таким образом, описанный выше алгоритм примет вид:</p>

<ul>

<li>Добавляем в рассмотрение очередную строку матрицы $a$.</li>

<li>Пока нет увеличивающей цепи, начинающейся в этой строке, пересчитываем потенциал.</li>

<li>Как только появляется увеличивающая цепь, чередуем паросочетание вдоль неё (включая тем самым последнюю строку в паросочетание), и переходим к началу (к рассмотрению следующей строки).</li>

</ul>

<p>Чтобы достичь требуемой асимптотики, надо реализовать шаги 2-3, выполняющиеся для каждой строки матрицы, за время $O(n^2)$ (для прямоугольных задач - за $O(n m)$).</p>

<p>Для этого мы вспомним два факта, доказанных нами выше:</p>

<ul>

<li>При изменении потенциала вершины, которые были достижимы обходом Куна, достижимыми и останутся.</li>

<li>Всего могло произойти лишь $O(n)$ пересчётов потенциала, прежде чем будет найдена увеличивающая цепь.</li>

</ul>

<p>Отсюда вытекают <b>ключевые идеи</b>, позволяющие достичь требуемой асимптотики:</p>

<ul>

<li>Для проверки наличия увеличивающей цепочки нет необходимости запускать обход Куна заново после каждого пересчёта потенциала. Вместо этого можно оформить обход Куна в <b>итеративном</b> виде: после каждого пересчёта потенциала мы просматриваем добавившиеся жёсткие рёбра и, если их левые концы были достижимыми, помечаем их правые концы также как достижимые и продолжаем обход из них.</li>

<li>Развивая эту идею дальше, можно прийти к такому представлению алгоритма: это цикл, на каждом шаге которого сначала пересчитывается потенциал, затем находится столбец, ставший достижимым (а таковой всегда найдётся, поскольку после пересчёта потенциала всегда появляются новые достижимые вершины), и если этот столбец был ненасыщен, то найдена увеличивающая цепь, а если столбец был насыщен - то соответствующая ему в паросочетании строка также становится достижимой.</li>

<p>Теперь алгоритм принимает вид: цикл добавления столбцов, на каждом из которых сначала пересчитывается потенциал, а затем какой-то новый столбец помечается как достижимый.</p>

<li>Чтобы быстро пересчитывать потенциал (быстрее, чем наивный вариант за $O(n^2)$), надо поддерживать вспомогательные минимумы по каждому из столбцов $j$:</li>

$$ minv[j] = \min_{i \in Z_1} \{ a[i][j] - u[i] - v[j] \}. $$

<p>Как легко видеть, искомая величина $\Delta$ выражается через них следующим образом:</p>

$$ \Delta = \min_{j \notin Z_2} \{ minv[j] \}. $$

<p>Таким образом, нахождение $\Delta$ теперь можно произвести за $O(n)$.</p>

<p>Поддерживать этот массив $minv[]$ необходимо при появлении новых посещённых строк. Это, очевидно, можно сделать за $O(n)$ на одну добавляемую строку (что в сумме даст $O(n^2)$). Также обновлять массив $minv[]$ надо при пересчёте потенциала, что также делается за время $O(n)$ на один пересчёт потенциала (поскольку $minv[]$ меняется только для недостигнутых пока столбцов: а именно, уменьшается на $\Delta$).</p>

</ul>

<p>Таким образом, алгоритм принимает такой вид: во внешнем цикле мы добавляем в рассмотрение строки матрицы одну за другой. Каждая строка обрабатывается за время $O(n^2)$, поскольку при этом могло происходить лишь $O(n)$ пересчётов потенциала (каждый - за время $O(n)$), для чего за время $O(n^2)$ поддерживается массив $minv[]$; алгоритм Куна суммарно отработает за время $O(n^2)$ (поскольку он представлен в форме $O(n)$ итераций, на каждой из которых посещается новый столбец).</p>

<p>Итоговая асимптотика составляет $O(n^3)$ - или, если задача прямоугольна, $O(n^2 m)$.</p>


<h3>Реализация венгерского алгоритма за $O(n^3)$ ($O(n^2 m)$)</h3>

<p>Приведённая реализация фактически была разработана <b>Андреем Лопатиным</b> несколько лет назад. Её отличает удивительная лаконичность: весь алгоритм помещается в <b>30 строк кода</b>.</p>

<p>Данная реализация ищет решение для прямоугольной входной матрицы $a[1 \ldots n][1 \ldots m]$, где $n \le m$. Матрица хранится в $1$-индексации в целях удобства и краткости кода. Дело в том, что в данной реализации вводятся фиктивные нулевая строка и нулевой столбец, что позволяет написать многие циклы в общем виде, без дополнительных проверок.</p>

<p>Массивы $u[0 \ldots n]$ и $v[0 \ldots m]$ хранят потенциал. Изначально он нулевой, что верно для матрицы, состоящей из нуля строк. (Отметим, что для данной реализации не важно, имеются или нет в матрице $a[][]$ отрицательные числа).</p>

<p>Массив $p[0 \ldots m] $ содержит паросочетание: для каждого столбца $i = 1 \ldots m$ он хранит номер соответствующей выбранной строки $p[i]$ (или $0$, если пока ничего не выбрано). При этом $p[0]$ для удобства реализации полагается равным номеру текущей рассматриваемой строки.</p>

<p>Массив $minv[1 \ldots m]$ содержит для каждого столбца $j$ вспомогательные минимумы, необходимые для быстрого пересчёта потенциала:</p>

$$ minv[j] = \min_{i \in Z_1} \{ a[i][j] - u[i] - v[j] \}. $$

<p>Массив $way[1 \ldots m]$ содержит информацию о том, где эти минимумы достигаются, чтобы мы впоследствии смогли восстановить увеличивающую цепочку. На первый взгляд кажется, что в массиве $way[]$ для каждого столбца надо хранить номер строки, а также завести ещё один массив: для каждой строки запомнить номер столбца, из которого мы в неё пришли. Однако вместо этого можно заметить, что алгоритм Куна всегда попадает в строки, проходя по ребру паросочетания из столбцов, поэтому номера строк для восстановления цепочки всегда можно взять из паросочетания (т.е. из массива $p[]$). Таким образом, $way[j]$ для каждого столбца $j$ содержит номер предшествующего столбца (или $0$, если такого нет).</p>

<p>Сам алгоритм представляет из себя внешний <b>цикл по строкам матрицы</b>, внутри которого происходит добавление в рассмотрение $i$-ой строки матрицы. Внутренняя часть представляет собой цикл "do-while (p[j0] != 0)", который работает, пока не будет найден свободный столбец $j0$. Каждая итерация цикла помечает посещённым новый столбец с номером $j0$ (посчитанным на прошлой итерации; а изначально равным нулю - т.е. стартуем мы с фиктивного столбца), а также новую строку $i0$ - смежную ему в паросочетании (т.е. $p[j0]$; а изначально при $j0=0$ берётся $i$-ая строка). Из-за появления новой посещённой строки $i0$ нужно соответствующим образом пересчитать массив $minv[]$, заодно мы находим минимум в нём - величину $delta$, и в каком столбце $j1$ этот минимум был достигнут (заметим, что при такой реализации $delta$ могло оказаться равной нулю, что означает, что на текущем шаге потенциал можно не менять: новый достижимый столбец есть и без того). После этого производится пересчёт потенциала $u[], v[]$, соответствующее изменение массива $minv[]$. По окончании цикла "do-while" мы нашли увеличивающую цепочку, оканчивающуюся в столбце $j0$, "раскрутить" которую можно, пользуясь массивом предков $way[]$.</p>

<p>Константа $INF$ - это "бесконечность", т.е. некоторое число, заведомо большее всех возможных чисел во входной матрице $a[][]$.</p>

\code
vector<int> u (n+1), v (m+1), p (m+1), way (m+1);
for (int i=1; i<=n; ++i) {
    p[0] = i;
    int j0 = 0;
    vector<int> minv (m+1, INF);
    vector<char> used (m+1, false);
    do {
        used[j0] = true;
        int i0 = p[j0],  delta = INF,  j1;
        for (int j=1; j<=m; ++j)
            if (!used[j]) {
                int cur = a[i0][j]-u[i0]-v[j];
                if (cur < minv[j])
                    minv[j] = cur,  way[j] = j0;
                if (minv[j] < delta)
                    delta = minv[j],  j1 = j;
            }
        for (int j=0; j<=m; ++j)
            if (used[j])
                u[p[j]] += delta,  v[j] -= delta;
            else
                minv[j] -= delta;
        j0 = j1;
    } while (p[j0] != 0);
    do {
        int j1 = way[j0];
        p[j0] = p[j1];
        j0 = j1;
    } while (j0);
}
\endcode

<p>Восстановление ответа в более привычной форме, т.е. нахождение для каждой строки $i = 1 \ldots n$ номера выбранного в ней столбца $ans[i]$, делается следующим образом:</p>

\code
vector<int> ans (n+1);
for (int j=1; j<=m; ++j)
    ans[p[j]] = j;
\endcode

<p>Стоимость найденного паросочетания можно просто взять как потенциал нулевого столбца (взятый с противоположным знаком). В самом деле, как легко проследить по коду, $-v[0]$ содержит в себе сумму всех величин $delta$, т.е. суммарное изменение потенциала. Хотя при каждом изменении потенциала изменяться могли сразу несколько величин $u[i]$ и $v[j]$, суммарное изменение величины потенциала в точности равно $delta$, поскольку пока нет увеличивающей цепи, число достижимых строк ровно на единицу больше числа достижимых столбцов (только текущая строка $i$ не имеет себе "пары" в виде посещённого столбца):</p>

\code
int cost = -v[0];
\endcode



<h2>Примеры задач</h2>

<p>Приведём здесь несколько примеров на решение задачи о назначениях: начиная от совсем тривиальных, и заканчивая менее очевидными задачами:</p>

<ul>

<li>Дан двудольный граф, требуется найти в нём паросочетание <b>максимальное паросочетание минимального веса</b> (т.е. в первую очередь максимизируется размер паросочетания, во вторую - минимизируется его стоимость).</li>

<p>Для решения просто строим задачу о назначениях, ставя на месте отсутствующих рёбер число "бесконечность". После этого решаем задачу венгерским алгоритмом, и удаляем из ответа рёбра бесконечного веса (они могли войти в ответ, если у задачи нет решения в виде совершенного паросочетания).</p>

<li>Дан двудольный граф, требуется найти в нём паросочетание <b>максимальное паросочетание максимального веса</b>.</li>

<p>Решение опять же очевидно, только все веса надо умножить на минус единицу (либо в венгерском алгоритме заменить все минимумы на максимумы, а бесконечности - на минус бесконечности).</p>

<li>Задача <b>детектирования движущихся объектов по снимкам</b>: было произведено два снимка, по итогам которых было получено два набор координат. Требуется соотнести объекты на первом и втором снимке, т.е. определить для каждой точки второго снимка, какой точке первого снимка она соответствовала. При этом требуется минимизировать сумму расстояний между сопоставленными точками (т.е. мы ищем решение, в котором объекты суммарно прошли наименьший путь).</li>

<p>Для решения мы просто строим и решаем задачу о назначениях, где в качестве весов рёбер выступают евклидовы расстояния между точками.</p>

<li>Задача <b>детектирования движущихся объектов по локаторам</b>: есть два локатора, которые умеют определять не положение объекта в пространстве, а лишь направление на него. С обоих локаторов (расположенных в различных точках) поступила информация в виде $n$ таких направлений. Требуется определить положение объектов, т.е. определить предполагаемые положения объектов и соответствующие им пары направлений так, чтобы минимизировать сумму расстояний от объектов до лучей-направлений.</li>

<p>Решение - опять же, просто строим и решаем задачу о назначениях, где вершинами первой доли являются $n$ направлений с первого локатора, вершинами второй доли - $n$ направлений со второго локатора, а весами рёбер - расстояния между соответствующими лучами.</p>

<li>Покрытие <b>ориентированного ациклического графа путями</b>: дан ориентированный ациклический граф, требуется найти наименьшее число путей (при равенстве - с наименьшим суммарным весом), чтобы каждая вершина графа лежала бы ровно в одном пути.</li>

<p>Решение - построить по данному графу соответствующий двудольный граф, и найти в нём максимальное паросочетание минимального веса. Более подробно см. <a href="path_cover">отдельную статью</a>.</p>

<li><b>Раскраска дерева</b>. Дано дерево, в котором каждая вершина, кроме листьев, имеет ровно $k-1$ сыновей. Требуется выбрать для каждой вершины некоторый цвет из $k$ цветов так, чтобы никакие две смежные вершины не имели одинакового цвета. Кроме того, для каждой вершины и каждого цвета известна стоимость покраски этой вершины в этот цвет, и требуется минимизировать суммарную стоимость.</li>

<p>Для решения воспользуемся методом динамического программирования. А именно, научимся считать величину $d[v][c]$, где $v$ - номер вершины, $c$ - номер цвета, а само значение $d[v][c]$ - это минимальная стоимость раскраски вершины $v$ вместе с её потомками, причём сама вершина $v$ имеет цвет $c$. Чтобы посчитать такую величину $d[v][c]$, надо распределить остальные $k-1$ цветов по сыновьям вершины $v$, а для этого надо построить и решить задачу о назначениях (в которой вершины одной доли - цвета, вершины другой доли - вершины-сыновья, а веса рёбер - это значения соответствующих динамик $d[][]$).</p>

<p>Таким образом, каждая величина $d[v][c]$ считается с помощью решения задачи о назначениях, что в итоге даёт асимптотику $O(n k^4)$.</p>

<li>Если в задаче о назначениях веса заданы не у рёбер, а у вершин, причём только <b>у вершин одной доли</b>, то можно обойтись без венгерского алгоритма, а достаточно лишь отсортировать вершины по весу и запустить обычный <a href="kuhn_matching">алгоритм Куна</a> (более подробно см. <a href="vertex_weighted_matching">отдельную статью</a>).</li>

<li>Рассмотрим следующий <b>частный случай</b>. Пусть каждой вершине первой доли приписано некоторое число $\alpha[i]$, а каждой вершине второй доли - $\beta[j]$. Пусть вес любого ребра $(i,j)$ равен $\alpha[i] \cdot \beta[j]$ (числа $\alpha[i]$ и $\beta[j]$ нам известны). Решить задачу о назначениях.</li>

<p>Для решения без венгерского алгоритма рассмотрим сначала случай, когда в обеих долях по две вершины. В этом случае, как нетрудно убедиться, выгодно соединять вершины в обратном порядке: вершину с меньшей $\alpha[i]$ соединить с вершиной с большей $\beta[j]$. Это правило легко обобщить на произвольное количество вершин: надо отсортировать вершины первой доли в порядке увеличения $\alpha[i]$, второй доли - в порядке уменьшения $\beta[j]$, и соединять вершины попарно в таком порядке. Таким образом, мы получаем решение с асимптотикой $O(n \log n)$.</p>

<li><b>Задача о потенциалах</b>. Дана матрица $a[1 \ldots n][1 \ldots m]$. Требуется найти два массива $u[1 \ldots n]$ и $v[1 \ldots m]$ такие, что для любых $i$ и $j$ выполняется $u[i] + v[j] \le a[i][j]$, но при этом сумма элементов массивов $u[]$ и $v[]$ максимальна.</li>

<p>Зная венгерский алгоритм, решение этой задачи не составит никакого труда: венгерский алгоритм как раз находит именно такой потенциал $u[], v[]$, который удовлетворяет условию задачи. С другой стороны, без знания венгерского алгоритма решить такую задачу представляется почти невозможным.</p>

</ul>



<h2>Литература</h2>

<ul>

<li>\book{Ravindra Ahuja, Thomas Magnanti, James Orlin}{Network Flows}{1993}{ahuja_flows.djvu}</li>

<li>\book{Harold Kuhn}{The Hungarian Method for the Assignment Problem}{1955}</li>

<li>\book{James Munkres}{Algorithms for Assignment and Transportation Problems}{1957}</li>

</ul>



<h2>Задачи в online judges</h2>

<p>Список задач на решение задачи о назначениях:</p>

<ul>

<li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1687">UVA #10746 <b>"Crime Wave – The Sequel"</b> [сложность: низкая]</a></li>

<li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1829">UVA #10888 <b>"Warehouse"</b> [сложность: средняя]</a></li>

<li><a href="http://livearchive.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1277">UVA #3276 <b>"The Great Wall Game"</b> [сложность: высокая]</a></li>

<li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1237">UVA #10296 <b>"Jogging Trails"</b> [сложность: высокая]</a></li>

</ul>