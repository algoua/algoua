<h1>тест BPSW на простоту чисел</h1>

<hr>

<h2>Введение</h2>
<p>Алгоритм BPSW - это тест числа на простоту. Этот алгоритм назван по фамилиям его изобретателей: Роберт Бэйли (Ballie), Карл Померанс (Pomerance), Джон Селфридж (Selfridge), Сэмюэль Вагстафф (Wagstaff). Алгоритм был предложен в 1980 году. На сегодняшний день к алгоритму не было найдено ни одного контрпримера, равно как и не было найдено доказательство.</p>
<p>Алгоритм BPSW был проверен на всех числах до 10<sup>15</sup>. Кроме того, контрпример пытались найти с помощью программы PRIMO (см. <a href="#6">[6]</a>), основанной на тесте на простоту с помощью эллиптических кривых. Программа, проработав три года, не нашла ни одного контрпримера, на основании чего Мартин предположил, что не существует ни одного BPSW-псевдопростого, меньшего 10<sup>10000</sup> (псевдопростое число - составное число, на котором алгоритм даёт результат "простое"). В то же время, Карл Померанс в 1984 году представил эвристическое доказательство того, что существует бесконечное множество BPSW-псевдопростых чисел.</p>
<p>Сложность алгоритма BPSW есть O (log<sup>3</sup>(N)) битовых операций. Если же сравнивать алгоритм BPSW с другими тестами, например, тестом Миллера-Рабина, то алгоритм BPSW обычно оказывается в 3-7 раз медленнее.</p>
<p>Алгоритм нередко применяется на практике. По-видимому, многие коммерческие математические пакеты, полностью или частично, полагаются на алгоритм BPSW для проверки чисел на простоту.</p>

<hr>

<h2>Краткое описание</h2>
<p>Алгоритм имеет несколько различных реализаций, отличающихся друг от друга только деталями. В нашем случае алгоритм имеет вид:</p>
<p>1. Выполнить тест Миллера-Рабина по основанию 2.</p>
<p>2. Выполнить сильный тест Лукаса-Селфриджа, используя последовательности Лукаса с параметрами Селфриджа.</p>
<p>3. Вернуть "простое" только в том случае, когда оба теста вернули "простое".</p>
<p>+0. Кроме того, в начало алгоритма можно добавить проверку на тривиальные делители, скажем, до 1000. Это позволит увеличить скорость работы на составных числах, правда, несколько замедлив алгоритм на простых.</p>
<p>Итак, алгоритм BPSW основывается на следующем:</p>
<p>1. (факт) тест Миллера-Рабина и тест Лукаса-Селфриджа если и ошибаются, то только в одну сторону: некоторые составные числа этими алгоритмами опознаются как простые. В обратную сторону эти алгоритмы не ошибаются никогда.</p>
<p>2. (предположение) тест Миллера-Рабина и тест Лукаса-Селфриджа если и ошибаются, то никогда не ошибаются на одном числе одновременно.</p>
<p>На самом деле, второе предположение вроде бы как и неверно - эвристическое доказательство-опровержение Померанса приведено ниже. Тем не менее, на практике ни одного псевдопростого до сих пор не нашли, поэтому условно можно считать второе предположение верным.</p>

<hr>

<h2>Реализация алгоритмов в данной статье</h2>
<p>Все алгоритмы в данной статье будут реализованы на C++. Все программы тестировались только на компиляторе Microsoft C++ 8.0 SP1 (2005), также должны компилироваться на g++.</p>
<p>Алгоритмы реализованы с использованием шаблонов (templates), что позволяет применять их как к встроенным числовым типам, так и собственным классам, реализующим длинную арифметику. [ пока длинная арифметика в статью не входит - TODO ]</p>
<p>В самой статье будут приведены только самые существенные функции, тексты же вспомогательных функций можно скачать в приложении к статье. Здесь будут приведены только заголовки этих функций вместе с комментариями:</p>
<code>//! Модуль 64-битного числа
long long <b>abs</b> (long long n);
unsigned long long abs (unsigned long long n);

//! Возвращает true, если n четное
template &lt;class T>
bool <b>even</b> (const T & n);

//! Делит число на 2
template &lt;class T>
void <b>bisect</b> (T & n);

//! Умножает число на 2
template &lt;class T>
void <b>redouble</b> (T & n);

//! Возвращает true, если n - точный квадрат простого числа
template &lt;class T>
bool <b>perfect_square</b> (const T & n);

//! Вычисляет корень из числа, округляя его вниз
template &lt;class T>
T <b>sq_root</b> (const T & n);

//! Возвращает количество бит в числе
template &lt;class T>
unsigned <b>bits_in_number</b> (T n);

//! Возвращает значение k-го бита числа (биты нумеруются с нуля)
template &lt;class T>
bool <b>test_bit</b> (const T & n, unsigned k);

//! Умножает a *= b (mod n)
template &lt;class T>
void <b>mulmod</b> (T & a, T b, const T & n);

//! Вычисляет a^k (mod n)
template &lt;class T, class T2>
T <b>powmod</b> (T a, T2 k, const T & n);

//! Переводит число n в форму q*2^p
template &lt;class T>
void <b>transform_num</b> (T n, T & p, T & q);

//! Алгоритм Евклида
template &lt;class T, class T2>
T <b>gcd</b> (const T & a, const T2 & b);

//! Вычисляет jacobi(a,b) - символ Якоби
template &lt;class T>
T <b>jacobi</b> (T a, T b)

//! Вычисляет pi(b) первых простых чисел. Возвращает вектор с простыми и в pi - pi(b)
template &lt;class T, class T2>
const std::vector<T> & <b>get_primes</b> (const T & b, T2 & pi);

//! Тривиальная проверка n на простоту, перебираются все делители до m.
//! Результат: 1 - если n точно простое, p - его найденный делитель, 0 - если неизвестно
template &lt;class T, class T2>
T2 <b>prime_div_trivial</b> (const T & n, T2 m);</code>

<hr>

<h2>Тест Миллера-Рабина</h2>
<p>Я не буду заострять внимание на тесте Миллера-Рабина, поскольку он описывается во многих источниках, в том числе и на русском языке (например. см. <a href="#5">[5]</a>).</p>
<p>Замечу лишь, что скорость его работы есть O (log<sup>3</sup>(N)) битовых операций и приведу готовую реализацию этого алгоритма:</p>
<code>template &lt;class T, class T2>
bool miller_rabin (T n, T2 b)
{

    // сначала проверяем тривиальные случаи
    if (n == 2)
        return true;
    if (n &lt; 2 || even (n))
        return false;

    // проверяем, что n и b взаимно просты (иначе это приведет к ошибке)
    // если они не взаимно просты, то либо n не просто, либо нужно увеличить b
    if (b &lt; 2)
        b = 2;
    for (T g; (g = gcd (n, b)) != 1; ++b)
        if (n > g)
            return false;

    // разлагаем n-1 = q*2^p
    T n_1 = n;
    --n_1;
    T p, q;
    transform_num (n_1, p, q);

    // вычисляем b^q mod n, если оно равно 1 или n-1, то n простое (или псевдопростое)
    T rem = powmod (T(b), q, n);
    if (rem == 1 || rem == n_1)
        return true;

    // теперь вычисляем b^2q, b^4q, ... , b^((n-1)/2)
    // если какое-либо из них равно n-1, то n простое (или псевдопростое)
    for (T i=1; i&lt;p; i++)
    {
        mulmod (rem, rem, n);
        if (rem == n_1)
            return true;
    }

    return false;

}</code>

<hr>

<h2>Сильный тест Лукаса-Селфриджа</h2>
<p>Сильный тест Лукаса-Селфриджа состоит из двух частей: алгоритма Селфриджа для вычисления некоторого параметра, и сильного алгоритма Лукаса, выполняемого с этим параметром.</p>
<h3>Алгоритм Селфриджа</h3>
<p>Среди последовательности 5, -7, 9, -11, 13, ... найти первое число D, для которого J (D, N) = -1 и gcd (D, N) = 1, где J(x,y) - символ Якоби.</p>
<p><b>Параметрами Селфриджа</b> будут P = 1 и Q = (1 - D) / 4.</p>
<p>Следует заметить, что параметр Селфриджа не существует для чисел, которые являются точными квадратами. Действительно, если число является точным квадратом, то перебор D дойдёт до sqrt(N), на котором окажется, что gcd (D, N) > 1, т.е. обнаружится, что число N составное.</p>
<p>Кроме того, параметры Селфриджа будут вычислены неправильно для чётных чисел и для единицы; впрочем, проверка этих случаев не составит труда.</p>
<p>Таким образом, <b>перед началом алгоритма</b> следует проверить, что число N является нечётным, большим 2, и не является точным квадратом, иначе (при невыполнении хотя бы одного условия) нужно сразу выйти из алгоритма с результатом "составное".</p>
<p>Наконец, заметим, что если D для некоторого числа N окажется слишком большим, то алгоритм с вычислительной точки зрения окажется неприменимым. Хотя на практике такого замечено не было (оказывалось вполне достаточно 4-байтного числа), тем не менее вероятность этого события не следует исключать. Впрочем, например, на отрезке [1; 10<sup>6</sup>] max(D) = 47, а на отрезке [10<sup>19</sup>; 10<sup>19</sup>+10<sup>6</sup>] max(D) = 67. Кроме того, Бэйли и Вагстаф в 1980 году аналитически доказали это наблюдение (см. Ribenboim, 1995/96, стр. 142).</p>
<h3>Сильный алгоритм Лукаса</h3>
<p><b>Параметрами алгоритма</b> Лукаса являются числа <b>D, P и Q</b> такие, что D = P<sup>2</sup> - 4*Q ? 0, и P > 0.</p>
<p>(нетрудно заметить, что параметры, вычисленные по алгоритму Селфриджа, удовлетворяют этим условиям)</p>
<p><b>Последовательности Лукаса</b> - это последовательности U<sub>k</sub> и V<sub>k</sub>, определяемые следующим образом:</p>
<formula>U<sub>0</sub> = 0
U<sub>1</sub> = 1
<p><b>U<sub>k</sub> = P U<sub>k-1</sub> - Q U<sub>k-2</sub></b></p>
V<sub>0</sub> = 2
V<sub>1</sub> = P
<b>V<sub>k</sub> = P V<sub>k-1</sub> - Q V<sub>k-2</sub></b></formula>
<p>Далее, пусть M = N - J (D, N).</p>
<p>Если N простое, и gcd (N, Q) = 1, то имеем:</p>
<formula><b>U<sub>M</sub> = 0 (mod N)</b></formula>
<p>В частности, когда параметры D, P, Q вычислены алгоритмом Селфриджа, имеем:</p>
<formula>U<sub>N+1</sub> = 0 (mod N)</b></formula>
<p>Обратное, вообще говоря, неверно. Тем не менее, псевдопростых чисел при данном алгоритме оказывается не очень много, на чём, собственно, и основывается алгоритм Лукаса.</p>
<p>Итак, <b>алгоритм Лукаса заключается в вычислении U<sub>M</sub> и сравнении его с нулём</b>.</p>
<p>Далее, необходимо найти какой-то способ ускорения вычисления U<sub>K</sub>, иначе, понятно, никакого практического смысла в этом алгоритма не было бы.</p>
<p>Имеем:</p>
<formula>U<sub>k</sub> = (a<sup>k</sup> - b<sup>k</sup>) / (a - b),
V<sub>k</sub> = a<sup>k</sup> + b<sup>k</sup>,</formula>
<p>где a и b - различные корни квадратного уравнения x<sup>2</sup> - P x + Q = 0.</p>
<p>Теперь следующие равенства можно доказать элементарно:</p>
<formula>U<sub>2k</sub> = U<sub>k</sub> V<sub>k</sub> (mod N)
V<sub>2k</sub> = V<sub>k</sub><sup>2</sup> - 2 Q<sup>k</sup> (mod N)</formula>
<p>Теперь, если представить M = E 2<sup>T</sup>, где E - нечётное число, то легко получить:</p>
<formula><b>U<sub>M</sub> = U<sub>E</sub> V<sub>E</sub> V<sub>2E</sub> V<sub>4E</sub> ... V<sub>2<sup>T-2</sup>E</sub> V<sub>2<sup>T-1</sup>E</sub> = 0 (mod N)</b>,</formula>
<p>и хотя бы один из множителей равен нулю по модулю N.</p>
<p>Понятно, что <b>достаточно вычислить U<sub>E</sub> и V<sub>E</sub></b>, а все последующие множители V<sub>2E</sub> V<sub>4E</sub> ... V<sub>2<sup>T-2</sup>E</sub> V<sub>2<sup>T-1</sup>E</sub> можно <b>получить уже из них</b>.</p>
<p>Таким образом, осталось научиться быстро вычислять U<sub>E</sub> и V<sub>E</sub> для нечётного E.</p>
<p>Сначала рассмотрим следующие формулы для сложения членов последовательностей Лукаса:</p>
<formula>U<sub>i+j</sub> = (U<sub>i</sub> V<sub>j</sub> + U<sub>j</sub> V<sub>i</sub>) / 2 (mod N)
V<sub>i+j</sub> = (V<sub>i</sub> V<sub>j</sub> + D U<sub>i</sub> U<sub>j</sub>) / 2 (mod N)</formula>
<p>Следует обратить внимание, что деление выполняется в поле (mod N).</p>
<p>Формулы эти доказываются очень просто, и здесь их доказательство опущено.</p>
<p>Теперь, обладая формулами для сложения и для удвоения членов последовательностей Лукаса, понятен и способ ускорения вычисления U<sub>E</sub> и V<sub>E</sub>.</p>
<p>Действительно, рассмотрим двоичную запись числа E. Положим сначала результат - U<sub>E</sub> и V<sub>E</sub> - равными, соответственно, U<sub>1</sub> и V<sub>1</sub>. Пройдёмся по всем битам числа E от более младших к более старшим, пропустив только самый первый бит (начальный член последовательности). Для каждого i-го бита будем вычислять U<sub>2<sup> i</sup></sub> и V<sub>2<sup> i</sup></sub> из предыдущих членов с помощью формул удвоения. Кроме того, если текущий i-ый бит равен единице, то к ответу будем прибавлять текущие U<sub>2<sup> i</sup></sub> и V<sub>2<sup> i</sup></sub> с помощью формул сложения. По окончании алгоритма, выполняющегося за O (log(E)), мы <b>получим искомые U<sub>E</sub> и V<sub>E</sub></b>.</p>
<p>Если U<sub>E</sub> или V<sub>E</sub> оказались равными нулю (mod N), то число N простое (или псевдопростое). Если они оба отличны от нуля, то вычисляем V<sub>2E</sub>, V<sub>4E</sub>, ... V<sub>2<sup>T-2</sup>E</sub>, V<sub>2<sup>T-1</sup>E</sub>. Если хотя бы один из них сравним с нулём по модулю N, то число N простое (или псевдопростое). Иначе число N составное.</p>
<h3>Обсуждение алгоритма Селфриджа</h3>
<p>Теперь, когда мы рассмотрели алгоритм Лукаса, можно более подробно остановиться на его параметрах D,P,Q, одним из способов получения которых и является алгоритм Селфриджа.</p>
<p>Напомним базовые требования к параметрам:</p>
<formula><b>P > 0</b>,
<b>D = P<sup>2</sup> - 4*Q ? 0</b>.</formula>
<p>Теперь продолжим изучение этих параметров.</p>
<p><b>D не должно быть точным квадратом (mod N)</b>.</p>
<p>Действительно, иначе получим:</p>
<p>D = b<sup>2</sup>, отсюда J(D,N) = 1, P = b + 2, Q = b + 1, отсюда U<sub>n-1</sub> = (Q<sup>n-1</sup> - 1) / (Q - 1).</p>
<p>Т.е. если D - точный квадрат, то алгоритм Лукаса становится практически обычным вероятностным тестом.</p>
<p>Один из лучших способов избежать подобного - <b>потребовать, чтобы J(D,N) = -1</b>.</p>
<p>Например, можно выбрать первое число D из последовательности 5, -7, 9, -11, 13, ..., для которого J(D,N) = -1. Также пусть P = 1. Тогда Q = (1 - D) / 4. Этот способ был предложен Селфриджем.</p>
<p>Впрочем, имеются и другие способы выбора D. Можно выбирать его из последовательности 5, 9, 13, 17, 21, ... Также пусть P - наименьшее нечётное, привосходящее sqrt(D). Тогда Q = (P<sup>2</sup> - D) / 4.</p>
<p>Понятно, что от выбора конкретного способа вычисления параметров Лукаса зависит и его результат - псевдопростые могут отличаться при различных способах выбора параметра. Как показала практика, алгоритм, предложенный Селфриджем, оказался очень удачным: все псевдопростые Лукаса-Селфриджа не являются псевдопростыми Миллера-Рабина, по крайней мере, ни одного контрпримера найдено не было.</p>
<h3>Реализация сильного алгоритма Лукаса-Селфриджа</h3>
<p>Теперь осталось только реализовать алгоритм:</p>
<code>template &lt;class T, class T2>
bool lucas_selfridge (const T & n, T2 unused)
{

    // сначала проверяем тривиальные случаи
    if (n == 2)
        return true;
    if (n &lt; 2 || even (n))
        return false;

    // проверяем, что n не является точным квадратом, иначе алгоритм даст ошибку
    if (perfect_square (n))
        return false;

    // алгоритм Селфриджа: находим первое число d такое, что:
    // jacobi(d,n)=-1 и оно принадлежит ряду { 5,-7,9,-11,13,... }
    T2 dd;
    for (T2 d_abs = 5, d_sign = 1; ; d_sign = -d_sign, ++++d_abs)
    {
        dd = d_abs * d_sign;
        T g = gcd (n, d_abs);
        if (1 &lt; g && g &lt; n)
            // нашли делитель - d_abs
            return false;
        if (jacobi (T(dd), n) == -1)
            break;
    }

    // параметры Селфриджа
    T2
        p = 1,
        q = (p*p - dd) / 4;
    
    // разлагаем n+1 = d*2^s
    T n_1 = n;
    ++n_1;
    T s, d;
    transform_num (n_1, s, d);

    // алгоритм Лукаса
    T
        u = 1,
        v = p,
        u2m = 1,
        v2m = p,
        qm = q,
        qm2 = q*2,
        qkd = q;
    for (unsigned bit = 1, bits = bits_in_number(d); bit &lt; bits; bit++)
    {
        mulmod (u2m, v2m, n);
        mulmod (v2m, v2m, n);
        while (v2m < qm2)
            v2m += n;
        v2m -= qm2;
        mulmod (qm, qm, n);
        qm2 = qm;
        redouble (qm2);
        if (test_bit (d, bit))
        {
            T t1, t2;
            t1 = u2m;
            mulmod (t1, v, n);
            t2 = v2m;
            mulmod (t2, u, n);
            
            T t3, t4;
            t3 = v2m;
            mulmod (t3, v, n);
            t4 = u2m;
            mulmod (t4, u, n);
            mulmod (t4, (T)dd, n);

            u = t1 + t2;
            if (!even (u))
                u += n;
            bisect (u);
            u %= n;

            v = t3 + t4;
            if (!even (v))
                v += n;
            bisect (v);
            v %= n;
            mulmod (qkd, qm, n);
        }
    }

    // точно простое (или псевдо-простое)
    if (u == 0 || v == 0)
        return true;

    // довычисляем оставшиеся члены
    T qkd2 = qkd;
    redouble (qkd2);
    for (T2 r = 1; r &lt; s; ++r)
    {
        mulmod (v, v, n);
        v -= qkd2;
        if (v &lt; 0) v += n;
        if (v &lt; 0) v += n;
        if (v >= n) v -= n;
        if (v >= n) v -= n;
        if (v == 0)
            return true;
        if (r &lt; s-1)
        {
            mulmod (qkd, qkd, n);
            qkd2 = qkd;
            redouble (qkd2);
        }
    }

    return false;

}</code>

<hr>

<h2>Код BPSW</h2>
<p>Теперь осталось просто скомбинировать результаты всех 3 тестов: проверка на небольшие тривиальные делители, тест Миллера-Рабина, сильный тест Лукаса-Селфриджа.</p>
<code>template &lt;class T>
bool baillie_pomerance_selfridge_wagstaff (T n)
{

    // сначала проверяем на тривиальные делители - например, до 29
    int div = prime_div_trivial (n, 29);
    if (div == 1)
        return true;
    if (div > 1)
        return false;

    // тест Миллера-Рабина по основанию 2
    if (!miller_rabin (n, 2))
        return false;

    // сильный тест Лукаса-Селфриджа
    return lucas_selfridge (n, 0);

}</code>
<p><a href=BPSW_main.zip>Отсюда</a> можно скачать программу (исходник + exe), содержащую полную реализацию теста BPSW. [77 КБ]</p>

<hr>

<h2>Краткая реализация</h2>
<p>Длину кода можно значительно уменьшить в ущерб универсальности, отказавшись от шаблонов и различных вспомогательных функций.</p>
<code>const int trivial_limit = 50;
int p[1000];

int gcd (int a, int b) {
    return a ? gcd (b%a, a) : b;
}

int powmod (int a, int b, int m) {
    int res = 1;
    while (b)
        if (b & 1)
            res = (res * 1ll * a) % m,  --b;
        else
            a = (a * 1ll * a) % m,  b >>= 1;
    return res;
}

bool miller_rabin (int n) {
    int b = 2;
    for (int g; (g = gcd (n, b)) != 1; ++b)
        if (n > g)
            return false;
    int p=0, q=n-1;
    while ((q & 1) == 0)
        ++p,  q >>= 1;
    int rem = powmod (b, q, n);
    if (rem == 1 || rem == n-1)
        return true;
    for (int i=1; i&lt;p; ++i) {
        rem = (rem * 1ll * rem) % n;
        if (rem == n-1)  return true;
    }
    return false;
}

int jacobi (int a, int b)
{
    if (a == 0)  return 0;
    if (a == 1)  return 1;
    if (a &lt; 0)
        if ((b & 2) == 0)
            return jacobi (-a, b);
        else
            return - jacobi (-a, b);
    int a1=a,  e=0;
    while ((a1 & 1) == 0)
        a1 >>= 1,  ++e;
    int s;
    if ((e & 1) == 0 || (b & 7) == 1 || (b & 7) == 7)
        s = 1;
    else
        s = -1;
    if ((b & 3) == 3 && (a1 & 3) == 3)
        s = -s;
    if (a1 == 1)
        return s;
    return s * jacobi (b % a1, a1);
}

bool bpsw (int n) {
    if ((int)sqrt(n+0.0) * (int)sqrt(n+0.0) == n)  return false;
    int dd=5;
    for (;;) {
        int g = gcd (n, abs(dd));
        if (1&lt;g && g&lt;n)  return false;
        if (jacobi (dd, n) == -1)  break;
        dd = dd&lt;0 ? -dd+2 : -dd-2;
    }
    int p=1,  q=(p*p-dd)/4;
    int d=n+1,  s=0;
    while ((d & 1) == 0)
        ++s,  d>>=1;
    long long u=1, v=p, u2m=1, v2m=p, qm=q, qm2=q*2, qkd=q;
    for (int mask=2; mask&lt;=d; mask&lt;&lt;=1) {
        u2m = (u2m * v2m) % n;
        v2m = (v2m * v2m) % n;
        while (v2m < qm2)   v2m += n;
        v2m -= qm2;
        qm = (qm * qm) % n;
        qm2 = qm * 2;
        if (d & mask) {
            long long t1 = (u2m * v) % n,  t2 = (v2m * u) % n,
                t3 = (v2m * v) % n,  t4 = (((u2m * u) % n) * dd) % n;
            u = t1 + t2;
            if (u & 1)  u += n;
            u = (u >> 1) % n;
            v = t3 + t4;
            if (v & 1)  v += n;
            v = (v >> 1) % n;
            qkd = (qkd * qm) % n;
        }
    }
    if (u==0 || v==0)  return true;
    long long qkd2 = qkd*2;
    for (int r=1; r&lt;s; ++r) {
        v = (v * v) % n - qkd2;
        if (v &lt; 0)  v += n;
        if (v &lt; 0)  v += n;
        if (v >= n)  v -= n;
        if (v >= n)  v -= n;
        if (v == 0)  return true;
        if (r &lt; s-1) {
            qkd = (qkd * 1ll * qkd) % n;
            qkd2 = qkd * 2;
        }
    }
    return false;
}

bool prime (int n) { // эту функцию нужно вызывать для проверки на простоту
    for (int i=0; i&lt;trivial_limit && p[i]&lt;n; ++i)
        if (n % p[i] == 0)
            return false;
    if (p[trivial_limit-1]*p[trivial_limit-1] >= n)
        return true;
    if (!miller_rabin (n))
        return false;
    return bpsw (n);
}

void prime_init() { // вызвать до первого вызова prime() !
    for (int i=2, j=0; j&lt;trivial_limit; ++i) {
        bool pr = true;
        for (int k=2; k*k&lt;=i; ++k)
            if (i % k == 0)
                pr = false;
        if (pr)
            p[j++] = i;
    }
}</code>

<hr>

<h2>Эвристическое доказательство-опровержение Померанса</h2>
<p>Померанс в 1984 году предложил следующее эвристическое доказательство.</p>
<p>Утверждение: <b>Количество BPSW-псевдопростых от 1 до X больше X<sup>1-a</sup> для любого a > 0</b>.</p>
<p>Доказательство.</p>
<p>Пусть k > 4 - произвольное, но фиксированное число. Пусть T - некоторое большое число.</p>
<p>Пусть P<sub>k</sub>(T) - множество таких простых p в интервале [T; T<sup>k</sup>], для которых:</p>
<p>(1) p = 3 (mod 8), J(5,p) = -1</p>
<p>(2) число (p-1)/2 не является точным квадратом</p>
<p>(3) число (p-1)/2 составлено исключительно из простых q < T
<p>(4) число (p-1)/2 составлено исключительно из таких простых q, что q = 1 (mod 4)</p>
<p>(5) число (p+1)/4 не является точным квадратом</p>
<p>(6) число (p+1)/4 составлено исключительно из простых d < T</p>
<p>(7) число (p+1)/4 составлено исключительно из таких простых d, что q = 3 (mod 4)</p>
<p>Понятно, что приблизительно 1/8 всех простых в отрезке [T; T<sup>k</sup>] удовлетворяет условию (1). Также можно показать, что условия (2) и (5) сохраняют некоторую часть чисел. Эвристически, условия (3) и (6) также позволяют нам оставить некоторую часть чисел из отрезка (T; T<sup>k</sup>). Наконец, событие (4) обладает вероятностью (c (log T)<sup>-1/2</sup>), так же как и событие (7). Таким образом, мощность множества P<sub>k</sub>(T) прблизительно равна при T -> oo</p>
<p><img src=BPSW_formula1.jpg></p>
<p>где c - некоторая положительная константа, зависящая от выбора k.</p>
<p>Теперь мы <b>можем построить число n</b>, не являющееся точным квадратом, составленное из l простых из P<sub>k</sub>(T), где l нечётно и меньше T<sup>2</sup> / log(T<sup>k</sup>). Количество способов выбрать такое число n есть примерно</p>
<p><img src=BPSW_formula2.jpg></p>
<p>для большого T и фиксированного k. Кроме того, каждое такое число n меньше e<sup>T<sup>2</sup></sup>.</p>
<p>Обозначим через Q<sub>1</sub> произведение простых q < T, для которых q = 1 (mod 4), а через Q<sub>3</sub> - произведение простых q < T, для которых q = 3 (mod 4). Тогда gcd (Q<sub>1</sub>, Q<sub>3</sub>) = 1 и Q<sub>1</sub> Q<sub>3</sub> ? e<sup>T</sup>. Таким образом, количество способов выбрать n <b>с дополнительными условиями</b></p>
<formula>n = 1 (mod Q<sub>1</sub>), n = -1 (mod Q<sub>3</sub>)</formula>
<p>должно быть, эвристически, как минимум</p>
<formula>e<sup>T<sup> 2</sup> (1 - 3 / k)</sup> / e<sup> 2T</sup> > <b>e<sup>T<sup> 2</sup> (1 - 4 / k)</sup></b></formula>
<p>для большого T.</p>
<p>Но <b>каждое такое n - это контрпример к тесту BPSW</b>. Действительно, n будет числом Кармайкла (т.е. числом, на котором тест Миллера-Рабина будет ошибаться при любом основании), поэтому оно автоматически будет псевдопростым по основанию 2. Поскольку n = 3 (mod 8) и каждое p | n равно 3 (mod 8), очевидно, что n также будет сильным псевдопростым по основанию 2. Поскольку J(5,n) = -1, то каждое простое p | n удовлетворяет J(5,p) = -1, и так как p+1 | n+1 для любого простого p | n, отсюда следует, что n - псевдопростое Лукаса для любого теста Лукаса с дискриминантом 5.</p>
<p>Таким образом, мы показали, что для любого фиксированного k и всех больших T, будет как минимум e<sup>T<sup> 2</sup> (1 - 4 / k)</sup> контрпримеров к тесту BPSW среди чисел, меньших e<sup>T<sup> 2</sup></sup>. Теперь, если мы положим x = e<sup>T<sup> 2</sup></sup>, будет как минимум x<sup>1 - 4 / k</sup> контрпримеров, меньших x. Поскольку k - случайное число, то наше доказательство означает, что <b>количество контрпримеров, меньших x, есть число, большее x<sup>1-a</sup> для любого a > 0</b>.</p>

<hr>

<h2>Практические испытания теста BPSW</h2>
<p>В этом разделе будут рассмотрены результаты, полученные мной в результате тестирования моей реализации теста BPSW. Все испытания проводились на встроенном типе - 64-битном числе long long. Длинная арифметика не тестировалась.</p>
<p>Тестирования проводились на компьютере с процессором Celeron 1.3 GHz.</p>
<p>Все времена даны в <b>микросекундах</b> (10<sup> -6</sup> сек).</p>

<h3>Среднее время работы на отрезке чисел в зависимости от предела тривиального перебора</h3>
<p>Имеется в виду параметр, передаваемый функции prime_div_trivial(), который в коде выше равен 29.</p>
<p><a href="BPSW_test_1.zip">Скачать</a> тестовую программу (исходник и exe-файл). [83 КБ]</p>
<p>Если запускать тест <b>на всех нечетных числах</b> из отрезка, то результаты получаются такими:</p>
<table class=table2 cellspacing=0>
<tr><th>начало<br>отрезка</th><th>конец<br>отрезка</th><th>предел ><br>перебора ></th><th width=13%>0</th><th width=13%>10<sup>2</sup></th><th width=13%>10<sup>3</sup></th><th width=13%>10<sup>4</sup></th><th width=13%>10<sup>5</sup></th></tr>
<tr><td>1</td><td>10<sup>5</sup></td><td></td><td>8.1</td><td>4.5</td><td>0.7</td><td>0.7</td><td>0.9</td></tr>
<tr><td>10<sup>6</sup></td><td>10<sup>6</sup>+10<sup>5</sup></td><td></td><td>12.8</td><td>6.8</td><td>7.0</td><td>1.6</td><td>1.6</td>
<tr><td>10<sup>9</sup></td><td>10<sup>9</sup>+10<sup>5</sup></td><td></td><td>28.4</td><td>12.6</td><td>12.1</td><td>17.0</td><td>17.1</td></tr>
<tr><td>10<sup>12</sup></td><td>10<sup>12</sup>+10<sup>5</sup></td><td></td><td>41.5</td><td>16.5</td><td>15.3</td><td>19.4</td><td>54.4</td></tr>
<tr><td>10<sup>15</sup></td><td>10<sup>15</sup>+10<sup>5</sup></td><td></td><td>66.7</td><td>24.4</td><td>21.1</td><td>24.8</td><td>58.9</td></tr>
</table>
<p>Если запускать тест <b>только на простых числах</b> из отрезка, то скорость работы такова:</p>
<table class=table2 cellspacing=0>
<tr><th>начало<br>отрезка</th><th>конец<br>отрезка</th><th>предел ><br>перебора ></th><th width=13%>0</th><th width=13%>10<sup>2</sup></th><th width=13%>10<sup>3</sup></th><th width=13%>10<sup>4</sup></th><th width=13%>10<sup>5</sup></th></tr>
<tr><td>1</td><td>10<sup>5</sup></td><td></td><td>42.9</td><td>40.8</td><td>3.1</td><td>4.2</td><td>4.2</td></tr>
<tr><td>10<sup>6</sup></td><td>10<sup>6</sup>+10<sup>5</sup></td><td></td><td>75.0</td><td>76.4</td><td>88.8</td><td>13.9</td><td>15.2</td>
<tr><td>10<sup>9</sup></td><td>10<sup>9</sup>+10<sup>5</sup></td><td></td><td>186.5</td><td>188.5</td><td>201.0</td><td>294.3</td><td>283.9</td></tr>
<tr><td>10<sup>12</sup></td><td>10<sup>12</sup>+10<sup>5</sup></td><td></td><td>288.3</td><td>288.3</td><td>302.2</td><td>387.9</td><td>1069.5</td></tr>
<tr><td>10<sup>15</sup></td><td>10<sup>15</sup>+10<sup>5</sup></td><td></td><td>485.6</td><td>489.1</td><td>496.3</td><td>585.4</td><td>1267.4</td></tr>
</table>
<p>Таким образом, оптимально выбирать <b>предел тривиального перебора равным 100 или 1000</b>.</p>
<p>Для всех следующих тестов я выбрал предел 1000.</p>

<h3>Среднее время работы на отрезке чисел</h3>
<p>Теперь, когда мы выбрали предел тривиального перебора, можно более точно протестировать скорость работы на различных отрезках.</p>
<p><a href=BPSW_test2.zip>Скачать</a> тестовую программу (исходник и exe-файл). [83 КБ]</p>
<table class=table1 cellspacing=0>
<tr><th width=100>начало<br>отрезка</th><th width=100>конец<br>отрезка</th><th width=200>время работы<br>на нечетных числах</th><th width=200>время работы<br>на простых числах</th></tr>
<tr><td>1</td><td>10<sup>5</sup></td><td>1.2</td><td>4.2</td></tr>
<tr><td>10<sup>6</sup></td><td>10<sup>6</sup>+10<sup>5</sup></td><td>13.8</td><td>88.8</td></tr>
<tr><td>10<sup>7</sup></td><td>10<sup>7</sup>+10<sup>5</sup></td><td>16.8</td><td>115.5</td></tr>
<tr><td>10<sup>8</sup></td><td>10<sup>8</sup>+10<sup>5</sup></td><td>21.2</td><td>164.8</td></tr>
<tr><td>10<sup>9</sup></td><td>10<sup>9</sup>+10<sup>5</sup></td><td>24.0</td><td>201.0</td></tr>
<tr><td>10<sup>10</sup></td><td>10<sup>10</sup>+10<sup>5</sup></td><td>25.2</td><td>225.5</td></tr>
<tr><td>10<sup>11</sup></td><td>10<sup>11</sup>+10<sup>5</sup></td><td>28.4</td><td>266.5</td></tr>
<tr><td>10<sup>12</sup></td><td>10<sup>12</sup>+10<sup>5</sup></td><td>30.4</td><td>302.2</td></tr>
<tr><td>10<sup>13</sup></td><td>10<sup>13</sup>+10<sup>5</sup></td><td>33.0</td><td>352.2</td></tr>
<tr><td>10<sup>14</sup></td><td>10<sup>14</sup>+10<sup>5</sup></td><td>37.5</td><td>424.3</td></tr>
<tr><td>10<sup>15</sup></td><td>10<sup>15</sup>+10<sup>5</sup></td><td>42.3</td><td>499.8</td></tr>
<tr><td>10<sup>16</sup></td><td>10<sup>15</sup>+10<sup>5</sup></td><td>46.5</td><td>553.6</td></tr>
<tr><td>10<sup>17</sup></td><td>10<sup>15</sup>+10<sup>5</sup></td><td>48.9</td><td>621.1</td></tr>
</table>
<p>Или, в виде графика, приблизительное время работы теста BPSW на одном числе:</p>
<p><img src=BPSW_graph1.gif></p>
<p>То есть мы получили, что на практике, на небольших числах (до 10<sup>17</sup>), <b>алгоритм работает за O (log N)</b>. Это объясняется тем, что для встроенного типа int64 операция деления выполняется за O(1), т.е. сложность деления не зависисит от количества битов в числе.</p>
<p>Если же применить тест BPSW к длинной арифметике, то ожидается, что он будет работать как раз за O (log<sup>3</sup>(N)). [ TODO ]</p>

<hr>

<h2>Приложение. Все программы</h2>
<p><a href=BPSW_all.zip>Скачать</a> все программы из данной статьи. [242 КБ]</p>

<hr>

<h2>Литература</h2>
<p>Использованная мной литература, полностью доступная в Интернете:</p>
<ol>
<li>Robert Baillie; Samuel S. Wagstaff<br><b>Lucas pseudoprimes</b><br>Math. Comp. 35 (1980) 1391-1417<br><a href="http://mpqs.free.fr/LucasPseudoprimes.pdf">mpqs.free.fr/LucasPseudoprimes.pdf</a><br>&nbsp;</li>
<li>Daniel J. Bernstein<br><b>Distinguishing prime numbers from composite numbers: the state of the art in 2004</b><br>Math. Comp. (2004)<br><a href="http://cr.yp.to/primetests/prime2004-20041223.pdf">cr.yp.to/primetests/prime2004-20041223.pdf</a><br>&nbsp;</li>
<li>Richard P. Brent<br><b>Primality Testing and Integer Factorisation</b><br>The Role of Mathematics in Science (1990)<br><a href="http://wwwmaths.anu.edu.au/~brent/pd/rpb120.pdf">wwwmaths.anu.edu.au/~brent/pd/rpb120.pdf</a><br>&nbsp;</li>
<li>H. Cohen; H. W. Lenstra<br><b>Primality Testing and Jacobi Sums</b><br>Amsterdam (1984)<br><a href="https://www.openaccess.leidenuniv.nl/bitstream/1887/2136/1/346_065.pdf">www.openaccess.leidenuniv.nl/bitstream/1887/2136/1/346_065.pdf</a><br>&nbsp;</li>
<li><a name=5></a>Thomas H. Cormen; Charles E. Leiserson; Ronald L. Rivest<br><b>Introduction to Algorithms</b><br>[ без ссылки ]<br>The MIT Press (2001)<br>&nbsp;</li>
<li><a name=6></a>M. Martin<br><b>PRIMO - Primality Proving</b><br><a href="http://www.ellipsa.net/">www.ellipsa.net</a><br>&nbsp;</li>
<li>F. Morain<br><b>Elliptic curves and primality proving</b><br>Math. Comp. 61(203) (1993)<br><a href="http://citeseer.ist.psu.edu/rd/43190198%2C72628%2C1%2C0.25%2CDownload/ftp%3AqSqqSqftp.inria.frqSqINRIAqSqpublicationqSqpubli-ps-gzqSqRRqSqRR-1256.ps.gz">citeseer.ist.psu.edu/rd/43190198%2C72628%2C1%2C0.25%2CDownload/ftp%3AqSqqSqftp.inria.frqSqINRIAqSqpublicationqSqpubli-ps-gzqSqRRqSqRR-1256.ps.gz</a><br>&nbsp;</li>
<li>Carl Pomerance<br><b>Are there counter-examples to the Baillie-PSW primality test?</b><br>Math. Comp. (1984)<br><a href="http://www.pseudoprime.com/dopo.pdf">www.pseudoprime.com/dopo.pdf</a><br>&nbsp;</li>
<li>Eric W. Weisstein<br><b>Baillie-PSW primality test</b><br>MathWorld (2005)<br><a href="http://mathworld.wolfram.com/Baillie-PSWPrimalityTest.html">mathworld.wolfram.com/Baillie-PSWPrimalityTest.html</a><br>&nbsp;</li>
<li>Eric W. Weisstein<br><b>Strong Lucas pseudoprime</b><br>MathWorld (2005)<br><a href="http://mathworld.wolfram.com/StrongLucasPseudoprime.html">mathworld.wolfram.com/StrongLucasPseudoprime.html</a><br>&nbsp;</li>
<li>Paulo Ribenboim<br><b>The Book of Prime Number Records</b><br>Springer-Verlag (1989)<br>[ без ссылки ]<br>&nbsp;</li>
</ol>
<p>Список других рекомендуемых книг, которых мне не удалось найти в Интернете:</p>
<ol start=12>
<li>Zhaiyu Mo; James P. Jones<br><b>A new primality test using Lucas sequences</b><br>Preprint (1997)<br>&nbsp;</li>
<li>Hans Riesel<br><b>Prime numbers and computer methods for factorization</b><br>Boston: Birkhauser (1994)<br>&nbsp;</li>
</ol>