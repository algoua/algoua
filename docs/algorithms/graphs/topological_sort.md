---
id: topological_sort
title: Топологічне сортування
sidebar_label: Топологічне сортування
---

Дано орієнтований граф з $n$ вершинами та $m$ ребрами. Потрібно **пронумерувати** його вершини таким чином, аби кожне ребро вело з вершини з меншим номером у вершину з більшим.

Іншими словами, потрібно знайти перестановку вершин (**топологічний порядок**), відповідну порядку, що задається усіма ребрами у графі.

Топологічне сортування може бути **не унікальним** (наприклад, коли є три такі вершини $a$, $b$, $c$, що з $a$ є шлях в $b$ та в $c$, але ні з $b$ в $c$, ні з $c$ в $b$ добратися не можна).

Топологічне сортування може **не існувати** зовсім - якщо граф містить цикли. Оскільки тоді виникає протиріччя: є шлях і з однієї вершини в іншу, і навпаки.

## Алгоритм

Для розв'язку скористаємось [пошуком в глибину](../graphs/dfs).

Припустимо, що граф ациклічний, тобто розв'язок існує. Що робить пошук в глибину? При запуску з якоїсь вершини $v$ він намагається запуститися уздовж всіх ребер, вихідних з $v$. Уздовж тих ребер, кінці яких вже були відвідані раніше, він не проходить, а уздовж всіх інших - проходить і викликає себе від їх кінців.

Таким чином, на момент виходу з виклику ${\rm dfs}(v)$ всі вершини, досяжні з $v$ як безпосередньо (по ребру), так і дотично (по деякому шляху), вже відвідані пошуком в глибину. Отже, якщо ми будемо в момент виходу з ${\rm dfs}(v)$ додавати нашу вершину в початок деякого списку, то у кінці алгоритму в цьому списку отримаємо **топологічне сортування**.

Пояснити можна також за допомогою поняття **"часу виходу"** пошуку в глибину. Час виходу для кожної вершини $v$ - це момент часу, в який закінчив працювати виклик ${\rm dfs}(v)$ пошуку в глибину. Часи виходу можна пронумерувати від $1$ до $n$. Легко зрозуміти, що при пошуці в глибину час виходу з будь-якої вершини $v$ завжди більший, ніж час виходу з усіх вершин, досяжних з неї (тобто вони були відвідані або до виклику ${\rm dfs}(v)$, або під час нього). Таким чином, шукане топологічне сортування - це сортування у порядку зменшення часів виходу.

Складність алгоритму така ж як і у пошуку в глибину - $O(n+m)$, де $n$ - кількість вершин, $m$ - кількість ребер.

## Реалізація

Наведемо реалізацію, що припускає, що граф ациклічний, тобто шукане топологічне сортування існує. При необхідності перевірку графа на ациклічність можна здійснити додатковим пошуком в глибину, як описано у [статті про пошук циклу](../graphs/finding_cycle).

<!--- topological_sort -->
``` cpp
int n; // кількість вершин
vector<int> g[MAXN]; // граф у вигляді списків суміжності
bool used[MAXN];
vector<int> ans;

void dfs(int v) {
    used[v] = true;
    for (size_t i = 0; i < g[v].size(); i++) {
        int to = g[v][i];
        if (!used[to]) {
            dfs(to);
        }
    }
    ans.push_back(v);
}

void topological_sort() {
    for (int i = 0; i < n; i++) {
        used[i] = false;
    }
    ans.clear();
    for (int i = 0; i < n; i++) {
        if (!used[i]) {
            dfs(i);
        }
    }
    reverse(ans.begin(), ans.end());
}
```

Тут константа `MAXN` задає максимально можливу кількість вершин у графі.

Основна функція розв'язку - це `topological_sort`. Вона ініціалізує допоміжний масив `used` пошуку в глибину, запускає його, і у кінці масив `ans` містить шукане топологічне сортування.

## Застосування

* Є $n$ змінних, значення яких нам невідомі. Відомо лише про деякі пари змінних, у яких одна змінна менша іншої. Потрібно перевірити чи не суперечливі ці нерівності, і якщо ні, видати змінні у порядку їх зростання (якщо розв'язків декілька - видати будь-який).

    Потрібно створити граф з $n$ вершинами, де ребра ведуть з меншої змінної у більшу. Провести [перевірку на ациклічність](../graphs/finding_cycle). Якщо граф містить цикл, то нерівності суперечливі, а якщо не містить циклу, то вершини у топологічному порядку відповідатимуть змінним у порядку їх зростання.

## Задачі

* [*e-olymp* - 1948 - **Топологічне сортування**](https://www.e-olymp.com/uk/problems/1948) | Розв'язки: [C++](https://github.com/memo735/e-olymp/blob/master/1000-1999/1948%20-%20Topological%20Sort%20-%20Топологическая%20сортировка%20-%20Topoloji%20sıralama%20-%20Топологічне%20сортування.cpp)

* [Spoj - TOPOSORT - **Topological Sorting**](https://www.spoj.com/problems/TOPOSORT) | Розв'язки: [C++](https://github.com/CNatka/Algorithms/blob/master/Graph-Theory/Topological%20Sort/spoj_toposort.cpp)

* [Spoj - RPLA - **Answer the boss!**](https://www.spoj.com/problems/RPLA) | Розв'язки: [C++](https://github.com/pedropaiola/unesp-progcomp/blob/527969dc54a0bf47c556d4060e63f666c053b4a6/Solu%C3%A7%C3%B5es/spoj/RPLA.cpp)

* [Online Judge - 124 - **Following Orders**](https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=60) | Розв'язки: [Go](https://shareablecode.com/snippets/golang-solution-for-uva-online-judge-124-following-orders-tFfX-K4c2)

* [Online Judge - 200 - **Rare Order**](https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=136) | Розв'язки: [Go](https://shareablecode.com/snippets/golang-solution-for-uva-online-judge-200-rare-order-sMvr-PMkC)

* [Online Judge - 10305 - **Ordering Tasks**](https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1246) | Розв'язки: [Go](https://shareablecode.com/snippets/golang-solution-for-uva-online-judge-10305-ordering-tasks-6a9n-AYhf), [Python](https://shareablecode.com/snippets/python-solution-for-uva-online-judge-10305-ordering-tasks-gw1b-QJ3i)
