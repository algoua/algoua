---
id: dfs
title: Пошук в глибину
description: Алгоритм пошуку в глибину
keywords:
  - Алгоритм
  - Пошук
  - Графи
---

*[DFS]: Depth-First Search

Пошук в глибину (обхід в глибину, DFS) - це один з основних алгоритмів на графах.

В результаті пошуку в глибину знаходиться лексикографічно перший шлях в графі.

Алгоритм працює за $O(n+m)$, де $n$ - кількість вершин, $m$ - кількість ребер.

## Алгоритм

TODO: add detailed description for DFS.

## Реалізація

Найпростіша реалізація:

<!--- dfs -->
``` cpp
vector<vector<int>> g; // граф, список суміжності
int n; // кількість вершин
vector<bool> used(n); // відвідані вершини

void dfs(int v) {
    used[v] = true;
    for (size_t i = 0; i < g[v].size(); i++) {
        int to = g[v][i];
        if (!used[to]) {
            dfs(to);
        }
    }
}
```

Інколи необхідно знати кольори вершин (0 - не відвідана вершина; 1 - відвідана вершина, але досі у стеці; 2 - відвідана і більше немає у стеці) та "час" заходу та виходу з вершин. Ці допоміжні величини використовуються у декількох наведених прикладах застосування алгоритму.

<!--- dfs_detailed -->
``` cpp
vector<vector<int>> g; // граф, список суміжності
int n; // кількість вершин

vector<int> color; // кольори вершин (0, 1, або 2)

vector<int> time_in, time_out; // "часи" заходу та виходу з вершин
int dfs_timer = 0; // "таймер" для визначення "часів"

void dfs(int v) {
    time_in[v] = dfs_timer++;
    color[v] = 1;
    for (size_t i = 0; i < g[v].size(); i++) {
        int to = g[v][i];
        if (color[to] == 0) {
            dfs(to);
        }
    }
    color[v] = 2;
    time_out[v] = dfs_timer++;
}
```

## Застосування

* Пошук будь-якого шляху у графі.

* Пошук лексикографічно першого шляху в графі.

* Перевірка чи одна вершина дерева є предком іншої.

    На початку і у кінці ітерації пошуку в глибину будемо запам'ятовувати "час" заходу і виходу з кожної вершині. Тепер за $O(1)$ можна знайти відповідь: вершина $a$ є предком вершини $b$ тоді і тільки тоді, коли $\rm time\_in[a] < time\_in[b]$ та $\rm time\_out[a] > time\_out[b]$.

* [Найменший спільний предок](../graphs/lca).

* [Топологічне сортування](../graphs/topological_sort).

    Запускаємо серію пошуків в глибину, щоб обійти всі вершини графа. Відсортуємо вершини по спаданню часу виходу - це і буде відповіддю.

* [Перевірка графа на ациклічність і знаходження циклу](../graphs/finding_cycle).

* [Пошук компонент сильної зв'язності](strong_connected_components).

    Спочатку проводимо топологічне сортування, а потім транспонуємо граф. Після того знову проводимо серію пошуків у глибину, але в порядку вершин, який було отримано топологічним сортуванням. Кожне дерево пошуку - сильнозв'язана компонента.

* [Пошук мостів](../graphs/bridge_searching).

    Спочатку перетворюємо граф в орієнтований, роблячи серію пошуків в глибину, і орієнтуючи кожне ребро так, як ми намагалися по ньому пройти. Потім знаходимо сильнозв'язані компоненти. Мостами є ті ребра, кінці яких належать різним сильнозв'язаним компонентам.

## Задачі

* [*e-olymp* - 122 - **Маршрути в горах**](https://www.e-olymp.com/uk/problems/122) | Розв'язки: [C++](https://github.com/memo735/e-olymp/blob/master/0000-0999/0122%20-%20Mountain%20routes%20-%20Горные%20маршруты%20-%20Dağlıq%20marşrutlar%20-%20Маршрути%20в%20горах.cpp)

* [*e-olymp* - 977 - **Дерево?**](https://www.e-olymp.com/uk/problems/977) | Розв'язки: [C++](https://github.com/memo735/e-olymp/blob/master/0000-0999/0977%20-%20Is%20it%20a%20Tree%3F%20-%20Дерево%3F.cpp)

* [*e-olymp* - 978 - **Отримай дерево**](https://www.e-olymp.com/uk/problems/978) | Розв'язки: [C#](https://github.com/memo735/e-olymp/blob/master/0000-0999/Problem0978_C%23)

* [*e-olymp* - 1941 - **Предок**](https://www.e-olymp.com/uk/problems/1941) | Розв'язки: [C++](https://github.com/memo735/e-olymp/blob/master/1000-1999/1941%20-%20Parent%20-%20Предок.cpp)

* [*e-olymp* - 2270 - **Пошук циклу**](https://www.e-olymp.com/uk/problems/2270) | Розв'язки: [C++](https://github.com/memo735/e-olymp/blob/master/2000-2999/2270%20-%20Find%20a%20cycle%20-%20Поиск%20цикла%20-%20Пошук%20циклу.cpp)

* [*e-olymp* - 2382 - **Графічна маска**](https://www.e-olymp.com/uk/problems/2382) | Розв'язки: [C++](https://github.com/memo735/e-olymp/blob/master/2000-2999/2382%20-%20Grafix%20Mask%20-%20Графическая%20маска%20-%20Графічна%20маска.cpp)

* [*e-olymp* - 2383 - **Електричні провода**](https://www.e-olymp.com/uk/problems/2383) | Розв'язки: [C++](https://github.com/memo735/e-olymp/blob/master/2000-2999/2383%20-%20Electrical%20Wires%20-%20Электрические%20провода%20-%20Електричні%20провода.cpp)

* [*e-olymp* - 3165 - **Двокольоровість**](https://www.e-olymp.com/uk/problems/3165) | Розв'язки: [C++](https://github.com/memo735/e-olymp/blob/master/3000-3999/3165%20-%20Bicoloring%20-%20Двухцветность%20-%20Двокольоровість.cpp)

* [*e-olymp* - 4077 - **Зарплата в корпорації**](https://www.e-olymp.com/uk/problems/4077) | Розв'язки: [C++](https://github.com/memo735/e-olymp/blob/master/4000-4999/4077%20-%20Corporation%20Salary%20-%20Зарплата%20в%20корпорации%20-%20Şirkətdəki%20əmək%20haqqı%20-%20Зарплата%20в%20корпорації.cpp)
