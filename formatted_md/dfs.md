# Поиск в глубину

Это один из основных алгоритмов на графах.

В результате поиска в глубину находится лексикографически первый путь в графе.

Алгоритм работает за **O (N+M)**.

## Применения алгоритма

* Поиск любого пути в графе.
* Поиск лексикографически первого пути в графе.
* Проверка, является ли одна вершина дерева предком другой:
В начале и конце итерации поиска в глубину будет запоминать "время" захода и выхода в каждой вершине. Теперь за O(1) можно найти ответ: вершина i является предком вершины j тогда и только тогда, когда start<sub>i</sub> < start<sub>j</sub> и end<sub>i</sub> > end<sub>j</sub>.
* [Задача LCA (наименьший общий предок)](lca).
* [Топологическая сортировка](topological_sort):
Запускаем серию поисков в глубину, чтобы обойти все вершины графа. Отсортируем вершины по времени выхода по убыванию - это и будет ответом.
* [Проверка графа на ацикличность и нахождение цикла](finding_cycle)
* [Поиск компонент сильной связности](strong_connected_components):
Сначала делаем топологическую сортировку, потом транспонируем граф и проводим снова серию поисков в глубину в порядке, определяемом топологической сортировкой. Каждое дерево поиска - сильносвязная компонента.
* [Поиск мостов](bridge_searching):
Сначала превращаем граф в ориентированный, делая серию поисков в глубину, и ориентируя каждое ребро так, как мы пытались по нему пройти. Затем находим сильносвязные компоненты. Мостами являются те рёбра, концы которых принадлежат разным сильносвязным компонентам.

## Реализация

<!--- TODO: specify code snippet id -->
``` cpp
vector<vector<int>> g; // граф
int n;                 // число вершин

vector<int> color; // цвет вершины (0, 1, или 2)

vector<int> time_in, time_out; // "времена" захода и выхода из вершины
int dfs_timer = 0;             // "таймер" для определения времён

void dfs(int v) {
    time_in[v] = dfs_timer++;
    color[v] = 1;
    for (vector<int>::iterator i = g[v].begin(); i != g[v].end(); ++i)
        if (color[*i] == 0)
            dfs(*i);
    color[v] = 2;
    time_out[v] = dfs_timer++;
}
```
Это наиболее общий код. Во многих случаях времена захода и выхода из вершины не важны, так же как и не важны цвета вершин (но тогда надо будет ввести аналогичный по смыслу булевский массив used). Вот наиболее простая реализация:

<!--- TODO: specify code snippet id -->
``` cpp
vector<vector<int>> g; // граф
int n;                 // число вершин

vector<char> used;

void dfs(int v) {
    used[v] = true;
    for (vector<int>::iterator i = g[v].begin(); i != g[v].end(); ++i)
        if (!used[*i])
            dfs(*i);
}
```
