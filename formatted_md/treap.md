# Декартово дерево (treap, дерамида)

Декартово дерево - это структура данных, объединяющая в себе бинарное дерево поиска и бинарную кучу (отсюда и второе её название: treap (tree+heap) и дерамида (дерево+пирамида).

Более строго, это структура данных, которая хранит пары (X,Y) в виде бинарного дерева таким образом, что она является бинарным деревом поиска по x и бинарной пирамидой по y. Предполагая, что все X и все Y являются различными, получаем, что если некоторый элемент дерева содержит (X<sub>0</sub>,Y<sub>0</sub>), то у всех элементов в левом поддереве X < X<sub>0</sub>, у всех элементов в правом поддереве X > X<sub>0</sub>, а также и в левом, и в правом поддереве имеем: Y &lt Y<sub>0</sub>.

Дерамиды были предложены Сиделем (Siedel) и Арагон (Aragon) в 1989 г.

## Преимущества такой организации данных

В том применении, которое мы рассматриваем (мы будем рассматривать дерамиды, поскольку декартово дерево - это фактически более общая структура данных), X'ы являются ключами (и одновременно значениями, хранящимися в структуре данных), а Y'и - называются **приоритетами**. Если бы приоритетов не было, то было бы обычное бинарное дерево поиска по X, и заданному набору X'ов могло бы соответствовать много деревьев, некоторые из которых являются вырожденными (например, в виде цепочки), а потому чрезвычайно медленными (основные операции выполнялись бы за O (N)).

В то же время, **приоритеты** позволяют **однозначно** указать дерево, которое будет построено (разумеется, не зависящее от порядка добавления элементов) (это доказывается соответствующей теоремой). Теперь очевидно, что если **выбирать приоритеты случайно**, то этим мы добьёмся построения **невырожденных** деревьев в среднем случае, что обеспечит асимптотику O (log N) в среднем. Отсюда и понятно ещё одно название этой структуры данных - **рандомизированное бинарное дерево поиска**.

## Операции

Итак, treap предоставляет следующие операции:

* **Insert (X, Y)** - за O (log N) в среднем
Выполняет добавление в дерево нового элемента.
Возможен вариант, при котором значение приоритета Y не передаётся функции, а выбирается случайно (правда, нужно учесть, что оно не должно совпадать ни с каким другим Y в дереве).
* **Search (X)** - за O (log N) в среднем
Ищет элемент с указанным значением ключа X. Реализуется абсолютно так же, как и для обычного бинарного дерева поиска.
* **Erase (X)** - за O (log N) в среднем
Ищет элемент и удаляет его из дерева.
* **Build (X<sub>1</sub>, ..., X<sub>N</sub>)** - за O (N)
Строит дерево из списка значений. Эту операцию можно реализовать за линейное время (в предположении, что значения X<sub>1</sub>, ..., X<sub>N</sub> отсортированы), но здесь эта реализация рассматриваться не будет.
Здесь будет использоваться только простейшая реализация - в виде последовательных вызовов Insert, т.е. за O (N log N).
* **Union (T<sub>1</sub>, T<sub>2</sub>)** - за O (M log (N/M)) в среднем
Объединяет два дерева, в предположении, что все элементы различны (впрочем, эту операцию можно реализовать с той же асимптотикой, если при объединении нужно удалять повторяющиеся элементы).
* **Intersect (T<sub>1</sub>, T<sub>2</sub>)** - за O (M log (N/M)) в среднем
Находит пересечение двух деревьев (т.е. их общие элементы). Здесь реализация этой операции не будет рассматриваться.

Кроме того, за счёт того, что декартово дерево является и бинарным деревом поиска по своим значениям, к нему применимы такие операции, как нахождение K-го по величине элемента, и, наоборот, определение номера элемента.

## Описание реализации

С точки зрения реализации, каждый элемент содержит в себе X, Y и указатели на левого L и правого R сына.

Для реализации операций понадобится реализовать две вспомогательные операции: Split и Merge.

**Split (T, X)** - разделяет дерево T на два дерева L и R (которые являются возвращаемым значением) таким образом, что L содержит все элементы, меньшие по ключу X, а R содержит все элементы, большие X. Эта операция выполняется за O (log N). Реализация её довольно проста - очевидная рекурсия.

**Merge (T<sub>1</sub>, T<sub>2</sub>)** - объединяет два поддерева T<sub>1</sub> и T<sub>2</sub>, и возвращает это новое дерево. Эта операция также реализуется за O (log N). Она работает в предположении, что T<sub>1</sub> и T<sub>2</sub> обладают соответствующим порядком (все значения X в первом меньше значений X во втором). Таким образом, нам нужно объединить их так, чтобы не нарушить порядок по приоритетам Y. Для этого просто выбираем в качестве корня то дерево, у которого Y в корне больше, и рекурсивно вызываем себя от другого дерева и соответствующего сына выбранного дерева.

Теперь очевидна реализация **Insert (X, Y)**. Сначала спускаемся по дереву (как в обычном бинарном дереве поиска по X), но останавливаемся на первом элементе, в котором значение приоритета оказалось меньше Y. Мы нашли позицию, куда будем вставлять наш элемент. Теперь вызываем Split (X) от найденного элемента (от элемента вместе со всем его поддеревом), и возвращаемые ею L и R записываем в качестве левого и правого сына добавляемого элемента.

Также понятна и реализация **Erase (X)**. Спускаемся по дереву (как в обычном бинарном дереве поиска по X), ища удаляемый элемент. Найдя элемент, мы просто вызываем Merge от его левого и правого сыновей, и возвращаемое ею значение ставим на место удаляемого элемента.

Операцию **Build** реализуем за O (N log N) просто с помощью последовательных вызовов Insert.

Наконец, операция **Union (T<sub>1</sub>, T<sub>2</sub>)**. Теоретически её асимптотика O (M log (N/M)), однако на практике она работает очень хорошо, вероятно, с весьма малой скрытой константой. Пусть, не теряя общности, T<sub>1</sub>->Y > T<sub>2</sub>->Y, т.е. корень T<sub>1</sub> будет корнем результата. Чтобы получить результат, нам нужно объединить деревья T<sub>1</sub>->L, T<sub>1</sub>->R и T<sub>2</sub> в два таких дерева, чтобы их можно было сделать сыновьями T<sub>1</sub>. Для этого вызовем Split (T<sub>2</sub>, T<sub>1</sub>->X), тем самым мы разобъём T<sub>2</sub> на две половинки L и R, которые затем рекурсивно объединим с сыновьями T<sub>1</sub>: Union (T<sub>1</sub>->L, L) и Union (T<sub>1</sub>->R, R), тем самым мы построим левое и правое поддеревья результата.

## Реализация

Реализуем все описанные выше операции. Здесь для удобства введены другие обозначения - приоритет обозначается prior, значения - key.

<!--- TODO: specify code snippet id -->
``` cpp
struct item {
    int key, prior;
    item *l, *r;
    item() {}
    item(int key, int prior) : key(key), prior(prior), l(NULL), r(NULL) {}
};
typedef item *pitem;

void split(pitem t, int key, pitem &l, pitem &r) {
    if (!t)
        l = r = NULL;
    else if (key < t->key)
        split(t->l, key, l, t->l), r = t;
    else
        split(t->r, key, t->r, r), l = t;
}

void insert(pitem &t, pitem it) {
    if (!t)
        t = it;
    else if (it->prior > t->prior)
        split(t, it->key, it->l, it->r), t = it;
    else
        insert(it->key < t->key ? t->l : t->r, it);
}

void merge(pitem &t, pitem l, pitem r) {
    if (!l || !r)
        t = l ? l : r;
    else if (l->prior > r->prior)
        merge(l->r, l->r, r), t = l;
    else
        merge(r->l, l, r->l), t = r;
}

void erase(pitem &t, int key) {
    if (t->key == key)
        merge(t, t->l, t->r);
    else
        erase(key < t->key ? t->l : t->r, key);
}

pitem unite(pitem l, pitem r) {
    if (!l || !r)
        return l ? l : r;
    if (l->prior < r->prior)
        swap(l, r);
    pitem lt, rt;
    split(r, l->key, lt, rt);
    l->l = unite(l->l, lt);
    l->r = unite(l->r, rt);
    return l;
}
```

## Поддержка размеров поддеревьев

Чтобы расширить функциональность декартового дерева, очень часто необходимо для каждой вершины хранить количество вершин в её поддереве - некое поле int cnt в структуре item. Например, с его помощью легко будет найти за O (log N) K-ый по величине элемент дерева, или, наоборот, за ту же асимптотику узнать номер элемента в отсортированном списке (реализация этих операций ничем не будет отличаться от их реализации для обычных бинарных деревьев поиска).

При изменении дерева (добавлении или удалении элемента и т.д). должны соответствующим образом меняться и cnt некоторых вершин. Реализуем две функции - функция cnt() будет возвращать текущее значение cnt или 0, если вершина не существует, а функция upd_cnt() будет обновлять значение cnt для указанной вершины, при условии, что для её сыновей l и r эти cnt уже корректно обновлены. Тогда, понятно, достаточно добавить вызовы функции upd_cnt() в конец каждой из функций insert, erase, split, merge, чтобы постоянно поддерживать корректные значения cnt.

<!--- TODO: specify code snippet id -->
``` cpp
int cnt(pitem t) { return t ? t->cnt : 0; }

void upd_cnt(pitem t) {
    if (t)
        t->cnt = 1 + cnt(t->l) + cnt(t->r);
}
```

## Построение декартового дерева за O (N) в оффлайн

TODO

## Неявные декартовы деревья

Неявное декартово дерево - это простая модификация обычного декартового дерева, которая, тем не менее, оказывается очень мощной структурой данных. Фактически, неявное декартово дерево можно воспринимать как массив, над которым можно реализовать следующие операции (все за O (log N) в режиме онлайн):

* Вставка элемента в массив в любую позицию
* Удаление произвольного элемента
* Сумма, минимум/максимум на произвольном отрезке, и т.д.
* Прибавление, покраска на отрезке
* Переворот (перестановка элементов в обратном порядке) на отрезке

Ключевая идея заключается в том, что в качестве ключей key следует использовать **индексы** элементов в массиве. Однако явно хранить эти значения key мы не будем (иначе, например, при вставке элемента пришлось бы изменять key в O (N) вершинах дерева).

Заметим, что фактически в данном случае ключ для какой-то вершины - это количество вершин, меньших неё. Следует заметить, что вершины, меньшие данной, находятся не только в её левом поддереве, но и, возможно, в левых поддеревьях её предков. Более строго, **неявный ключ** для некоторой вершины t равен количеству вершин cnt(t->l) в левом поддереве этой вершины плюс аналогичные величины cnt(p->l)+1 для каждого предка p этой вершины, при условии, что t находится в правом поддереве для p.

Ясно, как теперь быстро вычислять для текущей вершины её неявный ключ. Поскольку во всех операциях мы приходим в какую-либо вершину, спускаясь по дереву, мы можем просто накапливать эту сумму, передавая её функции. Если мы идём в левое поддерево - накапливаемая сумма не меняется, а если идём в правое - увеличивается на cnt(t->l)+1.

Приведём новые реализации функций split и merge:

<!--- TODO: specify code snippet id -->
``` cpp
void merge(pitem &t, pitem l, pitem r) {
    if (!l || !r)
        t = l ? l : r;
    else if (l->prior > r->prior)
        merge(l->r, l->r, r), t = l;
    else
        merge(r->l, l, r->l), t = r;
    upd_cnt(t);
}

void split(pitem t, pitem &l, pitem &r, int key, int add = 0) {
    if (!t)
        return void(l = r = 0);
    int cur_key = add + cnt(t->l); // вычисляем неявный ключ
    if (key <= cur_key)
        split(t->l, l, t->l, key, add), r = t;
    else
        split(t->r, t->r, r, key, add + 1 + cnt(t->l)), l = t;
    upd_cnt(t);
}
```
Теперь перейдём к реализации различных дополнительных операций на неявных декартовых деревьях:

* **Вставка** элемента.
Пусть нам надо вставить элемент в позицию pos. Разобьём декартово дерево на две половинки: соответствующую массиву [0..pos-1] и массиву [pos..sz]; для этого достаточно вызвать split (t, t1, t2, pos). После этого мы можем объединить дерево t1 с новой вершиной; для этого достаточно вызвать merge (t1, t1, new_item) (нетрудно убедиться в том, что все предусловия для merge выполнены). Наконец, объединим два дерева t1 и t2 обратно в дерево t - вызовом merge (t, t1, t2).
* **Удаление** элемента.
Здесь всё ещё проще: достаточно найти удаляемый элемент, а затем выполнить merge для его сыновей l и r, и поставить результат объединения на место вершины t. Фактически, удаление из неявного декартова дерева не отличается от удаления из обычного декартова дерева.
* **Сумма/минимум** и т.п. на отрезке.
Во-первых, для каждой вершины создадим дополнительное поле f в структуре item, в котором будет храниться значение целевой функции для поддерева этой вершины. Такое поле легко поддерживать, для этого надо поступить аналогично поддержке размеров cnt (создать функцию, вычисляющую значение этого поля, пользуясь его значениями для сыновей, и вставить вызовы этой функции в конце всех функций, меняющих дерево).
Во-вторых, нам надо научиться отвечать на запрос на произвольном отрезке [A;B]. Научимся выделять из дерева его часть, соответствующую отрезку [A;B]. Нетрудно понять, что для этого достаточно сначала вызвать split (t, t1, t2, A), а затем split (t2, t2, t3, B-A+1). В результате дерево t2 и будет состоять из всех элементов в отрезке [A;B], и только них. Следовательно, ответ на запрос будет находиться в поле f вершины t2. После ответа на запрос дерево надо восстановить вызовами merge (t, t1, t2) и merge (t, t, t3).
* **Прибавление/покраска** на отрезке.
Здесь мы поступаем аналогично предыдущему пункту, но вместо поля f будем хранить поле add, которое и будет содержать прибавляемую величину (или величину, в которую красят всё поддерево этой вершины). Перед выполнением любой операции эту величину add надо "протолкнуть" - т.е. соответствующим образом изменить t-l->add и t->r->add, а у себя значение add снять. Тем самым мы добьёмся того, что ни при каких изменениях дерева информация не будет потеряна.
* **Переворот** на отрезке.
Этот пункт почти аналогичен предыдущему - нужно ввести поле bool rev, которое ставить в true, когда требуется произвести переворот в поддереве текущей вершины. "Проталкивание" поля rev заключается в том, что мы обмениваем местами сыновья текущей вершины, и ставим этот флаг для них.

**Реализация**. Приведём для примера полную реализацию неявного декартова дерева с переворотом на отрезке. Здесь для каждой вершины также хранится поле value - собственно значение элемента, стоящего в массиве на текущей позиции. Приведена также реализация функции output(), которая выводит массив, соответствующий текущему состоянию неявного декартова дерева.

<!--- TODO: specify code snippet id -->
``` cpp
typedef struct item *pitem;
struct item {
    int prior, value, cnt;
    bool rev;
    pitem l, r;
};

int cnt(pitem it) { return it ? it->cnt : 0; }

void upd_cnt(pitem it) {
    if (it)
        it->cnt = cnt(it->l) + cnt(it->r) + 1;
}

void push(pitem it) {
    if (it && it->rev) {
        it->rev = false;
        swap(it->l, it->r);
        if (it->l)
            it->l->rev ^= true;
        if (it->r)
            it->r->rev ^= true;
    }
}

void merge(pitem &t, pitem l, pitem r) {
    push(l);
    push(r);
    if (!l || !r)
        t = l ? l : r;
    else if (l->prior > r->prior)
        merge(l->r, l->r, r), t = l;
    else
        merge(r->l, l, r->l), t = r;
    upd_cnt(t);
}

void split(pitem t, pitem &l, pitem &r, int key, int add = 0) {
    if (!t)
        return void(l = r = 0);
    push(t);
    int cur_key = add + cnt(t->l);
    if (key <= cur_key)
        split(t->l, l, t->l, key, add), r = t;
    else
        split(t->r, t->r, r, key, add + 1 + cnt(t->l)), l = t;
    upd_cnt(t);
}

void reverse(pitem t, int l, int r) {
    pitem t1, t2, t3;
    split(t, t1, t2, l);
    split(t2, t2, t3, r - l + 1);
    t2->rev ^= true;
    merge(t, t1, t2);
    merge(t, t, t3);
}

void output(pitem t) {
    if (!t)
        return;
    push(t);
    output(t->l);
    printf("%d ", t->value);
    output(t->r);
}
```
