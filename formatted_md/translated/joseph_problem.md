# Задача Йосипа

Умова задачі. Дано натуральні $n$ і $k$. За кругу выписывают всі натуральні числа від 1 до $n$. Спочатку отсчитывают $k$-е число, починаючи з першого, і удаляют його. Потім від нього отсчитывают $k$ чисел і $k$-е удаляют, і т.д. Процес зупиняється, коли залишається одне число. Потрібно знайти це число.

Задача була поставлена **Иосифом Флавием** (Flavius Josephus) ще в 1 веке (правда, в декілька більш узкой формулюванні: при $k = 2$).

Розв'язувати цю задачу можна моделированием. Простейшее моделирование буде працювати $O(n^2)$. Використовуючи [Дерево відрізків](segment_tree), можна провести моделирование за $O(n \log n)$.

## Розв'язок за $O(n)$

Спробуємо знайти закономірність, выражающую відповідь для задачі $J_{n,k}$ через розв'язок попередніх задач.

З допомогою моделирования побудуємо таблицю значень, наприклад, таку:

$$ \bordermatrix {
n \setminus k&1&2&3&4&5&6&7&8&9&10 \cr
1&1&1&1&1&1&1&1&1&1&1& \cr
2&2&1&2&1&2&1&2&1&2&1& \cr
3&3&3&2&2&1&1&3&3&2&2& \cr
4&4&1&1&2&2&3&2&3&3&4& \cr
5&5&3&4&1&2&4&4&1&2&4& \cr
6&6&5&1&5&1&4&5&3&5&2& \cr
7&7&7&4&2&6&3&5&4&7&5& \cr
8&8&1&7&6&3&1&4&4&8&7& \cr
9&9&3&1&1&8&7&2&3&8&8& \cr
10&10&5&4&5&3&3&9&1&7&8& \cr
} $$

І тут достатньо отчётливо видна наступна **закономірність**:
$$ J_{n,k} = \left( J_{(n-1),k} + k - 1 \right)\ \%\ n + 1 $$
$$ J_{1,k} = 1 $$

Тут 1-индексация декілька портит элегантность формули, якщо нумерувати позиції з нуля, то вийде дуже наглядная формула:

$$ J_{n,k} = \left( J_{(n-1),k} + k \right)\ \%\ n = \sum_{i=1}^n k\ \%\ i $$

Отже, ми знайшли розв'язок задачі Йосипа, работающее за $O(n)$ операцій.

Проста **рекурсивна реалізація** (в 1-індексації):
<!--- TODO: specify code snippet id -->
``` cpp
int joseph (int n, int k) {
    return n>1 ? (joseph (n-1, k) + k - 1) % n + 1 : 1;
}
```

**Нерекурсивная форма**:
<!--- TODO: specify code snippet id -->
``` cpp
int joseph (int n, int k) {
    int res = 0;
    for (int i=1; i<=n; ++i)
        res = (res + k) % i;
    return res + 1;
}
```

## Розв'язок за $O(k \log n)$

Для порівняно невеликих $k$ можна придумати більш оптимальне розв'язок, ніж рассмотренное вище рекурсивное розв'язок за $O(n)$. Якщо $k$ невелике, то навіть інтуїтивно зрозуміло, що той алгоритм робить багато зайвих дій: серьёзные зміни відбуваються, тільки коли відбувається взяття за модулем $n$, а до цього моменту алгоритм просто декілька раз додає до відповіді число $k$. Відповідно, можна позбутися від цих ненужных кроків, 

Небольшая що виникає при цим складність полягає в тому, що після видалення цих чисел у нас вийде задача з меншим $n$, але стартової позицією не в першому числі, а де-то в другом місці. Тому, вызвав рекурсивно собі від задачі з новим $n$, ми потім повинні акуратно перевести результат в нашу систему нумерації з його собственной.

Також окремо треба розбирати випадок, коли $n$ стане менше $k$ - в цим випадку вышеописанная оптимізація выродится в нескінченний цикл.

**Реалізація** (для зручності в 0-індексації):
<!--- TODO: specify code snippet id -->
``` cpp
int joseph (int n, int k) {
    if (n == 1)  return 0;
    if (k == 1)  return n-1;
    if (k > n)  return (joseph (n-1, k) + k) % n;
    int cnt = n / k;
    int res = joseph (n - cnt, k);
    res -= n % k;
    if (res < 0)  res += n;
    else  res += res / (k - 1);
    return res;
}
```

Оцінимо **асимптотику** цього алгоритму. Відразу зауважимо, що випадок $n < k$ разбирается у нас старым розв'язком, яке відпрацює в даному випадку за $O(k)$. Тепер розглянемо сам алгоритм. Фактично, на кожної його ітерації замість $n$ чисел ми отримуємо приблизно $n \left( 1 - \frac{1}{k} \right)$ чисел, тому загальне число $x$ ітерацій алгоритму приблизно можна знайти з рівняння:
$$ n \left( 1 - \frac{1}{k} \right) ^ x = 1, $$
логарифмируя його, отримуємо:
$$ \ln n + x \ln \left( 1 - \frac{1}{k} \right) = 0, $$
$$ x = - \frac{ \ln n }{ \ln \left( 1 - \frac{1}{k} \right) }, $$
користуючись разложением логарифма в ряд Тейлора, отримуємо приблизительную оцінку:
$$ x \approx k \ln n $$

Таким чином, асимптотика алгоритму дійсно $O(k \log n)$.

## Аналитическое розв'язок для $k=2$

В цим приватному випадку (в якому і була поставлена ця задача Иосифом Флавием) задача вирішується значно простіше.

В випадку парного $n$ отримуємо, що будуть вычеркнуты всі парні числа, а потім залишиться задача для $\frac{n}{2}$, тоді відповідь для $n$ буде виходити з відповіді для $\frac{n}{2}$ множенням на два і вычитанием одиниці (за рахунок зсуву позицій):

$$ J_{2n,2} = 2 J_{n,2} - 1 $$

Аналогічно, в випадку непарного $n$ будуть вычеркнуты всі парні числа, потім перший число, і залишиться задача для $\frac{n-1}{2}$, і з урахуванням зсуву позицій отримуємо одному формулу:

$$ J_{2n+1,2} = 2 J_{n,2} + 1 $$

При реалізації можна безпосередньо використовувати цю рекурентну залежність. Можна цю закономірність перевести в іншу форму: $J_{n,2}$ являють собою послідовність всіх непарних чисел, "перезапускающуюся" з одиниці всякий раз, коли $n$ виявляється степенем двійки. Це можна записати і в вигляді однієї формули:

$$ J_{n,2} = 1 + 2 \left( n - 2^{\lfloor \log_2 n \rfloor} \right) $$

## Аналитическое розв'язок для $k>2$

Незважаючи на простий вид задачі і велике кількість статей по цій і смежным задачам, простого аналитического уявлення розв'язку задачі Йосипа до сих пір не знайдено. Для невеликих $k$ выведены деякі формули, але, мабуть, всі вони трудноприменимы на практиці (наприклад, див. Halbeisen, Hungerbuhler "The Josephus Problem" і Odlyzko, Wilf "Functional iteration and the Josephus problem").
