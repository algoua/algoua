# Пошук мостів

Нехай дано неорієнтований граф. Мостом називається таке ребро, видалення якого робить граф незв'язним (або, точніше, збільшує число компонент зв'язності). Потрібно знайти всі мости в заданому графі.

Неформально ця задача ставиться наступним чином: потрібно знайти на заданої мапі доріг всі "важливі" дороги, тобто такі дороги, що видалення будь-якої з них приведе до исчезновению шляхи між якийсь парою міст.

Нижче ми опишемо алгоритм, заснований на [пошуку в глибину](dfs), і працюючий за час $O(n+m)$, де $n$ - кількість вершин, $m$ - ребер в графі.

Зауважимо, що на сайті також описаний [онлайновый алгоритм пошуку мостів](bridge_searching_online) - в відміну від описаного тут алгоритму, онлайновый алгоритм умеет підтримувати всі мости графа в изменяющемся графі (є в увазі додавання нових ребер).

## Алгоритм

Запустимо [обхід в глибину](dfs) з довільної вершини графа ; позначимо її через $\rm root$. Зауважимо наступного **факт** (який не складно довести):

* Нехай ми знаходимося в обході в глибину, просматривая зараз всі ребра з вершини $v$. Значить, якщо поточний ребро $(v,to)$ таке, що з вершини $to$ і з будь-якого її нащадка в дереві обходу в глибину ні зворотнього ребра в вершину $v$ або какого-або її предка, то це ребро є мостом. В іншому випадку воно мостом не є. (Насправді, ми цим умовою перевіряємо, ні або іншого шляхи з $v$ в $to$, крім як спуск по ребру $(v,to)$ дерева обходу в глибину).

Тепер залишилося навчитися перевіряти цей факт для кожної вершини ефективно. Для цього скористаємось "временами входу в вершину", вычисляемыми [алгоритмом пошуку в глибину](dfs).

Отже, нехай $tin[v]$ - це час заходу пошуку в глибину в вершину $v$. Тепер введемо масив $fup[v]$, який і дозволить нам відповідати на вищеописані запити. Час $fup[v]$ рівне мінімуму з часу заходу в саму вершину $tin[v]$, часів заходу в кожну вершину $p$, що є кінцем деякого зворотнього ребра $(v,p)$, а також з всіх значень $fup[to]$ для кожної вершини $to$, є безпосереднім сином $v$ в дереві пошуку:

$$ fup[v] = \min \cases{
tin[v], & \cr
tin[p], & {\rm for all} (v,p){\rm\ - back edge } \cr
fup[to], & {\rm for all} (v,to){\rm\ - tree edge } \cr
} $$

(тут "back edge" - зворотнє ребро, "tree edge" - ребро дерева)

Значить, з вершини $v$ або її нащадка є зворотнє ребро в її предка тоді і тільки тоді, коли знайдеться такий син $to$, що $fup[to] \le tin[v]$. (Якщо $fup[to] = tin[v]$, то це означає, що знайдеться зворотнє ребро, приходящее точно в $v$; якщо ж $fup[to] < tin[v]$, то це означає наявність зворотнього ребра в какого-або предка вершини $v$).

Таким чином, якщо для поточного ребра $(v,to)$ (належить дереву пошуку) виконується $fup[to] > tin[v]$, то це ребро є мостом; в іншому випадку воно мостом не є.

## Реалізація

Якщо говорити про самою реалізації, то тут нам потрібно вміти розрізняти три випадку: коли ми йдемо по ребру дерева пошуку в глибину, коли йдемо по зворотному ребру, і коли намагаємося піти по ребру дерева в зворотню сторону. Це, відповідно, випадки:

* $used[to]=false$ - критерій ребра дерева пошуку;
* $used[to]=true\ \&\&\ to \ne parent$ - критерій зворотнього ребра ;
* $to=parent$ - критерій проходу по ребру дерева пошуку в зворотню сторону.

Таким чином, для реалізації цих критериев нам треба передавати в функцію пошуку в глибину вершину-предка поточній вершини.

<!--- TODO: specify code snippet id -->
``` cpp
const int MAXN = ...;
vector<int> g[MAXN];
bool used[MAXN];
int timer, tin[MAXN], fup[MAXN];

void dfs (int v, int p = -1) {
    used[v] = true;
    tin[v] = fup[v] = timer++;
    for (size_t i=0; i<g[v].size(); ++i) {
        int to = g[v][i];
        if (to == p)  continue;
        if (used[to])
            fup[v] = min (fup[v], tin[to]);
        else {
            dfs (to, v);
            fup[v] = min (fup[v], fup[to]);
            if (fup[to] > tin[v])
                IS_BRIDGE(v,to);
        }
    }
}

void find_bridges() {
    timer = 0;
    for (int i=0; i<n; ++i)
        used[i] = false;
    for (int i=0; i<n; ++i)
        if (!used[i])
            dfs (i);
}
```

Тут основна функція для виклику - це ${\rm find\_bridges}$ - вона виробляє необхідну ініціалізацію і запуск обходу в глибину для кожної компоненти зв'язності графа.

При цим ${\rm IS\_BRIDGE}(a,b)$ - це якась функція, яка буде реагувати на то, що ребро $(a,b)$ є мостом, наприклад, виводити це ребро на екран.

Константі ${\rm MAXN}$ в самому початку коду випливає задати значення, рівне максимально можливого числу вершин у вхідному графі.

Варто замітити, що ця реалізація некоректно працює при наявності в графі **кратних ребер**: вона фактично не обращает уваги, кратне або ребро або воно єдино. Зрозуміло, кратні ребра не повинні входити в відповідь, тому при виклику $\rm IS\_BRIDGE$ можна перевіряти додатково, не кратне або ребро ми хочемо додати в відповідь. Інший спосіб - більш аккуратная робота з предками, тобто передавати в $\rm dfs$ не вершину-предка, а номер ребра, по якому ми вошли в вершину (для цього треба буде додатково зберігати номера всіх ребер).

## Задачі в online judges

Список задач, в яких потрібно шукати мости:

* [UVA #796 **"Critical Links"** [складність: низька]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=737)

* [UVA #610 **"Street Directions"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=551)
