# Модифікація стека і черги для знаходження мінімуму за O (1)

Тут ми розглянемо три задачі: модифицирование стека з додаванням знаходження найменшого елементу за O (1), аналогичное модифицирование черги, а також застосування їх до задачі знаходження мінімуму у всіх підвідрізках фіксованою довжини даного масиву за O (N).

## Модифікація стека

Потрібно додати можливість знаходження мінімуму в стеці за O (1), сохранив такий ж асимптотику додавання і видалення елементів з стека.

Для цього будемо зберігати в стеці не самі елементи, а пари: елемент і мінімум в стеці, починаючи з цього елементу і нижче. Іншими словами, якщо уявити стек як масив пар, то

$$ stack[i].second = min { stack[j].first }
                 j = 0..i $$
Зрозуміло, що тоді знаходження мінімуму у усьому стеці буде полягати просто у взятии значення stack.top().second.

Також очевидно, що при додаванні нового елементу в стек величина second буде рівна min (stack.top().second, new_element). Видалення елементу з стека нічим не відрізняється від видалення з звичайного стека, оскільки видаляється елемент ніяк не міг повлиять на значення second для залишилися елементів.

Реалізація:

<!--- TODO: specify code snippet id -->
``` cpp
stack< pair<int,int> > st;
```

* Додавання елементу:
<!--- TODO: specify code snippet id -->
``` cpp
int minima = st.empty() ? new_element : min (new_element, st.top().second);
st.push (make_pair (new_element, minima));
```
* Витяг елементу:
<!--- TODO: specify code snippet id -->
``` cpp
int result = st.top().first;
st.pop();
```
* Знаходження мінімуму:
<!--- TODO: specify code snippet id -->
``` cpp
minima = st.top().second;
```

## Модифікація черги. Спосіб 1

Тут розглянемо простий спосіб модифікації черги, але має той недолік, що модифікована чергу реально можливо зберігати не всі елементи (тобто при добуванні елементу з черги нам треба буде знати значення елементу, який ми хочемо извлечь). Ясно, що це вельми специфичная ситуація (зазвичай чергу потрібна як раз для того, аби дізнаватися черговий елемент, а не навпаки), однак цей спосіб привлекателен своєї простотою. Також цей метод застосуємо до задачі про знаходженні мінімуму в підвідрізках (див. нижче).

Ключова ідея полягає в тому, аби реально зберігати в черги не всі елементи, а тільки потрібні нам для визначення мінімуму. А саме, нехай чергу представляє собою неубывающую послідовність чисел (тобто в голове зберігається найменше значення), причому, звісно, не довільну, а завжди що містить мінімум. Значить мінімум у всій черги завжди буде бути першим її елементом. Перед додаванням нового елементу в чергу достатньо провести "срезку": поки в хвосте черги знаходиться елемент, більший нового елементу, будемо видаляти цей елемент з черги; потім додамо новий елемент в кінець черги. Тим самим ми, з однієї сторони, не порушимо порядку, а з іншої сторони, не потеряем поточний елемент, якщо він на якому-або последующем кроці виявиться мінімумом. Але при добуванні елементу з головы черги його там, взагалі кажучи, можливо вже не виявитися - наша модифікована чергу могла выкинуть цей елемент в процесі перестроения. Тому при видаленні елементу нам треба знати значення извлекаемого елементу - якщо елемент з цим значенням знаходиться в голове черги, то извлекаем його; інакше просто нічого не робимо.

Розглянемо реалізацію вищеописаних операцій:

<!--- TODO: specify code snippet id -->
``` cpp
deque<int> q;
```

* Знаходження мінімуму:
<!--- TODO: specify code snippet id -->
``` cpp
current_minimum = q.front();
```
* Додавання елементу:
<!--- TODO: specify code snippet id -->
``` cpp
while (!q.empty() && q.back() > added_element)
    q.pop_back();
q.push_back (added_element);
```
* Витяг елементу:
<!--- TODO: specify code snippet id -->
``` cpp
if (!q.empty() && q.front() == removed_element)
    q.pop_front();
```

Зрозуміло, що в середньому час виконання всіх цих операцій є O (1).

## Модифікація черги. Спосіб 2

Розглянемо тут іншої спосіб модифікації черги для знаходження мінімуму за O (1), який декілька більш сложен для реалізації, однак лишён основного недостатка попереднього методу: всі елементи черги реально сохраняются в ній, і, в зокрема, при добуванні елементу не потрібно знати його значення.

Ідея полягає в тому, аби звести задачу до задачі на стеках, яка вже була нами вирішена. Навчимося моделировать чергу з допомогою двох стеков.

Заведемо два стека: s1 і s2; звісно, є в увазі стеки, модифицированные для знаходження мінімуму за O (1). Добавлять нові елементи буде завжди в стек s1, а витягувати елементи - тільки з стека s2. При цим, якщо при попытке вилучення елементу з стека s2 він виявився порожнім, просто перенесемо всі елементи з стека s1 в стек s2 (при цим елементи в стеці s2 получатся вже в зворотньому порядку, що нам і потрібно для вилучення елементів; стек s1 ж стане порожнім). Нарешті, знаходження мінімуму в черги буде фактично полягати в знаходженні мінімуму з мінімуму в стеці s1 і мінімуму в стеці s2.

Тим самим, ми виконуємо всі операції як і раніше за O (1) (по тією простий причини, що кожний елемент в гіршому випадку 1 раз додається в стек s1, 1 раз переносится в стек s2 і 1 раз извлекается з стека s2).

Реалізація:

<!--- TODO: specify code snippet id -->
``` cpp
stack< pair<int,int> > s1, s2;
```

* Знаходження мінімуму:
<!--- TODO: specify code snippet id -->
``` cpp
if (s1.empty() || s2.empty())
    current_minimum = s1.empty ? s2.top().second : s1.top().second;
else
    current_minimum = min (s1.top().second, s2.top().second);
```
* Додавання елементу:
<!--- TODO: specify code snippet id -->
``` cpp
int minima = s1.empty() ? new_element : min (new_element, s1.top().second);
s1.push (make_pair (new_element, minima));
```
* Витяг елементу:
<!--- TODO: specify code snippet id -->
``` cpp
if (s2.empty())
    while (!s1.empty()) {
        int element = s1.top().first;
        s1.pop();
        int minima = s2.empty() ? element : min (element, s2.top().second);
        s2.push (make_pair (element, minima));
    }
result = s2.top().first;
s2.pop();
```

## Задача знаходження мінімуму у всіх підвідрізках фіксованою довжини даного масиву

Нехай дано масив A довжини N, і дано число M &le; N. Потрібно знайти мінімум в кожному підвідрізку довжини M даного масиву, тобто знайти:

$$ min A[i],    min A[i],    min A[i],    ...,    min A[i]
0&le;i&le;M-1      1&le;i&le;M        2&le;i&le;M+1              N-M&le;i&le;N-1 $$
Вирішимо цю задачу за лінійне час, тобто O (N).

Для цього достатньо завести чергу, модифіковану для знаходження мінімуму за O (1), що було рассмотрено нами вище, причому в даній задачі підійде будь-якої з двох методів реалізації такий черги. Далі розв'язок вже зрозуміло: додамо в чергу перші M елементів масиву, найдемо в ній мінімум і виведемо його, потім додамо в чергу наступного елемент, і виберемо з її перший елемент масиву, знову виведемо мінімум, і т.д. Оскільки всі операції з очередью виконуються в середньому за константне час, то і асимптотика всього алгоритму вийде O (N).

Варто замітити, що реалізація модифікованій черги першим методом простіше, однак для її, ймовірно, буде потрібно зберігати весь масив (оскільки на i-ом кроці буде потрібно знати i-ый і (i-M)-ый елементи масиву). При реалізації черги іншим методом масив A зберігати явно не знадобиться - тільки дізнаватися черговий, i-ый елемент масиву.
