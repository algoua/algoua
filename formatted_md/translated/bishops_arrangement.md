# Расстановка слонів на шаховій дошці

Потрібно знайти кількість способів розставити K слонів на дошці розміром NxN.

## Алгоритм

Розв'язувати задачу будемо з допомогою **динамічного програмування**.

Нехай **D[i][j]** - кількість способів розставити j слонів на діагоналях до i-ой включно, причому тільки тих діагоналях, які того ж кольори, що і i-ая діагональ. Значить i = 1..2N-1, j = 0..K.

Диагонали занумеруем наступним чином (приклад для дошки 5x5):

$$ черные:     білі:
1 _ 5 _ 9   _ 2 _ 6 _
_ 5 _ 9 _   2 _ 6 _ 8
5 _ 9 _ 7   _ 6 _ 8 _ 
_ 9 _ 7 _   6 _ 8 _ 4
9 _ 7 _ 3   _ 8 _ 4 _ $$
тобто. нечётные номера відповідають чёрным диагоналям, парні - белым; діагоналі нумеруем в порядку збільшення кількості елементів в них.

При такий нумерації ми можемо обчислити кожне D[i][], грунтуючись тільки на D[i-2][] (двойка вычитается, аби ми розглядали діагональ того ж кольори).

Отже, нехай поточний елемент динаміки - D[i][j]. Маємо два переходу. Перший - D[i-2][j], тобто ставимо всіх j слонів на попередні діагоналі. Другий перехід - якщо ми ставимо одного слона на поточну діагональ, а інших j-1 слонів - на попередні; зауважимо, що кількість способів поставити слона на поточну діагональ рівне кількості клітин в ній мінус j-1, т.до. слоны, стоять на попередніх діагоналях, будуть перекрывать частина напрямків. Таким чином, маємо:

$$ D[i][j] = D[i-2][j] + D[i-2][j-1] (cells(i) - j + 1) $$
де cells(i) - кількість клітин, лежачих на i-ой діагоналі. Наприклад, cells можна обчислювати так:
<!--- TODO: specify code snippet id -->
``` cpp
int cells (int i) {
    if (i & 1)
        return i / 4 * 2 + 1;
    else
        return (i - 1) / 4 * 2 + 2;
}
```
Залишилося визначити базу динаміки, тут ніяких складнощів ні: D[i][0] = 1, D[1][1] = 1.

Нарешті, вычислив динаміку, знайти власне **відповідь** до задачі не складно. Перебираем кількість i=0..K слонів, стоящих на чорних діагоналях (номер останньої чёрной діагоналі - 2N-1), відповідно K-i слонів ставимо на білі діагоналі (номер останньої білою діагоналі - 2N-2), тобто до відповіді додаємо величину D[2N-1][i] * D[2N-2][K-i].

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
int n, k; // вхідні дані
if (k > 2*n-1) {
    cout << 0;
    return 0;
}

vector < vector<int> > d (n*2, vector<int> (k+2));
for (int i=0; i<n*2; ++i)
    d[i][0] = 1;
d[1][1] = 1;
for (int i=2; i<n*2; ++i)
    for (int j=1; j<=k; ++j)
        d[i][j] = d[i-2][j] + d[i-2][j-1] * (cells(i) - j + 1);

int ans = 0;
for (int i=0; i<=k; ++i)
    ans += d[n*2-1][i] * d[n*2-2][k-i];
cout << ans;
```
