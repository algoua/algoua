# Z-функція стрічки і її обчислення

Нехай дана стрічка $s$ довжини $n$. Значить **Z-функція** ("зет-функція") від цій стрічки - це масив довжини $n$, $i$-ый елемент якого рівний найбільшому числу символів, починаючи з позиції $i$, співпадаючих з першими символами стрічки $s$.

Іншими словами, $z[i]$ - це найбільший загальний префікс стрічки $s$ і її $i$-го суфікса.

**Зауваження**. В даній статті, у уникнути неопределённости, ми будемо вважати стрічку 0-индексированной - тобто перший символ стрічки має індекс $0$, а останній - $n-1$.

Перший елемент Z-функції, $z[0]$, зазвичай считают неопределённым. В даній статті ми будемо вважати, що він рівний нулю (хоча ні в алгоритмі, ні в наведеної реалізації це нічого не змінює).

В даній статті наводиться алгоритм обчислення Z-функції за час $O(n)$, а також різні застосування цього алгоритму.

## Приклади

Наведемо для прикладу подсчитанную Z-функцію для декількох стрічок:

* $"aaaaa"$:

$$ z[0] = 0, $$
$$ z[1] = 4, $$
$$ z[2] = 3, $$
$$ z[3] = 2, $$
$$ z[4] = 1. $$

* $"aaabaab"$:

$$ z[0] = 0, $$
$$ z[1] = 2, $$
$$ z[2] = 1, $$
$$ z[3] = 0, $$
$$ z[4] = 2, $$
$$ z[5] = 1, $$
$$ z[6] = 0. $$

* $"abacaba"$:

$$ z[0] = 0, $$
$$ z[1] = 0, $$
$$ z[2] = 1, $$
$$ z[3] = 0, $$
$$ z[4] = 3, $$
$$ z[5] = 0, $$
$$ z[6] = 1. $$

## Тривіальний алгоритм

Формальное визначення можна уявити в вигляді наступного элементарной реалізації за $O(n^2)$:

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> z_function_trivial (string s) {
    int n = (int) s.length();
    vector<int> z (n);
    for (int i=1; i<n; ++i)
        while (i + z[i] < n && s[z[i]] == s[i+z[i]])
            ++z[i];
    return z;
}
```

Ми просто для кожної позиції $i$ перебираємо відповідь для її $z[i]$, починаючи з нуля, і до тих пір, поки ми не виявимо несовпадение або не дійдемо до кінця стрічки.

Зрозуміло, ця реалізація занадто неэффективна, перейдемо тепер до побудови ефективного алгоритму.

## Эффективный алгоритм обчислення Z-функції

Щоб получити ефективний алгоритм, будемо обчислювати значення $z[i]$ по черги - від $i=1$ до $n-1$, і при цим постараемся при обчисленні чергового значення $z[i]$ максимально використовувати вже обчислені значення.

Назвемо для стислості підстрічку, збігається з префіксом стрічки $s$, **відрізком збіги**. Наприклад, значення шуканої Z-функції $z[i]$ - це довжелезний відрізок збіги, що починається в позиції $i$ (і заканчиваться він буде в позиції $i + z[i] - 1$).

Для цього будемо підтримувати **координати $[l;r]$ самого правого відрузку збіги**, тобто з всіх виявлених відрізків будемо зберігати той, який закінчується правіше всього. В деякому сенсі, індекс $r$ - це така межа, до якій наша стрічка вже була просканирована алгоритмом, а усе остальное - поки ще не відомо.

Значить якщо поточний індекс, для якого ми хочемо порахувати чергове значення Z-функції, - це $i$, ми маємо один з двох варіантів:

* $i > r$ - тобто поточна позиція лежить **за пределами** того, що ми вже успели обробити.

Значить будемо шукати $z[i]$ **тривіальним алгоритмом**, тобто просто пробуя значення $z[i]=0$, $z[i]=1$, і т.д. Зауважимо, що в підсумку, якщо $z[i]$ виявиться $>0$, то ми будемо зобов'язані оновити координати самого правого відрузку $[l;r]$ - т.до. $i + z[i] - 1$ гарантовано виявиться більше $r$.

* $i \le r$ - тобто поточна позиція лежить всередині відрузку збіги $[l;r]$.

Значить ми можемо використовувати вже подсчитанные **попередні** значення Z-функції, аби проинициализировать значення $z[i]$ не нулем, а яким-то можливо бОльшим числом.

Для цього зауважимо, що підстрічки $s[l \ldots r]$ і $s[0 \ldots r-l]$ **збігаються**. Це означає, що в якості початкового наближення для $z[i]$ можна взяти відповідне йому значення з відрузку $s[0 \ldots r-l]$, а саме, значення $z[i-l]$.

Однак значення $z[i-l]$ могло виявитися занадто великим: таким, що при застосуванні його до позиції $i$ воно "вылезет" за межі межі $r$. Этого допустить не можна, т.до. про символи правіше $r$ ми нічого не знаємо, і вони можуть відрізнятися від требуемых.

Наведемо **приклад** такий ситуації, на прикладі стрічки:

$$ "aaaabaa" $$

Коли ми дійдемо до останньої позиції ($i=6$), поточним самим правим відрізком буде $[5;6]$. Позиції $6$ з урахуванням цього відрузку буде відповідати позиція $6-5=1$, відповідь в якій рівний $z[1] = 3$. Очевидно, що таким значенням инициализировать $z[6]$ не можна, воно цілковито некоректно. Максимум, яким значенням ми могли проинициализировать - це $1$, оскільки це найбільше значення, яке не вилазить за межі відрузку $[l;r]$.

Таким чином, в якості **початкового наближення** для $z[i]$ безопасно брати тільки таке вираз:

$$ z_0[i] = \min (r-i+1, z[i-l]). $$

Проинициализировав $z[i]$ таким значенням $z_0[i]$, ми знову далі діємо **тривіальним алгоритмом** - тому що після межі $r$, взагалі кажучи, могло обнаружиться продолжение відрузку збіг, предугадать яке одними лише попередніми значеннями Z-функції ми не могли.

Таким чином, весь алгоритм представляє з собі два випадку, які фактично розрізняються тільки **початковим значенням** $z[i]$: в першому випадку воно покладається рівним нулю, а у іншому - визначається по попереднім значенням по зазначеної формулою. Після цього обидві ветки алгоритму зводяться до выполнению **тривіального алгоритму**, стартующего зразу з зазначеного початкового значення.

Алгоритм вийшов вельми простим. Незважаючи на то, що при кожному $i$ в ньому так або інакше виконується тривіальний алгоритм - ми досягли существенного прогресса, отримавши алгоритм, працюючий за лінійне час. Чому це так, розглянемо нижче, після того, як наведемо реалізацію алгоритму.

## Реалізація

Реалізація виходить вельми лаконичной:

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> z_function (string s) {
    int n = (int) s.length();
    vector<int> z (n);
    for (int i=1, l=0, r=0; i<n; ++i) {
        if (i <= r)
            z[i] = min (r-i+1, z[i-l]);
        while (i+z[i] < n && s[z[i]] == s[i+z[i]])
            ++z[i];
        if (i+z[i]-1 > r)
            l = i,  r = i+z[i]-1;
    }
    return z;
}
```

Прокоментуємо цю реалізацію.

Всё розв'язок оформлено в вигляді функції, яка по стрічки повертає масив довжини $n$ - обчислену Z-функцію.

Масив $z[]$ спершу заповнюється нулями. Текущий самий правий відрізок збіги покладається рівним $[0;0]$, тобто свідомо маленький відрізок, в який не потрапить ні одне $i$.

Усередині циклу по $i = 1 \ldots n-1$ ми спочатку по описаного вище алгоритму визначаємо початкова значення $z[i]$ - воно або залишиться нулем, або вычислится на основі наведеної формули.

Після цього виконується тривіальний алгоритм, який намагається збільшити значення $z[i]$ настільки, наскільки це можливо.

В наприкінці виконується оновлення поточного самого правого відрузку збіги $[l;r]$, якщо, звісно, це оновлення потрібно - тобто якщо $i+z[i]-1 > r$.

## Асимптотика алгоритму

Доведемо, що наведений вище алгоритм працює за лінійне щодо довжини стрічки час, тобто за $O(n)$.

Доведення дуже просте.

Нас цікавить вкладений цикл $\rm while$ - т.до. усе остальное - лише константные операції, выполняемые $O(n)$ раз.

Покажемо, що **кожна ітерація** цього циклу $\rm while$ приведе до збільшення правою межі $r$ на одиницю.

Для цього розглянемо обидві ветки алгоритму:

* $i > r$

В цим випадку або цикл $\rm while$ не зробить ні однієї ітерації (якщо $s[0] \ne s[i]$), або ж зробить декілька ітерацій, продвигаясь кожний раз на один символ вправо, починаючи з позиції $i$, а після цього - права межа $r$ обов'язково обновится.

Оскільки $i > r$, то ми отримуємо, що дійсно кожна ітерація цього циклу збільшує нове значення $r$ на одиницю.

* $i \le r$

В цим випадку ми по наведеної формулою инициализируем значення $z[i]$ деяким числом $z_0$. Сравним це початкова значення $z_0$ з величиною $r-i+1$, отримуємо три варіанти:

* $z_0 < r-i+1$

Доведемо, що в цим випадку ні однієї ітерації цикл $\rm while$ не зробить.

Це легко довести, наприклад, від противного: якщо б цикл $\rm while$ сделал хоча б одну ітерацію, це б означало, що певне нами значення $z_0$ було неточным, менше настоящей довжини збіги. Але т.до. стрічки $s[l \ldots r]$ і $s[0 \ldots r-l]$ збігаються, то це означає, що в позиції $z[i-l]$ варто неправильное значення: менше, ніж має бути.

Таким чином, в цим варіанті з коректності значення $z[i-l]$ і з того, що воно менше $r-i+1$, випливає, що це значення збігається з шуканим значенням $z[i]$.

* $z_0 = r-i+1$

В цим випадку цикл $\rm while$ можливо совершить декілька ітерацій, однак кожна з них буде приводити до збільшення нового значення $r$ на одиницю: тому що першим ж сравниваемым символом буде $s[r+1]$, який вилазить за межі відрузку $[l;r]$.

* $z_0 > r-i+1$

Цей різновид принципово невозможен, в силу визначення $z_0$.

Таким чином, ми довели, що кожна ітерація вкладеного циклу призводить до продвижению покажчика $r$ вправо. Т.до. $r$ не могло виявитися більше $n-1$, це означає, що всього цей цикл зробить не більш $n-1$ ітерації.

Оскільки вся остальная частина алгоритму, очевидно, працює за $O(n)$, то ми довели, що і весь алгоритм обчислення Z-функції виконується за лінійне час.

## Застосування

Розглянемо декілька застосувань Z-функції при рішенні конкретних задач.

Застосування ці будуть у многом аналогічним применениям [префікс-функції](prefix_function).

### Пошук підстрічки в стрічки

У избежании путаницы, назвемо одну стрічку **текстом** $t$, іншу - **образцом** $p$. Таким чином, задача полягає в тому, аби знайти всі входження зразка $p$ в текст $t$.

Для розв'язку цій задачі образуем стрічку $s = p + \# + t$, тобто до зразком пріпішем текст через символ-роздільник (який не зустрічається ніде в самих рядках).

Порахуємо для отриманої стрічки Z-функцію. Значить для будь-якого $i$ в відрізку $[0; length(t)-1]$ по соответствующему значенням $z[i + length(p) + 1]$ можна зрозуміти, входити або образец $p$ в текст $t$, починаючи з позиції $i$: якщо це значення Z-функції рівне $length(p)$, то да, входити, інакше - ні.

Таким чином, асимптотика розв'язку вийшла $O(length(t) + length(p))$. Потребление пам'яті має ту ж асимптотику.

### Кількість різних підстрічок в стрічки

Дана стрічка $s$ довжини $n$. Потрібно порахувати кількість її різних підстрічок.

Будемо розв'язувати цю задачу ітеративно. А саме, навчимося, знаючи поточний кількість різних підстрічок, перераховувати це кількість при додаванні в кінець одного символу.

Отже, нехай $k$ - поточний кількість різних підстрічок стрічки $s$, і ми додаємо в кінець символ $c$. Очевидно, в результаті могли з'явитися деякі нові підстрічки, оканчивавшиеся на цим новому символі $c$ (а саме, всі підстрічки, оканчивающиеся на цим символі, але не встречавшиеся раніше).

Візьмемо стрічку $t=s+c$ і інвертуємо її (запишемо символи в зворотньому порядку). Наша задача - порахувати, скільки у стрічки $t$ таких префіксів, які не зустрічаються в ній більш ніде. Але якщо ми порахуємо для стрічки $t$ Z-функцію і найдемо її максимальне значення $z_{\rm max}$, то, очевидно, в стрічки $t$ зустрічається (не в початку) її префікс довжини $z_{\rm max}$, але не більшої довжини. Зрозуміло, префікси меншої довжини вже точно зустрічаються в ній.

Отже, ми отримали, що число нових підстрічок, з'являються при дописуванні символу $c$, рівне $len - z_{\rm max}$, де $len$ - поточна довжина стрічки після приписування символу $c$.

Отже, асимптотика розв'язку для стрічки довжини $n$ становить $O(n^2)$.

Варто замітити, що цілковито аналогічно можна перераховувати за $O(n)$ кількість різних підстрічок і при дописуванні символу в початок, а також при видаленні символу з кінця або з початку.

### Стиснення стрічки

Дана стрічка $s$ довжини $n$. Потрібно знайти саме короткий її "стислий" уявлення, тобто знайти таку стрічку $t$ найменшою довжини, що $s$ можна уявити в вигляді конкатенації однієї або декількох копій $t$.

Для розв'язку порахуємо Z-функцію стрічки $s$, і найдемо першу позицію $i$ таку, що $i + z[i] = n$, і при цим $n$ ділиться на $i$. Значить стрічку $s$ можна стиснути до стрічки довжини $i$.

Доведення такого розв'язку практично не відрізняється від доведення розв'язку з допомогою [префікс-функції](prefix_function).

## Задачі в online judges

Список задач, які можна розв'язати, використовуючи Z-функцію:

* [UVA #455 **"Periodic Strings"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=396)

* [UVA #11022 **"String Factoring"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1963=)
