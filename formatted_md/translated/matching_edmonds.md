# Алгоритм Едмондса знаходження найбільшого паросполука в довільних графах

Дан неорієнтований незважений граф $G$ з $n$ вершинами. Потрібно знайти в ньому найбільше паросполука, тобто таке найбільше (по потужності) множину $m$ його ребер, що ніякі два ребра з обраних не инцидентны один одному (тобто не мають загальних вершин).

В відміну від випадку дводольного графа (див. [Алгоритм Куна](kuhn_matching)), в графі $G$ можуть бути присутнім цикли непарної довжини, що значно усложняет пошук збільшують шляхів.

Наведемо спочатку теорему Бержа, з якій випливає, що, як і в випадку дводольних графів, найбільше паросполука можна знаходити при допомоги збільшують шляхів.

## Увеличивающие шляхи. Теорема Бержа

Нехай зафіксовано деякий паросполука $M$. Значить проста ланцюг $P = (v_1, v_2, \ldots, v_k)$ називається чередующейся ланцюгом, якщо в ній ребра по черги належать - не належать паросполуці $M$. Чередующаяся ланцюг називається збільшоючим, якщо її перша і остання вершини не належать паросполуці. Іншими словами, проста ланцюг $P$ є збільшоючим тоді і тільки тоді, коли вершина $v_1 \not\in M$, ребро $(v_2,v_3) \in M$, ребро $(v_4,v_5) \in M$, ..., ребро $(v_{k-2},v_{k-1}) \in M$, і вершина $v_k \not\in M$.

\img{edmonds_1.png}

**Теорема Бержа** (Claude Berge, 1957 г).. Паросочетание $M$ є найбільшим тоді і тільки тоді, коли для нього не існує збільшоючим ланцюги.

**Доведення необхідності**. Нехай для паросполука $M$ існує збільшує ланцюг $P$. Покажемо, як перейти до паросполуці більшої потужності. Выполним чергування паросполука $M$ уздовж цій ланцюги $P$, тобто включимо в паросполука ребра $(v_1,v_2)$, $(v_3,v_4)$, ..., $(v_{k-1},v_k)$, і видалимо з паросполука ребра $(v_2,v_3)$, $(v_4,v_5)$, ..., $(v_{k-2},v_{k-1})$. В результаті, очевидно, буде отримано коректне паросполука, потужність якого буде на одиницю вище, ніж у паросполука $M$ (т.до. ми додали $k/2$ ребер, а видалили $k/2-1$ ребро).

**Доведення достатності**. Нехай для паросполука $M$ не існує збільшоючим ланцюги, доведемо, що воно є найбільшим. Нехай $\overline M$ - найбільше паросполука. Розглянемо симметрическую різницю $\overline G = M \oplus \overline M$ (тобто множину ребер, що належать або $M$, або $\overline M$, але не обом одночасно). Покажемо, що $\overline G$ містить однакове число ребер з $M$ і $\overline M$ (т.до. ми исключили з $\overline G$ тільки загальні для них ребра, то звідси буде дотримуватися і $|M| = |\overline M|$). Зауважимо, що $\overline G$ складається тільки з простих ланцюгів і циклів (т.до. інакше однієї вершині були б инцидентны зразу два ребра какого-або паросполука, що неможливо). Далі, цикли не можуть мати непарну довжину (по тією ж самою причини). Цепь в $\overline G$ також не можливо мати непарну довжину (інакше б вона являлась збільшоючим ланцюгом для $M$, що суперечить умові, або для $\overline M$, що суперечить його максимальности). Нарешті, в парних циклах і цепях парної довжини в $\overline G$ ребра поочерёдно входять в $M$ і $\overline M$, що і означає, що в $\overline G$ входити однакове кількість ребер від $M$ і $\overline M$. Як вже згадувалося вище, звідси випливає, що $|M| = |\overline M|$, тобто $M$ є найбільшим паросполукою.

Теорема Бержа дає основу для алгоритму Едмондса - пошук збільшують ланцюгів і чергування уздовж них, поки збільшують ланцюги знаходяться.

## Алгоритм Едмондса. Стиснення квіток

Основна проблема полягає в тому, як знаходити збільшує шлях. Якщо в графі є цикли непарної довжини, то просто запускати обхід в глибину/ширину не можна.

Можна привести простий контрприклад, коли при запуску з однієї з вершин алгоритм, не обрабатывающий особливо цикли непарної довжини (фактично, [Алгоритм Куна](kuhn_matching)) не знайде збільшує шлях, хоча повинен. Це цикл довжини 3 з висящим на ньому ребром, тобто граф 1-2, 2-3, 3-1, 2-4, і ребро 2-3 взято в паросполука. Значить при запуску з вершини 1, якщо обхід піде спочатку в вершину 2, то він "упрётся" в вершину 3, замість того аби знайти збільшує ланцюг 1-3-2-4. Правда, на цим прикладі при запуску з вершини 4 алгоритм Куна усе ж знайде цю збільшує ланцюг.

\img{edmonds_2.png}

Тим не менш, можна побудувати граф, на якому при определённом порядку в списках суміжності алгоритм Куна зайдёт в тупик. В якості прикладу можна привести такий граф з 6 вершинами і 7 ребрами: 1-2, 1-6, 2-6, 2-4, 4-3, 1-5, 4-5. Якщо застосувати тут алгоритм Куна, то він знайде паросполука 1-6, 2-4, після чого він повинен буде виявити збільшує ланцюг 5-1-6-2-4-3, однак можливо так і не виявити її (якщо з вершини 5 він піде спочатку в 4, і тільки потім в 1, а при запуску з вершини 3 він з вершини 2 піде спочатку в 1, і тільки потім в 6).

\img{edmonds_3.png}

Як ми увидели на цим прикладі, вся проблема в тому, що при попадании в цикл непарної довжини обхід можливо піти по циклу в неправильном напрямку. Насправді, нас цікавлять тільки "насыщенные" цикли, тобто в яких є $k$ насичених ребер, де довжина циклу рівна $2k+1$. В такому циклі є рівне одна вершина, не насыщенная ребрами цього циклу, назвемо її **базой** (base). До базовой вершині підходить чергується шлях парної (можливо, нульовий) довжини, що починається в вільної (тобто не принадлежащей паросполуці) вершині, і цей шлях називається **стеблем** (stem). Нарешті, підграф, образованный "насыщенным" непарним циклом, називається **цветком** (blossom).

\img{edmonds_4.png}

Ідея алгоритму Едмондса (Jack Edmonds, 1965 г). - в **стисканні квіток** (blossom shrinking). Стиснення квітки - це стиснення всього непарного циклу в одну псевдо-вершину (відповідно, всі ребра, инцидентные вершин цього циклу, стають инцидентными псевдо-вершині). Алгоритм Едмондса шукає в графі всі цветки, сжимает їх, після чого в графі не залишається "поганих" циклів непарної довжини, і на такому графі (называемом "поверхностным" (surface) графом) вже можна шукати збільшує ланцюг простим обходом в глибину/ширину. Після знаходження збільшоючим ланцюги в поверхностном графі необхідно "развернуть" цветки, восстановив тим самим збільшує ланцюг в вихідному графі.

Однак неочевидно, що після стиснення квітки не нарушится структура графа, а саме, що якщо в графі $G$ существовала збільшує ланцюг, то вона існує і в графі $\overline G$, отриманому після стиснення квітки, і навпаки.

**Теорема Едмондса**. В графі $\overline G$ існує збільшує ланцюг тоді і тільки тоді, коли існує збільшує ланцюг в $G$.

**Доведення**. Отже, нехай граф $\overline G$ був отриманий з графа $G$ сжатием одного квітки (позначимо через $B$ цикл квітки, і через $\overline B$ відповідну стислу вершину), доведемо твердження теореми. На Початку зауважимо, що достатньо розглядати випадок, коли база квітки є вільної вершиною (не принадлежащей паросполуці). Дійсно, в іншому випадку в базі квітки закінчується чергується шлях парної довжини, що починається в вільної вершині. Прочередовав паросполука уздовж цього шляхи, потужність паросполука не зміниться, а база квітки стане вільної вершиною. Отже, при доведенні можна вважати, що база квітки є вільної вершиною.

**Доведення необхідності**. Нехай шлях $P$ є збільшує в графі $G$. Якщо він не проходити через $B$, то тоді, очевидно, він буде збільшує і в графі $\overline G$. Нехай $P$ проходити через $B$. Значить можна не втрачаючи спільності вважати, що шлях $P$ представляє собою деякий шлях $P_1$, не проходить по вершин $B$, плюс деякий шлях $P_2$, проходить по вершин $B$ і, можливо, іншим вершин. Але тоді шлях $P_1 + \overline B$ буде бути збільшує шляхом в графі $\overline G$, що і потрібно довести.

**Доведення достатності**. Нехай шлях $\overline P$ є збільшує шляхом в графі $\overline G$. Знову, якщо шлях $\overline P$ не проходити через $\overline B$, то шлях $\overline P$ без змін є збільшує шляхом в $G$, тому цей випадок ми розглядати не будемо.

Розглянемо окремо випадок, коли $\overline P$ починається зі сжатого квітки $\overline B$, тобто має вид $(\overline B, c, \ldots)$. Значить в цветке $B$ знайдеться відповідна вершина $v$, яка связана (ненасыщенным) ребром з $c$. Залишилося тільки замітити, що з бази квітки завжди знайдеться чергується шлях парної довжини до вершини $v$. Враховуючи усе вышесказанное, отримуємо, що шлях $P = (b, \ldots, v, c, ..).$ є збільшує шляхом в графі $G$.

Нехай тепер шлях $\overline P$ проходити через псевдо-вершину $\overline B$, але не починається і не закінчується в ній. Значить в $\overline P$ є два ребра, проходять через $\overline B$, нехай це $(a, \overline B)$ і $(\overline B, c)$. Одне з них обов'язково має належати паросполуці $M$, однак, т.до. база квітки не насичена, а всі інші вершини циклу квітки $B$ насыщены ребрами циклу, то ми приходимо до протиріччя. Таким чином, цей випадок просто невозможен.

Отже, ми розглянули всі випадки і в кожному з них показали справедливость теореми Едмондса.

**Загальна схема алгоритму Едмондса** приймає наступного вид:

<!--- TODO: specify code snippet id -->
``` cpp
void edmonds() {
    for (int i=0; i<n; ++i)
        if (вершина i не в паросполуці) {
            int last_v = find_augment_path (i);
            if (last_v != -1)
                виконати чергування уздовж шляхи з i в last_v;
        }
}

int find_augment_path (int root) {
    обхід в ширину:
        int v = поточна_вершина;
        перебрати всі ребра з v
            якщо виявили цикл непарної довжини, стиснути його
            якщо прийшли в вільну вершину, return
            якщо прийшли в несвободную вершину, то додати
                в чергу суміжну їй в паросполуці
    return -1;
}
```

## Эффективная реалізація

Відразу оцінимо асимптотику. Всього є $n$ ітерацій, на кожної з яких виконується обхід в ширину за $O(m)$, крім того, можуть відбуватися операції стиснення квіток - їх можливо бути $O(n)$. Таким чином, якщо ми навчимося стискати квітка за $O(n)$, то загальна асимптотика алгоритму складе $O(n \cdot (m + n^2)) = O(n^3)$.

Основную складність являють операції стиснення квіток. Якщо виконувати їх, безпосередньо об'єднуючи списки суміжності в один і видаляючи з графа зайві вершини, то асимптотика стиснення одного квітки буде $O(m)$, крім того, возникнут складності при "разворачивании" квіток.

Замість цього будемо для кожної вершини графа $G$ підтримувати вказівник на базу квітки, якому вона належить (або на собі, якщо вершина не належить никакому цветку). Нам треба розв'язати дві задачі: стиснення квітки за $O(n)$ при його обнаружении, а також удобное сохранение всій інформації для последующего чергування уздовж збільшує шляхи.

Отже, одна ітерація алгоритму Едмондса представляє собою обхід в ширину, выполняемый з заданої вільної вершини $\rm root$. Постепенно буде строиться дерево обходу в ширину, причому шлях в ньому до будь-якої вершини буде бути чередующимся шляхом, начинающимся зі вільної вершини $\rm root$. Для зручності програмування будемо класти в чергу тільки ті вершини, відстань до яких в дереві шляхів парне (будемо називати такі вершини парними - тобто це корінь дерева, і другі кінці ребер в паросполуці). Саме дерево будемо зберігати в вигляді масиву предків $\rm p[]$, в якому для кожної непарної вершини (тобто до якій відстань в дереві шляхів непарне, тобто це перші кінці ребер в паросполуці) будемо зберігати предка - парну вершину. Таким чином, для відновлення шляхи з дерева нам треба поочерёдно користуватися массивами $\rm p[]$ і $\rm match[]$, де $\rm match[]$ - для кожної вершини містить суміжну їй в паросполуці, або $-1$, якщо такий ні.

Тепер стає зрозуміло, як обнаруживать цикли непарної довжини. Якщо ми з поточній вершини $v$ в процесі обходу в ширину приходимо в таку вершину $u$, що є коренем $\rm root$ або принадлежащую паросполуці і дереву шляхів (тобто $\rm p[match[]]$ від якій не рівне -1), то ми виявили квітка. Дійсно, при виконанні цих умов і вершина $v$, і вершина $u$ є парними вершинами. Расстояние від них до їх найменшого загального предка має одну парність, тому знайдений нами цикл має непарну довжину.

Навчимося **стискати цикл**. Отже, ми виявили нечётный цикл при розгляді ребра $(v,u)$, де $u$ і $v$ - парні вершини. Знайдемо їх найменшого загального предка $b$, він і буде базой квітки. Неважко замітити, що база теж є парної вершиною (оскільки у непарних вершин в дереві шляхів є тільки один син). Однак треба замітити, що $b$ - це, можливо, псевдовершина, тому ми фактично найдемо базу квітки, являющегося найменшим загальним предком вершин $v$ і $u$. Реалізуємо зразу знаходження найменшого загального предка (нас цілком устраивает асимптотика $O(n)$):

<!--- TODO: specify code snippet id -->
``` cpp
int lca (int a, int b) {
    bool used[MAXN] = { 0 };
    // піднімаємося від вершини a до кореня, помечая всі парні вершини
    for (;;) {
        a = base[a];
        used[a] = true;
        if (match[a] == -1)  break; // дійшли до кореня
        a = p[match[a]];
    }
    // піднімаємося від вершини b, поки не найдемо позначену вершину
    for (;;) {
        b = base[b];
        if (used[b])  return b;
        b = p[match[b]];
    }
}
```

Тепер нам треба выявить сам цикл - пройтися від вершин $v$ і $u$ до бази $b$ квітки. Будет більш зручно, якщо ми поки просто пометим в якому-то специальном масиві (назвемо його $\rm blossom[]$) вершини, належать поточному цветку. Після цього нам треба буде симитировать обхід в ширину з псевдо-вершини - для цього достатньо покласти в чергу обходу в ширину всі вершини, що лежать на циклі квітки. Тим самим ми избежим явного про'єднання списків суміжності.

Однак залишається ще одна проблема: коректне відновлення шляхів по закінченні обходу в ширину. Для нього ми сохраняли масив предків $\rm p[]$. Але після стиснення квіток виникає єдина проблема: обхід в ширину продолжился зразу з всіх вершин циклу, в тому числі і непарних, а масив предків у нас предназначался для відновлення шляхів по чётным вершин. Більш того, коли в стислому графі знайдеться збільшує ланцюг, що проходить через квітка, вона взагалі буде проходити по цьому циклу в такому напрямку, що в дереві шляхів це буде представляться движением вниз. Однак всі ці проблеми изящно решаются таким манёвром: при стисканні циклу, проставимо предків для всіх його парних вершин (крім бази), аби ці "предки" указывали на соседнюю вершину в циклі. Для вершин $u$ і $v$, якщо вони також не бази, направим вказівники предків один на одного. В результаті, якщо при відновленні збільшує шляхи ми прийдемо в цикл квітки в непарну вершину, шлях по предкам буде восстановлен правильно, і приведе в базу квітки (з якій він вже далі буде восстанавливаться нормально).

\img{edmonds_5.png}

Отже, ми готовы реалізувати стиснення квітки:

<!--- TODO: specify code snippet id -->
``` cpp
int v, u; // ребро (v,u), при розгляді якого був обнаружен квітка
int b = lca (v, u);
memset (blossom, 0, sizeof blossom);
mark_path (v, b, u);
mark_path (u, b, v);
```

де функція $\rm mark\_path()$ проходити по шляхи від вершини до бази квітки, проставляє в специальном масиві $\rm blossom[]$ для них $\rm true$ і проставляє предків для парних вершин. Параметр $\rm children$ - син для самою вершини $v$ (з допомогою цього параметра ми замкнём цикл в предках).

<!--- TODO: specify code snippet id -->
``` cpp
void mark_path (int v, int b, int children) {
    while (base[v] != b) {
        blossom[base[v]] = blossom[base[match[v]]] = true;
        p[v] = children;
        children = match[v];
        v = p[match[v]];
    }
}
```

Нарешті, реалізуємо основную функцію - $\rm find\_path ~ (int ~ root)$, яка буде шукати збільшує шлях з вільної вершини $\rm root$ і повертати останню вершину цього шляхи, або $-1$, якщо збільшує шлях не знайдений.

На Початку зробимо ініціалізацію:

<!--- TODO: specify code snippet id -->
``` cpp
int find_path (int root) {
    memset (used, 0, sizeof used);
    memset (p, -1, sizeof p);
    for (int i=0; i<n; ++i)
        base[i] = i;
```

Далі йде обхід в ширину. Рассматривая чергове ребро $(v, to)$, у нас є декілька варіантів:

* Ребро несуществующее. Під цим ми подразумеваем, що $v$ і $to$ належать однієї сжатой псевдо-вершині (${\rm base}[v] == {\rm base}[to]$), тому в поточному поверхностном графі цього ребра ні. Крім цього випадку, є ще один випадок: коли ребро $(v, to)$ вже належить поточному паросполуці; т.до. ми припустимо, що вершина $v$ є парної вершиною, то прохід по цьому ребру означає в дереві шляхів подъём до предку вершини $v$, що недопустимо.

<!--- TODO: specify code snippet id -->
``` cpp
if (base[v] == base[to] || match[v] == to)  continue;
```

* Ребро замыкает цикл непарної довжини, тобто обнаруживается квітка. Як вже згадувалося вище, цикл непарної довжини обнаруживается при виконанні умови:

<!--- TODO: specify code snippet id -->
``` cpp
if (to == root || match[to] != -1 && p[match[to]] != -1)
```

В цим випадку потрібно виконати стиснення квітки. Вище вже детально разбирался цей процес, тут наведемо його реалізацію:

<!--- TODO: specify code snippet id -->
``` cpp
int curbase = lca (v, to);
memset (blossom, 0, sizeof blossom);
mark_path (v, curbase, to);
mark_path (to, curbase, v);
for (int i=0; i<n; ++i)
    if (blossom[base[i]]) {
        base[i] = curbase;
        if (!used[i]) {
            used[i] = true;
            q[qt++] = i;
        }
    }
```

* Інакше - це "звичайне" ребро, чинимо як і в звичайному пошуку в ширину. Єдина тонкість - при перевірці, що цю вершину ми ще не посещали, треба смотреть не в масив $\rm used$, а в масив $p$ - саме він заповнюється для відвіданих непарних вершин. Якщо ми в вершину $to$ ще не заходили, і вона оказалась ненасиченої, то ми знайшли збільшує ланцюг, заканчивающуюся на вершині $to$, повертаємо її.

<!--- TODO: specify code snippet id -->
``` cpp
if (p[to] == -1) {
    p[to] = v;
    if (match[to] == -1)
        return to;
    to = match[to];
    used[to] = true;
    q[qt++] = to;
}
```

Отже, повна реалізація функції $\rm find\_path()$:

<!--- TODO: specify code snippet id -->
``` cpp
int find_path (int root) {
    memset (used, 0, sizeof used);
    memset (p, -1, sizeof p);
    for (int i=0; i<n; ++i)
        base[i] = i;

    used[root] = true;
    int qh=0, qt=0;
    q[qt++] = root;
    while (qh < qt) {
        int v = q[qh++];
        for (size_t i=0; i<g[v].size(); ++i) {
            int to = g[v][i];
            if (base[v] == base[to] || match[v] == to)  continue;
            if (to == root || match[to] != -1 && p[match[to]] != -1) {
                int curbase = lca (v, to);
                memset (blossom, 0, sizeof blossom);
                mark_path (v, curbase, to);
                mark_path (to, curbase, v);
                for (int i=0; i<n; ++i)
                    if (blossom[base[i]]) {
                        base[i] = curbase;
                        if (!used[i]) {
                            used[i] = true;
                            q[qt++] = i;
                        }
                    }
            }
            else if (p[to] == -1) {
                p[to] = v;
                if (match[to] == -1)
                    return to;
                to = match[to];
                used[to] = true;
                q[qt++] = to;
            }
        }
    }
    return -1;
}
```

Нарешті, наведемо визначення всіх глобальних масивів, і реалізацію основний програми знаходження найбільшого паросполука:

<!--- TODO: specify code snippet id -->
``` cpp
const int MAXN = ...; // максимально возможное число вершин у вхідному графі

int n;
vector<int> g[MAXN];
int match[MAXN], p[MAXN], base[MAXN], q[MAXN];
bool used[MAXN], blossom[MAXN];

...

int main() {
    ... читання графа ...

    memset (match, -1, sizeof match);
    for (int i=0; i<n; ++i)
        if (match[i] == -1) {
            int v = find_path (i);
            while (v != -1) {
                int pv = p[v],  ppv = match[pv];
                match[v] = pv,  match[pv] = v;
                v = ppv;
            }
        }
}
```

## Оптимизация: предварительное побудова паросполука

Як і в випадку [Алгоритма Куна](kuhn_matching), перед виконанням алгоритму Едмондса можна яким-нибудь простим алгоритмом побудувати предварительное паросполука. Наприклад, таким жадібним алгоритмом:
<!--- TODO: specify code snippet id -->
``` cpp
for (int i=0; i<n; ++i)
    if (match[i] == -1)
        for (size_t j=0; j<g[i].size(); ++j)
            if (match[g[i][j]] == -1) {
                match[g[i][j]] = i;
                match[i] = g[i][j];
                break;
            }
```

Така оптимізація значно (до декількох раз) ускорит роботу алгоритму на випадкових графах.

## Випадок дводольного графа

В дводольних графах відсутні цикли непарної довжини, і, отже, код, выполняющий стиснення квіток, ніколи не виконається. Удалив подумки всі частини коду, обрабатывающие стиснення квіток, ми отримаємо [Алгоритм Куна](kuhn_matching) практично в чистом вигляді. Таким чином, на дводольних графах алгоритм Едмондса вырождается в [алгоритм Куна](kuhn_matching) і працює за $O(n m)$.

## Дальнейшая оптимізація

У всіх вищеописаних операциях з цветками легко угадываются операції з непересічними множествами, які можна виконувати набагато эффективнее (див. [Система що не перетинаються множин](dsu)). Якщо переписать алгоритм з використанням цій структури, то асимптотика алгоритму понизится до $O(n m)$. Таким чином, для довільних графів ми отримали ту ж асимптотическую оцінку, що і в випадку дводольних графів (алгоритм Куна), але помітно більш складним алгоритмом.
