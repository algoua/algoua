# Пошук пари пересічних відрізків алгоритмом заметающей прямої за O (N log N)

Дано $n$ відрізків на площині. Потрібно перевірити, перетинаються або один з другом хоча б два з них. (Якщо відповідь положителен - то вивести цю пару пересічних відрізків; серед декількох відповідей достатньо вибрати будь-якої з них).

Наивный алгоритм розв'язку - перебрати за $O(n^2)$ всі пари відрізків і перевірити для кожної пари, перетинаються вони або ні. В даній статті описується алгоритм з часом роботи $O(n \log n)$, який заснований на принципе **скануючої (заметающей) прямої** (по-английски: "sweep line").

## Алгоритм

Проведемо подумки вертикальну пряму $x = -\infty$ і начнём двигать цю пряму вправо. За ходу свого руху ця пряма буде зустрічатися з відрізками, причому в будь-якої момент часу кожний відрізок буде перетинатися з нашій прямої по однієї точці (ми поки будемо вважати, що вертикальных відрізків ні).

\img{sweep_line_1.png}

Таким чином, для кожного відрузку в якийсь момент часу його точка з'явиться на скануючої прямої, потім з движением прямої буде рухатися і ця точка, і, нарешті, в якийсь момент відрізок исчезнет з прямої.

Нас цікавить **относительный порядок відрізків** по вертикали. А саме, ми будемо зберігати список відрізків, перетинають сканирующую пряму в даний момент часу, де відрізки будуть відсортовані по їх $y$-координаті на скануючої прямої.

\img{sweep_line_2.png}

Цей порядок интересен тим, що пересічні відрізки будуть мати однакову $y$-координату хоча б в один момент часу:

\img{sweep_line_3.png}

Сформулируем ключевые затвердження:

* Для пошуку пересекающейся пари достатньо розглядати при кожному фіксованому положенні скануючої прямої **тільки сусідні відрізки**.

* Досить розглядати сканирующую пряму не у всіх можливих дійсних позиціях $(-\infty \ldots +\infty)$, а **тільки в тих позиціях, коли з'являються нові відрізки або исчезают старі**. Іншими словами, достатньо обмежитися лише тільки положениями, рівними абсциссам точок-кінців відрізків.

* При появі нового відрузку достатньо **вставити** його в потрібне місце в список, отриманий для попередньою скануючої прямої. Проверять на перетин треба **тільки добавляемый відрізок з його непосредственными сусідами в списку зверху і знизу**.

* При исчезновении відрузку достатньо **вилучити** його з поточного списку. Після цього треба **перевірити на перетин з верхним і нижнім сусідами** в списку.

* Інших змін в порядку слідування відрізків в списку, крім описаних, не існує. Інших проверок на перетину виробляти не треба.

Для розуміння істинності цих утверждений достатньо наступних замечаний:

* Два що не перетинаються відрузку ніколи не змінюють свого **относительного порядку**.

Насправді, якщо один відрізок спочатку був вище іншого, а потім став нижче, то між двома цими моментами відбулося перетин цих двох відрізків.

* Иметь совпадающие $y$-координати два що не перетинаються відрузку також не можуть.

* З цього випливає, що в момент появи відрузку ми можемо знайти в черги позицію для цього відрузку, і більше цей відрізок переставлять в черги не доведеться: його **порядок щодо інших відрізків в черги змінюватися не буде**.

* Два пересічних відрузку в момент точки свого перетину окажутся **сусідами** один одного в черги.

* Отже, для знаходження пари пересічних відрізків достатньо перевірити на перетин тільки всі ті пари відрізків, які коли-нибудь за час руху скануючої прямої хоча б раз **були сусідами один одного**.

Легко замітити, що цього достатньо лише перевіряти добавляемый відрізок зі своїми верхним і нижнім сусідами, а також при видаленні відрузку - його верхнего і нижнего сусідів (які після видалення стануть сусідами один одного).

* Слід звернути увага, що при фіксованому положенні скануючої прямої ми **спочатку** повинні провести **додавання** всіх з'являються тут відрізків, і лише **потім** - **видалення** всіх исчезающих тут відрізків.

Тим самим, ми не пропустимо перетину відрізків по вершині: тобто такі випадки, коли два відрузку мають загальну вершину.

* Зауважимо, що **вертикальні відрізки** насправді ніяк не впливають на коректність алгоритму.

Ці відрізки выделяются тим, що вони з'являються і исчезают в один і той ж момент часу. Однак, за рахунок попереднього замечания, ми знаємо, що спочатку всі відрізки будуть добавлены в чергу, і лише потім будуть удалены. Отже, якщо вертикальный відрізок пересекается з яким-то іншим открытым в цей момент відрізком (в тому числі вертикальным), то це буде обнаружено.

В яке місце черги поміщати вертикальні відрізки? Ведь вертикальный відрізок не має однієї певної $y$-координати, він простирается на цілий відрізок по $y$-координаті. Однак легко зрозуміти, що в якості $y$-координати можна взяти будь-яку координату з цього відрузку.

Таким чином, весь алгоритм зробить не більш $2n$ тестів на перетин пари відрізків, і зробить $O(n)$ операцій з очередью відрізків (по $O(1)$ операцій в моменты появи і зникнення кожного відрузку).

Підсумкова **асимптотика** алгоритму становить, таким чином, $O(n \log n)$.

## Реалізація

Наведемо повну реалізацію описаного алгоритму:

<!--- TODO: specify code snippet id -->
``` cpp
const double EPS = 1E-9;

struct pt {
    double x, y;
};

struct seg {
    pt p, q;
    int id;

    double get_y (double x) const {
        if (abs (p.x - q.x) < EPS)  return p.y;
        return p.y + (q.y - p.y) * (x - p.x) / (q.x - p.x);
    }
};

inline bool intersect1d (double l1, double r1, double l2, double r2) {
    if (l1 > r1)  swap (l1, r1);
    if (l2 > r2)  swap (l2, r2);
    return max (l1, l2) <= min (r1, r2) + EPS;
}

inline int vec (const pt & a, const pt & b, const pt & c) {
    double s = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
    return abs(s)<EPS ? 0 : s>0 ? +1 : -1;
}

bool intersect (const seg & a, const seg & b) {
    return intersect1d (a.p.x, a.q.x, b.p.x, b.q.x)
        && intersect1d (a.p.y, a.q.y, b.p.y, b.q.y)
        && vec (a.p, a.q, b.p) * vec (a.p, a.q, b.q) <= 0
        && vec (b.p, b.q, a.p) * vec (b.p, b.q, a.q) <= 0;
}

bool operator< (const seg & a, const seg & b) {
    double x = max (min (a.p.x, a.q.x), min (b.p.x, b.q.x));
    return a.get_y(x) < b.get_y(x) - EPS;
}

struct event {
    double x;
    int tp, id;

    event() { }
    event (double x, int tp, int id)
        : x(x), tp(tp), id(id)
    { }

    bool operator< (const event & e) const {
        if (abs (x - e.x) > EPS)  return x < e.x;
        return tp > e.tp;
    }
};

set<seg> s;
vector < set<seg>::iterator > where;

inline set<seg>::iterator prev (set<seg>::iterator it) {
    return it == s.begin() ? s.end() : --it;
}

inline set<seg>::iterator next (set<seg>::iterator it) {
    return ++it;
}

pair<int,int> solve (const vector<seg> & a) {
    int n = (int) a.size();
    vector<event> e;
    for (int i=0; i<n; ++i) {
        e.push_back (event (min (a[i].p.x, a[i].q.x), +1, i));
        e.push_back (event (max (a[i].p.x, a[i].q.x), -1, i));
    }
    sort (e.begin(), e.end());

    s.clear();
    where.resize (a.size());
    for (size_t i=0; i<e.size(); ++i) {
        int id = e[i].id;
        if (e[i].tp == +1) {
            set<seg>::iterator
                nxt = s.lower_bound (a[id]),
                prv = prev (nxt);
            if (nxt != s.end() && intersect (*nxt, a[id]))
                return make_pair (nxt->id, id);
            if (prv != s.end() && intersect (*prv, a[id]))
                return make_pair (prv->id, id);
            where[id] = s.insert (nxt, a[id]);
        }
        else {
            set<seg>::iterator
                nxt = next (where[id]),
                prv = prev (where[id]);
            if (nxt != s.end() && prv != s.end() && intersect (*nxt, *prv))
                return make_pair (prv->id, nxt->id);
            s.erase (where[id]);
        }
    }

    return make_pair (-1, -1);
}
```

Основна функція тут - $\rm solve()$, яка повертає номера знайдених пересічних відрізків, або $(-1, -1)$, якщо перетину відсутні.

Перевірка на перетин двох відрізків здійснюється функцією $\rm intersect()$, з допомогою [алгоритму на основі ориентированной площі трикутника](segments_intersection_checking).

Черга відрізків в глобальной змінній $s$ - $\rm set<event>$. Итераторы, указывающие становище кожного відрузку в черги (для удобного видалення відрізків з черги), зберігаються в глобальном масиві $\rm where$.

Введены також дві допоміжні функції $\rm prev()$ і $\rm next()$, які возвращают итераторы на предыдущий і наступного елементи (або $\rm end()$, якщо такового не існує).

Константа $\rm EPS$ позначає похибка порівняння двох речових чисел (в основному вона використовується при перевірці двох відрізків на перетин).
