# Пошук в ширину

Пошук в ширину (обхід в ширину, breadth-first search) - це один з основних алгоритмів на графах.

В результаті пошуку в ширину знаходиться шлях найкоротшою довжини в невиважені графі, тобто шлях, що містить найменше число ребер.

Алгоритм працює за $O(n+m)$, де $n$ - число вершин, $m$ - число ребер.

## Опис алгоритму

На вхід алгоритму подається завдань граф (незважений), і номер стартової вершини $s$. Граф можливо бути як орієнтованим, так і неориентированным, для алгоритму це не важливо.

Сам алгоритм можна розуміти як процес "поджигания" графа: на нульовому кроці поджигаем тільки вершину $s$. На кожному наступному кроці огонь з кожної вже горящей вершини перекидывается на всіх її сусідів; тобто за одну ітерацію алгоритму відбувається расширение "кольца огня" в ширину на одиницю (звідси і назва алгоритму).

Більш строго це можна уявити наступним чином. Створимо чергу $q$, в яку будуть помещаться горящие вершини, а також заведемо булевий масив $\rm used[]$, в якому для кожної вершини будемо відзначати, горит вона вже або ні (або іншими словами, була або вона переглянуло).

Cпершу в чергу поміщається тільки вершина $s$, і $\rm used[s] = true$, а для всіх інших вершин $\rm used[] = false$. Потім алгоритм представляє собою цикл: поки чергу не порожня, достать з її головы одну вершину, переглянути всі ребра, вихідні з цій вершини, і якщо які-то з просмотренных вершин ще не горят, то поджечь їх і поместить в кінець черги.

В результаті, коли чергу опустеет, обхід в ширину обойдёт всі досяжні з $s$ вершини, причому до кожної дійде найкоротшим шляхом. Також можна порахувати довжини найкоротших шляхів (для чого просто треба завести масив довжин шляхів $d[]$), і компактно зберегти інформацію, достаточную для відновлення всіх цих найкоротших шляхів (для цього треба завести масив "предків" $p[]$, в якому для кожної вершини зберігати номер вершини, по якій ми потрапили в цю вершину).

## Реалізація

Реалізуємо вищеописаний алгоритм на мові C++.

Входные дані:

<!--- TODO: specify code snippet id -->
``` cpp

vector < vector<int> > g; // граф
int n; // число вершин
int s; // стартова вершина (вершини всюди нумеруються з нуля)

// читання графа
...
```

Сам обхід:

<!--- TODO: specify code snippet id -->
``` cpp

queue<int> q;
q.push (s);
vector<bool> used (n);
vector<int> d (n), p (n);
used[s] = true;
p[s] = -1;
while (!q.empty()) {
    int v = q.front();
    q.pop();
    for (size_t i=0; i<g[v].size(); ++i) {
        int to = g[v][i];
        if (!used[to]) {
            used[to] = true;
            q.push (to);
            d[to] = d[v] + 1;
            p[to] = v;
        }
    }
}
```

Якщо тепер треба відновити і вивести найкоротший шлях до якийсь вершини $\rm to$, це можна зробити наступним чином:

<!--- TODO: specify code snippet id -->
``` cpp

if (!used[to])
    cout << "No path!";
else {
    vector<int> path;
    for (int v=to; v!=-1; v=p[v])
        path.push_back (v);
    reverse (path.begin(), path.end());
    cout << "Path: ";
    for (size_t i=0; i<path.size(); ++i)
        cout << path[i] + 1 << " ";
}
```

## Додатки алгоритму

* Пошук **найкоротшого шляхи** в невиважені графі.

* Пошук **компонент зв'язності** в графі за $O(n+m)$.

Для цього ми просто запускаємо обхід в ширину від кожної вершини, за винятком вершин, залишилися посещёнными ($\rm used=true$) після попередніх запусків. Таким чином, ми виконуємо звичайний запуск в ширину від кожної вершини, але не обнуляем кожний раз масив $\rm used[]$, за рахунок чого ми кожний раз будемо обходити нову компоненту зв'язності, а сумарне час роботи алгоритму складе як і раніше $O(n+m)$ (такі декілька запусків обходу на графі без обнуления масиву $\rm used$ називаються серией обходів в ширину).

* Нахождения розв'язку який-або задачі (гри) **з найменшим числом ходів**, якщо кожне стан системи можна уявити вершиною графа, а переходи з одного стан в інше - ребрами графа.

Классический приклад - гра, де робот двигается по полю, при цим він можливо передвигать ящики, що знаходяться на цим ж поле, і потрібно за найменше число ходів передвинуть ящики в необхідні позиції. Решается це обходом в ширину по графу, де станом (вершиною) є набір координат: координати робота, і координати всіх коробок.

* Знаходження найкоротшого шляхи в **0-1-графі** (тобто графі взвешенном, але з вагами рівними тільки 0 або 1): достатньо трохи модифікувати пошук в ширину: якщо поточний ребро нульового ваги, і відбувається поліпшення відстані до якийсь вершини, то цю вершину додаємо не в кінець, а в початок черги.

* Знаходження **найкоротшого циклу** в ориентированном невиважені графі: виробляємо пошук в ширину з кожної вершини; як тільки в процесі обходу ми намагаємося піти з поточній вершини по якого-то ребру в вже посещённую вершину, то це означає, що ми знайшли найкоротший цикл, і зупиняємо обхід в ширину; серед всіх таких знайдених циклів (по одному від кожного запуску обходу) вибираємо найкоротший.

* Знайти всі ребра, що лежать **на якому-або найкоротшому шляхи** між заданої парою вершин $(a,b)$. Для цього треба запустити 2 пошуку в ширину: з $a$, і з $b$. Позначимо через $d_a[]$ масив найкоротших відстаней, отриманий в результаті першого обходу, а через $d_b[]$ - в результаті іншого обходу. Тепер для будь-якого ребра $(u,v)$ легко перевірити, лежить або він на якому-або найкоротшому шляхи: критерієм буде умова $d_a[u] + 1 + d_b[v] = d_a[b]$.

* Знайти всі вершини, що лежать **на якому-або найкоротшому шляхи** між заданої парою вершин $(a,b)$. Для цього треба запустити 2 пошуку в ширину: з $a$, і з $b$. Позначимо через $d_a[]$ масив найкоротших відстаней, отриманий в результаті першого обходу, а через $d_b[]$ - в результаті іншого обходу. Тепер для будь-якої вершини $v$ легко перевірити, лежить або він на якому-або найкоротшому шляхи: критерієм буде умова $d_a[v] + d_b[v] = d_a[b]$.

* Знайти **найкоротший чётный шлях** в графі (тобто шлях парної довжини). Для цього треба побудувати допоміжний граф, вершинами якого будуть стан $(v,c)$, де $v$ - номер поточній вершини, $c = 0 \ldots 1$ - поточна парність. Будь-яке ребро $(a,b)$ вихідного графа в цим новому графі перетвориться в два ребра $((u,0),(v,1))$ і $((u,1),(v,0))$. Після цього на цим графі треба обходом в ширину знайти найкоротший шлях з стартової вершини в конечную, з чётностью, рівній 0.

## Задачі в online judges

Список задач, які можна здати, використовуючи обхід в ширину:

TODO
