# Sqrt-декомпозиція

Sqrt-декомпозиція - це метод, або структура данних, яка дозваляє виконувати деякі типичные операції (підсумовування елементів підмасиву, знаходження мінімуму/максимуму і т.д). за $O(\sqrt{n})$, що значно швидше, ніж $O(n)$ для тривіального алгоритму.

Спочатку ми опишемо структуру данних для одного з найпростіших застосувань цій ідеї, потім покажемо, як обобщать її для розв'язку деяких інших задач, і, нарешті, розглянемо декілька інше застосування цій ідеї: розбиття вхідних запитів на sqrt-блоки.

## Структура данних на основі sqrt-декомпозиції

**Поставимо задачу**. Дан масив $a[0 \ldots n-1]$. Потрібно реалізувати таку структуру данних, яка зможе знаходити суму елементів $a[l \ldots r]$ для довільних $l$ і $r$ за $O(\sqrt{n})$ операцій.

### Опис

Основна ідея sqrt-декомпозиції полягає в тому, що зробимо наступного **предпосчёт**: розділимо масив $a$ на блоки довжини приблизно $\sqrt{n}$, і в кожному блоці $i$ заздалегідь предпосчитаем суму $b[i]$ елементів в ньому.

Можна вважати, що довжина одного блоку і кількість блоків рівні одному і тому ж числу - корені з $n$, округлённому вгору:

$$ s = \left\lceil \sqrt{n} \right\rceil, $$

тоді масив $a[]$ розбивається на блоки приблизно таким чином:

$$ \underbrace{ a[0] ~ a[1] ~ \ldots ~ a[s-1] }_{b[0]} ~~~ \underbrace{ a[s] ~ a[s+1] ~ \ldots ~ a[2 \cdot s-1] }_{b[1]} ~~~ \ldots ~~~ \underbrace{ a[(s-1) \cdot s] ~ \ldots ~ a[n] }_{b[s-1]}. $$

Хоча останній блок можливо містити менше, ніж $s$, елементів (якщо $n$ не ділиться на $s$), - це не принципово.

Таким чином, для кожного блоку $k$ ми знаємо суму на ньому $b[k]$:

$$ b[k] = \sum_{i=k \cdot s}^{\min (n-1, (k+1) \cdot s - 1)} a[i]. $$

Отже, нехай ці значення $b_k$ попередньо підраховані (для цього треба, очевидно, $O(n)$ операцій). Що вони можуть дати при обчисленні відповіді на черговий запит $(l,r)$? Зауважимо, що якщо відрізок $[l;r]$ довгий, то в ньому будуть міститися декілька блоків цілком, і на такі блоки ми можемо дізнатися суму на них за одну операцію. В результаті від всього відрузку $[l;r]$ залишиться лише два блоку, попадающие в нього лише частково, і на цих кусках нам доведеться провести підсумовування тривіальним алгоритмом.

Ілюстрація (тут через $k$ обозначен номер блоку, в якому лежить $l$, а через $p$ - номер блоку, в якому лежить $r$):

$$ \ldots ~ \overbrace{ a[l] ~ \ldots ~ a[(k+1) \cdot s-1] ~ \underbrace{ a[(k+1) \cdot s] ~ \ldots ~ a[(k+2) \cdot s-1] }_{b[k+1]} ~ \ldots ~ \underbrace{ a[(p-1) \cdot s] ~ \ldots ~ a[p \cdot s-1] }_{b[p]}\ a[p \cdot s] ~ \ldots a_r }^{sum=?} ~ \ldots $$

На цим рисунке видно, що для того аби порахувати суму в відрізку $[l \ldots r]$, треба підсумувати елементи тільки в двох "хвостах": $[l \ldots (k+1) \cdot s-1]$ і $[p \cdot s \ldots r]$, і підсумувати значення $b[i]$ у всіх блоках, починаючи з $k+1$ і закінчуючи $p-1$:

$$ \sum_{i=l}^{r} a[i] = \sum_{i=l}^{(k+1) \cdot s-1} a[i] + \sum_{i=k+1}^{p-1} b[i] + \sum_{i=p \cdot s}^{r} a[i] $$

(примечание: ця формула неверна, коли $k=p$: в такому випадку деякі елементи будуть просуммированы двічі; в цим випадку треба просто підсумувати елементи з $l$ по $r$)

Тим самим ми экононим значительное кількість операцій. Дійсно, розмір кожного з "хвостів", очевидно, не перевершує довжини блоку $s$, і кількість блоків також не перевершує $s$. Оскільки $s$ ми выбирали $\approx \sqrt{n}$, то всього для обчислення суми на відрізку $[l \ldots r]$ нам знадобиться лише $O(\sqrt{n})$ операцій.

### Реалізація

Наведемо спочатку простейшую реалізацію:

<!--- TODO: specify code snippet id -->
``` cpp
// вхідні дані
int n;
vector<int> a (n);

// предпосчёт
int len = (int) sqrt (n + .0) + 1; // і розмір блоку, і кількість блоків
vector<int> b (len);
for (int i=0; i<n; ++i)
    b[i / len] += a[i];

// відповідь на запити
for (;;) {
    int l, r; // считываем вхідні дані - черговий запит
    int sum = 0;
    for (int i=l; i<=r; )
        if (i % len == 0 && i + len - 1 <= r) {
            // якщо i вказує на початок блоку, цілком лежащего в [l;r]
            sum += b[i / len];
            i += len;
        }
        else {
            sum += a[i];
            ++i;
        }
}
```

Недоліком цій реалізації є то, що в ній невиправдано багато операцій ділення (які, як відомо, виконуються значно повільніше інших операцій). Замість цього можна порахувати номера блоків $c_l$ і $c_r$, в яких лежати межі $l$ і $r$ відповідно, і потім зробити цикл по блокам з $c_l+1$ по $c_r-1$, окремо обработав "хвосты" в блоках $c_l$ і $c_r$. Крім того, при такий реалізації випадок $c_l = c_r$ стає особым і вимагає окремої обробки:

<!--- TODO: specify code snippet id -->
``` cpp
int sum = 0;
int c_l = l / len,   c_r = r / len;
if (c_l == c_r)
    for (int i=l; i<=r; ++i)
        sum += a[i];
else {
    for (int i=l, end=(c_l+1)*len-1; i<=end; ++i)
        sum += a[i];
    for (int i=c_l+1; i<=c_r-1; ++i)
        sum += b[i];
    for (int i=c_r*len; i<=r; ++i)
        sum += a[i];
}
```

### Інші задачі

Ми розглядали задачу знаходження суми елементів масиву в якому-то його підвідрізку. Цю задачу можна трохи розширити: разрешим також **змінюватися** отдельным елементам масиву $A$. Дійсно, якщо змінюється якийсь елемент $a_i$, то достатньо оновити значення $b[k]$ в тому блоці, в якому цей елемент знаходиться ($k = i / len$):

$$ b[k] += a[i] - old\_a[i]. $$

З іншої сторони, замість задачі про сумі аналогічно можна розв'язувати задачі про **минимальном, максимальному** элементах в відрізку. Якщо в цих завданнях допускать зміни окремих елементів, то теж треба буде перераховувати значення $b_k$ того блоку, якому належить изменяемый елемент, але перераховувати вже повністю, проходом по всім елементам блоку за $O(len) = O(\sqrt{n})$ операцій.

Аналогічним чином sqrt-декомпозицію можна застосовувати і для множини **інших** подобных задач: знаходження кількості нулевых елементів, першого ненульового елементу, підрахунку кількості определённых елементів, і т.д.

Є і цілий клас задач, коли відбуваються **зміни елементів на цілому підвідрізку**: додаток або привласнення елементів на якому-то підвідрізку масиву $A$.

Наприклад, потрібно виконувати наступні два увазі запитів: додати до всім елементам деякого відрузку $[l;r]$ величину $\delta$, і дізнаватися значення окремого елементу $a_i$. Значить в якості $b_k$ покладемо ту величину, яка повинна бути прибавлена до всім елементам $k$-го блоку (наприклад, спершу всі $b_k = 0$); тоді при виконанні запиту "додаток" потрібно буде виконати додаток до всім елементам $a_i$ "хвостів", а потім виконати додаток до всім елементам $b_i$ для блоків, цілком лежачих в відрізку $[l \ldots r]$. А відповіддю на другий запит, очевидно, буде просто $a_i + b_k$, де $k = i / len$. Таким чином, додаток на відрізку буде виконуватися за $O(\sqrt{n})$, а запит окремого елементу - за $O(1)$.

Нарешті, можна комбинировать обидва увазі задач: зміна елементів на відрізку і відповідь на запити теж на відрізку. Обидва увазі операцій будуть виконуватися за $O(\sqrt{n})$. Для цього вже треба буде робити два "блоковых" масиву $b$ і $c$: один - для обеспечения змін на відрізку, іншої - для відповіді на запити.

Можна привести приклад і інших задач, до яким можна застосувати sqrt-декомпозицію. Наприклад, можна розв'язувати задачу про **поддержании множини чисел** з возможностью додавання/видалення чисел, перевірки числа на належність безлічі, пошук $k$-го по порядку числа. Для розв'язку цій задачі треба зберігати числа в відсортованому порядку, разделёнными на декілька блоків по $\sqrt{n}$ чисел в кожному. При додаванні або видаленні числа треба буде виробляти "перебалансировку" блоків, перебрасывая числа з начал/кінців одних блоків в початку/кінці сусідніх блоків.

## Sqrt-декомпозиція вхідних запитів

Розглянемо тепер цілковито інше застосування ідеї про sqrt-декомпозиції.

Припустимо, що у нас є деяка задача, в якій нам даются деякі вхідні дані, а потім надходять $k$ команд/запитів, кожну з яких ми повинні дати обробити і видати відповідь. Ми розглядаємо випадок, коли запити бувають як запитують (не меняющие стан системи, а тільки запитують деяку інформацію), так і модифікують (тобто влияющие на стан системи, спершу заданий входными даними).

Конкретная задача можливо бути вельми складної, і "честное" її розв'язок (яке зчитує один запит, обробляє його, изменяя стан системи, і повертає відповідь) можливо бути технически складним або зовсім бути не по силам для решающего. З іншої сторони, розв'язок "офлайнового" варіанти задачі, тобто коли відсутні модифікують операції, а є тільки лише запитують запити - часто виявляється набагато простіше. Припустимо, що ми **вміємо розв'язувати "оффлайновый" різновид** задачі, тобто будувати за деякий час $B(n)$ якусь структуру данних, яка можливо відповідати на запити, але не умеет обробляти модифікують запити.

Значить **розіб'ємо вхідні запити на блоки** (який довжини - поки не уточняем; позначимо цю довжину через $s$). В початку обробки кожного блоку будемо за $B(n)$ будувати структуру данних для "офлайнового" варіанти задачі по станом данних на момент початку цього блоку.

Тепер будемо по черги брати запити з поточного блоку і обробляти кожний з них. Якщо поточний запит - модифицирующий, то пропустимо його. Якщо ж поточний запит - запрашивающий, то обратимся до структурі данних для офлайнового варіанти задачі, але попередньо **учтя всі модифікують запити в поточному блоці**. Таке учитывание модифицирующих запитів буває можливим далеко не завжди, і воно має відбуватися достатньо швидко - за час $O(s)$ або трохи гірше; позначимо це час через $Q(s)$.

Таким чином, якщо всього у нас $m$ запитів, то на їх обробку буде потрібно $B(m) \frac{m}{s} + m Q(s)$ часу. Величину $s$ випливає вибирати, виходячи з конкретного увазі функцій $B()$ і $Q()$. Наприклад, якщо $B(m)=O(m)$ і $Q(s)=O(s)$, то оптимальним вибором буде $s \approx \sqrt{m}$, і підсумкова асимптотика вийде $O(m \sqrt{m})$.

Оскільки наведені вище міркування занадто абстрактны, наведемо декілька прикладів задач, до яким применима така sqrt-декомпозиція.

### Приклад задачі: додаток на відрізку

Умова задачі: дано масив чисел $a[1 \ldots n]$, і надходять запити двох видів: дізнатися значення в $i$-ом елементі масиву, і додати деякий число $x$ до всім елементам масиву в деякому відрізку $a[l \dots r]$.

Хоча цю задачу можна розв'язувати і без цього приёма з разбиением запитів на блоки, ми наведемо її тут - як простейшее і наглядное застосування цього методу.

Отже, розіб'ємо вхідні запити на блоки по $\sqrt{m}$ (де $m$ - число запитів). В початку першого блоку запитів ніяких структур будувати не треба, просто зберігаємо масив $a[]$. Идём тепер по запитам першого блоку. Якщо поточний запит - запит додавання, то поки пропускаємо його. Якщо ж поточний запит - запит читання значення в деякої позиції $i$, то на початку просто візьмемо в якості відповіді значення $a[i]$. Потім пройдемося по всім пропущенным в цим блоці запитам додавання, і для тих з них, в які потрапляє $i$, застосуємо їх збільшення до поточному відповіді.

Таким чином, ми навчилися відповідати на запитують запити за час $O(\sqrt{m})$.

Залишилося тільки замітити, що в наприкінці кожного блоку запитів ми повинні застосувати всі модифікують запити цього блоку до масиву $a[]$. Але це легко зробити за $O(n)$ - достатньо для кожного запиту додавання $(l,r,x)$ відзначити в вспомогательном масиві в точці $l$ число $x$, а в точці $r+1$ - число $-x$, і потім пройтися по цьому масиву, прибавляя поточну суму до масиву $a[]$.

Таким чином, підсумкова асимптотика розв'язку складе $O(\sqrt{m} (n + m))$.

### Приклад задачі: disjoint-set-union з разделением

Є неорієнтований граф з $n$ вершинами і $m$ ребрами. Надходять запити трьох видів: додати ребро $(x_i,y_i)$, вилучити ребро $(x_i,y_i)$, і перевірити, связаны або ні вершини $x_i$ і $y_i$ шляхом.

Якщо б запити видалення отсутствовали, то розв'язком задачі була б відома структура данних [disjoint-set-union (система що не перетинаються множин)](dsu). Однак при наявності удалений задача значно усложняется.

Сделаем наступним чином. В початку кожного блоку запитів подивимося, які ребра в цим блоці будуть удаляться, і зразу **видалимо** їх з графа. Тепер побудуємо систему що не перетинаються множин (dsu) на отриманому графі.

Як ми тепер повинні відповідати на черговий запит з поточного блоку? Наша система що не перетинаються множин "знает" про всіх ребрах, крім тих, що додаються/видаляються в поточному блоці. Однак видалення з dsu нам робити вже не треба - ми заздалегідь видалили всі такі ребра з графа. Таким чином, усе, що можливо бути - це додаткові, добавляющиеся ребра, яких можливо бути максимум $\sqrt{m}$ штук.

Отже, при відповіді на поточний запрашивающий запит ми можемо просто пустити обхід в ширину по компонентів зв'язності dsu, який відпрацює за $O(\sqrt{m})$, оскільки у нас в розгляді будуть тільки $O(\sqrt{m})$ ребер.

## Оффлайновые задачі на запити на підвідрізках масиву і универсальная sqrt-евристика для них

Розглянемо ще одну цікаву вариацию ідеї sqrt-декомпозиції.

Нехай у нас є деяка задача, в якій є масив чисел, і надходять запитують запити, мають вид $(l,r)$ - дізнатися що-то про підвідрізку $a[l \ldots r]$. Ми припустимо, що запити не модифікують, і відомі нам заздалегідь, тобто задача - оффлайновая.

Нарешті, введемо останнє **обмеження**: ми припустимо, що вміємо швидко перераховувати відповідь на запит при зміні лівої або правою межі на одиницю. тобто. якщо ми знали відповідь на запит $(l,r)$, то швидко зможемо порахувати відповідь на запит $(l+1,r)$ або $(l-1,r)$ або $(l,r+1)$ або $(l,r-1)$.

Опишемо тепер **универсальную евристику** для всіх таких задач. Відсортуємо запити по пари: $(l ~ {\rm div} ~ \sqrt{n}, r)$. тобто. ми отсортировали запити по номеру sqrt-блоку, в якому лежить лівий кінець, а при рівності - по правому кінця.

Розглянемо тепер групу запитів з одинаковым значенням $l ~ {\rm div} ~ \sqrt{n}$ і будемо обробляти всі запити цій групи. Відповідь на перший запит порахуємо тривіальним чином. Кожен наступного запит будемо вважати на основі попереднього відповіді: тобто двигать ліву і праву межі попереднього запиту до границам наступного запиту, підтримуючи при цим поточний відповідь. Оцінимо асимптотику: ліва межа кожний раз могла рухатися на не більш $\sqrt{n}$ раз, а права - не більш $n$ раз в сумі по всім запитам поточній групи. Разом, якщо поточна группа состояла з $k$ запитів, в сумі буде совершено не більш $n + k \cdot \sqrt{n}$ перерахунків. В сумі по всьому алгоритму вийде - $O((n + m) \cdot \sqrt{n})$ перерахунків.

Простым **прикладом** на дану евристику є така задача: дізнатися кількість різних чисел в відрізку масиву $[l;r]$.

Чуть більш усложнённым варіантом цій задачі є [задача з одного з раундов Codeforces](http://www.codeforces.ru/contest/86/problem/D).
