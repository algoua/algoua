# Топологічна сортування

Дан орієнтований граф з $n$ вершинами і $m$ ребрами. Потрібно **перенумеровать** його вершини таким чином, аби кожне рёбро вело з вершини з меншим номером в вершину з великим.

Іншими словами, потрібно знайти перестановку вершин (**топологический порядок**), відповідну порядку, задаваемому усіма ребрами графа.

Топологічна сортування можливо бути **не єдиною** (наприклад, якщо граф - порожній; або якщо є три такі вершини $a$, $b$, $c$, що з $a$ є шляхи в $b$ і в $c$, але ні з $b$ в $c$, ні з $c$ в $b$ добраться не можна).

Топологической сортування можливо **не існувати** зовсім - якщо граф містить цикли (оскільки при цим виникає протиріччя: є шлях і з однієї вершини в іншу, і навпаки).

**Распространённая задача** на топологічну сортування - наступна. Є $n$ змінних, значення яких нам неизвестны. Відомо лише про деякі пари змінних, що одна змінна менше іншої. Потрібно перевірити, не противоречивы або ці нерівності, і якщо ні, видати змінні в порядку їх зростання (якщо рішень декілька - видати будь-яке). Легко замітити, що це в точності і є задача про пошуку топологічної сортування в графі з $n$ вершин.

## Алгоритм

Для розв'язку скористаємось [обходом в глибину](dfs).

Припустимо, що граф аціклічен, тобто розв'язок існує. Що робить обхід в глибину? При запуску з якийсь вершини $v$ він намагається запуститися уздовж всіх ребер, вихідних з $v$. Вдоль тих ребер, кінці яких вже були відвідані раніше, він не проходити, а уздовж всіх інших - проходити і викликає собі від їх кінців.

Таким чином, до моменту виходу з виклику ${\rm dfs}(v)$ всі вершини, досяжні з $v$ як безпосередньо (по одному ребру), так і косвенно (по шляхи) - всі такі вершини вже відвідані обходом. Отже, якщо ми будемо в момент виходу з ${\rm dfs}(v)$ додавати нашу вершину в початок некоего списку, то в наприкінці кінців в цим списку вийде **топологічна сортування**.

Ці объяснения можна уявити і в декілька іншому свете, з допомогою понятия **"часу виходу"** обходу в глибину. Час виходу для кожної вершини $v$ - це момент часу, в який закончил працювати виклик ${\rm dfs}(v)$ обходу в глибину від її (часи виходу можна занумеровать від $1$ до $n$). Легко зрозуміти, що при обході в глибину час виходу з який-або вершини $v$ завжди більше, ніж час виходу з всіх вершин, досяжних з її (т.до. вони були відвідані або до виклику ${\rm dfs}(v)$, або у час нього). Таким чином, шукана топологічна сортування - це сортування в порядку зменшення часів виходу.

## Реалізація

Наведемо реалізацію, предполагающую, що граф аціклічен, тобто шукана топологічна сортування існує. При необхідності перевірку графа на ациклічності легко вставити в обхід в глибину, як описано в [статті по обходу в глибину](dfs).

<!--- TODO: specify code snippet id -->
``` cpp
int n; // число вершин
vector<int> g[MAXN]; // граф
bool used[MAXN];
vector<int> ans;

void dfs (int v) {
    used[v] = true;
    for (size_t i=0; i<g[v].size(); ++i) {
        int to = g[v][i];
        if (!used[to])
            dfs (to);
    }
    ans.push_back (v);
}

void topological_sort() {
    for (int i=0; i<n; ++i)
        used[i] = false;
    ans.clear();
    for (int i=0; i<n; ++i)
        if (!used[i])
            dfs (i);
    reverse (ans.begin(), ans.end());
}
```

Тут константі $\rm MAXN$ випливає задати значення, рівне максимально можливого числу вершин в графі.

Основна функція розв'язку - це topological_sort, вона инициализирует пометки обходу в глибину, запускает його, і відповідь в підсумку виходить в векторі $\rm ans$.

## Задачі в online judges

Список задач, в яких потрібно шукати топологічну сортування:

* [UVA #10305 **"Ordering Tasks"** [складність: низька]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1246)

* [UVA #124 **"Following Orders"** [складність: низька]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=60)

* [UVA #200 **"Rare Order"** [складність: низька]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=136)
