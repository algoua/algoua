# тест BPSW на простоту чисел

## Введение

Алгоритм BPSW - это тест числа на простоту. Этот алгоритм назван по фамилиям его изобретателей: Роберт Бэйли (Ballie), Карл Померанс (Pomerance), Джон Селфридж (Selfridge), Сэмюэль Вагстафф (Wagstaff). Алгоритм был предложен в 1980 году. На сегодняшний день к алгоритму не было найдено ни одного контрпримера, равно как и не было найдено доказательство.

Алгоритм BPSW был проверен на всех числах до 10<sup>15</sup>. Кроме того, контрпример пытались найти с помощью программы PRIMO (см. [[6]](#6)), основанной на тесте на простоту с помощью эллиптических кривых. Программа, проработав три года, не нашла ни одного контрпримера, на основании чего Мартин предположил, что не существует ни одного BPSW-псевдопростого, меньшего 10<sup>10000</sup> (псевдопростое число - составное число, на котором алгоритм даёт результат "простое"). В то же время, Карл Померанс в 1984 году представил эвристическое доказательство того, что существует бесконечное множество BPSW-псевдопростых чисел.

Сложность алгоритма BPSW есть O (log<sup>3</sup>(N)) битовых операций. Если же сравнивать алгоритм BPSW с другими тестами, например, тестом Миллера-Рабина, то алгоритм BPSW обычно оказывается в 3-7 раз медленнее.

Алгоритм нередко применяется на практике. По-видимому, многие коммерческие математические пакеты, полностью или частично, полагаются на алгоритм BPSW для проверки чисел на простоту.

## Краткое описание

Алгоритм имеет несколько различных реализаций, отличающихся друг от друга только деталями. В нашем случае алгоритм имеет вид:

1. Выполнить тест Миллера-Рабина по основанию 2.

2. Выполнить сильный тест Лукаса-Селфриджа, используя последовательности Лукаса с параметрами Селфриджа.

3. Вернуть "простое" только в том случае, когда оба теста вернули "простое".

+0. Кроме того, в начало алгоритма можно добавить проверку на тривиальные делители, скажем, до 1000. Это позволит увеличить скорость работы на составных числах, правда, несколько замедлив алгоритм на простых.

Итак, алгоритм BPSW основывается на следующем:

1. (факт) тест Миллера-Рабина и тест Лукаса-Селфриджа если и ошибаются, то только в одну сторону: некоторые составные числа этими алгоритмами опознаются как простые. В обратную сторону эти алгоритмы не ошибаются никогда.

2. (предположение) тест Миллера-Рабина и тест Лукаса-Селфриджа если и ошибаются, то никогда не ошибаются на одном числе одновременно.

На самом деле, второе предположение вроде бы как и неверно - эвристическое доказательство-опровержение Померанса приведено ниже. Тем не менее, на практике ни одного псевдопростого до сих пор не нашли, поэтому условно можно считать второе предположение верным.

## Реализация алгоритмов в данной статье

Все алгоритмы в данной статье будут реализованы на C++. Все программы тестировались только на компиляторе Microsoft C++ 8.0 SP1 (2005), также должны компилироваться на g++.

Алгоритмы реализованы с использованием шаблонов (templates), что позволяет применять их как к встроенным числовым типам, так и собственным классам, реализующим длинную арифметику. [ пока длинная арифметика в статью не входит - TODO ]

В самой статье будут приведены только самые существенные функции, тексты же вспомогательных функций можно скачать в приложении к статье. Здесь будут приведены только заголовки этих функций вместе с комментариями:

<!--- TODO: specify code snippet id -->
``` cpp
//! Модуль 64-битного числа
long long **abs **(long long n);
unsigned long long abs(unsigned long long n);

//! Возвращает true, если n четное
template <class T> bool **even **(const T &n);

//! Делит число на 2
template <class T> void **bisect **(T &n);

//! Умножает число на 2
template <class T> void **redouble **(T &n);

//! Возвращает true, если n - точный квадрат простого числа
template <class T> bool **perfect_square **(const T &n);

//! Вычисляет корень из числа, округляя его вниз
template <class T> T **sq_root **(const T &n);

//! Возвращает количество бит в числе
template <class T> unsigned **bits_in_number **(T n);

//! Возвращает значение k-го бита числа (биты нумеруются с нуля)
template <class T> bool **test_bit **(const T &n, unsigned k);

//! Умножает a *= b (mod n)
template <class T> void **mulmod **(T &a, T b, const T &n);

//! Вычисляет a^k (mod n)
template <class T, class T2> T **powmod **(T a, T2 k, const T &n);

//! Переводит число n в форму q*2^p
template <class T> void **transform_num **(T n, T &p, T &q);

//! Алгоритм Евклида
template <class T, class T2> T **gcd **(const T &a, const T2 &b);

//! Вычисляет jacobi(a,b) - символ Якоби
template <class T>
T **jacobi **(T a, T b)

    //! Вычисляет pi(b) первых простых чисел. Возвращает вектор с простыми и в pi - pi(b)
    template <class T, class T2>
    const std::vector<T> &**get_primes **(const T &b, T2 &pi);

//! Тривиальная проверка n на простоту, перебираются все делители до m.
//! Результат: 1 - если n точно простое, p - его найденный делитель, 0 - если неизвестно
template <class T, class T2> T2 **prime_div_trivial **(const T &n, T2 m);
```

## Тест Миллера-Рабина

Я не буду заострять внимание на тесте Миллера-Рабина, поскольку он описывается во многих источниках, в том числе и на русском языке (например. см. [[5]](#5)).

Замечу лишь, что скорость его работы есть O (log<sup>3</sup>(N)) битовых операций и приведу готовую реализацию этого алгоритма:

<!--- TODO: specify code snippet id -->
``` cpp
template <class T, class T2> bool miller_rabin(T n, T2 b) {

    // сначала проверяем тривиальные случаи
    if (n == 2)
        return true;
    if (n < 2 || even(n))
        return false;

    // проверяем, что n и b взаимно просты (иначе это приведет к ошибке)
    // если они не взаимно просты, то либо n не просто, либо нужно увеличить b
    if (b < 2)
        b = 2;
    for (T g; (g = gcd(n, b)) != 1; ++b)
        if (n > g)
            return false;

    // разлагаем n-1 = q*2^p
    T n_1 = n;
    --n_1;
    T p, q;
    transform_num(n_1, p, q);

    // вычисляем b^q mod n, если оно равно 1 или n-1, то n простое (или псевдопростое)
    T rem = powmod(T(b), q, n);
    if (rem == 1 || rem == n_1)
        return true;

    // теперь вычисляем b^2q, b^4q, ... , b^((n-1)/2)
    // если какое-либо из них равно n-1, то n простое (или псевдопростое)
    for (T i = 1; i < p; i++) {
        mulmod(rem, rem, n);
        if (rem == n_1)
            return true;
    }

    return false;
}
```

## Сильный тест Лукаса-Селфриджа

Сильный тест Лукаса-Селфриджа состоит из двух частей: алгоритма Селфриджа для вычисления некоторого параметра, и сильного алгоритма Лукаса, выполняемого с этим параметром.

### Алгоритм Селфриджа

Среди последовательности 5, -7, 9, -11, 13, ... найти первое число D, для которого J (D, N) = -1 и gcd (D, N) = 1, где J(x,y) - символ Якоби.

**Параметрами Селфриджа** будут P = 1 и Q = (1 - D) / 4.

Следует заметить, что параметр Селфриджа не существует для чисел, которые являются точными квадратами. Действительно, если число является точным квадратом, то перебор D дойдёт до sqrt(N), на котором окажется, что gcd (D, N) > 1, т.е. обнаружится, что число N составное.

Кроме того, параметры Селфриджа будут вычислены неправильно для чётных чисел и для единицы; впрочем, проверка этих случаев не составит труда.

Таким образом, **перед началом алгоритма** следует проверить, что число N является нечётным, большим 2, и не является точным квадратом, иначе (при невыполнении хотя бы одного условия) нужно сразу выйти из алгоритма с результатом "составное".

Наконец, заметим, что если D для некоторого числа N окажется слишком большим, то алгоритм с вычислительной точки зрения окажется неприменимым. Хотя на практике такого замечено не было (оказывалось вполне достаточно 4-байтного числа), тем не менее вероятность этого события не следует исключать. Впрочем, например, на отрезке [1; 10<sup>6</sup>] max(D) = 47, а на отрезке [10<sup>19</sup>; 10<sup>19</sup>+10<sup>6</sup>] max(D) = 67. Кроме того, Бэйли и Вагстаф в 1980 году аналитически доказали это наблюдение (см. Ribenboim, 1995/96, стр. 142).

### Сильный алгоритм Лукаса

**Параметрами алгоритма** Лукаса являются числа **D, P и Q** такие, что D = P<sup>2</sup> - 4*Q ? 0, и P > 0.

(нетрудно заметить, что параметры, вычисленные по алгоритму Селфриджа, удовлетворяют этим условиям)

**Последовательности Лукаса** - это последовательности U<sub>k</sub> и V<sub>k</sub>, определяемые следующим образом:

$$
U<sub>0</sub> = 0
U<sub>1</sub> = 1
**U<sub>k</sub> = P U<sub>k-1</sub> - Q U<sub>k-2</sub>**
V<sub>0</sub> = 2
V<sub>1</sub> = P
**V<sub>k</sub> = P V<sub>k-1</sub> - Q V<sub>k-2</sub>**
$$

Далее, пусть M = N - J (D, N).

Если N простое, и gcd (N, Q) = 1, то имеем:

$$
**U<sub>M</sub> = 0 (mod N)**
$$

В частности, когда параметры D, P, Q вычислены алгоритмом Селфриджа, имеем:

$$
U<sub>N+1</sub> = 0 (mod N)**
$$

Обратное, вообще говоря, неверно. Тем не менее, псевдопростых чисел при данном алгоритме оказывается не очень много, на чём, собственно, и основывается алгоритм Лукаса.

Итак, **алгоритм Лукаса заключается в вычислении U<sub>M</sub> и сравнении его с нулём**.

Далее, необходимо найти какой-то способ ускорения вычисления U<sub>K</sub>, иначе, понятно, никакого практического смысла в этом алгоритма не было бы.

Имеем:

$$
U<sub>k</sub> = (a<sup>k</sup> - b<sup>k</sup>) / (a - b),
V<sub>k</sub> = a<sup>k</sup> + b<sup>k</sup>,
$$

где a и b - различные корни квадратного уравнения x<sup>2</sup> - P x + Q = 0.

Теперь следующие равенства можно доказать элементарно:

$$
U<sub>2k</sub> = U<sub>k</sub> V<sub>k</sub> (mod N)
V<sub>2k</sub> = V<sub>k</sub><sup>2</sup> - 2 Q<sup>k</sup> (mod N)
$$

Теперь, если представить M = E 2<sup>T</sup>, где E - нечётное число, то легко получить:

$$
**U<sub>M</sub> = U<sub>E</sub> V<sub>E</sub> V<sub>2E</sub> V<sub>4E</sub> ... V<sub>2<sup>T-2</sup>E</sub> V<sub>2<sup>T-1</sup>E</sub> = 0 (mod N)**,
$$

и хотя бы один из множителей равен нулю по модулю N.

Понятно, что **достаточно вычислить U<sub>E</sub> и V<sub>E</sub>**, а все последующие множители V<sub>2E</sub> V<sub>4E</sub> ... V<sub>2<sup>T-2</sup>E</sub> V<sub>2<sup>T-1</sup>E</sub> можно **получить уже из них**.

Таким образом, осталось научиться быстро вычислять U<sub>E</sub> и V<sub>E</sub> для нечётного E.

Сначала рассмотрим следующие формулы для сложения членов последовательностей Лукаса:

$$
U<sub>i+j</sub> = (U<sub>i</sub> V<sub>j</sub> + U<sub>j</sub> V<sub>i</sub>) / 2 (mod N)
V<sub>i+j</sub> = (V<sub>i</sub> V<sub>j</sub> + D U<sub>i</sub> U<sub>j</sub>) / 2 (mod N)
$$

Следует обратить внимание, что деление выполняется в поле (mod N).

Формулы эти доказываются очень просто, и здесь их доказательство опущено.

Теперь, обладая формулами для сложения и для удвоения членов последовательностей Лукаса, понятен и способ ускорения вычисления U<sub>E</sub> и V<sub>E</sub>.

Действительно, рассмотрим двоичную запись числа E. Положим сначала результат - U<sub>E</sub> и V<sub>E</sub> - равными, соответственно, U<sub>1</sub> и V<sub>1</sub>. Пройдёмся по всем битам числа E от более младших к более старшим, пропустив только самый первый бит (начальный член последовательности). Для каждого i-го бита будем вычислять U<sub>2<sup> i</sup></sub> и V<sub>2<sup> i</sup></sub> из предыдущих членов с помощью формул удвоения. Кроме того, если текущий i-ый бит равен единице, то к ответу будем прибавлять текущие U<sub>2<sup> i</sup></sub> и V<sub>2<sup> i</sup></sub> с помощью формул сложения. По окончании алгоритма, выполняющегося за O (log(E)), мы **получим искомые U<sub>E</sub> и V<sub>E</sub>**.

Если U<sub>E</sub> или V<sub>E</sub> оказались равными нулю (mod N), то число N простое (или псевдопростое). Если они оба отличны от нуля, то вычисляем V<sub>2E</sub>, V<sub>4E</sub>, ... V<sub>2<sup>T-2</sup>E</sub>, V<sub>2<sup>T-1</sup>E</sub>. Если хотя бы один из них сравним с нулём по модулю N, то число N простое (или псевдопростое). Иначе число N составное.

### Обсуждение алгоритма Селфриджа

Теперь, когда мы рассмотрели алгоритм Лукаса, можно более подробно остановиться на его параметрах D,P,Q, одним из способов получения которых и является алгоритм Селфриджа.

Напомним базовые требования к параметрам:

$$
**P > 0**,
**D = P<sup>2</sup> - 4*Q ? 0**.
$$

Теперь продолжим изучение этих параметров.

**D не должно быть точным квадратом (mod N)**.

Действительно, иначе получим:

D = b<sup>2</sup>, отсюда J(D,N) = 1, P = b + 2, Q = b + 1, отсюда U<sub>n-1</sub> = (Q<sup>n-1</sup> - 1) / (Q - 1).

Т.е. если D - точный квадрат, то алгоритм Лукаса становится практически обычным вероятностным тестом.

Один из лучших способов избежать подобного - **потребовать, чтобы J(D,N) = -1**.

Например, можно выбрать первое число D из последовательности 5, -7, 9, -11, 13, ..., для которого J(D,N) = -1. Также пусть P = 1. Тогда Q = (1 - D) / 4. Этот способ был предложен Селфриджем.

Впрочем, имеются и другие способы выбора D. Можно выбирать его из последовательности 5, 9, 13, 17, 21, ... Также пусть P - наименьшее нечётное, привосходящее sqrt(D). Тогда Q = (P<sup>2</sup> - D) / 4.

Понятно, что от выбора конкретного способа вычисления параметров Лукаса зависит и его результат - псевдопростые могут отличаться при различных способах выбора параметра. Как показала практика, алгоритм, предложенный Селфриджем, оказался очень удачным: все псевдопростые Лукаса-Селфриджа не являются псевдопростыми Миллера-Рабина, по крайней мере, ни одного контрпримера найдено не было.

### Реализация сильного алгоритма Лукаса-Селфриджа

Теперь осталось только реализовать алгоритм:

<!--- TODO: specify code snippet id -->
``` cpp
template <class T, class T2> bool lucas_selfridge(const T &n, T2 unused) {

    // сначала проверяем тривиальные случаи
    if (n == 2)
        return true;
    if (n < 2 || even(n))
        return false;

    // проверяем, что n не является точным квадратом, иначе алгоритм даст ошибку
    if (perfect_square(n))
        return false;

    // алгоритм Селфриджа: находим первое число d такое, что:
    // jacobi(d,n)=-1 и оно принадлежит ряду { 5,-7,9,-11,13,... }
    T2 dd;
    for (T2 d_abs = 5, d_sign = 1;; d_sign = -d_sign, ++ ++d_abs) {
        dd = d_abs * d_sign;
        T g = gcd(n, d_abs);
        if (1 < g && g < n)
            // нашли делитель - d_abs
            return false;
        if (jacobi(T(dd), n) == -1)
            break;
    }

    // параметры Селфриджа
    T2 p = 1, q = (p * p - dd) / 4;

    // разлагаем n+1 = d*2^s
    T n_1 = n;
    ++n_1;
    T s, d;
    transform_num(n_1, s, d);

    // алгоритм Лукаса
    T u = 1, v = p, u2m = 1, v2m = p, qm = q, qm2 = q * 2, qkd = q;
    for (unsigned bit = 1, bits = bits_in_number(d); bit < bits; bit++) {
        mulmod(u2m, v2m, n);
        mulmod(v2m, v2m, n);
        while (v2m < qm2)
            v2m += n;
        v2m -= qm2;
        mulmod(qm, qm, n);
        qm2 = qm;
        redouble(qm2);
        if (test_bit(d, bit)) {
            T t1, t2;
            t1 = u2m;
            mulmod(t1, v, n);
            t2 = v2m;
            mulmod(t2, u, n);

            T t3, t4;
            t3 = v2m;
            mulmod(t3, v, n);
            t4 = u2m;
            mulmod(t4, u, n);
            mulmod(t4, (T)dd, n);

            u = t1 + t2;
            if (!even(u))
                u += n;
            bisect(u);
            u %= n;

            v = t3 + t4;
            if (!even(v))
                v += n;
            bisect(v);
            v %= n;
            mulmod(qkd, qm, n);
        }
    }

    // точно простое (или псевдо-простое)
    if (u == 0 || v == 0)
        return true;

    // довычисляем оставшиеся члены
    T qkd2 = qkd;
    redouble(qkd2);
    for (T2 r = 1; r < s; ++r) {
        mulmod(v, v, n);
        v -= qkd2;
        if (v < 0)
            v += n;
        if (v < 0)
            v += n;
        if (v >= n)
            v -= n;
        if (v >= n)
            v -= n;
        if (v == 0)
            return true;
        if (r < s - 1) {
            mulmod(qkd, qkd, n);
            qkd2 = qkd;
            redouble(qkd2);
        }
    }

    return false;
}
```

## Код BPSW

Теперь осталось просто скомбинировать результаты всех 3 тестов: проверка на небольшие тривиальные делители, тест Миллера-Рабина, сильный тест Лукаса-Селфриджа.

<!--- TODO: specify code snippet id -->
``` cpp
template <class T> bool baillie_pomerance_selfridge_wagstaff(T n) {

    // сначала проверяем на тривиальные делители - например, до 29
    int div = prime_div_trivial(n, 29);
    if (div == 1)
        return true;
    if (div > 1)
        return false;

    // тест Миллера-Рабина по основанию 2
    if (!miller_rabin(n, 2))
        return false;

    // сильный тест Лукаса-Селфриджа
    return lucas_selfridge(n, 0);
}
```
<a href=BPSW_main.zip>Отсюда</a> можно скачать программу (исходник + exe), содержащую полную реализацию теста BPSW. [77 КБ]

## Краткая реализация

Длину кода можно значительно уменьшить в ущерб универсальности, отказавшись от шаблонов и различных вспомогательных функций.

<!--- TODO: specify code snippet id -->
``` cpp
const int trivial_limit = 50;
int p[1000];

int gcd(int a, int b) { return a ? gcd(b % a, a) : b; }

int powmod(int a, int b, int m) {
    int res = 1;
    while (b)
        if (b & 1)
            res = (res * 1ll * a) % m, --b;
        else
            a = (a * 1ll * a) % m, b >>= 1;
    return res;
}

bool miller_rabin(int n) {
    int b = 2;
    for (int g; (g = gcd(n, b)) != 1; ++b)
        if (n > g)
            return false;
    int p = 0, q = n - 1;
    while ((q & 1) == 0)
        ++p, q >>= 1;
    int rem = powmod(b, q, n);
    if (rem == 1 || rem == n - 1)
        return true;
    for (int i = 1; i < p; ++i) {
        rem = (rem * 1ll * rem) % n;
        if (rem == n - 1)
            return true;
    }
    return false;
}

int jacobi(int a, int b) {
    if (a == 0)
        return 0;
    if (a == 1)
        return 1;
    if (a < 0)
        if ((b & 2) == 0)
            return jacobi(-a, b);
        else
            return -jacobi(-a, b);
    int a1 = a, e = 0;
    while ((a1 & 1) == 0)
        a1 >>= 1, ++e;
    int s;
    if ((e & 1) == 0 || (b & 7) == 1 || (b & 7) == 7)
        s = 1;
    else
        s = -1;
    if ((b & 3) == 3 && (a1 & 3) == 3)
        s = -s;
    if (a1 == 1)
        return s;
    return s * jacobi(b % a1, a1);
}

bool bpsw(int n) {
    if ((int)sqrt(n + 0.0) * (int)sqrt(n + 0.0) == n)
        return false;
    int dd = 5;
    for (;;) {
        int g = gcd(n, abs(dd));
        if (1 < g && g < n)
            return false;
        if (jacobi(dd, n) == -1)
            break;
        dd = dd < 0 ? -dd + 2 : -dd - 2;
    }
    int p = 1, q = (p * p - dd) / 4;
    int d = n + 1, s = 0;
    while ((d & 1) == 0)
        ++s, d >>= 1;
    long long u = 1, v = p, u2m = 1, v2m = p, qm = q, qm2 = q * 2, qkd = q;
    for (int mask = 2; mask <= d; mask <<= 1) {
        u2m = (u2m * v2m) % n;
        v2m = (v2m * v2m) % n;
        while (v2m < qm2)
            v2m += n;
        v2m -= qm2;
        qm = (qm * qm) % n;
        qm2 = qm * 2;
        if (d & mask) {
            long long t1 = (u2m * v) % n, t2 = (v2m * u) % n, t3 = (v2m * v) % n, t4 = (((u2m * u) % n) * dd) % n;
            u = t1 + t2;
            if (u & 1)
                u += n;
            u = (u >> 1) % n;
            v = t3 + t4;
            if (v & 1)
                v += n;
            v = (v >> 1) % n;
            qkd = (qkd * qm) % n;
        }
    }
    if (u == 0 || v == 0)
        return true;
    long long qkd2 = qkd * 2;
    for (int r = 1; r < s; ++r) {
        v = (v * v) % n - qkd2;
        if (v < 0)
            v += n;
        if (v < 0)
            v += n;
        if (v >= n)
            v -= n;
        if (v >= n)
            v -= n;
        if (v == 0)
            return true;
        if (r < s - 1) {
            qkd = (qkd * 1ll * qkd) % n;
            qkd2 = qkd * 2;
        }
    }
    return false;
}

bool prime(int n) { // эту функцию нужно вызывать для проверки на простоту
    for (int i = 0; i < trivial_limit && p[i] < n; ++i)
        if (n % p[i] == 0)
            return false;
    if (p[trivial_limit - 1] * p[trivial_limit - 1] >= n)
        return true;
    if (!miller_rabin(n))
        return false;
    return bpsw(n);
}

void prime_init() { // вызвать до первого вызова prime() !
    for (int i = 2, j = 0; j < trivial_limit; ++i) {
        bool pr = true;
        for (int k = 2; k * k <= i; ++k)
            if (i % k == 0)
                pr = false;
        if (pr)
            p[j++] = i;
    }
}
```

## Эвристическое доказательство-опровержение Померанса

Померанс в 1984 году предложил следующее эвристическое доказательство.

Утверждение: **Количество BPSW-псевдопростых от 1 до X больше X<sup>1-a</sup> для любого a > 0**.

Доказательство.

Пусть k > 4 - произвольное, но фиксированное число. Пусть T - некоторое большое число.

Пусть P<sub>k</sub>(T) - множество таких простых p в интервале [T; T<sup>k</sup>], для которых:

(1) p = 3 (mod 8), J(5,p) = -1

(2) число (p-1)/2 не является точным квадратом

(3) число (p-1)/2 составлено исключительно из простых q < T
(4) число (p-1)/2 составлено исключительно из таких простых q, что q = 1 (mod 4)

(5) число (p+1)/4 не является точным квадратом

(6) число (p+1)/4 составлено исключительно из простых d < T

(7) число (p+1)/4 составлено исключительно из таких простых d, что q = 3 (mod 4)

Понятно, что приблизительно 1/8 всех простых в отрезке [T; T<sup>k</sup>] удовлетворяет условию (1). Также можно показать, что условия (2) и (5) сохраняют некоторую часть чисел. Эвристически, условия (3) и (6) также позволяют нам оставить некоторую часть чисел из отрезка (T; T<sup>k</sup>). Наконец, событие (4) обладает вероятностью (c (log T)<sup>-1/2</sup>), так же как и событие (7). Таким образом, мощность множества P<sub>k</sub>(T) прблизительно равна при T -> oo

<img src=BPSW_formula1.jpg>

где c - некоторая положительная константа, зависящая от выбора k.

Теперь мы **можем построить число n**, не являющееся точным квадратом, составленное из l простых из P<sub>k</sub>(T), где l нечётно и меньше T<sup>2</sup> / log(T<sup>k</sup>). Количество способов выбрать такое число n есть примерно

<img src=BPSW_formula2.jpg>

для большого T и фиксированного k. Кроме того, каждое такое число n меньше e<sup>T<sup>2</sup></sup>.

Обозначим через Q<sub>1</sub> произведение простых q < T, для которых q = 1 (mod 4), а через Q<sub>3</sub> - произведение простых q < T, для которых q = 3 (mod 4). Тогда gcd (Q<sub>1</sub>, Q<sub>3</sub>) = 1 и Q<sub>1</sub> Q<sub>3</sub> ? e<sup>T</sup>. Таким образом, количество способов выбрать n **с дополнительными условиями**

$$
n = 1 (mod Q<sub>1</sub>), n = -1 (mod Q<sub>3</sub>)
$$

должно быть, эвристически, как минимум

$$
e<sup>T<sup> 2</sup> (1 - 3 / k)</sup> / e<sup> 2T</sup> > **e<sup>T<sup> 2</sup> (1 - 4 / k)</sup>**
$$

для большого T.

Но **каждое такое n - это контрпример к тесту BPSW**. Действительно, n будет числом Кармайкла (т.е. числом, на котором тест Миллера-Рабина будет ошибаться при любом основании), поэтому оно автоматически будет псевдопростым по основанию 2. Поскольку n = 3 (mod 8) и каждое p | n равно 3 (mod 8), очевидно, что n также будет сильным псевдопростым по основанию 2. Поскольку J(5,n) = -1, то каждое простое p | n удовлетворяет J(5,p) = -1, и так как p+1 | n+1 для любого простого p | n, отсюда следует, что n - псевдопростое Лукаса для любого теста Лукаса с дискриминантом 5.

Таким образом, мы показали, что для любого фиксированного k и всех больших T, будет как минимум e<sup>T<sup> 2</sup> (1 - 4 / k)</sup> контрпримеров к тесту BPSW среди чисел, меньших e<sup>T<sup> 2</sup></sup>. Теперь, если мы положим x = e<sup>T<sup> 2</sup></sup>, будет как минимум x<sup>1 - 4 / k</sup> контрпримеров, меньших x. Поскольку k - случайное число, то наше доказательство означает, что **количество контрпримеров, меньших x, есть число, большее x<sup>1-a</sup> для любого a > 0**.

## Практические испытания теста BPSW

В этом разделе будут рассмотрены результаты, полученные мной в результате тестирования моей реализации теста BPSW. Все испытания проводились на встроенном типе - 64-битном числе long long. Длинная арифметика не тестировалась.

Тестирования проводились на компьютере с процессором Celeron 1.3 GHz.

Все времена даны в **микросекундах** (10<sup> -6</sup> сек).

### Среднее время работы на отрезке чисел в зависимости от предела тривиального перебора

Имеется в виду параметр, передаваемый функции prime_div_trivial(), который в коде выше равен 29.

[Скачать](BPSW_test_1.zip) тестовую программу (исходник и exe-файл). [83 КБ]

Если запускать тест **на всех нечетных числах** из отрезка, то результаты получаются такими:

<table class=table2 cellspacing=0>
<tr><th>начало
отрезка</th><th>конец
отрезка</th><th>предел >
перебора ></th><th width=13%>0</th><th width=13%>10<sup>2</sup></th><th width=13%>10<sup>3</sup></th><th width=13%>10<sup>4</sup></th><th width=13%>10<sup>5</sup></th></tr>
<tr><td>1</td><td>10<sup>5</sup></td><td></td><td>8.1</td><td>4.5</td><td>0.7</td><td>0.7</td><td>0.9</td></tr>
<tr><td>10<sup>6</sup></td><td>10<sup>6</sup>+10<sup>5</sup></td><td></td><td>12.8</td><td>6.8</td><td>7.0</td><td>1.6</td><td>1.6</td>
<tr><td>10<sup>9</sup></td><td>10<sup>9</sup>+10<sup>5</sup></td><td></td><td>28.4</td><td>12.6</td><td>12.1</td><td>17.0</td><td>17.1</td></tr>
<tr><td>10<sup>12</sup></td><td>10<sup>12</sup>+10<sup>5</sup></td><td></td><td>41.5</td><td>16.5</td><td>15.3</td><td>19.4</td><td>54.4</td></tr>
<tr><td>10<sup>15</sup></td><td>10<sup>15</sup>+10<sup>5</sup></td><td></td><td>66.7</td><td>24.4</td><td>21.1</td><td>24.8</td><td>58.9</td></tr>
</table>
Если запускать тест **только на простых числах** из отрезка, то скорость работы такова:

<table class=table2 cellspacing=0>
<tr><th>начало
отрезка</th><th>конец
отрезка</th><th>предел >
перебора ></th><th width=13%>0</th><th width=13%>10<sup>2</sup></th><th width=13%>10<sup>3</sup></th><th width=13%>10<sup>4</sup></th><th width=13%>10<sup>5</sup></th></tr>
<tr><td>1</td><td>10<sup>5</sup></td><td></td><td>42.9</td><td>40.8</td><td>3.1</td><td>4.2</td><td>4.2</td></tr>
<tr><td>10<sup>6</sup></td><td>10<sup>6</sup>+10<sup>5</sup></td><td></td><td>75.0</td><td>76.4</td><td>88.8</td><td>13.9</td><td>15.2</td>
<tr><td>10<sup>9</sup></td><td>10<sup>9</sup>+10<sup>5</sup></td><td></td><td>186.5</td><td>188.5</td><td>201.0</td><td>294.3</td><td>283.9</td></tr>
<tr><td>10<sup>12</sup></td><td>10<sup>12</sup>+10<sup>5</sup></td><td></td><td>288.3</td><td>288.3</td><td>302.2</td><td>387.9</td><td>1069.5</td></tr>
<tr><td>10<sup>15</sup></td><td>10<sup>15</sup>+10<sup>5</sup></td><td></td><td>485.6</td><td>489.1</td><td>496.3</td><td>585.4</td><td>1267.4</td></tr>
</table>
Таким образом, оптимально выбирать **предел тривиального перебора равным 100 или 1000**.

Для всех следующих тестов я выбрал предел 1000.

### Среднее время работы на отрезке чисел

Теперь, когда мы выбрали предел тривиального перебора, можно более точно протестировать скорость работы на различных отрезках.

<a href=BPSW_test2.zip>Скачать</a> тестовую программу (исходник и exe-файл). [83 КБ]

<table class=table1 cellspacing=0>
<tr><th width=100>начало
отрезка</th><th width=100>конец
отрезка</th><th width=200>время работы
на нечетных числах</th><th width=200>время работы
на простых числах</th></tr>
<tr><td>1</td><td>10<sup>5</sup></td><td>1.2</td><td>4.2</td></tr>
<tr><td>10<sup>6</sup></td><td>10<sup>6</sup>+10<sup>5</sup></td><td>13.8</td><td>88.8</td></tr>
<tr><td>10<sup>7</sup></td><td>10<sup>7</sup>+10<sup>5</sup></td><td>16.8</td><td>115.5</td></tr>
<tr><td>10<sup>8</sup></td><td>10<sup>8</sup>+10<sup>5</sup></td><td>21.2</td><td>164.8</td></tr>
<tr><td>10<sup>9</sup></td><td>10<sup>9</sup>+10<sup>5</sup></td><td>24.0</td><td>201.0</td></tr>
<tr><td>10<sup>10</sup></td><td>10<sup>10</sup>+10<sup>5</sup></td><td>25.2</td><td>225.5</td></tr>
<tr><td>10<sup>11</sup></td><td>10<sup>11</sup>+10<sup>5</sup></td><td>28.4</td><td>266.5</td></tr>
<tr><td>10<sup>12</sup></td><td>10<sup>12</sup>+10<sup>5</sup></td><td>30.4</td><td>302.2</td></tr>
<tr><td>10<sup>13</sup></td><td>10<sup>13</sup>+10<sup>5</sup></td><td>33.0</td><td>352.2</td></tr>
<tr><td>10<sup>14</sup></td><td>10<sup>14</sup>+10<sup>5</sup></td><td>37.5</td><td>424.3</td></tr>
<tr><td>10<sup>15</sup></td><td>10<sup>15</sup>+10<sup>5</sup></td><td>42.3</td><td>499.8</td></tr>
<tr><td>10<sup>16</sup></td><td>10<sup>15</sup>+10<sup>5</sup></td><td>46.5</td><td>553.6</td></tr>
<tr><td>10<sup>17</sup></td><td>10<sup>15</sup>+10<sup>5</sup></td><td>48.9</td><td>621.1</td></tr>
</table>
Или, в виде графика, приблизительное время работы теста BPSW на одном числе:

<img src=BPSW_graph1.gif>

То есть мы получили, что на практике, на небольших числах (до 10<sup>17</sup>), **алгоритм работает за O (log N)**. Это объясняется тем, что для встроенного типа int64 операция деления выполняется за O(1), т.е. сложность деления не зависисит от количества битов в числе.

Если же применить тест BPSW к длинной арифметике, то ожидается, что он будет работать как раз за O (log<sup>3</sup>(N)). [ TODO ]

## Приложение. Все программы

<a href=BPSW_all.zip>Скачать</a> все программы из данной статьи. [242 КБ]

## Литература

Использованная мной литература, полностью доступная в Интернете:

<ol>
* Robert Baillie; Samuel S. Wagstaff
**Lucas pseudoprimes**
Math. Comp. 35 (1980) 1391-1417
[mpqs.free.fr/LucasPseudoprimes.pdf](http://mpqs.free.fr/LucasPseudoprimes.pdf)
&nbsp;
* Daniel J. Bernstein
**Distinguishing prime numbers from composite numbers: the state of the art in 2004**
Math. Comp. (2004)
[cr.yp.to/primetests/prime2004-20041223.pdf](http://cr.yp.to/primetests/prime2004-20041223.pdf)
&nbsp;
* Richard P. Brent
**Primality Testing and Integer Factorisation**
The Role of Mathematics in Science (1990)
[wwwmaths.anu.edu.au/~brent/pd/rpb120.pdf](http://wwwmaths.anu.edu.au/~brent/pd/rpb120.pdf)
&nbsp;
* H. Cohen; H. W. Lenstra
**Primality Testing and Jacobi Sums**
Amsterdam (1984)
[www.openaccess.leidenuniv.nl/bitstream/1887/2136/1/346_065.pdf](https://www.openaccess.leidenuniv.nl/bitstream/1887/2136/1/346_065.pdf)
&nbsp;
* <a name=5></a>Thomas H. Cormen; Charles E. Leiserson; Ronald L. Rivest
**Introduction to Algorithms**
[ без ссылки ]
The MIT Press (2001)
&nbsp;
* <a name=6></a>M. Martin
**PRIMO - Primality Proving**
[www.ellipsa.net](http://www.ellipsa.net/)
&nbsp;
* F. Morain
**Elliptic curves and primality proving**
Math. Comp. 61(203) (1993)
[citeseer.ist.psu.edu/rd/43190198%2C72628%2C1%2C0.25%2CDownload/ftp%3AqSqqSqftp.inria.frqSqINRIAqSqpublicationqSqpubli-ps-gzqSqRRqSqRR-1256.ps.gz](http://citeseer.ist.psu.edu/rd/43190198%2C72628%2C1%2C0.25%2CDownload/ftp%3AqSqqSqftp.inria.frqSqINRIAqSqpublicationqSqpubli-ps-gzqSqRRqSqRR-1256.ps.gz)
&nbsp;
* Carl Pomerance
**Are there counter-examples to the Baillie-PSW primality test?**
Math. Comp. (1984)
[www.pseudoprime.com/dopo.pdf](http://www.pseudoprime.com/dopo.pdf)
&nbsp;
* Eric W. Weisstein
**Baillie-PSW primality test**
MathWorld (2005)
[mathworld.wolfram.com/Baillie-PSWPrimalityTest.html](http://mathworld.wolfram.com/Baillie-PSWPrimalityTest.html)
&nbsp;
* Eric W. Weisstein
**Strong Lucas pseudoprime**
MathWorld (2005)
[mathworld.wolfram.com/StrongLucasPseudoprime.html](http://mathworld.wolfram.com/StrongLucasPseudoprime.html)
&nbsp;
* Paulo Ribenboim
**The Book of Prime Number Records**
Springer-Verlag (1989)
[ без ссылки ]
&nbsp;
</ol>
Список других рекомендуемых книг, которых мне не удалось найти в Интернете:

<ol start=12>
* Zhaiyu Mo; James P. Jones
**A new primality test using Lucas sequences**
Preprint (1997)
&nbsp;
* Hans Riesel
**Prime numbers and computer methods for factorization**
Boston: Birkhauser (1994)
&nbsp;
</ol>
