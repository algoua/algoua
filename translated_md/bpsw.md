# тест BPSW на простоту чисел

## Введение

Алгоритм BPSW - це тест числа на простоту. Цей алгоритм назван по фамилиям його изобретателей: Роберт Бэйли (Ballie), Карл Померанс (Pomerance), Джон Селфридж (Selfridge), Сэмюэль Вагстафф (Wagstaff). Алгоритм був запропонований в 1980 році. На сегодняшний день до алгоритму не було знайдено ні одного контрпримера, рівне як і не було знайдено доведення.

Алгоритм BPSW був проверен на всіх числах до 10<sup>15</sup>. Крім того, контрприклад намагалися знайти з допомогою програми PRIMO (див. [[6]](#6)), основанной на тесті на простоту з допомогою эллиптических кривих. Програма, проработав три року, не нашла ні одного контрпримера, на основании чого Мартин предположил, що не існує ні одного BPSW-псевдопростого, меншого 10<sup>10000</sup> (псевдопросте число - складене число, на якому алгоритм дає результат "просте"). В то ж час, Карл Померанс в 1984 році представил евристичне доведення того, що існує нескінченне множину BPSW-псевдопростих чисел.

Сложность алгоритму BPSW є O (log<sup>3</sup>(N)) бітових операцій. Якщо ж порівнювати алгоритм BPSW з іншими тестами, наприклад, тестом Міллера-Рабіна, то алгоритм BPSW зазвичай виявляється в 3-7 раз повільніше.

Алгоритм нерідко застосовується на практиці. За-видимому, багато коммерческие математические пакеты, повністю або частково, полагаются на алгоритм BPSW для перевірки чисел на простоту.

## Краткое опис

Алгоритм має декілька різних реализаций, отличающихся один від одного тільки деталями. В нашому випадку алгоритм має вид:

1. Выполнить тест Міллера-Рабіна по основи 2.

2. Выполнить сильний тест Лукаса-Селфрідж, використовуючи послідовності Лукаса з параметрами Селфрідж.

3. Вернуть "просте" тільки в тому випадку, коли обидва тесту вернули "просте".

+0. Крім того, в початок алгоритму можна додати перевірку на тривіальні подільники, скажімо, до 1000. Це дозволить збільшити швидкість роботи на составных числах, правда, декілька замедлив алгоритм на простих.

Отже, алгоритм BPSW базується на наступному:

1. (факт) тест Міллера-Рабіна і тест Лукаса-Селфрідж якщо і помиляються, то тільки в одну сторону: деякі складові числа цими алгоритмами опознаются як прості. В зворотню сторону ці алгоритми не помиляються ніколи.

2. (припущення) тест Міллера-Рабіна і тест Лукаса-Селфрідж якщо і помиляються, то ніколи не помиляються на одному числі одночасно.

Насправді, друге припущення вроде б як і невірно - евристичне доведення-опровержение Померанса наведено нижче. Тим не менш, на практиці ні одного псевдопростого до сих пір не знайшли, тому условно можна вважати друге припущення верным.

## Реалізація алгоритмів в даній статті

Усе алгоритми в даній статті будуть реалізовані на C++. Усе програми тестировались тільки на компиляторе Microsoft C++ 8.0 SP1 (2005), також повинні компилироваться на g++.

Алгоритми реалізовані з використанням шаблонов (templates), що дозваляє застосовувати їх як до встроенным числовым типам, так і власним классам, реализующим довгу арифметику. [ поки довга арифметика в статтю не входити - TODO ]

В самою статті будуть наведені тільки самі существенные функції, тексты ж допоміжних функцій можна завантажити в приложении до статті. Тут будуть наведені тільки заголовки цих функцій разом з комментариями:

<!--- TODO: specify code snippet id -->
``` cpp
//! Модуль 64-битного числа
long long **abs** (long long n);
unsigned long long abs (unsigned long long n);

//! Повертає true, якщо n четное
template <class T>
bool **even** (const T & n);

//! Делит число на 2
template <class T>
void **bisect** (T & n);

//! Примножує число на 2
template <class T>
void **redouble** (T & n);

//! Повертає true, якщо n - точный квадрат простого числа
template <class T>
bool **perfect_square** (const T & n);

//! Обчислює корінь з числа, округляя його вниз
template <class T>
T **sq_root** (const T & n);

//! Повертає кількість біт в числі
template <class T>
unsigned **bits_in_number** (T n);

//! Повертає значення k-го біта числа (біти нумеруються з нуля)
template <class T>
bool **test_bit** (const T & n, unsigned k);

//! Примножує a *= b (mod n)
template <class T>
void **mulmod** (T & a, T b, const T & n);

//! Обчислює a^k (mod n)
template <class T, class T2>
T **powmod** (T a, T2 k, const T & n);

//! Переводит число n в форму q*2^p
template <class T>
void **transform_num** (T n, T & p, T & q);

//! Алгоритм Евкліда
template <class T, class T2>
T **gcd** (const T & a, const T2 & b);

//! Обчислює jacobi(a,b) - символ Якобі
template <class T>
T **jacobi** (T a, T b)

//! Обчислює pi(b) перших простих чисел. Повертає вектор з простими і в pi - pi(b)
template <class T, class T2>
const std::vector<T> & **get_primes** (const T & b, T2 & pi);

//! Тривиальная перевірка n на простоту, перебираются всі подільники до m.
//! Результат: 1 - якщо n точно просте, p - його знайдений дільник, 0 - якщо неизвестно
template <class T, class T2>
T2 **prime_div_trivial** (const T & n, T2 m);
```

## Тест Міллера-Рабіна

Я не буду заострять увага на тесті Міллера-Рабіна, оскільки він описується у багатьох источниках, в тому числі і на русском мові (наприклад. див. [[5]](#5)).

Замечу лише, що швидкість його роботи є O (log<sup>3</sup>(N)) бітових операцій і приведу готовую реалізацію цього алгоритму:

<!--- TODO: specify code snippet id -->
``` cpp
template <class T, class T2>
bool miller_rabin (T n, T2 b)
{

    // спочатку перевіряємо тривіальні випадки
    if (n == 2)
        return true;
    if (n < 2 || even (n))
        return false;

    // перевіряємо, що n і b взаємно прості (інакше це приведет до ошибке)
    // якщо вони не взаємно прості, то або n не просто, або потрібно збільшити b
    if (b < 2)
        b = 2;
    for (T g; (g = gcd (n, b)) != 1; ++b)
        if (n > g)
            return false;

    // розкладаємо n-1 = q*2^p
    T n_1 = n;
    --n_1;
    T p, q;
    transform_num (n_1, p, q);

    // обчислюємо b^q mod n, якщо воно рівне 1 або n-1, то n просте (або псевдопросте)
    T rem = powmod (T(b), q, n);
    if (rem == 1 || rem == n_1)
        return true;

    // тепер обчислюємо b^2q, b^4q, ... , b^((n-1)/2)
    // якщо яке-або з них рівне n-1, то n просте (або псевдопросте)
    for (T i=1; i<p; i++)
    {
        mulmod (rem, rem, n);
        if (rem == n_1)
            return true;
    }

    return false;

}
```

## Сильний тест Лукаса-Селфрідж

Сильний тест Лукаса-Селфрідж складається з двох частин: алгоритму Селфрідж для обчислення деякого параметра, і сильного алгоритму Лукаса, выполняемого з цим параметром.

### Алгоритм Селфрідж

Среди послідовності 5, -7, 9, -11, 13, ... знайти перший число D, для якого J (D, N) = -1 і gcd (D, N) = 1, де J(x,y) - символ Якобі.

**Параметрами Селфрідж** будуть P = 1 і Q = (1 - D) / 4.

Слід замітити, що параметр Селфрідж не існує для чисел, які є точными квадратами. Дійсно, якщо число є точним квадратом, то перебор D дійде до sqrt(N), на якому виявиться, що gcd (D, N) > 1, тобто обнаружится, що число N складене.

Крім того, параметри Селфрідж будуть обчислені неправильно для парних чисел і для одиниці; втім, перевірка цих випадків не складе праці.

Таким чином, **перед початком алгоритму** випливає перевірити, що число N є непарним, великим 2, і не є точним квадратом, інакше (при невыполнении хоча б одного умови) потрібно зразу вийти з алгоритму з результатом "складене".

Нарешті, зауважимо, що якщо D для деякого числа N виявиться занадто великим, то алгоритм з обчислювальної точки зору виявиться неприменимым. Хоча на практиці такого замечено не було (оказывалось цілком достатньо 4-байтного числа), тим не менш ймовірність цього події не випливає исключать. Втім, наприклад, на відрізку [1; 10<sup>6</sup>] max(D) = 47, а на відрізку [10<sup>19</sup>; 10<sup>19</sup>+10<sup>6</sup>] max(D) = 67. Крім того, Бэйли і Вагстаф в 1980 році аналітично довели це наблюдение (див. Ribenboim, 1995/96, стр. 142).

### Сильний алгоритм Лукаса

**Параметрами алгоритму** Лукаса є числа **D, P і Q** такі, що D = P<sup>2</sup> - 4*Q ? 0, і P > 0.

(неважко замітити, що параметри, обчислені по алгоритму Селфрідж, задовольняють цим умовами)

**Последовательности Лукаса** - це послідовності U<sub>k</sub> і V<sub>k</sub>, определяемые наступним чином:

$$
U<sub>0</sub> = 0
U<sub>1</sub> = 1
**U<sub>k</sub> = P U<sub>k-1</sub> - Q U<sub>k-2</sub>**
V<sub>0</sub> = 2
V<sub>1</sub> = P
**V<sub>k</sub> = P V<sub>k-1</sub> - Q V<sub>k-2</sub>**
$$

Далі, нехай M = N - J (D, N).

Якщо N просте, і gcd (N, Q) = 1, то маємо:

$$
**U<sub>M</sub> = 0 (mod N)**
$$

В зокрема, коли параметри D, P, Q обчислені алгоритмом Селфрідж, маємо:

$$
U<sub>N+1</sub> = 0 (mod N)**
$$

Зворотне, взагалі кажучи, невірно. Тим не менш, псевдопростих чисел при даному алгоритмі виявляється не дуже багато, на чому, власне, і базується алгоритм Лукаса.

Отже, **алгоритм Лукаса полягає в обчисленні U<sub>M</sub> і порівняно його з нулем**.

Далі, необхідно знайти якийсь спосіб прискорення обчислення U<sub>K</sub>, інакше, зрозуміло, ніякого практичного сенсу в цим алгоритму не було б.

Маємо:

$$
U<sub>k</sub> = (a<sup>k</sup> - b<sup>k</sup>) / (a - b),
V<sub>k</sub> = a<sup>k</sup> + b<sup>k</sup>,
$$

де a і b - різні коріння квадратного рівняння x<sup>2</sup> - P x + Q = 0.

Тепер наступні рівності можна довести элементарно:

$$
U<sub>2k</sub> = U<sub>k</sub> V<sub>k</sub> (mod N)
V<sub>2k</sub> = V<sub>k</sub><sup>2</sup> - 2 Q<sup>k</sup> (mod N)
$$

Тепер, якщо уявити M = E 2<sup>T</sup>, де E - непарне число, то легко получити:

$$
**U<sub>M</sub> = U<sub>E</sub> V<sub>E</sub> V<sub>2E</sub> V<sub>4E</sub> ... V<sub>2<sup>T-2</sup>E</sub> V<sub>2<sup>T-1</sup>E</sub> = 0 (mod N)**,
$$

і хоча б один з множителей рівний нулю за модулем N.

Зрозуміло, що **достатньо обчислити U<sub>E</sub> і V<sub>E</sub>**, а всі наступні множники V<sub>2E</sub> V<sub>4E</sub> ... V<sub>2<sup>T-2</sup>E</sub> V<sub>2<sup>T-1</sup>E</sub> можна **получити вже з них**.

Таким чином, залишилося навчитися швидко обчислювати U<sub>E</sub> і V<sub>E</sub> для непарного E.

Спочатку розглянемо наступні формули для складання членів послідовностей Лукаса:

$$
U<sub>i+j</sub> = (U<sub>i</sub> V<sub>j</sub> + U<sub>j</sub> V<sub>i</sub>) / 2 (mod N)
V<sub>i+j</sub> = (V<sub>i</sub> V<sub>j</sub> + D U<sub>i</sub> U<sub>j</sub>) / 2 (mod N)
$$

Слід звернути увага, що поділ виконується в поле (mod N).

Формулы ці доказываются дуже просто, і тут їх доведення опущено.

Тепер, обладая формулами для складання і для удвоения членів послідовностей Лукаса, зрозумілий і спосіб прискорення обчислення U<sub>E</sub> і V<sub>E</sub>.

Дійсно, розглянемо двоичную запис числа E. Покладемо спочатку результат - U<sub>E</sub> і V<sub>E</sub> - рівними, відповідно, U<sub>1</sub> і V<sub>1</sub>. Пройдёмся по всім бітам числа E від більш младших до більш старшим, пропустив тільки самий перший біт (начальный член послідовності). Для кожного i-го біта будемо обчислювати U<sub>2<sup> i</sup></sub> і V<sub>2<sup> i</sup></sub> з попередніх членів з допомогою формул удвоения. Крім того, якщо поточний i-ый біт рівний одиниці, то до відповіді будемо додавати поточні U<sub>2<sup> i</sup></sub> і V<sub>2<sup> i</sup></sub> з допомогою формул складання. За закінченні алгоритму, выполняющегося за O (log(E)), ми **отримаємо шукані U<sub>E</sub> і V<sub>E</sub>**.

Якщо U<sub>E</sub> або V<sub>E</sub> виявилися рівними нулю (mod N), то число N просте (або псевдопросте). Якщо вони обидва отличны від нуля, то обчислюємо V<sub>2E</sub>, V<sub>4E</sub>, ... V<sub>2<sup>T-2</sup>E</sub>, V<sub>2<sup>T-1</sup>E</sub>. Якщо хоча б один з них порівняємо з нулем за модулем N, то число N просте (або псевдопросте). Інакше число N складене.

### Обсуждение алгоритму Селфрідж

Тепер, коли ми розглянули алгоритм Лукаса, можна більш детально зупинитися на його параметрах D,P,Q, одним з способів отримання яких і є алгоритм Селфрідж.

Нагадаємо базовые требования до параметрам:

$$
**P > 0**,
**D = P<sup>2</sup> - 4*Q ? 0**.
$$

Тепер продовжимо вивчення цих параметрів.

**D не має бути точним квадратом (mod N)**.

Дійсно, інакше отримаємо:

D = b<sup>2</sup>, звідси J(D,N) = 1, P = b + 2, Q = b + 1, звідси U<sub>n-1</sub> = (Q<sup>n-1</sup> - 1) / (Q - 1).

тобто. якщо D - точный квадрат, то алгоритм Лукаса стає практично звичайним вероятностным тестом.

Один з кращих способів уникнути подобного - **потребовать, аби J(D,N) = -1**.

Наприклад, можна вибрати перший число D з послідовності 5, -7, 9, -11, 13, ..., для якого J(D,N) = -1. Також нехай P = 1. Значить Q = (1 - D) / 4. Цей спосіб був запропонований Селфриджем.

Втім, є і інші способы вибору D. Можна вибирати його з послідовності 5, 9, 13, 17, 21, ... Також нехай P - найменше непарне, привосходящее sqrt(D). Значить Q = (P<sup>2</sup> - D) / 4.

Зрозуміло, що від вибору конкретного способу обчислення параметрів Лукаса залежить і його результат - псевдопростые можуть відрізнятися при різних способах вибору параметра. Як показала практика, алгоритм, запропонований Селфриджем, виявився дуже удачным: всі псевдопростые Лукаса-Селфрідж не є псевдопростыми Міллера-Рабіна, по крайньої міру, ні одного контрпримера знайдено не було.

### Реалізація сильного алгоритму Лукаса-Селфрідж

Тепер залишилося тільки реалізувати алгоритм:

<!--- TODO: specify code snippet id -->
``` cpp
template <class T, class T2>
bool lucas_selfridge (const T & n, T2 unused)
{

    // спочатку перевіряємо тривіальні випадки
    if (n == 2)
        return true;
    if (n < 2 || even (n))
        return false;

    // перевіряємо, що n не є точним квадратом, інакше алгоритм дасть ошибку
    if (perfect_square (n))
        return false;

    // алгоритм Селфрідж: знаходимо перший число d таке, що:
    // jacobi(d,n)=-1 і воно належить ряду { 5,-7,9,-11,13,... }
    T2 dd;
    for (T2 d_abs = 5, d_sign = 1; ; d_sign = -d_sign, ++++d_abs)
    {
        dd = d_abs * d_sign;
        T g = gcd (n, d_abs);
        if (1 < g && g < n)
            // знайшли дільник - d_abs
            return false;
        if (jacobi (T(dd), n) == -1)
            break;
    }

    // параметри Селфрідж
    T2
        p = 1,
        q = (p*p - dd) / 4;
    
    // розкладаємо n+1 = d*2^s
    T n_1 = n;
    ++n_1;
    T s, d;
    transform_num (n_1, s, d);

    // алгоритм Лукаса
    T
        u = 1,
        v = p,
        u2m = 1,
        v2m = p,
        qm = q,
        qm2 = q*2,
        qkd = q;
    for (unsigned bit = 1, bits = bits_in_number(d); bit < bits; bit++)
    {
        mulmod (u2m, v2m, n);
        mulmod (v2m, v2m, n);
        while (v2m < qm2)
            v2m += n;
        v2m -= qm2;
        mulmod (qm, qm, n);
        qm2 = qm;
        redouble (qm2);
        if (test_bit (d, bit))
        {
            T t1, t2;
            t1 = u2m;
            mulmod (t1, v, n);
            t2 = v2m;
            mulmod (t2, u, n);
            
            T t3, t4;
            t3 = v2m;
            mulmod (t3, v, n);
            t4 = u2m;
            mulmod (t4, u, n);
            mulmod (t4, (T)dd, n);

            u = t1 + t2;
            if (!even (u))
                u += n;
            bisect (u);
            u %= n;

            v = t3 + t4;
            if (!even (v))
                v += n;
            bisect (v);
            v %= n;
            mulmod (qkd, qm, n);
        }
    }

    // точно просте (або псевдо-просте)
    if (u == 0 || v == 0)
        return true;

    // довычисляем залишилися члены
    T qkd2 = qkd;
    redouble (qkd2);
    for (T2 r = 1; r < s; ++r)
    {
        mulmod (v, v, n);
        v -= qkd2;
        if (v < 0) v += n;
        if (v < 0) v += n;
        if (v >= n) v -= n;
        if (v >= n) v -= n;
        if (v == 0)
            return true;
        if (r < s-1)
        {
            mulmod (qkd, qkd, n);
            qkd2 = qkd;
            redouble (qkd2);
        }
    }

    return false;

}
```

## Код BPSW

Тепер залишилося просто скомбинировать результати всіх 3 тестів: перевірка на небольшие тривіальні подільники, тест Міллера-Рабіна, сильний тест Лукаса-Селфрідж.

<!--- TODO: specify code snippet id -->
``` cpp
template <class T>
bool baillie_pomerance_selfridge_wagstaff (T n)
{

    // спочатку перевіряємо на тривіальні подільники - наприклад, до 29
    int div = prime_div_trivial (n, 29);
    if (div == 1)
        return true;
    if (div > 1)
        return false;

    // тест Міллера-Рабіна по основи 2
    if (!miller_rabin (n, 2))
        return false;

    // сильний тест Лукаса-Селфрідж
    return lucas_selfridge (n, 0);

}
```
<a href=BPSW_main.zip>Звідси</a> можна завантажити програму (код + exe), що містить повну реалізацію тесту BPSW. [77 КБ]

## Краткая реалізація

Длину коду можна значно зменшити в ущерб универсальности, отказавшись від шаблонов і різних допоміжних функцій.

<!--- TODO: specify code snippet id -->
``` cpp
const int trivial_limit = 50;
int p[1000];

int gcd (int a, int b) {
    return a ? gcd (b%a, a) : b;
}

int powmod (int a, int b, int m) {
    int res = 1;
    while (b)
        if (b & 1)
            res = (res * 1ll * a) % m,  --b;
        else
            a = (a * 1ll * a) % m,  b >>= 1;
    return res;
}

bool miller_rabin (int n) {
    int b = 2;
    for (int g; (g = gcd (n, b)) != 1; ++b)
        if (n > g)
            return false;
    int p=0, q=n-1;
    while ((q & 1) == 0)
        ++p,  q >>= 1;
    int rem = powmod (b, q, n);
    if (rem == 1 || rem == n-1)
        return true;
    for (int i=1; i<p; ++i) {
        rem = (rem * 1ll * rem) % n;
        if (rem == n-1)  return true;
    }
    return false;
}

int jacobi (int a, int b)
{
    if (a == 0)  return 0;
    if (a == 1)  return 1;
    if (a < 0)
        if ((b & 2) == 0)
            return jacobi (-a, b);
        else
            return - jacobi (-a, b);
    int a1=a,  e=0;
    while ((a1 & 1) == 0)
        a1 >>= 1,  ++e;
    int s;
    if ((e & 1) == 0 || (b & 7) == 1 || (b & 7) == 7)
        s = 1;
    else
        s = -1;
    if ((b & 3) == 3 && (a1 & 3) == 3)
        s = -s;
    if (a1 == 1)
        return s;
    return s * jacobi (b % a1, a1);
}

bool bpsw (int n) {
    if ((int)sqrt(n+0.0) * (int)sqrt(n+0.0) == n)  return false;
    int dd=5;
    for (;;) {
        int g = gcd (n, abs(dd));
        if (1<g && g<n)  return false;
        if (jacobi (dd, n) == -1)  break;
        dd = dd<0 ? -dd+2 : -dd-2;
    }
    int p=1,  q=(p*p-dd)/4;
    int d=n+1,  s=0;
    while ((d & 1) == 0)
        ++s,  d>>=1;
    long long u=1, v=p, u2m=1, v2m=p, qm=q, qm2=q*2, qkd=q;
    for (int mask=2; mask<=d; mask<<=1) {
        u2m = (u2m * v2m) % n;
        v2m = (v2m * v2m) % n;
        while (v2m < qm2)   v2m += n;
        v2m -= qm2;
        qm = (qm * qm) % n;
        qm2 = qm * 2;
        if (d & mask) {
            long long t1 = (u2m * v) % n,  t2 = (v2m * u) % n,
                t3 = (v2m * v) % n,  t4 = (((u2m * u) % n) * dd) % n;
            u = t1 + t2;
            if (u & 1)  u += n;
            u = (u >> 1) % n;
            v = t3 + t4;
            if (v & 1)  v += n;
            v = (v >> 1) % n;
            qkd = (qkd * qm) % n;
        }
    }
    if (u==0 || v==0)  return true;
    long long qkd2 = qkd*2;
    for (int r=1; r<s; ++r) {
        v = (v * v) % n - qkd2;
        if (v < 0)  v += n;
        if (v < 0)  v += n;
        if (v >= n)  v -= n;
        if (v >= n)  v -= n;
        if (v == 0)  return true;
        if (r < s-1) {
            qkd = (qkd * 1ll * qkd) % n;
            qkd2 = qkd * 2;
        }
    }
    return false;
}

bool prime (int n) { // цю функцію потрібно викликати для перевірки на простоту
    for (int i=0; i<trivial_limit && p[i]<n; ++i)
        if (n % p[i] == 0)
            return false;
    if (p[trivial_limit-1]*p[trivial_limit-1] >= n)
        return true;
    if (!miller_rabin (n))
        return false;
    return bpsw (n);
}

void prime_init() { // викликати до першого виклику prime() !
    for (int i=2, j=0; j<trivial_limit; ++i) {
        bool pr = true;
        for (int k=2; k*k<=i; ++k)
            if (i % k == 0)
                pr = false;
        if (pr)
            p[j++] = i;
    }
}
```

## Эвристическое доведення-опровержение Померанса

Померанс в 1984 році запропонував випливає евристичне доведення.

Утверждение: **Кількість BPSW-псевдопростих від 1 до X більше X<sup>1-a</sup> для будь-якого a > 0**.

Доведення.

Нехай k > 4 - довільне, але фиксированное число. Нехай T - деякий велике число.

Нехай P<sub>k</sub>(T) - множину таких простих p в интервале [T; T<sup>k</sup>], для яких:

(1) p = 3 (mod 8), J(5,p) = -1

(2) число (p-1)/2 не є точним квадратом

(3) число (p-1)/2 складено виключно з простих q < T
(4) число (p-1)/2 складено виключно з таких простих q, що q = 1 (mod 4)

(5) число (p+1)/4 не є точним квадратом

(6) число (p+1)/4 складено виключно з простих d < T

(7) число (p+1)/4 складено виключно з таких простих d, що q = 3 (mod 4)

Зрозуміло, що приблизно 1/8 всіх простих в відрізку [T; T<sup>k</sup>] задовольняє умові (1). Також можна показати, що умови (2) і (5) сохраняют деяку частина чисел. Эвристически, умови (3) і (6) також дозволяють нам залишити деяку частина чисел з відрузку (T; T<sup>k</sup>). Нарешті, событие (4) володіє ймовірністю (c (log T)<sup>-1/2</sup>), так ж як і событие (7). Таким чином, потужність множини P<sub>k</sub>(T) прблизительно рівна при T -> oo

<img src=BPSW_formula1.jpg>

де c - деяка положительная константа, зависящая від вибору k.

Тепер ми **можемо побудувати число n**, не є точним квадратом, составленное з l простих з P<sub>k</sub>(T), де l непарне і менше T<sup>2</sup> / log(T<sup>k</sup>). Кількість способів вибрати таке число n є приблизно

<img src=BPSW_formula2.jpg>

для великого T і фіксованого k. Крім того, кожне таке число n менше e<sup>T<sup>2</sup></sup>.

Позначимо через Q<sub>1</sub> добуток простих q < T, для яких q = 1 (mod 4), а через Q<sub>3</sub> - добуток простих q < T, для яких q = 3 (mod 4). Значить gcd (Q<sub>1</sub>, Q<sub>3</sub>) = 1 і Q<sub>1</sub> Q<sub>3</sub> ? e<sup>T</sup>. Таким чином, кількість способів вибрати n **з дополнительными условиями**

$$
n = 1 (mod Q<sub>1</sub>), n = -1 (mod Q<sub>3</sub>)
$$

має бути, эвристически, як мінімум

$$
e<sup>T<sup> 2</sup> (1 - 3 / k)</sup> / e<sup> 2T</sup> > **e<sup>T<sup> 2</sup> (1 - 4 / k)</sup>**
$$

для великого T.

Але **кожне таке n - це контрприклад до тесту BPSW**. Дійсно, n буде числом Кармайкла (тобто числом, на якому тест Міллера-Рабіна буде ошибаться при будь-якому основании), тому воно автоматично буде псевдопростым по основи 2. Оскільки n = 3 (mod 8) і кожне p | n рівне 3 (mod 8), очевидно, що n також буде сильным псевдопростым по основи 2. Оскільки J(5,n) = -1, то кожне просте p | n задовольняє J(5,p) = -1, і так як p+1 | n+1 для будь-якого простого p | n, звідси випливає, що n - псевдопросте Лукаса для будь-якого тесту Лукаса з дискриминантом 5.

Таким чином, ми показали, що для будь-якого фіксованого k і всіх великих T, буде як мінімум e<sup>T<sup> 2</sup> (1 - 4 / k)</sup> контрприкладів до тесту BPSW серед чисел, менших e<sup>T<sup> 2</sup></sup>. Тепер, якщо ми покладемо x = e<sup>T<sup> 2</sup></sup>, буде як мінімум x<sup>1 - 4 / k</sup> контрприкладів, менших x. Оскільки k - случайное число, то наше доведення означає, що **кількість контрприкладів, менших x, є число, більше x<sup>1-a</sup> для будь-якого a > 0**.

## Практические испытания тесту BPSW

В цим розділі будуть розглянуті результати, отримані мной в результаті тестирования моей реалізації тесту BPSW. Усе испытания проводились на встроенном типе - 64-битном числі long long. Довга арифметика не тестировалась.

Тестирования проводились на комп'ютері з процессором Celeron 1.3 GHz.

Усе часи дані в **микросекундах** (10<sup> -6</sup> сек).

### Среднее час роботи на відрізку чисел в залежності від предела тривіального перебору

Є в увазі параметр, передаваемый функції prime_div_trivial(), який в коді вище рівний 29.

[Скачать](BPSW_test_1.zip) тестовую програму (код і exe-файл). [83 КБ]

Якщо запускати тест **на всіх нечетных числах** з відрузку, то результати виходять такими:

<table class=table2 cellspacing=0>
<tr><th>початок
відрузку</th><th>кінець
відрузку</th><th>межа >
перебору ></th><th width=13%>0</th><th width=13%>10<sup>2</sup></th><th width=13%>10<sup>3</sup></th><th width=13%>10<sup>4</sup></th><th width=13%>10<sup>5</sup></th></tr>
<tr><td>1</td><td>10<sup>5</sup></td><td></td><td>8.1</td><td>4.5</td><td>0.7</td><td>0.7</td><td>0.9</td></tr>
<tr><td>10<sup>6</sup></td><td>10<sup>6</sup>+10<sup>5</sup></td><td></td><td>12.8</td><td>6.8</td><td>7.0</td><td>1.6</td><td>1.6</td>
<tr><td>10<sup>9</sup></td><td>10<sup>9</sup>+10<sup>5</sup></td><td></td><td>28.4</td><td>12.6</td><td>12.1</td><td>17.0</td><td>17.1</td></tr>
<tr><td>10<sup>12</sup></td><td>10<sup>12</sup>+10<sup>5</sup></td><td></td><td>41.5</td><td>16.5</td><td>15.3</td><td>19.4</td><td>54.4</td></tr>
<tr><td>10<sup>15</sup></td><td>10<sup>15</sup>+10<sup>5</sup></td><td></td><td>66.7</td><td>24.4</td><td>21.1</td><td>24.8</td><td>58.9</td></tr>
</table>
Якщо запускати тест **тільки на простих числах** з відрузку, то швидкість роботи така:

<table class=table2 cellspacing=0>
<tr><th>початок
відрузку</th><th>кінець
відрузку</th><th>межа >
перебору ></th><th width=13%>0</th><th width=13%>10<sup>2</sup></th><th width=13%>10<sup>3</sup></th><th width=13%>10<sup>4</sup></th><th width=13%>10<sup>5</sup></th></tr>
<tr><td>1</td><td>10<sup>5</sup></td><td></td><td>42.9</td><td>40.8</td><td>3.1</td><td>4.2</td><td>4.2</td></tr>
<tr><td>10<sup>6</sup></td><td>10<sup>6</sup>+10<sup>5</sup></td><td></td><td>75.0</td><td>76.4</td><td>88.8</td><td>13.9</td><td>15.2</td>
<tr><td>10<sup>9</sup></td><td>10<sup>9</sup>+10<sup>5</sup></td><td></td><td>186.5</td><td>188.5</td><td>201.0</td><td>294.3</td><td>283.9</td></tr>
<tr><td>10<sup>12</sup></td><td>10<sup>12</sup>+10<sup>5</sup></td><td></td><td>288.3</td><td>288.3</td><td>302.2</td><td>387.9</td><td>1069.5</td></tr>
<tr><td>10<sup>15</sup></td><td>10<sup>15</sup>+10<sup>5</sup></td><td></td><td>485.6</td><td>489.1</td><td>496.3</td><td>585.4</td><td>1267.4</td></tr>
</table>
Таким чином, оптимально вибирати **межа тривіального перебору рівним 100 або 1000**.

Для всіх наступних тестів я выбрал межа 1000.

### Среднее час роботи на відрізку чисел

Тепер, коли ми вибрали межа тривіального перебору, можна більш точно протестировать швидкість роботи на різних відрізках.

<a href=BPSW_test2.zip>Скачать</a> тестовую програму (код і exe-файл). [83 КБ]

<table class=table1 cellspacing=0>
<tr><th width=100>початок
відрузку</th><th width=100>кінець
відрузку</th><th width=200>час роботи
на нечетных числах</th><th width=200>час роботи
на простих числах</th></tr>
<tr><td>1</td><td>10<sup>5</sup></td><td>1.2</td><td>4.2</td></tr>
<tr><td>10<sup>6</sup></td><td>10<sup>6</sup>+10<sup>5</sup></td><td>13.8</td><td>88.8</td></tr>
<tr><td>10<sup>7</sup></td><td>10<sup>7</sup>+10<sup>5</sup></td><td>16.8</td><td>115.5</td></tr>
<tr><td>10<sup>8</sup></td><td>10<sup>8</sup>+10<sup>5</sup></td><td>21.2</td><td>164.8</td></tr>
<tr><td>10<sup>9</sup></td><td>10<sup>9</sup>+10<sup>5</sup></td><td>24.0</td><td>201.0</td></tr>
<tr><td>10<sup>10</sup></td><td>10<sup>10</sup>+10<sup>5</sup></td><td>25.2</td><td>225.5</td></tr>
<tr><td>10<sup>11</sup></td><td>10<sup>11</sup>+10<sup>5</sup></td><td>28.4</td><td>266.5</td></tr>
<tr><td>10<sup>12</sup></td><td>10<sup>12</sup>+10<sup>5</sup></td><td>30.4</td><td>302.2</td></tr>
<tr><td>10<sup>13</sup></td><td>10<sup>13</sup>+10<sup>5</sup></td><td>33.0</td><td>352.2</td></tr>
<tr><td>10<sup>14</sup></td><td>10<sup>14</sup>+10<sup>5</sup></td><td>37.5</td><td>424.3</td></tr>
<tr><td>10<sup>15</sup></td><td>10<sup>15</sup>+10<sup>5</sup></td><td>42.3</td><td>499.8</td></tr>
<tr><td>10<sup>16</sup></td><td>10<sup>15</sup>+10<sup>5</sup></td><td>46.5</td><td>553.6</td></tr>
<tr><td>10<sup>17</sup></td><td>10<sup>15</sup>+10<sup>5</sup></td><td>48.9</td><td>621.1</td></tr>
</table>
Або, в вигляді графика, приблизне час роботи тесту BPSW на одному числі:

<img src=BPSW_graph1.gif>

Те є ми отримали, що на практиці, на невеликих числах (до 10<sup>17</sup>), **алгоритм працює за O (log N)**. Це объясняется тим, що для встроенного типу int64 операція ділення виконується за O(1), тобто складність ділення не зависисит від кількості бітів в числі.

Якщо ж застосувати тест BPSW до довгою арифметиці, то ожидается, що він буде працювати як раз за O (log<sup>3</sup>(N)). [ TODO ]

## Приложение. Усе програми

<a href=BPSW_all.zip>Скачать</a> всі програми з даній статті. [242 КБ]

## Література

Использованная мной литература, повністю доступная в Інтернеті:

<ol>
* Robert Baillie; Samuel S. Wagstaff
**Lucas pseudoprimes**
Math. Comp. 35 (1980) 1391-1417
[mpqs.free.fr/LucasPseudoprimes.pdf](http://mpqs.free.fr/LucasPseudoprimes.pdf)
&nbsp;
* Daniel J. Bernstein
**Distinguishing prime numbers from composite numbers: the state of the art in 2004**
Math. Comp. (2004)
[cr.yp.to/primetests/prime2004-20041223.pdf](http://cr.yp.to/primetests/prime2004-20041223.pdf)
&nbsp;
* Richard P. Brent
**Primality Testing and Integer Factorisation**
The Role of Mathematics in Science (1990)
[wwwmaths.anu.edu.au/~brent/pd/rpb120.pdf](http://wwwmaths.anu.edu.au/~brent/pd/rpb120.pdf)
&nbsp;
* H. Cohen; H. W. Lenstra
**Primality Testing and Jacobi Sums**
Amsterdam (1984)
[www.openaccess.leidenuniv.nl/bitstream/1887/2136/1/346_065.pdf](https://www.openaccess.leidenuniv.nl/bitstream/1887/2136/1/346_065.pdf)
&nbsp;
* <a name=5></a>Thomas H. Cormen; Charles E. Leiserson; Ronald L. Rivest
**Introduction to Algorithms**
[ без посилання ]
The MIT Press (2001)
&nbsp;
* <a name=6></a>M. Martin
**PRIMO - Primality Proving**
[www.ellipsa.net](http://www.ellipsa.net/)
&nbsp;
* F. Morain
**Elliptic curves and primality proving**
Math. Comp. 61(203) (1993)
[citeseer.ist.psu.edu/rd/43190198%2C72628%2C1%2C0.25%2CDownload/ftp%3AqSqqSqftp.inria.frqSqINRIAqSqpublicationqSqpubli-ps-gzqSqRRqSqRR-1256.ps.gz](http://citeseer.ist.psu.edu/rd/43190198%2C72628%2C1%2C0.25%2CDownload/ftp%3AqSqqSqftp.inria.frqSqINRIAqSqpublicationqSqpubli-ps-gzqSqRRqSqRR-1256.ps.gz)
&nbsp;
* Carl Pomerance
**Are there counter-examples to the Baillie-PSW primality test?**
Math. Comp. (1984)
[www.pseudoprime.com/dopo.pdf](http://www.pseudoprime.com/dopo.pdf)
&nbsp;
* Eric W. Weisstein
**Baillie-PSW primality test**
MathWorld (2005)
[mathworld.wolfram.com/Baillie-PSWPrimalityTest.html](http://mathworld.wolfram.com/Baillie-PSWPrimalityTest.html)
&nbsp;
* Eric W. Weisstein
**Strong Lucas pseudoprime**
MathWorld (2005)
[mathworld.wolfram.com/StrongLucasPseudoprime.html](http://mathworld.wolfram.com/StrongLucasPseudoprime.html)
&nbsp;
* Paulo Ribenboim
**The Book of Prime Number Records**
Springer-Verlag (1989)
[ без посилання ]
&nbsp;
</ol>
Список інших рекомендуемых книг, яких мне не вдалося знайти в Інтернеті:

<ol start=12>
* Zhaiyu Mo; James P. Jones
**A new primality test using Lucas sequences**
Preprint (1997)
&nbsp;
* Hans Riesel
**Prime numbers and computer methods for factorization**
Boston: Birkhauser (1994)
&nbsp;
</ol>
