# Алгоритм Евкліда знаходження НСД (найбільшого загального подільника)

Дано два цілих невід'ємних числа $a$ і $b$. Потрібно знайти їх найбільший загальний дільник, тобто найбільше число, яке є дільником одночасно і $a$, і $b$. На англійською мові "найбільший загальний дільник" пишеться "greatest common divisor", і распространённым його обозначением є ${\rm gcd}$:

$$
{\rm gcd}(a,b) = \max_{k=1 \ldots \infty \ :\  k|a \ \&\  k|b} k
$$

(тут символом "$|$" позначена делимость, тобто "$k|a$" позначає "$k$ ділить $a$")

Коли воно з чисел рівне нулю, а інше відмінно від нуля, їх найбільшим загальним дільником, згідно визначенню, буде це друге число. Коли обидва числа рівні нулю, результат не визначений (підійде будь-яке нескінченно велике число), ми покладемо в цим випадку найбільший загальний дільник рівним нулю. Тому можна говорити про такому правиле: якщо одне з чисел рівне нулю, то їх найбільший загальний дільник рівний другого числу.

**Алгоритм Евкліда**, рассмотренный нижче, вирішує задачу знаходження найбільшого загального подільника двох чисел $a$ і $b$ за $O(\log \min(a,b))$.

Даний алгоритм був вперше описаний в книзі Евкліда "Начала" (близько 300 р. до н.е)., хоча, цілком можливо, цей алгоритм має більш раннее происхождение.

## Алгоритм

Сам алгоритм надзвичайно простий і описується наступного формулою:

$$
{\rm gcd}(a,b) = \cases{ a, & {\rm if} b=0 \cr {\rm gcd} (b, a\ {\rm mod}\ b), & {\rm otherwise} }
$$

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
int gcd(int a, int b) {
    if (b == 0)
        return a;
    else
        return gcd(b, a % b);
}
```

Використовуючи тернарний условный оператор C++, алгоритм можна записати ще коротше:

<!--- TODO: specify code snippet id -->
``` cpp
int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }
```

Нарешті, наведемо і нерекурсивную форму алгоритму:

<!--- TODO: specify code snippet id -->
``` cpp
int gcd(int a, int b) {
    while (b) {
        a %= b;
        swap(a, b);
    }
    return a;
}
```

## Доведення коректності

Спочатку зауважимо, що при кожної ітерації алгоритму Евкліда його другий аргумент строго зменшується, отже, посколько він неотрицательный, то алгоритм Евкліда **завжди завершується**.

Для **доведення коректності** нам необхідно показати, що ${\rm gcd}(a,b) = {\rm gcd} (b, a\ {\rm mod}\ b)$ для будь-яких $a \ge 0, b > 0$.

Покажемо, що величина, що стоїть в лівої частини рівності, ділиться на настоящую в правою, а що стоїть в правою - ділиться на стоящую в лівої. Очевидно, це буде означати, що ліва і права частини збігаються, що і докажет коректність алгоритму Евкліда.

Позначимо $d = {\rm gcd}(a,b)$. Значить, по визначенню, $d|a$ і $d|b$.

Далі, разложим залишок від ділення $a$ на $b$ через їх приватна:

$$
a\ {\rm mod}\ b = a - b \left\lfloor \frac{a}{b} \right\rfloor
$$

Але тоді звідси випливає:

$$
d\ |\ (a\ {\rm mod}\ b)
$$

Отже, згадуючи твердження $d|b$, отримуємо систему:

$$
\cases{ d\ |\ b, \cr d\ |\ (a\ {\rm mod}\ b) }
$$

Скористаємося тепер наступним простим фактом: якщо для якихось трьох чисел $p,q,r$ виконано: $p|q$ і $p|r$, то виконується і: $p\ |\ {\rm gcd}(q,r)$. В нашій ситуації отримуємо:

$$
d\ |\ {\rm gcd}(b, a\ {\rm mod}\ b)
$$

Або, підставляючи замість $d$ його визначення як ${\rm gcd}(a,b)$, отримуємо:

$$
{\rm gcd}(a,b)\ |\ {\rm gcd}(b, a\ {\rm mod}\ b)
$$

Отже, ми провели половину доведення: показали, що ліва частина ділить праву. Друга половина доведення виготовляється аналогічно.

## Час роботи

Час роботи алгоритму оцінюється **теоремою Ламе**, яка устанавливает удивительную зв'язок алгоритму Евкліда і послідовності Фібоначчі:

Якщо $a > b \ge 1$ і $b < F_n$ для деякого $n$, то алгоритм Евкліда виконає не більш $n-2$ рекурсивних викликів.

Більш того, можна показати, що верхняя межа цій теореми - оптимальна. При $a = F_n, b = F_{n-1}$ буде виконано саме $n-2$ рекурсивних виклику. Іншими словами, **последовательные числа Фібоначчі - наихудшие вхідні дані** для алгоритму Евкліда.

Враховуючи, що числа Фібоначчі растут експоненціально (як константа в степені $n$), отримуємо, що алгоритм Евкліда виконується за $O(\log \min(a,b))$ операцій множення.

## НСК (найменше загальне кратне)

Обчислення найменшого загального кратного (least common multiplier, lcm) зводиться до обчислення $\rm gcd$ наступним простим утверждением:

$$
{\rm lcm}(a,b) = \frac{ a \cdot b }{ {\rm gcd}(a,b) }
$$

Таким чином, обчислення НСК також можна зробити з допомогою алгоритму Евкліда, з тією ж асимптотикою:

<!--- TODO: specify code snippet id -->
``` cpp
int lcm(int a, int b) { return a / gcd(a, b) * b; }
```

(тут вигідно спочатку поделить на $\rm gcd$, а тільки потім домножувати на $b$, оскільки це поможет уникнути переполнений в деяких випадках)

## Література

* \book{Томас Кормен, Чарльз Лейзерсон, Рональд Рівест, Кліффорд Штайн}{Алгоритми: Побудова і аналіз}{2005}{cormen.djvu}
