# Алгоритми хешування в завданнях на стрічки

Алгоритми хешування стрічок помогают розв'язати дуже багато задач. Але у них є великий недолік: що частіше всього вони не 100%-ны, оскільки є множину стрічок, хеші яких збігаються. Другое дело, що в більшості задач на це можна не обращать уваги, оскільки ймовірність збіги хеш усе-таки дуже мала.

&nbsp;

## Визначення хеша і його обчислення

Один з кращих способів визначити хеш-функцію від стрічки S наступного:

$$
h(S)  =  S[0]  +  S[1] * P  +  S[2] * P^2  +  S[3] * P^3  +  ...  +  S[N] * P^N
$$

де P - деякий число.

Разумно вибирати для P просте число, приблизно рівне кількості символів у вхідному алфавите. Наприклад, якщо стрічки предполаются состоящими тільки з маленьких латинських букв, то хорошим вибором буде P = 31. Якщо букви можуть бути і заглавными, і маленькими, то, наприклад, можна P = 53.

У всіх кусках коду в цій статті буде використовуватися P = 31.

Саме значення хеша бажано зберігати в самому великому числовом типе - int64, він ж long long. Очевидно, що при довжині стрічки порядку 20 символів вже буде відбуватися переповнення значення. Ключевой момент - що ми не обращаем увага на ці переповнення, як б беручи хеш за модулем 2^64.

Приклад обчислення хеша, якщо допустимі тільки маленькі латинские букви:

<!--- TODO: specify code snippet id -->
``` cpp
const int p = 31;
long long hash = 0, p_pow = 1;
for (size_t i = 0; i < s.length(); ++i) {
    // бажано віднімати 'a' від коду букви
    // одиницю додаємо, аби у стрічки увазі 'aaaaa' хеш був ненульовий
    hash += (s[i] - 'a' + 1) * p_pow;
    p_pow *= p;
}
```
В більшості задач має сенс спочатку обчислити всі потрібні степені P в якому-або масиві.

&nbsp;

## Приклад задачі. Пошук однакових стрічок

Уже тепер ми в стані ефективно розв'язати таку задачу. Дан список стрічок S[1..N], кожна довжиною не більш M символів. Припустимо, потрібно знайти всі повторювані стрічки і розділити їх на групи, аби в кожної группе були тільки однакові стрічки.

Обычной сортуванням стрічок ми б отримали алгоритм зі сложностью O (N M log N), в то час як використовуючи хеші, ми отримаємо O (N M + N log N).

Алгоритм. Порахуємо хеш від кожної стрічки, і відсортуємо стрічки по цьому хэшу.

<!--- TODO: specify code snippet id -->
``` cpp
vector<string> s(n);
// ... зчитування стрічок ...

// припустимо всі степені p, допустим, до 10000 - максимальної довжини стрічок
const int p = 31;
vector<long long> p_pow(10000);
p_pow[0] = 1;
for (size_t i = 1; i < p_pow.size(); ++i)
    p_pow[i] = p_pow[i - 1] * p;

// припустимо хеші від всіх стрічок
// в масиві зберігаємо значення хеша і номер стрічки в масиві s
vector<pair<long long, int>> hashes(n);
for (int i = 0; i < n; ++i) {
    long long hash = 0;
    for (size_t j = 0; j < s[i].length(); ++j)
        hash += (s[i][j] - 'a' + 1) * p_pow[j];
    hashes[i] = make_pair(hash, i);
}

// сортуємо по хэшам
sort(hashes.begin(), hashes.end());

// виводимо відповідь
for (int i = 0, group = 0; i < n; ++i) {
    if (i == 0 || hashes[i].first != hashes[i - 1].first)
        cout << "\nGroup " << ++group << ":";
    cout << ' ' << hashes[i].second;
}
```

&nbsp;

## Хэш підстрічки і його швидке обчислення

Припустимо, нам дана стрічка S, і дані індекси I і J. Потрібно знайти хеш від підстрічки S[I..J].

За визначенню маємо:

$$
H[I..J]  =  S[I]  +  S[I+1] * P  +  S[I+2] * P^2  +  ...  + S[J] * P^(J-I)
$$

звідки:

$$
H[I..J] * P[I]  =  S[I] * P[I]  +  ...  +  S[J] * P[J],
H[I..J] * P[I]  =  H[0..J]  -  H[0..I-1]
$$

Полученное властивість є дуже важливим.

Дійсно, виходить, що, **знаючи тільки хеші від всіх префіксів стрічки S, ми можемо за O (1) получити хеш будь-який підстрічки**.

Єдина що виникає проблема - це то, що потрібно вміти ділити на P[I]. Насправді, це не так просто. Оскільки ми обчислюємо хеш за модулем 2^64, то для ділення на P[I] ми повинні знайти до нього зворотний елемент в поле (наприклад, з допомогою [Расширенного алгоритму Евкліда](extended_Euclid_algorithm)), і виконати множення на цей зворотний елемент.

Втім, є і більш простий шлях. В більшості випадків, **замість того аби ділити хеші на степені P, можна, навпаки, умножать їх на ці степені**.

Припустимо, дані два хеша: один умноженный на P[I], а іншої - на P[J]. Якщо I < J, то помножимо перый хеш на P[J-I], інакше ж помножимо другий хеш на P[I-J]. Тепер ми привели хеші до однієї степені, і можемо їх спокойно порівнювати.

Наприклад, код, який обчислює хеші всіх префіксів, а потім за O (1) сравнивает дві підстрічки:

<!--- TODO: specify code snippet id -->
``` cpp
string s;
int i1, i2, len; // вхідні дані

// припустимо всі степені p
const int p = 31;
vector<long long> p_pow(s.length());
p_pow[0] = 1;
for (size_t i = 1; i < p_pow.size(); ++i)
    p_pow[i] = p_pow[i - 1] * p;

// припустимо хеші від всіх префіксів
vector<long long> h(s.length());
for (size_t i = 0; i < s.length(); ++i) {
    h[i] = (s[i] - 'a' + 1) * p_pow[i];
    if (i)
        h[i] += h[i - 1];
}

// отримуємо хеші двох підстрічок
long long h1 = h[i1 + len - 1];
if (i1)
    h1 -= h[i1 - 1];
long long h2 = h[i2 + len - 1];
if (i2)
    h2 -= h[i2 - 1];

// порівнюємо їх
if (i1 < i2 && h1 * p_pow[i2 - i1] == h2 || i1 > i2 && h1 == h2 * p_pow[i1 - i2])
    cout << "equal";
else
    cout << "different";
```

## Застосування хешування

Ось деякі типичные застосування хешування:

* [Алгоритм Рабина-Карпа пошуку підстрічки в стрічки за O (N)](rabin_karp)
* Визначення кількості різних підстрічок за O (N^2 log N) (див. нижче)
* Визначення кількості паліндромів всередині стрічки

## Визначення кількості різних підстрічок

Нехай дана стрічка S довжиною N, що складається тільки з маленьких латинських букв. Потрібно знайти кількість різних підстрічок в цій стрічки.

Для розв'язку переберемо по черги довжину підстрічки: L = 1 .. N.

Для кожного L ми побудуємо масив хеш підстрічок довжини L, причому наведемо хеші до однієї степені, і відсортуємо цей масив. Кількість різних елементів в цим масиві додаємо до відповіді.

Реалізація:

<!--- TODO: specify code snippet id -->
``` cpp
string s; // вхідні стрічка
int n = (int)s.length();

// припустимо всі степені p
const int p = 31;
vector<long long> p_pow(s.length());
p_pow[0] = 1;
for (size_t i = 1; i < p_pow.size(); ++i)
    p_pow[i] = p_pow[i - 1] * p;

// припустимо хеші від всіх префіксів
vector<long long> h(s.length());
for (size_t i = 0; i < s.length(); ++i) {
    h[i] = (s[i] - 'a' + 1) * p_pow[i];
    if (i)
        h[i] += h[i - 1];
}

int result = 0;

// перебираємо довжину підстрічки
for (int l = 1; l <= n; ++l) {
    // шукаємо відповідь для поточній довжини

    // отримуємо хеші для всіх підстрічок довжини l
    vector<long long> hs(n - l + 1);
    for (int i = 0; i < n - l + 1; ++i) {
        long long cur_h = h[i + l - 1];
        if (i)
            cur_h -= h[i - 1];
        // наводимо всі хеші до однієї степені
        cur_h *= p_pow[n - i - 1];
        hs[i] = cur_h;
    }

    // припустимо кількість різних хеш
    sort(hs.begin(), hs.end());
    hs.erase(unique(hs.begin(), hs.end()), hs.end());
    result += (int)hs.size();
}

cout << result;
```
