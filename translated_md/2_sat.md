# Задача 2-SAT

Задача 2-SAT (2-satisfiability) - це задача распределения значень булевым змінним таким чином, аби вони удовлетворяли всім наложенным обмеженням.

Завдання 2-SAT можна уявити в вигляді конъюнктивной нормальної формы, де в кожному выражении в скобках варто рівне по дві змінній; така форма називається 2-CNF (2-conjunctive normal form). Наприклад:

$$
(a || c) && (a || !d) && (b || !d) && (b || !e) && (c || d)
$$

## Додатки

Алгоритм для розв'язку 2-SAT можливо бути застосуємо у всіх завданнях, де є набір величин, кожна з яких можливо приймати 2 можливих значення, і є зв'язку між цими величинами:

* **Расположение текстовых міток на мапі або діаграмі**.
Є в увазі знаходження такого расположения міток, при якому ніякі дві не перетинаються.
Варто замітити, що в загалом випадку, коли кожна мітка можливо займати множину різних позицій, ми отримуємо задачу general satisfiability, яка є NP-повної. Однак, якщо обмежитися тільки двома можливими позиціями, то полученная задача буде завданням 2-SAT.
* **Расположение ребер при рисовании графа**.
Аналогічно попередньому пункту, якщо обмежитися тільки двома можливими способами провести ребро, то ми прийдемо до 2-SAT.
* **Составление розкладу ігор**.
Є в увазі така система, коли кожна команда повинна сыграть з кожної по одному разу, а потрібно розподілити гри по типу домашняя-выездная, з деякими наложенными обмеженнями.
* і т.д.

## Алгоритм

Спочатку наведемо задачу до іншої формі - так званої импликативной формі. Зауважимо, що вираз увазі a || b еквівалентно !a => b або !b => a. Це можна сприймати наступним чином: якщо є вираз a || b, і нам необхідно домогтися обращения його в true, то, якщо a=false, то необхідно b=true, і навпаки, якщо b=false, то необхідно a=true.

Побудуємо тепер так званий **граф імплікацій**: для кожної змінній в графі буде по дві вершини, позначимо їх через x<sub>i</sub> і !x<sub>i</sub>. Рёбра в графі будуть відповідати импликативным связям.

Наприклад, для 2-CNF формы:

$$
(a || b) && (b || !c)
$$

Граф імплікацій буде містити наступні ребра (орієнтовані):

$$
!a => b
!b => a
!b => !c
c => b
$$

Варто звернути увага на таке властивість графа імплікацій, що якщо є ребро a => b, то є і ребро !b => !a.

Тепер зауважимо, що якщо для якийсь змінній x виконується, що з x досяжно !x, а з !x досяжно x, то задача розв'язку не має. Дійсно, яке б значення для змінній x ми б ні вибрали, ми завжди прийдемо до протиріччя - що має бути вибрано і зворотнє йому значення. Виявляється, що це умова є не тільки достаточным, але і необходимым (доказательством цього факту буде описаний нижче алгоритм). Переформулюємо даний критерій в термінах теорії графів. Нагадаємо, що якщо з однієї вершини досяжна інша, а з тією вершини досяжна перша, то ці дві вершини знаходяться в однієї сильно связной компоненті. Значить ми можемо сформулировать **критерій існування розв'язку** наступним чином:

Для того, аби дана задача 2-SAT **мала розв'язок**, необхідно і достатньо, аби для будь-який змінній x вершини x і !x знаходилися **в різних компонентах сильної зв'язності** графа імплікацій.

Цей критерій можна перевірити за час O (N + M) з допомогою [алгоритму пошуку сильно зв'язаних компонент](strong_connected_components).

Тепер побудуємо власне **алгоритм** знаходження розв'язку задачі 2-SAT в припущенні, що розв'язок існує.

Зауважимо, що, незважаючи на то, що розв'язок існує, для деяких змінних можливо виконуватися, що з x досяжно !x, або (але не одночасно), з !x досяжно x. В такому випадку вибір одного з значень змінній x буде приводити до протиріччя, в то час як вибір іншого - не буде. Навчимося вибирати з двох значень то, яке не призводить до возникновению противоречий. Відразу зауважимо, що, выбрав яке-або значення, ми повинні запустити з нього обхід в глибину/ширину і пометить всі значення, які следуют з нього, тобто досяжні в графі імплікацій. Відповідно, для вже помічених вершин ніякого вибору між x і !x робити не потрібно, для них значення вже вибрано і зафіксовано. Нижеописанное правило застосовується тільки до непомеченным ще вершин.

**Стверджується** випливає. Нехай comp[v] позначає номер компоненти сильної зв'язності, якій належить вершина v, причому номера впорядковані в порядку топологічної сортування компонент сильної зв'язності в графі компонентов (тобто більш ранним в порядку топологічної сортування відповідають великі номера: якщо є шлях з v в w, то comp[v] <= comp[w]). Значить, якщо comp[x] < comp[!x], то вибираємо значення !x, інакше, тобто якщо comp[x] > comp[!x], то вибираємо x.

**Доведемо**, що при такому виборі значень ми не прийдемо до протиріччя. Нехай, для определённости, обрана вершина x (випадок, коли обрана вершина !x, доводиться симетрично).

По-перше, доведемо, що з x не досяжно !x. Дійсно, так як номер компоненти сильної зв'язності comp[x] більше номера компоненти comp[!x], то це означає, що компонента зв'язності, що містить x, расположена левее компоненти зв'язності, містить !x, і з першо] ніяк не можливо бути досяжна остання.

По-друге, доведемо, що ніяка вершина y, досяжна з x, не є "плохой", тобто невірно, що з y досяжно !y. Доведемо це від противного. Нехай з x досяжно y, а з y досяжно !y. Так як з x досяжно y, то, по властивості графа імплікацій, з !y буде досяжно !x. Але, по припущенням, з y досяжно !y. Значить ми отримуємо, що з x досяжно !x, що суперечить умові, що і потрібно довести.

Отже, ми побудували алгоритм, який знаходить шукані значення змінних в припущенні, що для будь-який змінній x вершини x і !x знаходяться в різних компонентах сильної зв'язності. Вище показали коректність цього алгоритму. Отже, ми одночасно довели зазначений вище критерій існування розв'язку.

Тепер ми можемо собрать **весь алгоритм** воедино:

* Побудуємо граф імплікацій.
* Знайдемо в цим графі компоненти сильної зв'язності за час O (N + M), нехай comp[v] - це номер компоненти сильної зв'язності, якій належить вершина v.
* Перевіримо, що для кожної змінній x вершини x і !x лежати в різних компонентах, тобто comp[x] &ne; comp[!x]. Якщо це умова не виконується, то повернути "розв'язок не існує".
* Якщо comp[x] > comp[!x], то змінній x вибираємо значення true, інакше - false.

## Реалізація

Нижче наведено реалізація розв'язку задачі 2-SAT для вже построенного графа імплікацій g і зворотнього йому графа gt (тобто в якому напрямок кожного ребра изменено на протилежне).

Програма виводить номера обраних вершин, або фразу "NO SOLUTION", якщо розв'язку не існує.

<!--- TODO: specify code snippet id -->
``` cpp
int n;
vector < vector<int> > g, gt;
vector<bool> used;
vector<int> order, comp;

void dfs1 (int v) {
    used[v] = true;
    for (size_t i=0; i<g[v].size(); ++i) {
        int to = g[v][i];
        if (!used[to])
            dfs1 (to);
    }
    order.push_back (v);
}

void dfs2 (int v, int cl) {
    comp[v] = cl;
    for (size_t i=0; i<gt[v].size(); ++i) {
        int to = gt[v][i];
        if (comp[to] == -1)
            dfs2 (to, cl);
    }
}

int main() {
    ... читання n, графа g, побудова графа gt ...

    used.assign (n, false);
    for (int i=0; i<n; ++i)
        if (!used[i])
            dfs1 (i);

    comp.assign (n, -1);
    for (int i=0, j=0; i<n; ++i) {
        int v = order[n-i-1];
        if (comp[v] == -1)
            dfs2 (v, j++);
    }

    for (int i=0; i<n; ++i)
        if (comp[i] == comp[i^1]) {
            puts ("NO SOLUTION");
            return 0;
        }
    for (int i=0; i<n; ++i) {
        int ans = comp[i] > comp[i^1] ? i : i^1;
        printf ("%d ", ans);
    }

}
```
