# Мінімальна каркасне дерево. Алгоритм Прима

Дан зважений неорієнтований граф $G$ з $n$ вершинами і $m$ ребрами. Потрібно знайти таке піддерево цього графа, яке б соединяло всі його вершини, і при цим обладало найменшим можливим вагою (тобто сумою ваг ребер). Поддерево - це набір ребер, з'єднують всі вершини, причому з будь-який вершини можна добраться до будь-який іншої рівне одним простим шляхом.

Таке піддерево називається мінімальним остовным деревом або просто **мінімальним каркасом**. Легко зрозуміти, що будь-який каркас обов'язково буде містити $n-1$ ребро.

В **естественной постановці** ця задача звучить наступним чином: є $n$ міст, і для кожної пари відома вартість соединения їх дорогой (або відомо, що з'єднати їх не можна). Потрібно з'єднати всі города так, аби можна було доехать з будь-якого города в іншої, а при цим вартість прокладки доріг була б мінімальної.

## Алгоритм Прима

Цей алгоритм назван в честь американского математика Роберта Прима (Robert Prim), який відкрив цей алгоритм в 1957 р. Втім, ще в 1930 р. цей алгоритм був відкритий чешским математиком Войтеком Ярником (Vojtěch Jarník). Крім того, Эдгар Дейкстра (Edsger Dijkstra) в 1959 р. також винайшов цей алгоритм, незалежно від них.

### Опис алгоритму

Сам **алгоритм** має дуже простий вид. Искомый мінімальний каркас будується поступово, додаванням в нього ребер по одному. Cпершу каркас покладається що складається з єдиною вершини (її можна вибрати довільно). Потім вибирається ребро мінімального ваги, исходящее з цій вершини, і додається в мінімальний каркас. Після цього каркас містить вже дві вершини, і тепер шукається і додається ребро мінімального ваги, имеющее один кінець в однієї з двох обраних вершин, а іншої - навпаки, у всіх інших, крім цих двох. І так далі, тобто всякий раз шукається мінімальне по вазі ребро, один кінець якого - вже взята в каркас вершина, а іншої кінець - ще не взята, і це ребро додається в каркас (якщо таких ребер декілька, можна взяти будь-яке). Цей процес повторяется до тих пір, поки каркас не стане містити всі вершини (або, що то ж саме, $n-1$ ребро).

В результаті буде побудований каркас, є мінімальним. Якщо граф був спершу не связен, то каркас знайдений не буде (кількість обраних ребер залишиться менше $n-1$).

### Доведення

Нехай граф $G$ був зв'язним, тобто відповідь існує. Позначимо через $T$ каркас, знайдений алгоритмом Прима, а через $S$ - мінімальний каркас. Очевидно, що $T$ дійсно є каркасом (тобто під деревом графа $G$). Покажемо, що ваги $S$ і $T$ збігаються.

Розглянемо перший момент часу, коли в $T$ происходило додавання ребра, не входящего в оптимальний каркас $S$. Позначимо це ребро через $e$, кінці його - через $a$ і $b$, а множину що входять на той момент в каркас вершин - через $V$ (згідно алгоритму, $a \in V$, $b \not\in V$, або навпаки). В оптимальном остові $S$ вершини $a$ і $b$ соединяются яким-то шляхом $P$; найдемо в цим шляхи будь-яке ребро $g$, один кінець якого лежить в $V$, а іншої - ні. Оскільки алгоритм Прима выбрал ребро $e$ замість ребра $g$, то це значить, що вага ребра $g$ більше або рівний вазі ребра $e$.

Удалим тепер з $S$ ребро $g$, і додамо ребро $e$. За тільки що сказанному, вага острови в результаті не міг збільшитися (зменшитися він теж не міг, оскільки $S$ було оптимальним). Крім того, $S$ не перестало бути каркасом (в тому, що зв'язність не нарушилась, неважко переконатися: ми замкнули шлях $P$ в цикл, і потім видалили з цього циклу одне ребро).

Отже, ми показали, що можна вибрати оптимальний каркас $S$ таким чином, що він буде включать ребро $e$. Повторюючи цю процедуру необхідне число раз, ми отримуємо, що можна вибрати оптимальний каркас $S$ так, аби він совпадал з $T$. Отже, вага построенного алгоритмом Прима $T$ минимален, що і потрібно довести.

## Реализации

Час роботи алгоритму істотно залежить від того, яким чином ми виробляємо пошук чергового мінімального ребра серед відповідних ребер. Тут можуть бути різні подходы, приводящие до різним асимптотикам і різним реализациям.

### Тривиальная реалізація: алгоритми за $O(n m)$ і $O(n^2 + m \log n)$

Якщо шукати кожний раз ребро простим просмотром серед всіх можливих варіантів, то асимптотично буде требоваться просмотр $O(m)$ ребер, аби знайти серед всіх допустимых ребро з найменшим вагою. Суммарная асимптотика алгоритму складе в такому випадку $O(nm)$, що в гіршому випадку є $O(n^3)$, - занадто повільний алгоритм.

Цей алгоритм можна покращити, якщо переглядати кожний раз не всі ребра, а тільки по одному ребру з кожної вже обраної вершини. Для цього, наприклад, можна відсортувати ребра з кожної вершини в порядку зростання ваг, і зберігати вказівник на перший допустимое ребро (нагадаємо, допустимі тільки ті ребра, які ведуть в множину ще не обраних вершин). Значить, якщо перераховувати ці вказівники при кожному додаванні ребра в каркас, сумарна асимптотика алгоритму буде $O(n^2 + m)$, але попередньо буде потрібно виконати сортування всіх ребер за $O(m \log n)$, що в гіршому випадку (для щільних графів) дає асимптотику $O(n^2 \log n)$.

Нижче ми розглянемо два трохи інших алгоритму: для щільних і для розріджених графів, отримавши в підсумку помітно лучшую асимптотику.

### Випадок щільних графів: алгоритм за $O(n^2)$

Подойдём до питання пошуку найменшого ребра з іншої сторони: для кожної ще не обраної будемо зберігати мінімальне ребро, ведущее в вже выбранную вершину.

Значить, аби на поточному кроці провести вибір мінімального ребра, треба просто переглянути ці минимальные ребра у кожної не обраної ще вершини - асимптотика складе $O(n)$.

Але тепер при додаванні в каркас чергового ребра і вершини ці вказівники треба перераховувати. Зауважимо, що ці вказівники можуть тільки зменшуватися, тобто у кожної не просмотренной ще вершини треба або залишити її вказівник без зміни, або присвоїти йому вага ребра в тільки що добавленную вершину. Отже, цю фазу можна зробити також за $O(n)$.

Таким чином, ми отримали різновид алгоритму Прима з асимптотикою $O(n^2)$.

В зокрема, така реалізація особливо удобна для розв'язку так званої **евклидовой задачі про минимальном остові**: коли дані $n$ точок на площині, відстань між якими измеряется по стандартної евклидовой метрике, і потрібно знайти каркас мінімального ваги, з'єднує їх всі (причому додавати нові вершини де-або в інших местах запрещается). Ця задача вирішується описаним тут алгоритмом за $O(n^2)$ часу і $O(n)$ пам'яті, чого не вийде домогтися [алгоритмом Крускала](mst_kruskal).

Реалізація алгоритму Прима для графа, заданого матрицею суміжності $g[][]$:

<!--- TODO: specify code snippet id -->
``` cpp
// вхідні дані
int n;
vector < vector<int> > g;
const int INF = 1000000000; // значення "нескінченність"

// алгоритм
vector<bool> used (n);
vector<int> min_e (n, INF), sel_e (n, -1);
min_e[0] = 0;
for (int i=0; i<n; ++i) {
    int v = -1;
    for (int j=0; j<n; ++j)
        if (!used[j] && (v == -1 || min_e[j] < min_e[v]))
            v = j;
    if (min_e[v] == INF) {
        cout << "No MST!";
        exit(0);
    }

    used[v] = true;
    if (sel_e[v] != -1)
        cout << v << " " << sel_e[v] << endl;

    for (int to=0; to<n; ++to)
        if (g[v][to] < min_e[to]) {
            min_e[to] = g[v][to];
            sel_e[to] = v;
        }
}
```

На вхід подаются кількість вершин $n$ і матриця $g[][]$ розміру $n \times n$, в якій отмечены ваги ребер, і стоять числа $INF$, якщо відповідне ребро відсутній. Алгоритм підтримує три масиву: прапор ${\rm used}[i] = {\rm true}$ означає, що вершина $i$ включена в каркас, величина ${\rm min\_e}[i]$ зберігає вага найменшого допустимого ребра з вершини $i$, а елемент ${\rm sel\_e}[i]$ містить кінець цього найменшого ребра (це потрібно для виведення ребер в відповіді). Алгоритм робить $n$ кроків, на кожному з яких выбирает вершину $v$ з найменшою меткой ${\rm min\_e}$, позначає її $\rm used$, і потім переглядає всі ребра з цій вершини, перераховуючи їх мітки.

### Випадок розріджених графів: алгоритм за $O(m \log n)$

В описанном вище алгоритмі можна побачити стандартні операції знаходження мінімуму в множині і зміна значень в цим множині. Ці дві операції є классическими, і виконуються многими структурами данних, наприклад, реализованным в мові C++ красно-чёрным деревом set.

За смыслу алгоритм залишається точно таким ж, однак тепер ми можемо знайти мінімальне ребро за час $O(\log n)$. З іншої сторони, час на перерахунок $n$ покажчиків тепер складе $O(n \log n)$, що гірше, ніж в вищеописаному алгоритмі.

Якщо врахувати, що всього буде $O(m)$ перерахунків покажчиків і $O(n)$ пошуків мінімального ребра, то сумарна асимптотика складе $O(m \log n)$ - для розріджених графів це краще, ніж обидва вищеописаних алгоритму, але на щільних графах цей алгоритм буде повільніше попереднього.

Реалізація алгоритму Прима для графа, заданого списками суміжності $g[]$:

<!--- TODO: specify code snippet id -->
``` cpp
// вхідні дані
int n;
vector < vector < pair<int,int> > > g;
const int INF = 1000000000; // значення "нескінченність"

// алгоритм
vector<int> min_e (n, INF), sel_e (n, -1);
min_e[0] = 0;
set < pair<int,int> > q;
q.insert (make_pair (0, 0));
for (int i=0; i<n; ++i) {
    if (q.empty()) {
        cout << "No MST!";
        exit(0);
    }
    int v = q.begin()->second;
    q.erase (q.begin());

    if (sel_e[v] != -1)
        cout << v << " " << sel_e[v] << endl;

    for (size_t j=0; j<g[v].size(); ++j) {
        int to = g[v][j].first,
            cost = g[v][j].second;
        if (cost < min_e[to]) {
            q.erase (make_pair (min_e[to], to));
            min_e[to] = cost;
            sel_e[to] = v;
            q.insert (make_pair (min_e[to], to));
        }
    }
}
```

На вхід подаются кількість вершин $n$ і $n$ списків суміжності: $g[i]$ - це список всіх ребер, вихідних з вершини $i$, в вигляді пар (другий кінець ребра, вага ребра). Алгоритм підтримує два масиву: величина ${\rm min\_e}[i]$ зберігає вага найменшого допустимого ребра з вершини $i$, а елемент ${\rm sel\_e}[i]$ містить кінець цього найменшого ребра (це потрібно для виведення ребер в відповіді). Крім того, підтримується чергу $q$ з всіх вершин в порядку збільшення їх міток ${\rm min\_e}$. Алгоритм робить $n$ кроків, на кожному з яких выбирает вершину $v$ з найменшою меткой ${\rm min\_e}$ (просто извлекая її з початку черги), і потім переглядає всі ребра з цій вершини, перераховуючи їх мітки (при пересчёте ми видаляємо з черги старую величину, і потім кладемо назад нову).

### Аналогия з алгоритмом Дейкстри

В двох описаних тільки що алгоритмах прослеживается цілком чёткая аналогия з [алгоритмом Дейкстри](dijkstra): він має таку ж структуру ($n-1$ фаза, на кожної з яких спочатку вибирається оптимальне ребро, додається в відповідь, а потім перераховуються значення для всіх не обраних ще вершин). Більш того, алгоритм Дейкстри теж має два варіанти реалізації: за $O(n^2)$ і $O(m \log n)$ (ми, звісно, тут не враховуємо можливість використання складних структур данних для досягнення ще менших асимптотик).

Якщо взглянуть на алгоритми Прима і Дейкстри більш формально, то виходить, що вони взагалі идентичны один одному, за винятком **ваговій функції** вершин: якщо в алгоритмі Дейкстри у кожної вершини підтримується довжина найкоротшого шляхи (тобто сума ваг деяких ребер), то в алгоритмі Прима кожної вершині приписується тільки вага мінімального ребра, провідного в множину вже взятих вершин.

На рівні реалізації це означає, що після додавання черговий вершини $v$ в множину обраних вершин, коли ми починаємо переглядати всі ребра $(v,to)$ з цій вершини, то в алгоритмі Прима вказівник $to$ оновлюється вагою ребра $(v,to)$, а в алгоритмі Дейкстри - мітка відстані $d[to]$ оновлюється сумою мітки $d[v]$ і ваги ребра $(v,to)$. В остальном ці два алгоритму можна вважати идентичными (хоть вони і решают зовсім різні задачі).

## Властивості мінімальних кістяків

* **Максимальний** каркас також можна шукати алгоритмом Прима (наприклад, замінивши всі ваги ребер на протилежні: алгоритм не вимагає неотрицательности ваг ребер).

* Мінімальний каркас **единственен**, якщо ваги всіх ребер різні. В іншому випадку, можливо існувати декілька мінімальних кістяків (який саме буде обраний алгоритмом Прима, залежить від порядку просмотра ребер/вершин з однаковими вагами/указателями)

* Мінімальний каркас також є каркасом, **мінімальним по произведению** всіх ребер (передбачається, що всі ваги положительны). Насправді, якщо ми замінимо ваги всіх ребер на їх логарифмы, то легко замітити, що в роботі алгоритму нічого не зміниться, і будуть найдены ті ж самі ребра.

* Мінімальний каркас є каркасом з мінімальним вагою **самого тяжёлого ребра**. Яснее всього це твердження зрозуміло, якщо розглянути роботу [алгоритму Крускала](mst_kruskal).

* **Критерій мінімальності** острови: каркас є мінімальним тоді і тільки тоді, коли для будь-якого ребра, не належить каркасу, цикл, образуемый цим ребром при додаванні до каркасу, не містить ребер тяжелее цього ребра. Насправді, якщо для якогось ребра виявилося, що воно легче деяких ребер утвореного циклу, то можна получити каркас з меншим вагою (додавши це ребро в каркас, і видаливши саме тяжелое ребро з циклу). Якщо ж це умова не виповнилося ні для одного ребра, то всі ці ребра не улучшают вага острови при їх додаванні.
