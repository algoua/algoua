# Дискретне логарифмирование

Задача дискретного логарифмирования полягає в тому, аби по даними цілим $a$, $b$, $m$ розв'язати рівняння:

$$
a^x = b \pmod m,
$$

де $a$ і $m$ - **взаємно прості** (примечание: якщо вони не взаємно прості, то описаний нижче алгоритм є некорректным; хоча, предположительно, його можна модифікувати, аби він як і раніше працював).

Тут описаний алгоритм, відомий як **"baby-step-giant-step algorithm"**, запропонований **Шэнксом (Shanks)** в 1971 р., працюючий за час за $O(\sqrt{m} \log m)$. Часто цей алгоритм просто називають алгоритмом **"meet-in-the-middle"** (тому що це одне з класичних застосувань техніки "meet-in-the-middle": "поділ задачі навпіл").

## Алгоритм

Отже, ми маємо рівняння:

$$
a^x = b \pmod m,
$$

де $a$ і $m$ взаємно прості.

Перетворимо рівняння. Покладемо

$$
x = np - q,
$$

де $n$ - це заздалегідь обрана константа (як її вибирати в залежності від $m$, ми поймём трохи пізніше). Іноді $p$ називають "giant step" (оскільки збільшення його на одиницю збільшує $x$ зразу на $n$), а в протилежність йому $q$ - "baby step".

Очевидно, що будь-яке $x$ (з промежутка $[0;m)$ - зрозуміло, що такого диапазона значень буде достатньо) можна уявити в такий формі, причому для цього буде достатньо значень:

$$
p \in \left[ 1; \left\lceil \frac{m}{n} \right\rceil \right], ~~~~~ q \in [0;n].
$$

Значить рівняння приймає вид:

$$
a^{np-q} = b \pmod m,
$$

звідки, користуючись тим, що $a$ і $m$ взаємно прості, отримуємо:

$$
a^{np} = b a^q \pmod m.
$$

Щоб розв'язати вихідне рівняння, потрібно знайти відповідні значення $p$ і $q$, аби значення лівої і правою частин збіглися. Інакше кажучи, треба розв'язати рівняння:

$$
f_1(p) = f_2(q).
$$

Ця задача вирішується з допомогою методу meet-in-the-middle наступним чином.  Перша фаза алгоритму: порахуємо значення функції $f_1$ для всіх значень аргументу $p$, і відсортуємо ці значення. Друга фаза алгоритму: будемо перебирати значення другий змінній $q$, обчислювати одному функцію $f_2$, і шукати це значення серед предвычисленных значень першо] функції з допомогою бінарного пошуку.

## Асимптотика

Спочатку оцінимо час обчислення кожної з функцій $f_1(p)$ і $f_2(q)$. І та, і інша містить піднесення в ступінь, яке можна виконувати з допомогою [алгоритму бінарного піднесення в ступінь](binary_pow). Значить обидві цих функції ми можемо обчислювати за час $O(\log m)$.

Сам алгоритм в першо] фазі містить обчислення функції $f_1(p)$ для кожного можливого значення $p$ і дальнейшую сортування значень, що дає нам асимптотику:

$$
O\left( \left\lceil \frac{m}{n} \right\rceil \left( \log m + \log \left\lceil \frac{m}{n} \right\rceil \right) \right) = O\left( \left\lceil \frac{m}{n} \right\rceil \log m \right).
$$

У другий фазі алгоритму відбувається обчислення функції $f_2(q)$ для кожного можливого значення $q$ і бінарний пошук по масиву значень $f_1$, що дає нам асимптотику:

$$
O\left( n \left( \log m + \log \left\lceil \frac{m}{n} \right\rceil \right) \right) = O\left( n \log m \right).
$$

Тепер, коли ми сложим ці дві асимптотики, у нас вийде $\log m$, умноженный на суму $n$ і $m/n$, і практично очевидно, що мінімум досягається, коли $n \approx m/n$, тобто для оптимальної роботи алгоритму константу $n$ випливає вибирати так:

$$
n \approx \sqrt{m}.
$$

Значить асимптотика алгоритму приймає вид:

$$
O\left( \sqrt{m} ~ \log m \right).
$$

Зауваження. Ми могли б обміняти ролями $f_1$ і $f_2$ (тобто на першо] фазі обчислювати значення функції $f_2$, а а другий - $f_1$), однак легко зрозуміти, що результат від цього не зміниться, і асимптотику цим ми ніяк не улучшим.

## Реалізація

### Найпростіша реалізація

Функція $\rm powmod$ виконує бінарне піднесення числа $a$ в ступінь $b$ за модулем $m$, див. [Бинарное піднесення в ступінь](binary_pow).

Функція $\rm solve$ виробляє власне розв'язок задачі. Ця функція повертає відповідь (число в проміжку $[0;m)$), точніше кажучи, один з відповідей. Функція вернёт $-1$, якщо розв'язку не існує.

<!--- TODO: specify code snippet id -->
``` cpp
int powmod (int a, int b, int m) {
    int res = 1;
    while (b > 0)
        if (b & 1) {
            res = (res * a) % m;
            --b;
        }
        else {
            a = (a * a) % m;
            b >>= 1;
        }
    return res % m;
}

int solve (int a, int b, int m) {
    int n = (int) sqrt (m + .0) + 1;
    map<int,int> vals;
    for (int i=n; i>=1; --i)
        vals[ powmod (a, i * n, m) ] = i;
    for (int i=0; i<=n; ++i) {
        int cur = (powmod (a, i, m) * b) % m;
        if (vals.count(cur)) {
            int ans = vals[cur] * n - i;
            if (ans < m)
                return ans;
        }
    }
    return -1;
}
```

Тут ми для зручності при реалізації першо] фази алгоритму скористалися структурою данних "map" (красно-чёрным деревом), яка для кожного значення функції $f_1(i)$ зберігає аргумент $i$, при якому це значення досягалося. При цим якщо одне і то ж значення досягалося декілька раз, записується найменший з всіх аргументів. Це сделано для того, аби згодом, на другий фазі алгоритму, знайшовся відповідь в проміжку $[0;m)$.

Враховуючи, що аргумент функції $f_1()$ на першо] фазі у нас перебирался від одиниці і до $n$, а аргумент функції $f_2()$ на другий фазі перебирається від нуля до $n$, то в підсумку ми покрываем усе множину можливих відповідей, т.до. відрізок $[0; n^2]$ містить в собі промежуток $[0;m)$. При цим негативним відповідь вийти не міг, а відповіді, великі або рівні $m$ ми можемо игнорировать - усе рівне повинні перебувати відповідні їм відповіді з промежутка $[0;m)$.

Цю функцію можна змінити на той випадок, якщо потрібно знаходити **всі розв'язку** задачі дискретного логарифма. Для цього треба замінити "map" на яку-або іншу структуру данних, позволяющую зберігати для одного аргументу зразу декілька значень (наприклад, "multimap"), і відповідним чином змінити код другий фази.

### Покращена реалізація

При **оптимізації по швидкості** можна вступити наступним чином.

По-перше, зразу бросается в глаза ненужность бінарного піднесення в ступінь на другий фазі алгоритму. Замість цього можна просто завести змінну і домножувати її кожний раз на $a$.

По-друге, таким ж чином можна позбутися від бінарного піднесення в ступінь і на першо] фазі: насправді, достатньо один раз порахувати величину $a^n$, і потім просто домножувати на її.

Таким чином, логарифм в асимптотиці як і раніше залишиться, але це буде тільки логарифм, связанный зі структурою данних $map<>$ (тобто, в термінах алгоритму, з сортуванням і бінарним пошуком значень) - тобто це буде логарифм від $\sqrt{m}$, що на практиці дає заметное прискорення.

<!--- TODO: specify code snippet id -->
``` cpp
int solve (int a, int b, int m) {
    int n = (int) sqrt (m + .0) + 1;

    int an = 1;
    for (int i=0; i<n; ++i)
        an = (an * a) % m;

    map<int,int> vals;
    for (int i=1, cur=an; i<=n; ++i) {
        if (!vals.count(cur))
            vals[cur] = i;
        cur = (cur * an) % m;
    }

    for (int i=0, cur=b; i<=n; ++i) {
        if (vals.count(cur)) {
            int ans = vals[cur] * n - i;
            if (ans < m)
                return ans;
        }
        cur = (cur * a) % m;
    }
    return -1;
}
```

Нарешті, якщо модуль $m$ достатньо малий, то можна і зовсім позбутися від логарифма в асимптотиці - просто заведя замість $map<>$ звичайний масив.

Також можна вспомнить про хеш-таблиці: в середньому вони працюють також за $O(1)$, що в цілому дає асимптотику $O(\sqrt{m})$.
