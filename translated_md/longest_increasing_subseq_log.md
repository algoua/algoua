# Знаходження найдовшої зростаючої підпослідовності

**Умова задачі** випливає. Дан масив з $n$ чисел: $a[0 \ldots n-1]$. Потрібно знайти в цій послідовності строго зростаючу підпослідовність найбільшою довжини.

**Формально** це виглядає наступним чином: потрібно знайти таку послідовність індексів $i_1 \ldots i_k$, що:

$$
i_1 < i_2 < \ldots < i_k,
$$

$$
a[i_1] < a[i_2] < \ldots < a[i_k].
$$

В даній статті розглядаються різні алгоритми розв'язку даній задачі, а також деякі задачі, які можна звести до даній задачі.

## Розв'язок за $O(n^2)$: метод динамічного програмування

Динамічне програмування - це вельми загальна методика, позволяющая розв'язувати огромный клас задач. Тут ми розглянемо цю методику применительно до нашій конкретної задачі.

Навчимося спочатку шукати **довжину** найдовшої зростаючої підпослідовності, а восстановлением самою підпослідовності займёмся трохи пізніше.

### Динамічне програмування для пошуку довжини відповіді

Для цього давайте навчимося вважати масив $d[0 \ldots n-1]$, де $d[i]$ - це довжина найдовшої зростаючої підпослідовності, оканчивающейся саме в елементі з индексом $i$. Масив цей (він і є - сама динаміка) будемо вважати поступово: спочатку $d[0]$, потім $d[1]$ і т.д. В наприкінці, коли цей масив буде подсчитан нами, відповідь на задачу буде рівний максимуму в масиві $d[]$.

Отже, нехай поточний індекс - $i$, тобто ми хочемо порахувати значення $d[i]$, а всі попередні значення $d[0] 
\ldots d[i-1]$ вже підраховані. Значить зауважимо, що у нас є два варіанти:

* або $d[i] = 1$, тобто шукана підпослідовність складається тільки з числа $a[i]$.

* або $d[i] > 1$. Значить перед числом $a[i]$ в шуканої підпослідовності варто якесь інше число. Давайте переберемо це число: це можливо бути будь-який елемент $a[j]$ $(j = 0 \ldots i-1)$, але такий, що $a[j] < a[i]$. Нехай ми розглядаємо якийсь поточний індекс $j$. Оскільки динаміка $d[j]$ для нього вже подсчитана, виходить, що це число $a[j]$ разом з числом $a[i]$ дає відповідь $d[j] + 1$. Таким чином, $d[i]$ можна вважати по такий формулою:

$$
d[i] = \max_{j=0 \ldots i-1, \atop a[j] < a[i]} ( d[j] + 1 ).
$$

Об'єднуючи ці два варіанти в один, отримуємо окончательный алгоритм для обчислення $d[i]$:

$$
d[i] = \max \Big( 1, \max_{j=0 \ldots i-1, \atop a[j] < a[i]} ( d[j] + 1 ) \Big).
$$

Цей алгоритм - і є сама динаміка.

### Реалізація

Наведемо реалізацію описаного вище алгоритму, яка знаходить і виводить довжину найдовшої зростаючої підпослідовності:

<!--- TODO: specify code snippet id -->
``` cpp
int d[MAXN]; // константа MAXN рівна найбільшому можливого значенням n

for (int i=0; i<n; ++i) {
    d[i] = 1;
    for (int j=0; j<i; ++j)
        if (a[j] < a[i])
            d[i] = max (d[i], 1 + d[j]);
}

int ans = d[0];
for (int i=0; i<n; ++i)
    ans = max (ans, d[i]);
cout << ans << endl;
```

### Відновлення відповіді

Поки Що ми лише навчилися шукати довжину відповіді, але саму найдовшу підпослідовність ми вивести не можемо, т.до. не зберігаємо ніякий додаткової інформації про тому, де достигаются максимуми.

Щоб суметь відновити відповідь, крім динаміки $d[0 \ldots n-1]$ треба також зберігати допоміжний масив $p[0 \ldots n-1]$ - то, в якому місці достигся максимум для кожного значення $d[i]$. Іншими словами, індекс $p[i]$ буде позначати той самий індекс $j$, при якому вийшло найбільше значення $d[i]$. (Цей масив $p[]$ в динамическом программировании часто називають "масивом предків").

Значить, аби вивести відповідь, треба просто йти від елементу з максимальним значенням $d[i]$ по його предкам до тих пір, поки ми не виведемо всю підпослідовність, тобто поки не дійдемо до елементу зі значенням $d = 1$.

### Реалізація відновлення відповіді

Отже, у нас зміниться і код самою динаміки, і добавится код, производящий висновок найдовшої підпослідовності (виводяться індекси елементів підпослідовності, в 0-індексації).

Для зручності ми спершу положили індекси $p[i] = -1$: для елементів, у яких динаміка вийшла рівній одиниці, це значення предка так і залишиться мінус единицей, що трохи-чуть зручніше при відновленні відповіді.

<!--- TODO: specify code snippet id -->
``` cpp
int d[MAXN], p[MAXN]; // константа MAXN рівна найбільшому можливого значенням n

for (int i=0; i<n; ++i) {
    d[i] = 1;
    p[i] = -1;
    for (int j=0; j<i; ++j)
        if (a[j] < a[i])
            if (1 + d[j] > d[i]) {
                d[i] = 1 + d[j];
                p[i] = j;
            }
}

int ans = d[0],  pos = 0;
for (int i=0; i<n; ++i)
    if (d[i] > ans) {
        ans = d[i];
        pos = i;
    }
cout << ans << endl;

vector<int> path;
while (pos != -1) {
    path.push_back (pos);
    pos = p[pos];
}
reverse (path.begin(), path.end());
for (int i=0; i<(int)path.size(); ++i)
    cout << path[i] << ' ';
```

### Альтернативный спосіб відновлення відповіді

Втім, як майже завжди в випадку динамічного програмування, для відновлення відповіді можна не зберігати додатковий масив предків $p[]$, а просто заново перераховуючи поточний елемент динаміки і ища, на якому ж индексе був досягнутий максимум.

Цей спосіб при реалізації призводить до трохи більш длинному коду, однак натомість отримуємо экономию пам'яті і абсолютное збіг логики програми в процесі підрахунку динаміки і в процесі відновлення.

## Розв'язок за $O(n \log n)$: динамическое програмування з двоичным пошуком

Щоб получити більш швидке розв'язок задачі, побудуємо іншої різновид динамічного програмування за $O(n^2)$, а потім поймём, як можна цей різновид прискорити до $O(n \log n)$.

**Динаміка** тепер буде такий: нехай $d[i]$ $(i = 0 \ldots n)$ - це число, на яке закінчується зростаюча підпослідовність довжини $i$ (а якщо таких чисел декілька - то найменше з них).

Cпершу ми вважаємо $d[0] = -\infty$, а всі інші елементи $d[i] = \infty$.

Вважати цю динаміку ми будемо поступово, обработав число $a[0]$, потім $a[1]$, і т.д.

Наведемо реалізацію цій динаміки за $O(n^2)$:

<!--- TODO: specify code snippet id -->
``` cpp
int d[MAXN];
d[0] = -INF;
for (int i=1; i<=n; ++i)
    d[i] = INF;

for (int i=0; i<n; i++)
    for (int j=1; j<=n; j++)
        if (d[j-1] < a[i] && a[i] < d[j])
            d[j] = a[i];
```

Зауважимо тепер, що у цій динаміки є одне **дуже важное властивість**: $d[i-1] \le d[i]$ для всіх $i = 1 \ldots n$. Другое властивість - що кожний елемент $a[i]$ обновляет максимум одну осередок $d[j]$.

Таким чином, це означає, що обробляти чергове $a[i]$ ми можемо за $O(\log n)$, зробивши двійковий пошук по масиву $d[]$. Насправді, ми просто шукаємо в масиві $d[]$ перший число, яке строго більше $a[i]$, і намагаємося провести оновлення цього елементу аналогічно наведеної вище реалізації.

### Реалізація за $O(n \log n)$

Скориставшись стандартним в мові C++ алгоритмом двійкового пошуку $upper\_bound$ (який повертає позицію першого елементу, строго більшого даного), отримуємо таку просту реалізацію:

<!--- TODO: specify code snippet id -->
``` cpp
int d[MAXN];
d[0] = -INF;
for (int i=1; i<=n; ++i)
    d[i] = INF;

for (int i=0; i<n; i++) {
    int j = int (upper_bound (d.begin(), d.end(), a[i]) - d.begin());
    if (d[j-1] < a[i] && a[i] < d[j])
        d[j] = a[i];
}
```

### Відновлення відповіді

За такий динаміці теж можна відновити відповідь, для чого знову ж крім динаміки $d[i]$ також треба зберігати масив "предків" $p[i]$ - то, на елементі з яким индексом закінчується оптимальна підпослідовність довжини $i$. Крім того, для кожного елементу масиву $a[i]$ треба буде зберігати його "предка" - тобто індекс того елементу, який повинен стояти перед $a[i]$ в оптимальної підпослідовності.

Поддерживая ці два масиву по ходу обчислення динаміки, в наприкінці буде неважко відновити шукану підпослідовність.

(Цікаво відзначити, що применительно до даній динаміці відповідь можна відновлювати тільки так, через масиви предків - а без них відновити відповідь після обчислення динаміки буде неможливо. Це один з редких випадків, коли до динаміці не застосовується альтернативний спосіб відновлення - без масивів предків).

## Розв'язок за $O(n \log n)$: структури данних

Якщо наведений вище спосіб за $O(n \log n)$ вельми красив, однак не зовсім тривиален идейно, то є і іншої шлях: скористатися однієї з відомих простих структур данних.

Насправді, давайте повернемося до самою першо] динаміці, де станом являлась просто поточна позиція. Текущее значення динаміки $d[i]$ обчислюється як максимум значень $d[i]$ серед всіх таких елементів $j$, що $a[j] < a[i]$.

Отже, якщо ми через $t[]$ позначимо такий **масив**, в який будемо записувати значення динаміки від чисел:

$$
t[a[i]] = d[i],
$$

то виходить, що усе, що нам треба вміти - це шукати **максимум на префиксе** масиву $t$: $t[0 \ldots a[i]-1]$.

Задача пошуку максимуму на префиксах масиву (з урахуванням того, що масив можливо змінюватися) вирішується многими стандартными структурами данних, наприклад, [деревом відрізків](segment_tree) або [деревом Фенвіка](fenwick_tree).

Скориставшись будь-який такий структурою данних, ми отримаємо розв'язок за $O(n \log n)$.

У цього способу розв'язку є явные **недостатки**: по довжині і складності реалізації цей шлях буде в будь-якому випадку гірше, ніж описана вище динаміка за $O(n \log n)$. Крім того, якщо вхідні числа $a[i]$ можуть бути достатньо великими, то швидше всього їх доведеться стискати (тобто перенумеровывать від $0$ до $n-1$) - без цього багато стандартні структури данних працювати не смогут з-за высокого споживання пам'яті.

З іншої сторони, у даного шляхи є і **преимущества**. По-перше, при такому способе розв'язку не доведеться задумываться про хитрой динаміці. По-друге, цей спосіб дозваляє розв'язувати деякі обобщения нашій задачі (про них див. нижче).

## Смежные задачі

Наведемо тут декілька задач, тесно пов'язаних з завданням пошуку найдовшої зростаючої підпослідовності.

### Наидлиннейшая неубывающая підпослідовність

Фактично, це та ж сама задача, тільки тепер в шуканої підпослідовності допускаються однакові числа (тобто ми повинні знайти нестрого зростаючу підпослідовність).

Розв'язок цій задачі по суті нічим не відрізняється від нашій вихідної задачі, просто при сравнениях изменятся знаки нерівностей, а також треба буде трохи змінити двійковий пошук.

### Кількість наидлиннейших зростаючих підпослідовностей

Для розв'язку цій задачі можна використовувати саму першу динаміку за $O(n^2)$ або підхід з допомогою структур данних для розв'язку за $O(n \log n)$. І в тому, і в тому випадку всі зміни заключаются тільки в тому, що крім значення динаміки $d[i]$ треба також зберігати, сколькими способами це значення могло бути отримано.

За всій видимості, спосіб розв'язку через динаміку за $O(n \log n)$ до даній задачі застосувати неможливо.

### Наименьшее число незростаюча підпослідовностей, покривають дану послідовність

**Умова** таке. Дан масив з $n$ чисел $a[0 \ldots n-1]$. Потрібно раскрасить його числа в найменше число квітів так, аби по кожному цвету получалась б невозрастающая підпослідовність.

**Розв'язок**. Стверджується, що мінімальне кількість необхідних квітів рівне довжині найдовшої зростаючої підпослідовності.

**Доведення**. Фактично, нам треба довести **двойственность** цій задачі і задачі пошуку найдовшої зростаючої підпослідовності.

Позначимо через $x$ довжину найдовшої зростаючої підпослідовності, а через $y$ - шукане найменше число незростаюча підпослідовностей. Нам треба довести, що $x=y$.

З однієї сторони, зрозуміло, чому не можливо бути $y<x$: адже якщо у нас є $x$ строго зростаючих елементів, то ніякі два з них не могли потрапити в одну невозрастающую підпослідовність, а, значить, $y \ge x$.

Покажемо тепер, що, навпаки, $y$ не можливо бути $> x$. Доведемо це від противного: припустимо, що $y > x$. Значить розглянемо будь-який оптимальний набір з $y$ незростаюча підпослідовностей. Перетворимо цей набір таким чином: поки є дві таких підпослідовності, що перша починається раніше другий, але при цим перша починається з числа, більше або рівного ніж початок другий - отцепим це стартовое число від першо] підпослідовності і прицепим в початок другий. Таким чином, через якесь кінцеве число кроків у нас залишиться $y$ підпослідовностей, причому їх стартові числа будуть образовывать зростаючу підпослідовність довжини $y$. Але $y > x$, тобто ми прийшли до протиріччя (адже не можливо бути зростаючих підпослідовностей длиннее $x$).

Таким чином, насправді, $y = x$, що і потрібно довести.

**Відновлення відповіді**. Стверджується, що саме шукане розбиття на підпослідовності можна шукати жадібно, тобто идя ліворуч направо і относя поточний число в ту підпослідовність, яка зараз закінчується на мінімальне число, більше або рівне поточному.

## Задачі в online judges

Список задач, які можна розв'язати по даній тематике:

* [MCCME #1793 **"Наибольшая зростаюча підпослідовність за O(n*log(n))"** [складність: низька]](http://informatics.mccme.ru/moodle/mod/statements/view3.php?chapterid=1793)

* [TopCoder SRM 278 **"500 IntegerSequence"** [складність: низька]](http://community.topcoder.com/stat?c=problem_statement&pm=5922&rd=8075)

* [TopCoder SRM 233 **"DIV2 1000 AutoMarket"** [складність: низька]](http://community.topcoder.com/stat?c=problem_statement&pm=3937&rd=6532)

* [Всеукраинская олимпиада школьников по информатике - задача F **"Турист"** [складність: середня]](http://codeforces.ru/contest/76/problem/F)

* [Codeforces Beta Round #10 - задача D **"НОВП"** [складність: середня]](http://codeforces.ru/problemset/problem/10/D)

* [ACM.TJU.EDU.CN 2707 **"Greatest Common Increasing Subsequence"** [складність: середня]](http://acm.tju.edu.cn/toj/showp2707.html)

* [SPOJ #57 **"SUPPER. Supernumbers in a permutation"** [складність: середня]](http://www.spoj.pl/problems/SUPPER/)

* [TopCoder Open 2004 - Round 4 - **"1000. BridgeArrangement"** [складність: висока]](http://community.topcoder.com/stat?c=problem_statement&pm=2967&rd=5881)
