# Знаходження найкоротших шляхів від заданої вершини до всіх інших вершин алгоритмом Дейкстри для розріджених графів

Постановку задачі, алгоритм і його доведення див. в [статті про загалом алгоритмі Дейкстри](dijkstra).

## Алгоритм

Нагадаємо, що складність алгоритму Дейкстри складається з двох основних операцій: час знаходження вершини з найменшою величиною відстані $d[v]$, і час совершения релаксації, тобто час зміни величини $d[to]$.

При найпростішої реалізації ці операції потребуют відповідно $O(n)$ і $O(1)$ часу. Враховуючи, що перша операція всього виконується $O(n)$ раз, а друга - $O(m)$, отримуємо асимптотику найпростішої реалізації алгоритму Дейкстри: $O(n^2+m)$.

Зрозуміло, що ця асимптотика є оптимальної для щільних графів, тобто коли $m \approx n^2$. Чем більш разрежен граф (тобто ніж менше $m$ по порівняно з максимальним кількість ребер $n^2$), тим менш оптимальної стає ця оцінка, і по вине першого доданка. Таким чином, треба улучшать час виконання операцій першого типу, не сильно ухудшая при цим час виконання операцій іншого типу.

Для цього треба використовувати різні допоміжні структури данних. Найбільш привлекательными є **Фібоначчових купи**, які дозволяють виробляти операцію першого увазі за $O(\log n)$, а іншого - за $O(1)$. Тому при використанні Фибоначчиевых куп час роботи алгоритму Дейкстри складе $O(n \log n + m)$, що є практично теоретическим мінімумом для алгоритму пошуку найкоротшого шляхи. До Речі кажучи, ця оцінка є оптимальної для алгоритмів, основанных на алгоритмі Дейкстри, тобто Фібоначчових купи є оптимальными з цій точки зору (це твердження про оптимальності насправді основано на невозможности існування такий "идеальной" структури данних - якщо б вона существовала, то можна було б виконувати сортування за лінійне час, що, як відомо, в загалом випадку неможливо; втім, цікаво, що існує алгоритм Торупа (Thorup), який шукає найкоротший шлях з оптимальної, лінійної, асимптотикою, але заснований він на зовсім іншої ідеї, ніж алгоритм Дейкстри, тому ніякого противоречия тут ні). Однак, Фібоначчових купи досить складні в реалізації (і, треба відзначити, мають немалую константу, приховану в асимптотиці).

В якості компромисса можна використовувати структури данних, дозволяють виконувати **обидва типу операцій** (фактично, це витяг мінімуму і оновлення елементу) за $O(\log n)$. Значить час роботи алгоритму Дейкстри складе:

$$
O(n \log n + m \log n) = O (m \log n)
$$

В якості такий структури данних программистам на C++ зручно взяти стандартний контейнер $\rm set$ або $\rm priority\_queue$. Перший заснований на красно-чёрном дереві, другий - на бінарної купі. Тому $\rm priority\_queue$ має меншу константу, приховану в асимпотике, однак у нього є і недолік: він не підтримує операцію видалення елементу, з-за чого доводиться робити "обходной манёвр", який фактично призводить до замене в асимптотиці $\log n$ на $\log m$ (з точки зору асимптотики це насправді нічого не змінює, але приховану константу збільшує).

## Реалізація

### set

Почнемо з контейнера $\rm set$. Оскільки в контейнере нам треба зберігати вершини, упорядоченные по їх величинам $d[]$, то зручно в контейнер поміщати пари: перший елемент пари - відстань, а другий - номер вершини. В результаті в $\rm set$ будуть зберігатися пари, автоматично упорядоченные по расстояниям, що нам і потрібно.

<!--- TODO: specify code snippet id -->
``` cpp
const int INF = 1000000000;

int main() {
    int n;
    ... читання n ...
    vector < vector < pair<int,int> > > g (n);
    ... читання графа ...
    int s = ...; // стартова вершина

    vector<int> d (n, INF),  p (n);
    d[s] = 0;
    set < pair<int,int> > q;
    q.insert (make_pair (d[s], s));
    while (!q.empty()) {
        int v = q.begin()->second;
        q.erase (q.begin());

        for (size_t j=0; j<g[v].size(); ++j) {
            int to = g[v][j].first,
                len = g[v][j].second;
            if (d[v] + len < d[to]) {
                q.erase (make_pair (d[to], to));
                d[to] = d[v] + len;
                p[to] = v;
                q.insert (make_pair (d[to], to));
            }
        }
    }
}
```

В відміну від звичайного алгоритму Дейкстри, стає непотрібним масив $u[]$. Його роль, як і функцію знаходження вершини з найменшим відстанню, виконує $\rm set$. Cпершу в нього поміщаємо стартову вершину $s$ з її відстанню. Основной цикл алгоритму виконується, поки в черги є хоть одна вершина. З черги извлекается вершина з найменшим відстанню, і потім з її виконуються релаксації. Перед виконанням кожної успешной релаксації ми спочатку видаляємо з $\rm set$ старую пару, а потім, після виконання релаксації, додаємо назад нову пару (з новим відстанню $d[to]$).

### priority_queue

Принципиально тут відмінностей від $\rm set$ ні, за винятком того моменту, що видаляти з $\rm priority\_queue$ довільні елементи неможливо (хоча теоретично купи поддерживают таку операцію, в стандартної библиотеке вона не реализована). Тому доводиться здійснювати "обходной манёвр": при релаксації просто не будемо видаляти старі пари з черги. В результаті в черги можуть перебувати одночасно декілька пар для однієї і тією ж вершини (але з різними расстояниями). Среди цих пар нас цікавить тільки одна, для якій елемент $\rm first$ рівний $d[v]$, а всі інші є фиктивными. Тому треба зробити небольшую модифікацію: в початку кожної ітерації, коли ми извлекаем з черги чергову пару, будемо перевіряти, фиктивная вона або ні (для цього достатньо порівняти $\rm first$ і $d[v]$). Слід відзначити, що це важная модифікація: якщо не зробити її, то це приведе до значительному ухудшению асимптотики (до $O(nm)$).

Ще потрібно пам'ятати про тому, що $\rm priority\_queue$ упорядочивает елементи по зменшенням, а не по возрастанию, як зазвичай. Простіше всього преодолеть цю особливість не указанием свого оператора порівняння, а просто поміщаючи в якості елементів $\rm first$ відстані зі знаком мінус. В результаті в корені купи будуть оказываться елементи з найменшим відстанню, що нам і потрібно.

<!--- TODO: specify code snippet id -->
``` cpp
const int INF = 1000000000;

int main() {
    int n;
    ... читання n ...
    vector < vector < pair<int,int> > > g (n);
    ... читання графа ...
    int s = ...; // стартова вершина

    vector<int> d (n, INF),  p (n);
    d[s] = 0;
    priority_queue < pair<int,int> > q;
    q.push (make_pair (0, s));
    while (!q.empty()) {
        int v = q.top().second,  cur_d = -q.top().first;
        q.pop();
        if (cur_d > d[v])  continue;

        for (size_t j=0; j<g[v].size(); ++j) {
            int to = g[v][j].first,
                len = g[v][j].second;
            if (d[v] + len < d[to]) {
                d[to] = d[v] + len;
                p[to] = v;
                q.push (make_pair (-d[to], to));
            }
        }
    }
}
```

Як правило, на практиці версія з $\rm priority\_queue$ виявляється декілька швидше версії з $\rm set$.

### Избавление від pair

Можна ще трохи покращити продуктивність, якщо в контейнерах усе ж зберігати не пари, а тільки номера вершин. При цим, зрозуміло, треба перегрузить оператор порівняння для вершин: порівнювати дві вершини треба по расстояниям до них $d[]$.

Оскільки в результаті релаксації величина відстані до якийсь вершини змінюється, то треба розуміти, що "сама по собі" структура данних не перестроится. Тому, хоча можливо здатися, що видаляти/додавати елементи в контейнер в процесі релаксації не треба, це приведе до разрушению структури данних. За-прежнему перед релаксацией треба вилучити з структури данних вершину $\rm to$, а після релаксації вставити її назад - тоді ніякі співвідношення між елементами структури данних не порушаться.

А оскільки видаляти елементи можна з $\rm set$, але не можна з $\rm priority\_queue$, то виходить, що цей прийом застосуємо тільки до $\rm set$. На практиці він помітно збільшує продуктивність, особливо коли для зберігання відстаней використовуються великі типи данних (як $\rm long\ long$ або $\rm double$).
