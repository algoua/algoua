# Обратный елемент в кольце за модулем

## Визначення

Нехай завдань деякий натуральный модуль $m$, і розглянемо кольцо, образуемое цим модулем (тобто що складається з чисел від $0$ до $m-1$). Значить для деяких елементів цього кольца можна знайти **зворотний елемент**.

Обратным до числу $a$ за модулем $m$ називається таке число $b$, що:

$$
a \cdot b \equiv 1 \pmod m,
$$

і його нерідко позначають через $a^{-1}$.

Зрозуміло, що для нуля зворотнього елементу не існує ніколи; для інших ж елементів зворотний можливо як існувати, так і ні. Стверджується, що зворотний існує тільки для тих елементів $a$, які **взаємно прості** з модулем $m$.

Розглянемо нижче два способу знаходження зворотнього елементу, працюючих при умови, що він існує.

В завершення, розглянемо алгоритм, який дозваляє знайти зворотні до всіх числах по деякого модулю за лінійне час.

## Знаходження з допомогою Расширенного алгоритму Евкліда

Розглянемо допоміжне рівняння (щодо неизвестных $x$ і $y$):

$$
a \cdot x + m \cdot y = 1.
$$

Це [лінійне диофантово рівняння іншого порядку](diofant_2_equation). Як показано в відповідної статті, з умови ${\rm gcd}(a,m)=1$ випливає, що це рівняння має розв'язок, яке можна знайти з допомогою [Расширенного алгоритму Евкліда](extended_euclid_algorithm) (звідси ж, до речі кажучи, випливає, що коли ${\rm gcd}(a,m) \ne 1$, розв'язку, а тому і зворотнього елементу, не існує).

З іншої сторони, якщо ми візьмемо від обох частин рівняння залишок за модулем $m$, то отримаємо:

$$
a \cdot x = 1 \pmod m.
$$

Таким чином, знайдене $x$ і буде бути зворотним до $a$.

Реалізація (з урахуванням того, що знайдене $x$ треба взяти за модулем $m$, і $x$ могло бути негативним):

<!--- TODO: specify code snippet id -->
``` cpp
int x, y;
int g = gcdex(a, m, x, y);
if (g != 1)
    cout << "no solution";
else {
    x = (x % m + m) % m;
    cout << x;
}
```

Асимптотика цього розв'язку виходить $O(\log m)$.

## Знаходження з допомогою Бинарного піднесення в ступінь

Скористаємося теоремою Ейлера:

$$
a ^ {\phi(m)} \equiv 1 \pmod m,
$$

яка вірна як раз для випадку взаємно простих $a$ і $m$.

До Речі кажучи, в випадку простого модуля $m$ ми отримуємо ще більш просте твердження - малу теорему Ферма:

$$
a^{m-1} \equiv 1 \pmod m.
$$

Умножим обидві частини кожного з рівнянь на $a^{-1}$, отримаємо:

* для будь-якого модуля $m$:

$$
a^{\phi(m)-1} \equiv a^{-1} \pmod m,
$$

* для простого модуля $m$:

$$
a^{m-2} \equiv a^{-1} \pmod m.
$$

Таким чином, ми отримали формули для безпосереднього обчислення зворотнього. Для практичного застосування зазвичай використовують ефективний [алгоритм бінарного піднесення в ступінь](binary_pow), який в нашому випадку дозволить провести піднесення в ступінь за $O(\log m)$.

Цей метод представляється декілька простіше описаного в попередньому пункті, однак він вимагає знання значення функції Ейлера, що фактично вимагає факторизації модуля $m$, що іноді можливо виявитися вельми складної завданням.

Якщо ж факторизація числа відома, то тоді і цей метод також працює за асимптотику $O(\log m)$.

## Знаходження всіх простих по заданому модулю за лінійне час

Нехай дано простий модуль $m$. Потрібно для кожного числа в відрізку $[1; m-1]$ знайти зворотнє до нього.

Применяя описані вище алгоритми, ми отримаємо лише розв'язку з асимптотикою $O(m \log m)$. Тут ж ми наведемо просте розв'язок з асимптотикою $O(m)$.

**Розв'язок** це виглядає наступним чином. Позначимо через $r[i]$ шукане зворотнє до числу $i$ за модулем $m$. Значить для $i > 1$ вірно тотожність:

$$
r[i] = - \left\lfloor \frac{m}{i} \right\rfloor \cdot r[m {\rm~mod~} i]. \pmod m
$$

**Реалізація** цього дивовижно лаконичного розв'язку:

<!--- TODO: specify code snippet id -->
``` cpp
r[1] = 1;
for (int i = 2; i < m; ++i)
    r[i] = (m - (m / i) * r[m % i] % m) % m;
```

**Доведення** цього розв'язку представляє з собі ланцюжок простих перетворень:

Распишем значення $m {\rm~mod~} i$:

$$
m {\rm~mod~} i = m - \left\lfloor \frac{m}{i} \right\rfloor \cdot i,
$$

звідки, беручи обидві частини за модулем $m$, отримуємо:

$$
m {\rm~mod~} i = - \left\lfloor \frac{m}{i} \right\rfloor \cdot i. \pmod m
$$

Умножая обидві частини на зворотнє до $i$ і зворотнє до $(m {\rm~mod~} i)$, отримуємо шукану формулу:

$$
r[i] = - \left\lfloor \frac{m}{i} \right\rfloor \cdot r[m {\rm~mod~} i], \pmod m
$$

що і потрібно довести.
