# Алгоритм Ахо-Корасік

Нехай дано набір стрічок в алфавите розміру $k$ сумарної довжини $m$. Алгоритм Ахо-Корасік будує для цього набору стрічок структуру данних "префіксне дерево", а потім по цьому бору будує автомат, усе за $O(m)$ часу і $O(m k)$ пам'яті. Полученный автомат вже можливо використовуватися в різних завданнях, простейшая з яких - це знаходження всіх входжень кожної стрічки з даного набору в деякий текст за лінійне час.

Даний алгоритм був запропонований канадским вченим Альфредом Ахо (Alfred Vaino Aho) і вченим Маргарет Корасик (Margaret John Corasick) в 1975 р.

## Бор. Побудова префіксного дерева

Формально, **префіксне дерево** - це дерево з коренем в деякої вершині $\rm Root$, причому кожне ребро дерево подписано деякої буквой. Якщо ми розглянемо список ребер, виходять з даній вершини (крім ребра, провідного в предка), то всі ребра повинні мати різні мітки.

Розглянемо в борі будь-який шлях з кореня; випишемо поспіль мітки ребер цього шляхи. В результаті ми отримаємо деяку стрічку, яка відповідає цьому шляхи. Якщо ж ми розглянемо будь-яку вершину префіксного дерева, то їй поставимо в відповідність стрічку, відповідну шляхи з кореня до цій вершини.

Кожна вершина префіксного дерева також має прапор $\rm leaf$, який рівний $\rm true$, якщо в цій вершині закінчується яка-або стрічка з даного набору.

Відповідно, **побудувати префіксне дерево** по даному набору стрічок - значить побудувати такий префіксне дерево, що кожної $\rm leaf$-вершині буде відповідати яка-або стрічка з набору, і, навпаки, кожної стрічки з набору буде відповідати якась $\rm leaf$-вершина.

Опишемо тепер, **як побудувати префіксне дерево** по заданому набору стрічок за лінійне час щодо їх сумарної довжини.

Введемо структуру, відповідну вершин префіксного дерева:

<!--- TODO: specify code snippet id -->
``` cpp
struct vertex {
    int next[K];
    bool leaf;
};

vertex t[NMAX+1];
int sz;
```

тобто. ми будемо зберігати префіксне дерево в вигляді масиву $t$ (кількість елементів в масиві - це sz) структур $\rm vertex$. Структура $\rm vertex$ містить прапор $\rm leaf$, і ребра в вигляді масиву $\rm next[]$, де $\rm next[i]$ - вказівник на вершину, в яку веде ребро по символу $i$, або $-1$, якщо такого ребра ні.

На Початку префіксне дерево складається тільки з однієї вершини - кореня (договоримся, що корінь завжди має в масиві $t$ індекс $0$). Тому **инициализация** префіксного дерева така:

<!--- TODO: specify code snippet id -->
``` cpp
memset (t[0].next, 255, sizeof t[0].next);
sz = 1;
```

Тепер реалізуємо функцію, яка буде **додавати в префіксне дерево** задану стрічку $s$. Реалізація вкрай проста: ми встаём в корінь префіксного дерева, дивимося, є або з кореня перехід по букві $s[0]$: якщо перехід є, то просто переходимо по нього в іншу вершину, інакше створюємо нову вершину і додаємо перехід в цю вершину по букві $s[0]$. Потім ми, стоя в якийсь вершині, повторюємо процес для букви $s[1]$, і т.д. Після закінчення процесу помічаємо останню посещённую вершину флагом $\rm leaf = true$.

<!--- TODO: specify code snippet id -->
``` cpp
void add_string (const string & s) {
    int v = 0;
    for (size_t i=0; i<s.length(); ++i) {
        char c = s[i]-'a'; // в залежності від алфавіту
        if (t[v].next[c] == -1) {
            memset (t[sz].next, 255, sizeof t[sz].next);
            t[v].next[c] = sz++;
        }
        v = t[v].next[c];
    }
    t[v].leaf = true;
}
```

Линейное час роботи, а також лінійне кількість вершин в борі очевидны. Оскільки на кожну вершину доводиться $O(k)$ пам'яті, то використання пам'яті є $O(n k)$.

Потребление пам'яті можна зменшити до лінійного ($O(n)$), але за рахунок збільшення асимптотики роботи до $O(n \log k)$. Для цього достатньо зберігати переходи $\rm next$ не масивом, а отображением $\rm map<char,int>$.

## Побудова автомата

Нехай ми побудували префіксне дерево для заданого набору стрічок. Подивимося на нього тепер трохи з іншої сторони. Якщо ми розглянемо будь-яку вершину, то стрічка, яка відповідає їй, є префіксом однієї або декількох стрічок з набору; тобто кожну вершину префіксного дерева можна розуміти як позицію в однієї або декількох рядках з набору.

Фактично, вершини префіксного дерева можна розуміти як стан **конечного детерминированного автомата**. Находясь в якому-або стані, ми під впливом якийсь вхідний букви переходимо в інше стан - тобто в іншу позицію в наборе стрічок. Наприклад, якщо в борі знаходиться тільки стрічка $"abc"$ і ми стоїмо в стані $2$ (якому відповідає стрічка $"ab"$), то під впливом букви $"c"$ ми перейдемо в стан $3$.

тобто. ми можемо розуміти ребра префіксного дерева як переходи в автоматі по відповідної букві. Однак одними тільки ребрами префіксного дерева не можна ограничиваться. Якщо ми намагаємося виконати перехід по який-або букві, а відповідного ребра в борі ні, то ми тим не менш повинні перейти в якесь стан.

Більш строго, нехай ми знаходимося в стані $p$, якому відповідає деяка стрічка $t$, і хочемо виконати перехід по символу $c$. Якщо в борі з вершини $p$ є перехід по букві $c$, то ми просто переходимо по цьому ребру і попадаем в вершину, якій відповідає стрічка $tc$. Якщо ж такого ребра ні, то ми повинні знайти стан, відповідне наидлиннейшему собственному суфіксу стрічки $t$ (наидлиннейшему з наявних в борі), і спробувати виконати перехід по букві $c$ з нього.

Наприклад, нехай префіксне дерево побудований по рядках $"ab"$ і $"bc"$, і ми під впливом стрічки $"ab"$ перейшли в деякий стан, є листком. Значить під впливом букви $"c"$ ми змушені перейти в стан, відповідне стрічки $"b"$, і тільки оттуда виконати перехід по букві $"c"$.

**Суффиксная посилання** для кожної вершини $p$ - це вершина, в якій закінчується наідліннейшій власний суфікс стрічки, відповідної вершині $p$. Єдиний особливий випадок - корінь префіксного дерева; для зручності суфіксну посилання з нього проведемо в собі ж. Тепер ми можемо переформулювати твердження по приводу переходів в автоматі так: поки з поточній вершини префіксного дерева ні переходу по відповідної букві (або поки ми не прийдемо в корінь префіксного дерева), ми повинні переходити по суфіксному посиланню.

Таким чином, ми звели задачу побудови автомата до задачі знаходження суфіксних посилань для всіх вершин префіксного дерева. Однак будувати ці суфіксние посилання ми будемо, як ні странно, навпаки, з допомогою побудованих в автоматі переходів.

Зауважимо, що якщо ми хочемо дізнатися суфіксну посилання для деякої вершини $v$, то ми можемо перейти в предка $p$ поточній вершини (нехай $c$ - літера, по якій з $p$ є перехід в $v$), потім перейти по його суфіксному посиланню, а потім з її виконати перехід в автоматі по букві $c$.

Таким чином, задача знаходження переходу звелася до задачі знаходження суфіксному посилання, а задача знаходження суфіксному посилання - до задачі знаходження суфіксному посилання і переходу, але вже для більш близких до корені вершин. Ми отримали рекурсивну залежність, але не бесконечную, і, більш того, разрешить яку можна за лінійне час.

Перейдемо тепер до **реалізації**. Зауважимо, що нам тепер знадобиться для кожної вершини зберігати її предка $\rm p$, а також символ $\rm pch$, по якому з предка є перехід в нашу вершину. Також в кожної вершині будемо зберігати $\rm int~link$ - суфіксна посилання (або $-1$, якщо вона ще не вычислена), і масив $\rm int~go[k]$ - переходи в автоматі по кожному з символів (знову ж, якщо елемент масиву рівний $-1$, то він ще не вычислен). Наведемо тепер повну реалізацію всіх необхідних функцій:

<!--- TODO: specify code snippet id -->
``` cpp
struct vertex {
    int next[K];
    bool leaf;
    int p;
    char pch;
    int link;
    int go[K];
};

vertex t[NMAX+1];
int sz;

void init() {
    t[0].p = t[0].link = -1;
    memset (t[0].next, 255, sizeof t[0].next);
    memset (t[0].go, 255, sizeof t[0].go);
    sz = 1;
}

void add_string (const string & s) {
    int v = 0;
    for (size_t i=0; i<s.length(); ++i) {
        char c = s[i]-'a';
        if (t[v].next[c] == -1) {
            memset (t[sz].next, 255, sizeof t[sz].next);
            memset (t[sz].go, 255, sizeof t[sz].go);
            t[sz].link = -1;
            t[sz].p = v;
            t[sz].pch = c;
            t[v].next[c] = sz++;
        }
        v = t[v].next[c];
    }
    t[v].leaf = true;
}

int go (int v, char c);

int get_link (int v) {
    if (t[v].link == -1)
        if (v == 0 || t[v].p == 0)
            t[v].link = 0;
        else
            t[v].link = go (get_link (t[v].p), t[v].pch);
    return t[v].link;
}

int go (int v, char c) {
    if (t[v].go[c] == -1)
        if (t[v].next[c] != -1)
            t[v].go[c] = t[v].next[c];
        else
            t[v].go[c] = v==0 ? 0 : go (get_link (v), c);
    return t[v].go[c];
}
```

Неважко зрозуміти, що, за рахунок запоминания знайдених суфіксних посилань і переходів, сумарне час знаходження всіх суфіксних посилань і переходів буде лінійним.

## Застосування

### Пошук всіх стрічок з заданого набору в тексті

Дан набір стрічок, і дано текст. Потрібно вивести всі входження всіх стрічок з набору в даний текст за час $O({\rm Len + Ans})$, де $\rm Len$ - довжина тексту, $\rm Ans$ - розмір відповіді.

Побудуємо по даному набору стрічок префіксне дерево. Будемо тепер обробляти текст по однієї букві, перемещаясь відповідним чином по дереву, фактично - по состояниям автомата. Cпершу ми знаходимося в корені дерева. Нехай ми на очередном кроці ми знаходимося в стані $v$, і чергова літера тексту $c$. Значить випливає переходити в стан ${\rm go} (v, c)$, тим самим або увеличивая на $1$ довжину поточній збігається підстрічки, або уменьшая її, проходячи по суфіксному посиланню.

Як тепер дізнатися по поточному станом $v$, є або збіг з якимись рядками з набору? По-перше, зрозуміло, що якщо ми стоїмо в поміченої вершині ($\rm leaf=true$), то є збіг з тим образцом, який в борі закінчується в вершині $v$. Однак це далеко не єдиний возможный випадок досягнення збіги: якщо ми, рухаючись по суфіксним посиланням, ми можемо досягти однієї або декількох помічених вершин, то збіг також буде, але вже для зразків, закінчуються в цих состояниях. Простий приклад такий ситуації - коли набір стрічок - це $\{ "dabce", "abc", "bc" \}$, а текст - це $"dabc"$.

Таким чином, якщо в кожної поміченої вершині зберігати номер зразка, оканчивающегося в ній (або список номерів, якщо допускаються повторювані зразки), то ми можемо для поточного стан за $O(n)$ знайти номера всіх зразків, для яких достигнуто збіг, просто пройшовши по суфіксним посиланням від поточній вершини до кореня. Однак це недостатньо эффективное розв'язок, оскільки в сумі асимптотика вийде $O(n \cdot {\rm Len})$. Однак можна замітити, що рух по суфіксним посиланням можна соптимизировать, попередньо вважаючи для кожної вершини найближчу до ній позначену вершину, достижимую по суфіксним посиланням (це називається "функцією виходу"). Цю величину можна вважати ледачою динамікою за лінійне час. Значить для поточній вершини ми зможемо за $O(1)$ знаходити наступну в суфіксном шляхи позначену вершину, тобто випливає збіг. Тим самим, на кожне збіг буде тратиться $O(1)$ дій, і в сумі вийде асимптотика $O({\rm Len + Ans})$.

В більш простому випадку, коли треба знайти не самі входження, а тільки їх кількість, можна замість функції виходу порахувати ледачою динамікою кількість помічених вершин, досяжних з поточній вершини $v$ по суфіксним посиланням. Ця величина можливо бути посчитана за $O(n)$ в сумі, і тоді для поточного стан $v$ ми зможемо за $O(1)$ знайти кількість входжень всіх зразків в текст, закінчуються в поточній позиції. Тим самим, задача знаходження суммарного кількості входжень можливо бути вирішена нами за $O({\rm Len})$.

### Знаходження лексикографічно найменшою стрічки даній довжини, не містить ні один з данних зразків

Дан набір зразків, і дана довжина $L$. Потрібно знайти стрічку довжини $L$, не що містить ні один з зразків, і з всіх таких стрічок вивести лексикографічно найменшу.

Побудуємо по даному набору стрічок префіксне дерево. Згадаймо тепер, що ті вершини, з яких по суфіксним посиланням можна досягти помічених вершин (а такі вершини можна знайти за $O(n)$, наприклад, ледачою динамікою), можна сприймати як входження який-або стрічки з набору в завдань текст. Оскільки в даній задачі нам необхідно избегать входжень, то це можна розуміти як то, що в такі вершини нам заходити не можна. З іншої сторони, у всі інші вершини ми заходити можемо. Таким чином, ми видаляємо з автомата всі "плохие" вершини, а в залишився графі автомата потрібно знайти лексикографічно найменший шлях довжини $L$. Цю задачу вже можна розв'язати за $O(L)$, наприклад, [пошуком в глибину](dfs).

### Знаходження найкоротшою стрічки, містить входження одночасно всіх зразків

Знову скористаємось тією ж ідеєю. Для кожної вершини будемо зберігати маску, позначає зразки, для яких відбулося входження в даній вершині. Значить задачу можна переформулювати так: спершу находясь в стані $(v={\rm Root},~{\rm Msk}=0)$, потрібно дійти до стан $(v,~{\rm Msk}=2^n-1)$, де $n$ - кількість зразків. Переходы з стан в стан будуть представляти собою додавання однієї букви до тексту, тобто перехід по ребру автомата в іншу вершину з відповідним зміною маски. Запустив [обхід в ширину](bfs) на такому графі, ми найдемо шлях до стан $(v,~{\rm Msk}=2^n-1)$ найменшою довжини, що нам як раз і потрібно.

### Знаходження лексикографічно найменшою стрічки довжини $L$, містить дані зразки в сумі $k$ раз

Як і в попередніх завданнях, порахуємо для кожної вершини кількість входжень, яке відповідає їй (тобто кількість помічених вершин, досяжних з її по суфіксним посиланням). Переформулюємо задачу таким чином: поточний стан визначається тройкой чисел $(v,~{\rm Len,~Cnt})$, і потрібно з стан $({\rm Root},~0,~0)$ прийти в стан $(v,~L,~k)$, де $v$ - будь-яка вершина. Переходы між станами - це просто переходи по ребрам автомата з поточній вершини. Таким чином, достатньо просто знайти [обходом в глибину](dfs) шлях між цими двома станами (якщо обхід в глибину буде переглядати букви в їх естественном порядку, то знайдений шлях автоматично буде лексикографічно найменшим).

## Задачі в online judges

Задачі, які можна розв'язати, використовуючи префіксне дерево або алгоритм Ахо-Корасік:

* [UVA #11590 **"Prefix Lookup"** [складність: низька]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2637)

* [UVA #11171 **"SMS"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2112)

* [UVA #10679 **"I Love Strings!!!"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1620)
