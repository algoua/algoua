# Максимальний потік методом Проштовхування предпотока за O (N<sup>4</sup>)

Нехай дано граф G, в якому виділені дві вершини: джерело S і стік T, а у кожного ребра визначена пропускна здатність C<sub>u,v</sub>. Потік F можна уявити як потік вещества, яке могло б пройти по мережі від джерела до стоку, якщо розглядати граф як мережа труб з деякими пропускними здібностями. тобто. потік - функція F<sub>u, v</sub>, певна на множині ребер графа.

&nbsp;

Задача полягає в знаходженні максимального потоку. Тут буде розглянуто метод Проштовхування предпотока, працюючий за O (N<sup>4</sup>), або, точніше, за O (N<sup>2</sup> M). Алгоритм був запропонований Гольдбергом в 1985 році.

## Алгоритм

Загальна схема алгоритму така. На кожному кроці будемо розглядати деякий предпоток - тобто функцію, яка по свойствам нагадує потік, але не обов'язково задовольняє закону збереження потоку. На кожному кроці будемо намагатися застосувати яку-або з двох операцій: проштовхування потоку або поднятие вершини. Якщо на якому-то кроці стане неможливо застосувати яку-або з двох операцій, то ми знайшли необхідний потік.

Для кожної вершини визначена її висота H<sub>u</sub>, причому H<sub>S</sub> = N, H<sub>T</sub> = 0, і для будь-якого остаточного ребра (u, v) маємо H<sub>u</sub> <= H<sub>v</sub> + 1.

Для кожної вершини (крім S) можна визначити її избыток: E<sub>u</sub> = F<sub>V, u</sub>. Вершина з позитивним избытком називається переповненій.

Операція проштовхування Push (u, v) применима, якщо вершина u переполнена, залишкова пропускна здатність Cf<sub>u, v</sub> > 0 і H<sub>u</sub> = H<sub>v</sub> + 1. Операція проштовхування полягає в максимальному збільшенні потоку з u в v, ограниченном избытком E<sub>u</sub> і залишкової пропускною здатністю Cf<sub>u, v</sub>.

Операція поднятия Lift (u) поднимает переполненную вершину u на максимально допустимую висоту. тобто. H<sub>u</sub> = 1 + min { H<sub>v</sub> }, де (u, v) - остаточное ребро.

Залишилося тільки розглянути ініціалізацію потоку. Потрібно инициализировать тільки наступні значення: F<sub>S, v</sub> = C<sub>S, v</sub>, F<sub>u, S</sub> = - C<sub>u, S</sub>, інші значення покласти рівними нулю.

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
const int inf = 1000 * 1000 * 1000;

typedef vector<int> graf_line;
typedef vector<graf_line> graf;

typedef vector<int> vint;
typedef vector<vint> vvint;

void push(int u, int v, vvint &f, vint &e, const vvint &c) {
    int d = min(e[u], c[u][v] - f[u][v]);
    f[u][v] += d;
    f[v][u] = -f[u][v];
    e[u] -= d;
    e[v] += d;
}

void lift(int u, vint &h, const vvint &f, const vvint &c) {
    int d = inf;
    for (int i = 0; i < (int)f.size(); i++)
        if (c[u][i] - f[u][i] > 0)
            d = min(d, h[i]);
    if (d == inf)
        return;
    h[u] = d + 1;
}

int main() {
    int n;
    cin >> n;
    vvint c(n, vint(n));
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            cin >> c[i][j];
    // джерело - вершина 0, стік - вершина n-1

    vvint f(n, vint(n));
    for (int i = 1; i < n; i++) {
        f[0][i] = c[0][i];
        f[i][0] = -c[0][i];
    }

    vint h(n);
    h[0] = n;

    vint e(n);
    for (int i = 1; i < n; i++)
        e[i] = f[0][i];

    for (;;) {
        int i;
        for (i = 1; i < n - 1; i++)
            if (e[i] > 0)
                break;
        if (i == n - 1)
            break;

        int j;
        for (j = 0; j < n; j++)
            if (c[i][j] - f[i][j] > 0 && h[i] == h[j] + 1)
                break;
        if (j < n)
            push(i, j, f, e, c);
        else
            lift(i, h, f, c);
    }

    int flow = 0;
    for (int i = 0; i < n; i++)
        if (c[0][i])
            flow += f[0][i];

    cout << max(flow, 0);
}
```
