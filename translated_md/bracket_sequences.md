# Правильные дужкові послідовності

Правильной дужковій послідовністю називається стрічка, що складається тільки з символів "дужки" (частіше всього розглядаються тільки круглые дужки, але тут буде розглядатися і загальний випадок декількох типів дужок), де кожної закриває скобці знайдеться відповідна відкриває (причому того ж типу).

Тут ми розглянемо классические задачі на правильні дужкові послідовності (далі для стислості просто "послідовності"): перевірка на правильність, кількість послідовностей, генерация всіх послідовностей, знаходження лексикографічно наступного послідовності, знаходження $k$-ой послідовності в відсортованому списку всіх послідовностей, і, навпаки, визначення номера послідовності. Кожна з задач розглянута в двох випадках - коли дозволені дужки тільки одного типу, і коли декількох типів.

## Перевірка на правильність

Нехай спочатку дозволені дужки тільки одного типу, тоді перевірити послідовність на правильність можна дуже простим алгоритмом. Нехай $\rm depth$ - це поточний кількість відкритих дужок. Cпершу $\rm depth = 0$. Будемо рухатися по стрічки ліворуч направо, якщо поточна дужка відкриває, то збільшимо $\rm depth$ на одиницю, інакше зменшимо. Якщо при цим коли-то виходило отрицательное число, або в наприкінці роботи алгоритму $\rm depth$ відмінно від нуля, то дана стрічка не є правильної дужковій послідовністю, інакше є.

Якщо допустимі дужки декількох типів, то алгоритм потрібно змінити. Замість счётчика $\rm depth$ випливає створити стек, в який будемо класти открывающие дужки по міру поступления. Якщо поточний символ стрічки - відкриває дужка, то кладемо його в стек, а якщо закриває - то перевіряємо, що стек не порожній, і що на його вершині лежить дужка того ж типу, що і поточна, і потім дістаємо цю дужку з стека. Якщо яке-або з умов не виповнилося, або в наприкінці роботи алгоритму стек остался не порожній, то послідовність не є правильної дужковій, інакше є.

Таким чином, обидві ці задачі ми навчилися розв'язувати за час $O(n)$.

## Кількість послідовностей

### Формула

Кількість правильних дужкових послідовностей з одним типом дужок можна обчислити як **[число Каталана](catalan_numbers)**. тобто. якщо є $n$ пар дужок (стрічка довжини $2n$), то кількість буде рівне:

$$
\frac{1}{n+1} \cdot C^n_{2n}.
$$

Нехай тепер є не один, а $k$ типів дужок. Значить кожна пара дужок незалежно від інших можливо приймати один з $k$ типів, а тому ми отримуємо таку формулу:

$$
\frac{1}{n+1} \cdot C^n_{2n} \cdot k^n.
$$

### Динамічне програмування

З іншої сторони, до цій задачі можна подойти і з точки зору **динамічного програмування**. Нехай $d[n]$ - кількість правильних дужкових послідовностей з $n$ пар дужок. Зауважимо, що в першо] позиції завжди буде стояти відкриває дужка. Зрозуміло, що всередині цій пари дужок варто якась правильная скобочная послідовність; аналогічно, після цій пари дужок також варто правильная скобочная послідовність. Тепер аби порахувати $d[n]$, переберемо, скільки пар дужок $i$ буде стояти всередині цій першо] пари, тоді, відповідно, $n-1-i$ пара дужок буде стояти після цій першо] пари. Отже, формула для $d[n]$ має вид:

$$
d[n] = \sum_{i=0}^{n-1} d[i] \cdot d[n-1-i].
$$

Начальное значення для цій рекуррентной формули - це $d[0] = 1$.

## Знаходження всіх послідовностей

Іноді потрібно знайти і вивести всі правильні дужкові послідовності зазначеної довжини $n$ (в даному випадку $n$ - це довжина стрічки).

Для цього можна почати з лексикографічно першо] послідовності $((\ldots(())\ldots))$, а потім знаходити кожний раз лексикографічно наступну послідовність з допомогою алгоритму, описаного в наступному розділі.

Але якщо обмеження не дуже великі ($n$ до $10-12$), то можна вступити значно простіше. Знайдемо всілякі перестановки цих дужок (для цього зручно використовувати функцію next_permutation()), їх буде $C_{2n}^n$, і кожну перевіримо на правильність вищеописаним алгоритмом, і в випадку правильности виведемо поточну послідовність.

Також процес знаходження всіх послідовностей можна оформить в вигляді рекурсивного перебору з отсечениями (що в идеале можна довести по швидкості роботи до першого алгоритму).

## Знаходження наступного послідовності

Тут розглядається тільки випадок одного типу дужок.

За заданої правильної дужковій послідовності потрібно знайти правильную дужкову послідовність, яка знаходиться наступного в лексикографічному порядку після поточній (або видати "No solution", якщо такий не існує).

Зрозуміло, що в цілому алгоритм виглядає наступним чином: найдем таку саму праву відкриває дужку, яку ми маємо право замінити на закриває (так, аби в цим місці правильність не нарушалась), а всю оставшуюся справа стрічку замінимо на лексикографічно мінімальну: тобто скільки-то відкривають дужок, потім всі залишилися закрывающие дужки. Іншими словами, ми намагаємося залишити без зміни як можна більш довгий префікс вихідної послідовності, а в суфікс цю послідовність замінюємо на лексикографічно мінімальну.

Залишилося навчитися шукати цю саму позицію першого зміни. Для цього будемо йти по стрічки справа наліво і підтримувати баланс $\rm depth$ відкритих і закрытых дужок (при встрече відкриває дужки будемо зменшувати $\rm depth$, а при закриває - збільшувати). Якщо в якийсь момент ми стоїмо на відкриває скобці, а баланс після обробки цього символу більше нуля, то ми знайшли саму праву позицію, від якій ми можемо почати змінювати послідовність (насправді, $\rm depth > 0$ означає, що ліворуч є не закрытая ще дужка). Поставимо в поточну позицію закриває дужку, потім максимально возможное кількість відкривають дужок, а потім всі залишилися закрывающие дужки, - відповідь знайдений.

Якщо ми просмотрели всю стрічку і так і не знайшли подходящую позицію, то поточна послідовність - максимальна, і відповіді не існує.

Реалізація алгоритму:

<!--- TODO: specify code snippet id -->
``` cpp
string s;
cin >> s;
int n = (int) s.length();
string ans = "No solution";
for (int i=n-1, depth=0; i>=0; --i) {
    if (s[i] == '(')
        --depth;
    else
        ++depth;
    if (s[i] == '(' && depth > 0) {
        --depth;
        int open = (n-i-1 - depth) / 2;
        int close = n-i-1 - open;
        ans = s.substr(0,i) + ')' + string (open, '(') + string (close, ')');
        break;
    }
}
cout << ans;
```

Таким чином, ми вирішили цю задачу за $O(n)$.

## Номер послідовності

Тут нехай $n$ - кількість пар дужок в послідовності. Потрібно по заданої правильної дужковій послідовності знайти її номер в списку лексикографічно упорядкованих правильних дужкових послідовностей.

Навчимося вважати допоміжну **динаміку** $d[i][j]$, де $i$ - довжина дужковій послідовності (вона "полуправильна": всякой закриває скобці є парная відкриває, але не всі открытые дужки закрыты), $j$ - баланс (тобто різницю між кількістю відкривають і закрывающих дужок), $d[i][j]$ - кількість таких послідовностей. При подсчёте цій динаміки ми припустимо, що дужки бувають тільки одного типу.

Вважати цю динаміку можна наступним чином. Нехай $d[i][j]$ - величина, яку ми хочемо порахувати. Якщо $i=0$, то відповідь зрозумілий зразу: $d[0][0] = 1$, всі інші $d[0][j] = 0$. Нехай тепер $i > 0$, тоді подумки переберемо, чему був рівний останній символ цій послідовності. Якщо він був рівний '(', то до цього символу ми знаходилися в стані $(i-1,j-1)$. Якщо він був рівний ')', то попереднім було стан $(i-1,j+1)$. Таким чином, отримуємо формулу:

$$
d[i][j] = d[i-1][j-1] + d[i-1][j+1]
$$

(вважається, що всі значення $d[i][j]$ при отрицательном $j$ рівні нулю). Таким чином, цю динаміку ми можемо порахувати за $O(n^2)$.

Перейдемо тепер до розв'язку самою задачі.

Спочатку нехай допустимі тільки дужки **одного** типу. Заведемо лічильник $\rm depth$ глибини вложенности в дужки, і будемо рухатися по послідовності ліворуч направо. Якщо поточний символ $s[i]$ ($i=0 \ldots 2n-1$) рівний '(', то ми збільшуємо $\rm depth$ на 1 і переходимо до наступного символу. Якщо ж поточний символ рівний ')', то ми повинні додати до відповіді $d[2n-i-1][\rm depth+1]$, тим самим враховуючи, що в цій позиції міг б стояти символ '(' (який б привёл до лексикографічно меншої послідовності, ніж поточна); потім ми зменшуємо $\rm depth$ на одиницю.

Нехай тепер дозволені дужки **декількох** $k$ типів. Значить при розгляді поточного символу $s[i]$ до перерахунку $\rm depth$ ми повинні перебирати всі дужки, які менше поточного символу, пробовать ставити цю дужку в поточну позицію (получая тим самим новий баланс $\rm ndepth = \rm depth \pm 1$), і и додавати до відповіді кількість відповідних "хвостів" - завершений (які мають довжину $2n-i-1$, баланс $\rm ndepth$ і $k$ типів дужок). Стверджується, що формула для цього кількості має вид:

$$
d[2n-i-1][{\rm ndepth}] \cdot k^{ (2n-i-1 - {\rm ndepth})/2 }.
$$

Ця формула виводиться з наступних міркувань. Спочатку ми "забываем" про то, що дужки бувають декількох типів, і просто беремо відповідь з $d[2n-i-1][{\rm ndepth}]$. Тепер порахуємо, як зміниться відповідь з-за наявності $k$ типів дужок. У нас є $2n-i-1$ неопределённых позицій, з яких $\rm ndepth$ є дужками, закрывающими які-то з відкритих раніше, - значить, тип таких дужок ми варіювати не можемо. А ось всі інші дужки (а їх буде $(2n-i-1 - {\rm ndepth})/2$ пар) можуть бути будь-якого з $k$ типів, тому відповідь множиться на цю ступінь числа $k$.

## Знаходження $k$-ой послідовності

Тут нехай $n$ - кількість пар дужок в послідовності. В даній задачі по заданому $k$ потрібно знайти $k$-ую правильную дужкову послідовність в списку лексикографічно упорядкованих послідовностей.

Як і в попередньому розділі, порахуємо **динаміку** $d[i][j]$ - кількість правильних дужкових послідовностей довжини $i$ з балансом $j$.

Нехай спочатку допустимі тільки дужки **одного** типу.

Будемо рухатися по символам шуканої стрічки, з $0$-го по $2n-1$-ый. Як і в попередньою задачі, будемо зберігати лічильник $\rm depth$ - поточну глибину вложенности в дужки. В кожної поточній позиції будемо перебирати возможный символ - відкриває дужку або закриває. Нехай ми хочемо поставити сюди відкриває дужку, тоді ми повинні подивитися на значення $d[i+1][\rm depth+1]$. Якщо воно $\ge k$, то ми ставимо в поточну позицію відкриває дужку, збільшуємо $\rm depth$ на одиницю і переходимо до наступного символу. Інакше ми віднімаємо від $k$ величину $d[i+1][\rm depth+1]$, ставимо закриває дужку і зменшуємо значення $\rm depth$. В наприкінці кінців ми і отримаємо шукану дужкову послідовність.

Реалізація на мові Java з використанням довгою арифметики:

<!--- TODO: specify code snippet id -->
``` cpp
int n;  BigInteger k;  // вхідні дані

BigInteger d[][] = new BigInteger [n*2+1][n+1];
for (int i=0; i<=n*2; ++i)
    for (int j=0; j<=n; ++j)
        d[i][j] = BigInteger.ZERO;
d[0][0] = BigInteger.ONE;
for (int i=0; i<n*2; ++i)
    for (int j=0; j<=n; ++j) {
        if (j+1 <= n)
            d[i+1][j+1] = d[i+1][j+1].add( d[i][j] );
        if (j > 0)
            d[i+1][j-1] = d[i+1][j-1].add( d[i][j] );
    }

String ans = new String();
if (k.compareTo( d[n*2][0] ) > 0)
    ans = "No solution";
else {
    int depth = 0;
    for (int i=n*2-1; i>=0; --i)
        if (depth+1 <= n && d[i][depth+1].compareTo( k ) >= 0) {
            ans += '(';
            ++depth;
        }
        else {
            ans += ')';
            if (depth+1 <= n)
                k = k.subtract( d[i][depth+1] );
            --depth;
        }
}
```

Нехай тепер разрешён не один, а **$k$ типів** дужок. Значить алгоритм розв'язку буде відрізнятися від попереднього випадку тільки тим, що ми повинні домножувати значення $D[i+1][\rm ndepth]$ на величину $k^{(2n-i-1- \rm ndepth)/2}$, аби врахувати, що в цим остатке могли бути дужки різних типів, а парных дужок в цим остатке буде тільки $2n-i-1- \rm ndepth$, оскільки $\rm ndepth$ дужок є закрывающими для відкривають дужок, находящихся поза цього залишку (а тому їх типи ми варіювати не можемо).

Реалізація на мові Java для випадку двох типів дужок - круглых і квадратных:

<!--- TODO: specify code snippet id -->
``` cpp
int n;  BigInteger k;  // вхідні дані

BigInteger d[][] = new BigInteger [n*2+1][n+1];
for (int i=0; i<=n*2; ++i)
    for (int j=0; j<=n; ++j)
        d[i][j] = BigInteger.ZERO;
d[0][0] = BigInteger.ONE;
for (int i=0; i<n*2; ++i)
    for (int j=0; j<=n; ++j) {
        if (j+1 <= n)
            d[i+1][j+1] = d[i+1][j+1].add( d[i][j] );
        if (j > 0)
            d[i+1][j-1] = d[i+1][j-1].add( d[i][j] );
    }

String ans = new String();
int depth = 0;
char [] stack = new char[n*2];
int stacksz = 0;
for (int i=n*2-1; i>=0; --i) {
    BigInteger cur;
    // '('
    if (depth+1 <= n)
        cur = d[i][depth+1].shiftLeft( (i-depth-1)/2 );
    else
        cur = BigInteger.ZERO;
    if (cur.compareTo( k ) >= 0) {
        ans += '(';
        stack[stacksz++] = '(';
        ++depth;
        continue;
    }
    k = k.subtract( cur );
    // ')'
    if (stacksz > 0 && stack[stacksz-1] == '(' && depth-1 >= 0)
        cur = d[i][depth-1].shiftLeft( (i-depth+1)/2 );
    else
        cur = BigInteger.ZERO;
    if (cur.compareTo( k ) >= 0) {
        ans += ')';
        --stacksz;
        --depth;
        continue;
    }
    k = k.subtract( cur );
    // '['
    if (depth+1 <= n)
        cur = d[i][depth+1].shiftLeft( (i-depth-1)/2 );
    else
        cur = BigInteger.ZERO;
    if (cur.compareTo( k ) >= 0) {
        ans += '[';
        stack[stacksz++] = '[';
        ++depth;
        continue;
    }
    k = k.subtract( cur );
    // ']'
    ans += ']';
    --stacksz;
    --depth;
}
```
