# Суфіксний автомат

**Суфіксний автомат** (або **орієнтований ациклічний граф слов**) - це мощная структура данних, яка дозваляє розв'язувати множину строковых задач.

Наприклад, з допомогою суфіксного автомата можна шукати всі входження однієї стрічки в іншу, або підраховувати кількість різних підстрічок даній стрічки - обидві задачі він дозваляє розв'язувати за лінійне час.

На интуитивном рівні, суфіксний автомат можна розуміти як стислу інформацію про **всіх подстроках** даній стрічки. Впечатляющим фактом є то, що суфіксний автомат містить всю інформацію в настільки стислому вигляді, що для стрічки довжини $n$ він вимагає лише $O(n)$ пам'яті. Більш того, він можливо бути побудований також за час $O(n)$ (якщо ми припустимо розмір алфавіту $k$ константою; в іншому випадку - за час $O(n \log k)$).

**Исторически**, вперше линейность розміру суфіксного автомата була відкрита в 1983 р. Blumer і др., а в 1985 - 1986 гг. були представлены перші алгоритми його побудови за лінійне час (Crochemore, Blumer і др).. Більш детально - див. список літератури в наприкінці статті.

На англійською мові суфіксний автомат називається "suffix automaton" (у множественном числі - "suffix automata"), а орієнтований ациклічний граф слов - "directed acyclic word graph" (або просто "DAWG").

## Визначення суфіксного автомата

Визначення. **Суффиксным автоматом** для даній стрічки $s$ називається такий мінімальний детерминированный конечный автомат, який приймає всі суфікси стрічки $s$.

Расшифруем це визначення.

* Суфіксний автомат представляє собою орієнтований ациклічний граф, в якому вершини називаються **станами**, а дуги графа - це **переходи** між цими станами.

* Одне з станів $t_0$ називається **початковим станом**, і воно має бути витоком графа (тобто з нього досяжні всі інші стан).

* Кожен **перехід** в автоматі - це дуга, помеченная деяким символом. Усе переходи, вихідні з какого-або стан, зобов'язані мати **різні** мітки. (З іншої сторони, з стан можливо не бути переходів по яким-або символам).

* Одне або декілька станів позначені як **термінальні стан**. Якщо ми пройдемо з початкового стан $t_0$ по будь-якого шляхи до какого-або терминального стан, і випишемо при цим мітки всіх пройдених дуг, то вийде стрічка, яка обязана бути одним з суфіксів стрічки $s$.

* Суфіксний автомат містить мінімальне кількість вершин серед всіх автоматів, задовольняють описаним вище умовами. (Минимальность числа переходів не потрібно, т.до. при умови мінімальності числа станів в автоматі не можливо бути "зайвих" шляхів - інакше це нарушило б попереднє властивість).

### Простейшие властивості суфіксного автомата

Простейшим, і разом з тим важнейшим властивістю суфіксного автомата є то, що він містить в собі інформацію про всіх подстроках стрічки $s$. А саме, **будь-який шлях** з початкового стан $t_0$, якщо ми випишемо мітки дуг уздовж цього шляхи, утворює обов'язково **підстрічку** стрічки $s$. І навпаки, будь-який підрядку стрічки $s$ відповідає деякий шлях, що починається в начальном стані $t_0$.

В цілях спрощення объяснений, ми будемо говорити, що підрядку **відповідає** той шлях з початкового стан, мітки уздовж якого утворюють цю підстрічку. І навпаки, ми будемо говорити, що будь-якого шляхи **відповідає** та стрічка, яку утворюють мітки його дуг.

В кожне стан суфіксного автомата веде один або декілька шляхів з початкового стан. Будемо говорити, що станом **відповідає** набір стрічок, відповідних всім цим шляхах.

### Приклади побудованих суфіксних автоматів

Наведемо примеры суфіксних автоматів, побудованих для декількох простих стрічок.

Начальное стан ми будемо позначати тут через $t0$, а термінальні стан - відзначати звёздочкой.

Для стрічки $s = ""$:

\img{suffix_automaton_sample_1.gif}

Для стрічки $s = "a"$:

\img{suffix_automaton_sample_2.gif}

Для стрічки $s = "aa"$:

\img{suffix_automaton_sample_3.gif}

Для стрічки $s = "ab"$:

\img{suffix_automaton_sample_4.gif}

Для стрічки $s = "aba"$:

\img{suffix_automaton_sample_5.gif}

Для стрічки $s = "abb"$:

\img{suffix_automaton_sample_6.gif}

Для стрічки $s = "abbb"$:

\img{suffix_automaton_sample_7.gif}

## Алгоритм побудови суфіксного автомата за лінійне час

Перед тим, як перейти безпосередньо до опису алгоритму побудови, треба ввести декілька нових понятий і довести прості, але дуже важливі для розуміння суфіксного автомата леми.

### Позиції закінчень $endpos$, їх властивості і зв'язок з суфіксним автоматом

Розглянемо будь-яку непустую підстрічку $t$ стрічки $s$. Значить назвемо **безліччю закінчень** $endpos(t)$ множину всіх позицій в стрічки $s$, в яких оканчиваются входження стрічки $t$.

Ми будемо називати дві підстрічки $t_1$ і $t_2$ $endpos$-еквівалентними, якщо їх множини закінчень збігаються: $endpos(t_1) = endpos(t_2)$. Таким чином, всі непусті підстрічки стрічки $s$ можна розбити на декілька **класів еквівалентності** відповідно їх безлічам $endpos$.

Виявляється, що в суфіксном автоматі **$endpos$-еквівалентним подстрокам відповідає одне і то ж стан**. Іншими словами, число станів в суфіксном автоматі рівне кількості класів $endpos$-еквівалентності серед всіх підстрічок, плюс одне початкова стан. Кожному станом суфіксного автомата відповідають одна або декілька підстрічок, мають одне і то ж значення $endpos$.

**Це твердження ми примем як аксиому**, і опишемо алгоритм побудови суфіксного автомата, виходячи з цього предположения - як ми потім побачимо, всі необхідні властивості суфіксного автомата, крім мінімальності, будуть виконані. (А минимальность випливає з теореми Nerode - див. список літератури).

Наведемо також декілька простих, але важных утверждений касательно значень $endpos$.

**Лема 1**. Две непусті підстрічки $u$ і $w$ ($length(u) \le length(w)$) є $endpos$-еквівалентними тоді і тільки тоді, коли стрічка $u$ зустрічається в стрічки $s$ тільки в вигляді суфікса стрічки $w$.

Доведення практично очевидно. В одну сторону: якщо $u$ і $w$ мають однакові позиції закінчень входження, то $u$ є суфіксом $w$, і вона присутній в $s$ тільки в вигляді суфікса $w$. В зворотню сторону: якщо $u$ є суфіксом $w$ і входити тільки як цей суфікс, то їх значення $endpos$ рівні по визначенню.

**Лема 2**. Розглянемо дві непусті підстрічки $u$ і $w$ ($length(u) \le length(w)$). Значить їх множини $endpos$ або не перетинаються, або $endpos(w)$ цілком міститься в $endpos(u)$, причому це залежить від того, є $u$ суфіксом $w$ або ні:

$$ \begin{cases}
endpos(w) \subset endpos(u) & \text{if $u$ - suffix $w$,}
\\
endpos(u) \cap endpos(w) = \emptyset & \text{otherwise.}
\end{cases} $$

Доведення. Припустимо, що множини $endpos(u)$ і $endpos(w)$ мають хоча б один загальний елемент. Значить це означає, що стрічки $u$ і $w$ оканчиваются в одному і тому ж місці, тобто $u$ - суфікс $w$. Але тоді кожне входження стрічки $w$ містить на своєму наприкінці входження стрічки $u$, що і означає, що його множину $endpos(w)$ цілком вкладывается в множину $endpos(u)$.

**Лема 3**. Розглянемо деякий клас $endpos$-еквівалентності. Відсортуємо всі підстрічки, що входять в цей клас, по невозрастанию довжини. Значить в получившейся послідовності кожна підстрічка буде на одиницю коротше попередньою, і при цим бути суфіксом попередньою. Іншими словами, **підстрічки, що входять в один клас еквівалентності, насправді є суфіксами один одного, і приймають всілякі різні довжини в деякому відрізку $[x;y]$**.

Доведення.

Зафіксуємо деякий клас $endpos$-еквівалентності. Якщо він містить тільки одну стрічку, то коректність леми очевидна. Нехай тепер кількість стрічок більше однієї.

Згідно з лемою 1, дві різні $endpos$-эквивалентные стрічки завжди такі, що одна є власним суфіксом іншої. Отже, в одному класі $endpos$-еквівалентності не можливо бути стрічок однаковою довжини.

Позначимо через $w$ довжелезну, а через $u$ - кратчайшую стрічку в даному класі еквівалентності. Згідно з лемою 1, стрічка $u$ є власним суфіксом стрічки $w$. Розглянемо тепер будь-який суфікс стрічки $w$ з довжиною в відрізку $[length(u); length(w)]$, і покажемо, що він міститься в цим ж класі еквівалентності. Насправді, цей суфікс можливо входити в $s$ тільки в вигляді суфікса стрічки $w$ (оскільки більш короткий суфікс $u$ входити тільки в вигляді суфікса стрічки $w$). Отже, згідно з лемою 1, цей суфікс $endpos$-еквівалентний стрічки $w$, що і потрібно довести.

### Суфіксние посилання

Розглянемо деякий стан автомата $v \ne t_0$. Як ми тепер знаємо, станом $v$ відповідає деякий клас стрічок з однаковими значеннями $endpos$, причому якщо ми позначимо через $w$ довжелезну з цих стрічок, то всі інші будуть суфіксами $w$.

Також ми знаємо, що перші декілька суфіксів стрічки $w$ (якщо ми розглядаємо суфікси в порядку зменшення їх довжини) містяться в тому ж самому класі еквівалентності, а всі інші суфікси (як мінімум, порожній суфікс) - в якихось інших классах. Позначимо через $t$ перший такий суфікс - в нього ми і проведемо суфіксну посилання.

Іншими словами, **суфіксна посилання** $link(v)$ веде в таке стан, якому відповідає **наідліннейшій суфікс** стрічки $w$, находящийся в другом класі $endpos$-еквівалентності.

Тут ми припустимо, що начальному станом $t_0$ відповідає окремий клас еквівалентності (що містить тільки пусту стрічку), і вважаємо $endpos(t_0) = [-1 \ldots length(s)-1]$.

**Лема 4**. Суфіксние посилання утворюють **дерево**, коренем якого є початкова стан $t_0$.

Доведення. Розглянемо довільне стан $v \ne t_0$. Суффиксная посилання $link(v)$ веде з нього в стан, якому відповідають стрічки строго меншої довжини (це випливає з визначення суфіксному посилання і з леми 3). Отже, рухаючись по суфіксним посиланням, ми рано або пізно прийдемо з стан $v$ в початкова стан $t_0$, якому відповідає пустая стрічка.

**Лема 5**. Якщо ми побудуємо з всіх наявних множин $endpos$ **дерево** (по принципом "множину-родитель містить як підмножини всіх своїх дітей"), то воно буде збігатися по структурі з деревом суфіксних посилань.

Доведення.

Те, що з множин $endpos$ можна побудувати дерево, випливає з леми 2 (про тому, що будь-які два множини $endpos$ або не перетинаються, або одне міститься в другом).

Розглянемо тепер довільне стан $v \ne t_0$ і його суфіксну посилання $link(v)$. З визначення суфіксному посилання і з леми 2 випливає:

$$
endpos(v) \subset endpos(link(v)),
$$

що вкупе з попередньою леммой і доводить наше твердження: дерево суфіксних посилань по суті своєї є дерево вкладывающихся множин $endpos$.

**Наведемо приклад** дерева суфіксних посилань в суфіксном автоматі, побудованому для стрічки $"abcbc"$:

\img{suffix_automaton_link.gif}

### Промежуточный підсумок

Перед тим, як приступить до самому алгоритму, систематизируем накопленные вище знання, і введемо пару допоміжних обозначений.

* Безліч підстрічок стрічки $s$ можна розбити на класи еквівалентності згідно їх безлічам закінчення $endpos$.

* Суфіксний автомат складається з початкового стан $t_0$, а також по одному станом на кожний клас $endpos$-еквівалентності.

* Кожному станом $v$ відповідає одна або декілька стрічок. Позначимо через $longest(v)$ довжелезну з таких стрічок, через $len(v)$ її довжину. Позначимо через $shortest(v)$ кратчайшую з таких стрічок, а її довжину через $minlen(v)$.

Значить всі стрічки, відповідні цьому станом, є різними суфіксами стрічки $longest(v)$ і мають всілякі довжини в відрізку $[minlen(v); len(v)]$.

* Для кожного стан $v \ne t_0$ визначена суфіксна посилання, ведущая в таке стан, яке відповідає суфіксу стрічки $longest(v)$ довжини $minlen(v)-1$. Суфіксние посилання утворюють дерево з коренем в $t_0$, причому це дерево, по суті, є деревом отношений включения між множествами $endpos$.

* Таким чином, $minlen(v)$ для $v \ne t_0$ виражається з допомогою суфіксному посилання $link(v)$ як:

$$
minlen(v) = len(link(v)) + 1.
$$

* Якщо ми стартуємо з довільного стан $v_0$ і будемо йти по суфіксним посиланням, то рано або пізно дійдемо до початкового стан $t_0$. При цим у нас вийде послідовність що не перетинаються відрізків $[minlen(v_i); len(v_i)]$, які в об'єднанні дадуть один суцільний відрізок.

### Алгоритм побудови суфіксного автомата за лінійне час

Приступим до опису самого алгоритму. Алгоритм буде **онлайновим**, тобто буде додавати по одному символу стрічки $s$, перестраивая відповідним чином поточний автомат.

Щоб досягти лінійного споживання пам'яті, в кожному стані ми будемо зберігати тільки значення $len$, $link$ і список переходів з цього стан. Метки терминальных станів ми підтримувати не будемо (ми покажемо, як розставити ці мітки після побудови суфіксного автомата, якщо є необхідність в них).

**Cпершу** автомат складається з єдиного стан $t_0$, яке ми условимся вважати нульовим станом (інші стан будуть получать номера $1, 2, \ldots$). Присвоим цьому станом $len = 0$, а значенням $link$ дамо для зручності $-1$ (означающее посилання на фіктивне, несуществующее стан).

Відповідно, вся задача тепер зводиться до тому, аби реалізувати обробку **додавання одного символу** $c$ в кінець поточній стрічки. Опишемо цей процес:

* Нехай $last$ - це стан, відповідне всій поточній стрічки до додавання символу $c$. (Cпершу $last = 0$, а після додавання кожного символу ми будемо змінювати значення $last$).

* Створимо нове стан $cur$, проставив йому $len(cur) = len(last) + 1$. Значення $link(cur)$ поки припустимо неопределённым.

* Сделаем такий цикл: спершу ми стоїмо в стані $last$; якщо з нього ні переходу по букві $c$, то додаємо цей перехід по букві $c$ в стан $cur$, і потім переходимо по суфіксному посиланню, знову проверяя - якщо ні переходу, то додаємо. Якщо в якийсь момент случится, що такий перехід вже є, то зупиняємося - і позначимо через $p$ номер стан, на якому це відбулося.

* Якщо ні разу не случилось, що перехід по букві $c$ вже имелся, і ми так і дійшли до фіктивного стан $-1$ (в яке ми потрапили по суфіксному посиланню з початкового стан $t_0$), то ми можемо просто присвоїти $link(cur) = 0$ і вийти.

* Припустимо тепер, що ми остановились на деякому стані $p$, з якого вже був перехід по букві $c$. Позначимо через $q$ то стан, куди веде цей наявний перехід.

* Тепер у нас два випадку в залежності від того, $len(p) + 1 = len(q)$ або ні.

* Якщо $len(p) + 1 = len(q)$, то ми можемо просто присвоїти $link(cur) = q$ і вийти.

* В іншому випадку, усе декілька складніше. Необходимо провести **"клонирование"** стан $q$: створити нове стан $clone$, скопировав в нього всі дані з вершини $q$ (суфіксну посилання, переходи), за винятком значення $len$: треба присвоїти $len(clone) = len(p) + 1$.

Після клонування ми проводимо суфіксну посилання з $cur$ в це стан $clone$, також перенаправляємо суфіксну посилання з $q$ в $clone$.

Нарешті, останнє, що ми повинні зробити - це пройтися від стан $p$ по суфіксним посиланням, і для кожного чергового стан перевіряти: якщо имелся перехід по букві $c$ в стан $q$, то перенаправлять його в стан $clone$ (а якщо ні, то останавливаться).

* В будь-якому випадку, ніж б ні закончилось виконання цій процедуры, ми в наприкінці оновлюємо значення $last$, присваивая йому $cur$.

Якщо нам також потрібно знати, які вершини є **терминальными**, а які - ні, то ми можемо знайти всі термінальні вершини після побудови суфіксного автомата для всій стрічки. Для цього розглянемо стан, відповідне всій стрічки (воно, очевидно, у нас сохранено в змінній $last$), і будемо йти по його суфіксним посиланням, поки не дійдемо до початкового стан, і помечать кожне пройденное стан як терминальное. Легко зрозуміти, що тим самим ми пометим стан, відповідні всім суфіксам стрічки $s$, що нам і потрібно.

В наступному розділі ми детально розглянемо кожний крок алгоритму і покажемо його **коректність**.

Тут ж лише відзначимо, що з алгоритму видно, що додавання одного символу призводить до добавлению одного або двох станів в автомат. Таким чином, **линейность числа станів** очевидна.

Линейность числа переходів, да і взагалі лінійне час роботи алгоритму менш понятны, і вони будуть доказаны нижче, після доведення коректності алгоритму.

### Доведення коректності алгоритму

* Назвемо перехід $(p,q)$ **сплошным**, якщо $len(p) + 1 = len(q)$. В іншому випадку, тобто коли $len(p) + 1 < len(q)$, перехід будемо називати **несплошным**.

Як можна побачити з опису алгоритму, суцільні і несплошные переходи призводять до різним ветвям алгоритму. Сплошные переходи називаються так тому, що, появившись вперше, вони більше ніколи не будуть змінюватися. В протилежність їм, несплошные переходи можуть змінитися при додаванні нових букв до стрічки (змінитися можливо кінець дуги-переходу).

* Щоб уникнути неоднозначностей, під рядком $s$ ми будемо подразумевать стрічку, для якій був побудований суфіксний автомат до додавання поточного символу $c$.

* Алгоритм починається з того, що ми створюємо нове стан $cur$, якому буде відповідати вся стрічка $s + c$. Зрозуміло, чому ми зобов'язані створити нове стан - т.до. разом з додаванням нового символу виникає новий клас еквівалентності - це клас стрічок, закінчуються на добавляемом символі $c$.

* Після создания нового стан алгоритм проходится по суфіксним посиланням, починаючи з стан, відповідного всій стрічки $s$, і намагається додати перехід по символу $c$ в стан $cur$. Тим самим, ми приписываем до кожному суфіксу стрічки $s$ символ $c$. Але додавати нові переходи ми можемо тільки в тому випадку, якщо вони не будуть конфликтовать з вже имеющимися, тому, як тільки ми встретим вже наявний перехід по символу $c$, ми зразу ж зобов'язані зупинитися.

* Самий простий випадок - якщо ми так і дійшли до фіктивного стан $-1$, додавши всюди по новому переходу уздовж символу $c$. Це означає, що символ $c$ в стрічки $s$ раніше не зустрічався. Ми успешно додали всі переходи, залишилося тільки проставить суфіксну посилання у стан $cur$ - вона, очевидно, повинна бути рівна $0$, оскільки станом $cur$ в даному випадку відповідають всі суфікси стрічки $s+c$.

* Другий випадок - коли ми наткнулись на вже наявний перехід $(p,q)$. Це означає, що ми намагалися додати в автомат стрічку $x+c$ (де $x$ - деякий суфікс стрічки $s$, має довжину $len(p)$), а ця стрічка **вже була раніше добавлена** в автомат (тобто стрічка $x+c$ вже входити як підстрічка в стрічку $s$). Оскільки ми припускаємо, що автомат для стрічки $s$ побудований правильно, то нових переходів ми більше додавати не повинні.

Однак виникає складність з тим, куди вести суфіксну посилання з стан $cur$. Нам потрібно провести суфіксну посилання в таке стан, в якому длиннейшей рядком буде бути як раз ця сама $x+c$, тобто $len$ для цього стан повинен бути рівний $len(p) + 1$. Однак такого стан могло і не існувати: в такому випадку нам треба провести **"розщеплення"** стан.

* Отже, по одному з можливих сценариев, перехід $(p,q)$ виявився сплошным, тобто $len(q) = len(p) + 1$. В цим випадку усе просто, ніякого расщепления виробляти не треба, і ми просто проводимо суфіксну посилання з стан $cur$ в стан $q$.

* Інший, більш складний різновид - коли перехід несплошной, тобто $len(q) > len(p) + 1$. Це означає, що станом $q$ відповідає не тільки нужная нам підстрічка $w+c$ довжини $len(p) + 1$, але також і підстрічки більшої довжини. Нам нічого не залишається, крім як провести **"розщеплення"** стан $q$: розбити відрізок стрічок, відповідних їй, на два підвідрізку, так що перший буде заканчиваться як раз довжиною $len(p) + 1$.

Як виробляти це розщеплення? Ми **"клонируем"** стан $q$, роблячи його копию $clone$ з параметром $len(clone) = len(p) + 1$. Ми копируем в $clone$ з $q$ всі переходи, оскільки ми не хочемо никоим чином змінювати шляхи, проходившие через $q$. Суффиксную посилання з $clone$ ми ведём туда, куди вела старая суфіксна посилання з $q$, а посилання з $q$ направляем в $clone$.

Після клонування ми проводимо суфіксну посилання з $cur$ в $clone$ - то, ради чого ми і производили клонирование.

Остался останній крок - перенаправить деякі що входять в $q$ переходи, перенаправив їх на $clone$. Які саме що входять переходи треба перенаправить? Досить перенаправить тільки переходи, відповідні всім суфіксам стрічки $w+c$, тобто нам треба продолжить рухатися по суфіксним посиланням, починаючи з вершини $p$, і до тих пір, поки ми не дійдемо до фіктивного стан $-1$ або не дійдемо до стан, перехід з якого веде в стан, отличное від $q$.

### Доведення лінійного числа операцій

По-перше, зразу оговоримся, що ми припустимо розмір алфавіту **константою**. Якщо це не так, то говорити про линейном часу роботи не вийде: список переходів з однієї вершини треба зберігати в вигляді сбалансированного дерева, позволяющего швидко виробляти операції пошуку по ключу і додавання ключа. Отже, якщо ми позначимо через $k$ розмір алфавіту, то асимптотика алгоритму складе $O(n \log k)$ при $O(n)$ пам'яті. Втім, якщо алфавит достатньо малий, то можна, пожертвовав пам'яттю, уникнути сбалансированных списків, а зберігати переходи в кожної вершині в вигляді масиву довжини $k$ (для швидкого пошуку по ключу) і динамічного списку (для швидкого обходу всіх наявних ключей). Тим самим ми достигнем $O(n)$ у часу роботи алгоритму, але ціною $O(n k)$ споживання пам'яті.

Отже, ми будемо вважати розмір алфавіту константным, тобто кожна операція пошуку переходу по символу, додавання переходу, пошук наступного переходу - всі ці операції ми припустимо работающими за $O(1)$.

Якщо ми розглянемо всі частини алгоритму, то він містить три місця, лінійна асимптотика яких не очевидна:

* Первое місце - це прохід по суфіксним посиланням від стан $last$ з додаванням ребер по символу $c$.

* Второе місце - копирование переходів при клонировании стан $q$ в нове стан $clone$.

* Третье місце - перенаправление переходів, провідних в $q$, на $clone$.

Скористаємося відомим фактом, що розмір суфіксного автомата (як по числу станів, так і по числу переходів) **лине**. (Доказательством лінійності по числу станів є сам алгоритм, а доведення лінійності по числу переходів ми наведемо нижче, після реалізації алгоритму)..

Значить очевидна лінійна сумарна асимптотика **першого і іншого місця**: адже кожна операція тут додає в автомат один новий перехід.

Залишилося оцінити сумарну асимптотику **в третьому місці** - в тому, де ми перенаправляємо переходи, провідні в $q$, на $clone$. Позначимо $v = longest(p)$. Це суфікс стрічки $s$, і з кожної ітерацією його довжина зменшується - а, значить, і позиція $v$ як суфікса стрічки $s$ монотонно зростає з кожної ітерацією. При цим, якщо перед першо] ітерацією циклу відповідна стрічка $v$ була на глубине $k$ ($k \ge 2$) від $last$ (якщо вважати глубиной число суфіксних посилань, які треба пройти), то після останньої ітерації стрічка $v+c$ стане $2$-ой суфіксному ссылкой на шляхи від $cur$ (яке стане новим значенням $last$).

Таким чином, кожна ітерація цього циклу призводить до тому, що позиція стрічки $longest(link(link(last))$ як суфікса всій поточній стрічки буде монотонно збільшуватися. Отже, всього цей цикл не міг отработать більш $n$ ітерацій, **що і потрібно довести**.

(Варто замітити, що аналогічні аргументы можна використовувати і для доведення лінійності роботи першого місця, замість посилання на доведення лінійності числа станів).

## Реалізація алгоритму

На Початку опишемо структуру данних, яка буде зберігати всю інформацію про конкретном переході ($len$, $link$, список переходів). При необхідності сюди можна додати прапор терминальности, а також іншу необхідну інформацію. Список переходів ми зберігаємо в вигляді стандартного контейнера $map$, що дозваляє досягти сумарно $O(n)$ пам'яті і $O(n \log k)$ часу на обробку всій стрічки.

<!--- TODO: specify code snippet id -->
``` cpp
struct state {
    int len, link;
    map<char,int> next;
};
```

Сам суфіксний автомат будемо зберігати в вигляді масиву цих структур $state$. Як доводиться в наступному розділі, якщо $MAXN$ - це максимально возможная в програмі довжина стрічки, то достатньо завести пам'ять під $2 \cdot MAXN - 1$ станів. Також ми зберігаємо змінну $last$ - стан, відповідне всій стрічки на даний момент.

<!--- TODO: specify code snippet id -->
``` cpp
const int MAXLEN = 100000;
state st[MAXLEN*2];
int sz, last;
```

Наведемо функцію, инициализирующую суфіксний автомат (создающую автомат з єдиним початковим станом):

<!--- TODO: specify code snippet id -->
``` cpp
void sa_init() {
    sz = last = 0;
    st[0].len = 0;
    st[0].link = -1;
    ++sz;
    /*
    // цей код потрібен, тільки якщо автомат будується багато раз для різних стрічок:
    for (int i=0; i<MAXLEN*2; ++i)
        st[i].next.clear();
    */
}
```

Нарешті, наведемо реалізацію основний функції - яка додає черговий символ в кінець поточній стрічки, перестраивая відповідним чином автомат:

<!--- TODO: specify code snippet id -->
``` cpp
void sa_extend (char c) {
    int cur = sz++;
    st[cur].len = st[last].len + 1;
    int p;
    for (p=last; p!=-1 && !st[p].next.count(c); p=st[p].link)
        st[p].next[c] = cur;
    if (p == -1)
        st[cur].link = 0;
    else {
        int q = st[p].next[c];
        if (st[p].len + 1 == st[q].len)
            st[cur].link = q;
        else {
            int clone = sz++;
            st[clone].len = st[p].len + 1;
            st[clone].next = st[q].next;
            st[clone].link = st[q].link;
            for (; p!=-1 && st[p].next[c]==q; p=st[p].link)
                st[p].next[c] = clone;
            st[q].link = st[cur].link = clone;
        }
    }
    last = cur;
}
```

Як вже згадувалося вище, якщо пожертвовать пам'яттю (до $O(n k)$, де $k$ - розмір алфавіту), то можна досягти часу побудови автомата $O(n)$ навіть для будь-яких $k$ - але для цього доведеться в кожному стані зберігати масив розміру $k$ (для швидкого пошуку переходу по потрібної букві) і список всіх переходів (для швидкого обходу або копирования всіх переходів).

## Дополнительные властивості суфіксного автомата

### Число станів

Число станів в суфіксном автоматі, побудованому для стрічки $s$ довжини $n$, **не перевищує $2n-1$** (для $n \ge 3$).

Доказательством цього є описаний вище алгоритм (оскільки спершу автомат складається з одного початкового стан, на першому і іншому кроках додається рівне по одному станом, а на кожному з інших $n-2$ кроках могло додаватися по дві вершини з-за расщепления стан).

Однак цю оцінку **легко показати і без знання алгоритму**. Згадаймо про тому, що число станів рівне кількості різних значень множин $endpos$. Крім того, ці множини $endpos$ утворюють дерево по принципом "вершина-родитель містить в собі як підмножини всіх дітей". Розглянемо це дерево, і трохи перетворимо його: поки в ньому є внутрішня вершина з одним сином, то це означає, що $endpos$ цього сина не містить як мінімум одне число з $endpos$ родителя; тоді створимо виртуальную вершину з $endpos$, рівним цьому числу, і привесим цього сина до родителю. В результаті ми отримаємо дерево, в якому кожна внутрішня вершина має ступінь більше одиниці, а число листя не перевершує $n$. Отже, всього в такому дереві не більш $2n-1$ вершини.

Отже, ми показали цю оцінку незалежно, без знання алгоритму.

Цікаво замітити, що ця оцінка неулучшаема, тобто існує **тест, на якому вона досягається**. Цей тест виглядає таким чином:

$$
" abbbb \ldots "
$$

При обробці цій стрічки на кожної ітерації, починаючи з третьої, буде відбуватися розщеплення стан, і, тим самим, буде достигаться оцінка $2n-1$.

### Число переходів

Число переходів в суфіксном автоматі, побудованому для стрічки $s$ довжини $n$, **не перевищує $3n-4$** (для $n \ge 3$).

**Доведемо** це.

Оцінимо число суцільних переходів. Розглянемо каркасне дерево з длиннейших шляхів в автоматі, починаються в стані $t_0$. Цей каркас буде складатися тільки з суцільних ребер, а, значить, їх кількість на одиницю менше числа станів, тобто не перевершує $2n-2$.

Оцінимо тепер число несплошних переходів. Розглянемо кожний несплошной перехід; нехай поточний перехід - це перехід $(p,q)$ по символу $c$. Поставимо йому в відповідність стрічку $u+c+w$, де стрічка $u$ відповідає длиннейшему шляхи з початкового стан в $p$, а $w$ - длиннейшему шляхи з $q$ в яке-або терминальное стан. З однієї сторони, всі такі стрічки $u+c+w$ для всіх несплошних переходів будуть різними (оскільки стрічки $u$ і $w$ образованы тільки сплошными переходами). З іншої сторони, кожна з таких стрічок $u+c+w$, по визначенню терминального стан, буде суфіксом всій стрічки $s$. Оскільки непустих суфіксів у стрічки $s$ всього $n$ штук, і до тому ж вся стрічка $s$ серед цих стрічок $u+c+w$ не могла міститися (т.до. всій стрічки $s$ відповідає шлях з $n$ суцільних ребер), то загальне число несплошних переходів не перевершує $n-1$.

Складывая ці дві оцінки, ми отримуємо оцінку $3n-3$. Однак, згадуючи, що максимальне число станів досягається тільки на тесті увазі $"abbbb \ldots "$, і на ньому оцінка $3n-3$ явно не досягається, отримуємо окончательную оцінку $3n-4$, що і потрібно довести.

Цікаво відзначити, що також існує **тест, на якому ця оцінка досягається**:

$$
"abbb \ldots bbbc"
$$

### Зв'Язок з суфіксним деревом. Побудова суфіксного дерева по суфіксному автомату і навпаки

Доведемо дві теореми, устанавливающие взаимную зв'язок між суфіксним автоматом і [суфіксним деревом](ukkonen).

Відразу оговоримся, що ми припустимо, що вхідні стрічка така, що кожний суфікс має собственную вершину в суфіксном дереві (оскільки для довільних стрічок це, взагалі кажучи, невірно: наприклад, для стрічки $"aaa \ldots"$). Обычно цього добиваются шляхом приписування в кінець стрічки какого-нибудь особого символу (зазвичай обозначаемого через знак доллара).

Для зручності введемо позначення: $\overline{s}$ - це стрічка $s$, записана в зворотньому порядку, $DAWG(s)$ - це суфіксний автомат, построенный для стрічки $s$, $ST(s)$ - це [суфіксне дерево](ukkonen) стрічки $s$.

Введемо поняття **расширяющей посилання**: зафіксуємо вершину суфіксного дерева $v$ і символ $c$; тоді расширяющая посилання $ext[c,v]$ веде в вершину дерева, відповідну стрічки $c+v$ (якщо цей шлях $c+v$ закінчується посередині ребра, то проведемо посилання в нижній кінець цього ребра); якщо такого шляхи $c+v$ взагалі ні в дереві, то расширяющая посилання не визначена. В деякому сенсі, розширюють посилання противоположны суфіксним посиланням.

**Теорема 1**. Дерево, образованное суфіксними ссылками в $DAWG(s)$, є суфіксним деревом $ST(\overline{s})$.

**Теорема 2**. $DAWG(s)$ - це граф расширяющих посилань суфіксного дерева $ST(\overline{s})$. Крім того, суцільні ребра в $DAWG(s)$ - це инвертированные суфіксние посилання в $ST(\overline{s})$.

Ці дві теореми дозволяють по однієї з структур (суфіксному дереву або суфіксному автомату) побудувати іншу за час $O(n)$ - ці два простих алгоритму будуть розглянуті нами нижче в теоремах 3 і 4.

В цілях наочності, наведемо суфіксний автомат з його деревом суфіксних посилань і відповідне суфіксне дерево для інвертованою стрічки. Для прикладу візьмемо стрічку $s = "abcbc"$.

$DAWG("abcbc")$ і його дерево суфіксних посилань (для наочності ми подписываем кожне стан його $longest$-рядком):

\img{suffix_automaton_st_1.gif}

$ST("cbcba")$:

\img{suffix_automaton_st_2.gif}

**Лема**. Следующие три затвердження еквівалентні для будь-яких двох підстрічок $u$ і $w$:

* $endpos(u) = endpos(w)$ в стрічки $s$
* $firstpos(\overline{u}) = firstpos(\overline{w})$ в стрічки $\overline{s}$
* $\overline{u}$ і $\overline{w}$ лежати на одному і тому ж шляхи з кореня в суфіксном дереві $ST(\overline{s})$.

Доведення її досить очевидно: якщо початку входжень двох стрічок збігаються, то одна стрічка є префіксом іншої, а, значить, одна стрічка лежить в суфіксном дереві на шляхи іншої стрічки.

**Доведення теореми 1**. 

Состояния суфіксного автомата відповідають вершин суфіксного дерева.

Розглянемо довільну суфіксну посилання $y = link(x)$. Згідно визначенню суфіксному посилання, $longest(y)$ є суфіксом $longest(x)$, причому серед всіх таких $y$ вибирається той, у якого $len(y)$ максимально.

В термінах інвертованою стрічки $\overline{s}$ це означає, що суфіксна посилання $link[x]$ веде в такий довжелезний префікс стрічки, відповідної станом $x$, аби цьому префиксу соответствовало окреме стан $y$. Іншими словами, суфіксна посилання $link[x]$ веде в предка вершини $x$ в суфіксном дереві, що і потрібно довести.

**Доведення теореми 2**.

Состояния суфіксного автомата відповідають вершин суфіксного дерева.

Розглянемо довільний перехід $(x,y,c)$ в суфіксном автоматі $DAWG(s)$. Наличие цього переходу означає, що $y$ - це таке стан, клас еквівалентності якого містить підстрічку $longest(x) + c$. В інвертованою стрічки $\overline{s}$ це означає, що $y$ це таке стан, якому відповідає підстрічка, $firstpos$ від якій (в тексті $\overline{s}$) збігається з $firstpos$ від підстрічки $c + \overline{longest(x)}$.

Це як раз і означає, що:

$$
\overline{longest(y)} = ext[c, \overline{longest(x)}].
$$

Перша частина теореми доведена, залишилося довести одному частина: що всі суцільні переходи в автоматі відповідають суфіксним посиланням в дереві. Сплошной перехід відрізняється від несплошного тим, що $length(y) = length(x) + 1$, тобто після приписування символу $c$ ми потрапили в стан зі рядком, максимальної з класу еквівалентності цього стан. Це означає, що при обчисленні відповідної расширяющей посилання $ext[c, \overline{longest(x)}]$ ми зразу потрапили в вершину дерева, а не спускались вниз до найближчій вершини дерева. Таким чином, приписав один символ в початок, ми потрапили в іншу вершину дерева - значить, якщо це і є инвертированная суфіксна посилання в дереві.

Теорема повністю доведена.

**Теорема 3**. Имея суфіксний автомат $DAWG(s)$, можна за час $O(n)$ побудувати суфіксне дерево $ST(\overline{s})$.

**Теорема 4**. Имея суфіксне дерево $ST(\overline{s})$, можна за час $O(n)$ побудувати суфіксний автомат $DAWG(s)$.

**Доведення теореми 3**.

Суфіксне дерево $ST(\overline{s})$ буде містити стільки ж вершин, скільки станів в $DAWG(s)$, причому вершині дерева, получившейся з стан $v$ автомата, відповідає стрічка довжини $len(v)$.

Згідно теоремі 1, ребра в дереві образуются як инвертированные суфіксние посилання, і дуговые мітки можна знайти, виходячи з різниці $len$ станів, і додатково знаючи для кожного стан автомата один будь-який елемент його множини $endpos$ (цей один елемент множини $endpos$ можна підтримувати при побудові автомата).

Суфіксние посилання в дереві ми можемо побудувати згідно теоремі 2: для цього достатньо переглянути всі суцільні переходи в автоматі, і для кожного такого переходу $(x,y)$ додати посилання $link(y) = x$.

Таким чином, за час $O(n)$ ми можемо побудувати суфіксне дерево разом з суфіксними ссылками в ньому.

(Якщо ми припустимо розмір $k$ алфавіту не константою, то на усе перестроение буде потрібно час $O(n \log k)$).

**Доведення теореми 4**.

Суфіксний автомат $DAWG(s)$ буде містити стільки ж станів, скільки вершин в $ST(\overline{s})$. У кожного стан $v$ його длиннейшая стрічка $longest(v)$ буде відповідати инвертированному шляхи з кореня дерева до вершини $v$.

Згідно теоремі 2, аби побудувати всі переходи в суфіксном автоматі, нам треба знайти всі розширюють посилання $ext[c,v]$.

По-перше, зауважимо, що частина цих расширяющих посилань виходять безпосередньо з суфіксних посилань в дереві. Насправді, якщо для будь-який вершини $x$ ми розглянемо її суфіксну посилання $y = link(x)$, то це означає, що треба провести расширяющую посилання з $y$ в $x$ по першого символу стрічки, відповідної вершині $x$.

Однак так ми найдемо не всі розширюють посилання. Дополнительно треба пройтися по суфіксному дереву від листя до кореня, і для кожної вершини $v$ переглянути всіх її синів, для кожного сина переглянути всі розширюють посилання $ext[c,w]$, і скопировать цю посилання в вершину $v$, якщо по цьому символу $c$ посилання з вершини $v$ ще не була знайдена:

$$ ext[c,v] = ext[c,w], \text{if $ext[c,w] = nil$.} $$

Цей процес відпрацює за час $O(n)$, якщо ми припустимо розмір алфавіту константным.

Нарешті, залишилося побудувати суфіксние посилання в автоматі, однак, згідно теоремі 1, ці суфіксние посилання виходять просто як ребра суфіксного дерева $ST(\overline{s})$.

Таким чином, описаний алгоритм за час $O(n)$ будує суфіксний автомат по суфіксному дереву для інвертованою стрічки.

(Якщо ж ми припустимо, що розмір $k$ алфавіту - також змінна величина, то асимптотика збільшиться до $O(n \log k)$).

## Застосування при рішенні задач

Нижче ми розглянемо, які задачі можна розв'язувати з допомогою суфіксного автомата.

Ми для простоти будемо вважати розмір алфавіту $k$ константою, що дозволить нам вважати асимптотику побудови суфіксного автомата і проходу по нього константными.

### Перевірка входження

**Умова**. Дан текст $T$, і надходять запити в вигляді: дана стрічка $P$, потрібно перевірити, входити або ні стрічка $P$ в текст $T$ як підстрічка.

**Асимптотика**. Препроцесинг $O(length (T))$ і $O(length (P))$ на один запит.

**Розв'язок**. Побудуємо суфіксний автомат по тексту $T$ за час $O(length (T))$.

Як тепер відповідати на один запит. Нехай поточний стан - це змінна $v$, спершу вона рівна начальному станом $t_0$. Будемо йти по символам стрічки $P$, відповідним чином роблячи перехід з поточного стан $v$ в нове стан. Якщо в якийсь момент случилось, що переходу з поточного стан по нужному символу не виявилося - то відповідь на запит "ні". Якщо ж ми змогли обробити всю стрічку $P$, то відповідь на запит "да".

Зрозуміло, що це буде працювати за час $O(length (P))$. Більш того, алгоритм фактично шукає довжину наидлиннейшего префікса $P$, встречающегося в тексті - і якщо вхідні зразки такі, що ці довжини маленькі, то і алгоритм буде працювати значно швидше, не обрабатывая всю стрічку цілком.

### Кількість різних підстрічок

**Умова**. Дана стрічка $S$. Потрібно дізнатися кількість різних її підстрічок.

**Асимптотика**. $O(length (S))$.

**Розв'язок**. Побудуємо суфіксний автомат по стрічки $S$.

В суфіксном автоматі будь-який підрядку стрічки $S$ відповідає якийсь шлях в автоматі. Оскільки повторюваних стрічок в автоматі бути не можливо, то відповідь на задачу - це **кількість різних шляхів** в автоматі, починаються в початкової вершині $t_0$.

Враховуючи, що суфіксний автомат представляє собою ациклічний граф, кількість різних шляхів можна вважати в ньому з допомогою динамічного програмування.

А саме, нехай $d[v]$ - це кількість різних шляхів, починаються з стан $v$ (включаючи шлях довжини нуль). Значить вірно:

$$
d[v] = 1 + \sum_{w ~ : \atop (v,w,c) \in DAWG} d[w],
$$

тобто $d[v]$ можна выразить як суму відповідей по всіляких переходам з стан $v$.

Відповіддю на задачу буде значення $d[t_0]-1$ (одиниця віднімається, аби не враховувати пусту підстрічку).

### Суммарная довжина різних підстрічок

**Умова**. Дана стрічка $S$. Потрібно дізнатися сумарну довжину всіх різних її підстрічок.

**Асимптотика**. $O(length (S))$.

**Розв'язок**. Розв'язок задачі аналогічно попередньою, тільки тепер треба вважати в динаміці дві величини: кількість різних підстрічок $d[v]$ і їх сумарну довжину $ans[v]$.

Як вважати $d[v]$, описано в попередньою задачі, а величину $ans[v]$ можна обчислити таким чином:

$$
ans[v] = \sum_{w ~ : \atop (v,w,c) \in DAWG} d[w] + ans[w],
$$

тобто ми беремо відповідь для кожної вершини $w$, і додаємо до нього $d[w]$, тим самим як б приписывая в початок кожної з стрічок по одному символу.

### Лексикографически k-ая підстрічка

**Умова**. Дана стрічка $S$. Надходять запити - числа $K_i$, і потрібно знаходити $K_i$-ую в порядку сортування підстрічку стрічки $S$.

**Асимптотика**. $O(length (ans) \cdot Alphabet)$ на один запит (де $ans$ - це відповідь на цей запит, $Alphabet$ - розмір алфавіту).

**Розв'язок**. Розв'язок даній задачі базируется на тією ж ідеї, що і попередні дві задачі. Лексикографически $k$-ая підстрічка - це лексикографический $k$-ый шлях в суфіксном автоматі. Тому вважаючи для кожного стан кількість шляхів з нього, ми зможемо легко шукати $k$-ый шлях, рухаючись від кореня автомата.

### Найменший циклічний зсув

**Умова**. Дана стрічка $S$. Потрібно знайти лексикографічно найменший її циклічний зсув.

**Асимптотика**. $O(length (S))$.

**Розв'язок**. Побудуємо суфіксний автомат для стрічки $S+S$. Значить цей автомат буде містити в собі як шляхи всі циклічні зрушення стрічки $S$.

Отже, задача сведётся до тому, аби знайти в автоматі лексикографічно мінімальний шлях довжини $length(S)$, що робиться тривіальним чином: ми стартуємо в начальном стані і кожний раз діємо жадібно, переходячи по переходу з мінімальним символом.

### Кількість входжень

**Умова**. Дан текст $T$, і надходять запити в вигляді: дана стрічка $P$, потрібно дізнатися, скільки раз стрічка $P$ входити в текст $T$ як підстрічка (входження можуть перекрываться).

**Асимптотика**. Препроцесинг $O(length (T))$ і $O(length (P))$ на один запит.

**Розв'язок**. Побудуємо суфіксний автомат по тексту $T$. 

Далі нам треба зробити такий препроцесинг: для кожного стан $v$ автомата порахувати число $cnt[v]$, рівне размеру множини $endpos(v)$. Насправді, всі стрічки, відповідні одному і тому ж станом, входять в $T$ однакове число раз, рівне кількості позицій в множині $endpos$.

Однак явно підтримувати множини $endpos$ для всіх станів ми не можемо, тому навчимося вважати тільки їх розміри $cnt$.

Для цього вчинимо наступним чином. Для кожного стан, якщо воно не було отримано шляхом клонування (і початкова стан $t_0$ ми також не враховуємо), спершу дамо $cnt = 1$. Потім будемо йти по всім состояниям в порядку зменшення їх довжини $len$ і пробрасывать поточний значення $cnt[v]$ по суфіксному посиланню:

$$
cnt[link(v)] += cnt[v].
$$

Стверджується, що в наприкінці кінців ми так порахуємо для кожного стан правильні значення $cnt$.

Чому це вірно? Всього станів, отриманих не шляхом клонування, рівне $length(S)$, і $i$-е з них з'явилося, коли ми додали перші $i$ символів. Отже, кожному з цих станів ми ставимо в відповідність цю позицію, при обробці якій воно з'явилося. Тому спершу у кожного такого стан $cnt = 1$, а у всіх інших станів $cnt = 0$.

Потім ми виконуємо для кожного $v$ таку операцію: $cnt[link(v)] += cnt[v]$. Смысл цього полягає в тому, що якщо стрічка, відповідна станом $v$, встречалась $cnt[v]$ раз, то всі її суфікси будуть зустрічатися стільки ж.

Чому тим самим ми не учтём одну і ту ж позицію декілька раз? Потому що з кожного стан його значення "пробрасывается" тільки один раз, тому не могло так вийти, що з одного стан його значення "пробросилось" до якогось іншого стан двічі, двома різними шляхами.

Таким чином, ми навчилися вважати ці величини $cnt$ для всіх станів автомата.

Після цього відповідь на запит тривиален - треба просто повернути $cnt[t]$, де $t$ - стан, відповідне зразком $P$.

### Позиция першого входження

**Умова**. Дан текст $T$, і надходять запити в вигляді: дана стрічка $P$, потрібно дізнатися позицію початку першого входження стрічки $P$.

**Асимптотика**. Препроцесинг $O(length (T))$ і $O(length (P))$ на один запит.

**Розв'язок**. Побудуємо суфіксний автомат по тексту $T$.

Для розв'язку задачі нам також треба додати в препроцесинг знаходження позицій $firstpos$ для всіх станів автомата, тобто для кожного стан $v$ ми хочемо знайти позицію $firstpos[v]$ закінчення першого входження. Іншими словами, ми хочемо знайти заздалегідь мінімальний елемент кожного з множин $endpos(v)$ (оскільки явно підтримувати всі множини $endpos$ ми не можемо).

**Поддерживать** ці позиції $firstpos$ простіше всього прямо по ходу побудови автомата: коли ми створюємо нове стан $cur$ при в ході в функцію $sa\_extend()$, то выставляем йому:

$$
firstpos(cur) = len(cur) - 1
$$

(якщо ми працюємо в $0$-індексації).

При клонировании вершини $q$ в $clone$ ми ставимо:

$$
firstpos(clone) = firstpos(q),
$$

(оскільки іншої різновид значення тільки один - це $firstpos(cur)$, що явно більше).

Таким чином, відповідь на запит - це просто $firstpos(t)-length(P)+1$, де $t$ - стан, відповідне зразком $P$.

### Позиції всіх входжень

**Умова**. Дан текст $T$, і надходять запити в вигляді: дана стрічка $P$, потрібно вивести позиції всіх її входжень в стрічку $T$ (входження могу перекрываться).

**Асимптотика**. Препроцесинг $O(length (T))$. Відповідь на один запит за $O(length (P) + answer (P))$, де $answer(P)$ - це розмір відповіді, тобто ми будемо розв'язувати задачу за час порядку розміру ввода і виведення.

**Розв'язок**. Побудуємо суфіксний автомат по тексту $T$. Аналогічно попередньою задачі, порахуємо в процесі побудови автомата для кожного стан позицію $firstpos$ закінчення першого входження.

Нехай тепер надійшов запит - стрічка $P$. Знайдемо, якого станом $t$ вона відповідає.

Зрозуміло, що $firstpos(t)$ точно має входити в відповідь. Які ще позиції треба знайти? Ми учли стан автомата, содержащее стрічку $P$, однак не учли інші стан, яким відповідають такі стрічки, що $P$ є їх суфіксом.

Іншими словами, нам потрібно знайти всі стан, з яких **досяжно по суфіксним посиланням** стан $t$.

Отже, для розв'язку задачі нам буде потрібно зберегти для кожного стан список суфіксних посилань, провідних в нього. Відповідь на запит тоді буде полягати в тому, аби зробити **обхід в глибину/в ширину** по цим инвертированным суфіксним посиланням, починаючи з стан $t$.

Цей обхід буде працювати за час $O(answer (P))$, оскільки ми не посетим одне і то ж стан двічі (тому що з кожного стан суфіксна посилання виходить тільки одна, тому не можливо бути двох шляхів, провідних в одне і то ж стан).

Правда, треба враховувати, що у двох станів їх значення $firstpos$ **можуть збігатися**: якщо одне стан було отримано клонированием іншого. Однак це не ухудшает асимптотику, оскільки у кожної не-клонированной вершини можливо бути максимум один клон.

Більш того, можна легко позбутися від виведення повторюваних позицій, якщо ми не будемо додавати в відповідь $firstpos$ від станів-клонов. Насправді, в будь-яке стан-клон веде суфіксна посилання з того первоначального стан, яке це стан клонировало. Таким чином, якщо ми для кожного стан запам'ятаємо прапор $is\_clon$, і не будемо додавати в відповідь $firstpos$ від станів, для яких $is\_clon = true$, то ми тим самим отримаємо всі необхідні $answer (P)$ позицій без повторів.

Наведемо наброски реалізації:

<!--- TODO: specify code snippet id -->
``` cpp
struct state {
    ...
    bool is_clon;
    int first_pos;
    vector<int> inv_link;
};

... після побудови автомата ...
for (int v=1; v<sz; ++v)
    st[st[v].link].inv_link.push_back (v);
...

// відповідь на запит - висновок всіх входжень (можливо, з повторами)
void output_all_occurences (int v, int P_length) {
    if (! st[v].is_clon)
        cout << st[v].first_pos - P_length + 1 << endl;
    for (size_t i=0; i<st[v].inv_link.size(); ++i)
        output_all_occurences (st[v].inv_link[i], P_length);
}
```

### Пошук найкоротшою стрічки, не входящей в дану

**Умова**. Дана стрічка $S$, і завдань определённый алфавит. Потрібно знайти таку стрічку найменшою довжини, що вона не зустрічається в $S$ як підстрічка.

**Асимптотика**. Розв'язок за $O(length (S))$.

**Розв'язок**. Розв'язувати буде динамическим програмування по автомату, построенному для стрічки $S$.

Нехай $d[v]$ - це відповідь для вершини $v$, тобто ми вже набрали частина підстрічки, оказавшись в стані $v$, і хочемо знайти найменше число символів, яке треба ще додати, аби вийти за межі автомата, знайшовши несуществующий перехід.

Вважається $d[v]$ дуже просто. Якщо з $v$ ні переходу хоча б по одному символу з алфавіту, то $d[v] = 1$: ми можемо приписать такий символ і вийти за межі автомата, отримавши тим самим шукану стрічку.

В іншому випадку, одним символом обійтися не вийде, тому треба взяти мінімум з відповідей по всіляких символам:

$$
d[v] = 1 + \min_{w ~ : \atop (v,w,c) \in DAWG} d[w].
$$

Відповідь на задачу буде рівний $d[t_0]$, а саму стрічку можна відновити, восстановив, яким чином в динаміці вийшов цей мінімум.

### Наидлиннейшая загальна підстрічка двох стрічок

**Умова**. Дано дві стрічки $S$ і $T$. Потрібно знайти їх найдовшу загальну підстрічку, тобто таку стрічку $X$, що вона є підрядком і $S$, і $T$.

**Асимптотика**. Розв'язок за $O(length(S) + length(T))$.

**Розв'язок**. Побудуємо суфіксний автомат по стрічки $S$.

Будемо тепер йти по стрічки $T$, і для кожного префікса шукати наідліннейшій суфікс цього префікса, встречающийся в $S$. Іншими словами, ми для кожної позиції в стрічки $T$ хочемо знайти найдовшу загальну підстрічку $S$ і $T$, заканчивающуюся саме в цій позиції.

Для цього будемо підтримувати дві змінні: **поточний стан** $v$ і **поточну довжину** $l$. Ці дві змінні будуть описувати поточну збігається частина: її довжину і стан, яке відповідає їй (без зберігання довжини не можна обійтися, оскільки одному станом можливо відповідати зразу декілька стрічок разной довжини).

Cпершу $p=t_0$, $l=0$, тобто збіг порожнє.

Нехай тепер ми розглядаємо символ $T[i]$ і хочемо перерахувати відповідь для нього.

* Якщо з стан $v$ в автоматі є перехід по символу $T[i]$, то ми просто совершаем цей перехід і збільшуємо $l$ на одиницю.

* Якщо ж з стан $v$ ні требуемого переходу, то ми повинні спробувати укоротить поточну збігається частина, для чого треба перейти по суфіксному посиланню:

$$
v = link(v).
$$

При цим поточну довжину треба укоротить, але залишити максимально возможной. Очевидно, для цього треба присвоїти $l = len(v)$, оскільки після проходу по суфіксному посиланню нас удовлетворит підстрічка будь-який довжини, відповідна цьому станом:

$$
l = len(v).
$$

Якщо з нового стан вновь не буде переходу по требуемому символу, то ми знову повинні пройти по суфіксному посиланню і зменшити $l$, і так далі, поки не найдемо перехід (тоді перейдемо до пункту 1) або ми не попадём в фіктивне стан $-1$ (що означає, що символ $T[i]$ взагалі не зустрічається в $S$, тому присвоюємо $v=l=0$ і переходимо до наступного $i$).

Відповіддю на задачу буде максимум з значень $l$ за усе час обходу.

Асимптотика такого проходу становить $O(length (T))$, оскільки за один хід ми можемо або збільшити на одиницю $l$, або зробити декілька проходов по суфіксному посиланню, кожний з яких буде строго зменшувати значення $l$. Отже, зменшень не могло бути більше $length (T)$, що і означає лінійну асимптотику.

Реалізація:

<!--- TODO: specify code snippet id -->
``` cpp
string lcs (string s, string t) {
    sa_init();
    for (int i=0; i<(int)s.length(); ++i)
        sa_extend (s[i]);

    int v = 0,  l = 0,
        best = 0,  bestpos = 0;
    for (int i=0; i<(int)t.length(); ++i) {
        while (v && ! st[v].next.count(t[i])) {
            v = st[v].link;
            l = st[v].length;
        }
        if (st[v].next.count(t[i])) {
            v = st[v].next[t[i]];
            ++l;
        }
        if (l > best)
            best = l,  bestpos = i;
    }
    return t.substr (bestpos-best+1, best);
}
```

### Наибольшая загальна підстрічка декількох стрічок.

**Умова**. Дано $K$ стрічок $S_i$. Потрібно знайти їх найдовшу загальну підстрічку, тобто таку стрічку $X$, що вона є підрядком всіх $S_i$.

**Асимптотика**. Розв'язок за $O(\sum length(S_i) \cdot K)$.

**Розв'язок**. Склеим всі стрічки $S_i$ в одну стрічку $T$, приписав після кожної стрічки $S_i$ свій власний символ-роздільник $D_i$ (тобто введя $K$ додаткових спец. символів $D_i$):

$$
T = S_1 ~ D_1 ~ S_2 ~ D_2 ~ \ldots ~ S_k D_k.
$$

Побудуємо для стрічки $T$ суфіксний автомат.

Тепер нам потрібно знайти таку стрічку в автоматі, яка міститься у всіх рядках $S_i$, і в цим нам помогут добавленные спец. символи. Зауважимо, що якщо яка-або підстрічка входити в деяку стрічку $S_j$, то в суфіксном автоматі з цій підстрічки знайдеться шлях, що містить символ $D_j$, і не що містить інших символів $D_1, \ldots, D_{j-1}, D_{j+1}, \ldots, D_k$.

Таким чином, нам потрібно порахувати достижимости: для кожного стан автомата і кожного символу $D_i$ є або шлях, що містить роздільник $D_i$, і не що містить інших разделителей. Це легко зробити обходом в глибину/ширину або ледачою динамікою. Після цього відповіддю на задачу буде стрічка $longest(v)$ для стан $v$, з якого були найдены шляхи по всім символам.

## Задачі в online judges

Задачі, які можна розв'язати з допомогою суфіксного автомата:

* [SPOJ #7258 SUBLEX **"Lexicographical Substring Search"** [складність: середня]](http://www.spoj.pl/problems/SUBLEX/)

## Література

Наведемо спочатку список перших работ, пов'язаних з суфіксними автоматами:

* A. Blumer, J. Blumer, A. Ehrenfeucht, D. Haussler, R. McConnell. **Linear Size Finite Automata for the Set of All Subwords of a Word. An Outline of Results** [1983]

* A. Blumer, J. Blumer, A. Ehrenfeucht, D. Haussler. **The Smallest Automaton Recognizing the Subwords of a Text** [1984]

* Maxime Crochemore. **Optimal Factor Transducers** [1985]

* Maxime Crochemore. **Transducers and Repetitions** [1986]

* A. Nerode. **Linear automaton transformations** [1958]

Крім цього, в більш сучасних источниках ця тема затрагивается у багатьох книгах по строковым алгоритмам:

* Maxime Crochemore, Wowjcieh Rytter. **Jewels of Stringology** [2002]

* Bill Smyth. **Computing Patterns in Strings** [2003]

* Билл Смит. **Методы і алгоритми обчислень на рядках** [2006]
