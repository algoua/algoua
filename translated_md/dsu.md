# Система що не перетинаються множин

В даній статті розглядається структура данних **"система що не перетинаються множин"** (на англійською "disjoint-set-union", або просто "DSU").

Ця структура данних предоставляет наступні возможности. Cпершу є декілька елементів, кожний з яких знаходиться в окремому (своєму собственном) множині. За одну операцію можна **об'єднати два яких-або множини**, а також можна **запросить, в якому множині** зараз знаходиться зазначений елемент. Також, в классическом варіанті, вводиться ще одна операція - создание нового елементу, який поміщається в окреме множину.

Таким чином, базовый интерфейс даній структури данних складається всього з трьох операцій:

* ${\rm make\_set}(x)$ - **додає** новий елемент $x$, поміщаючи його в нове множину, що складається з одного нього.

* ${\rm union\_sets}(x,y)$ - **об'єднує** два указанных множини (множину, в якому знаходиться елемент $x$, і множину, в якому знаходиться елемент $y$).

* ${\rm find\_set}(x)$ - **повертає, в якому множині** знаходиться зазначений елемент $x$. Насправді при цим повертається один з елементів множини (званий **представителем** або **лідером** (в англоязычной літературі "leader")). Цей представник вибирається в кожному множині самою структурою данних (і можливо змінюватися з течением часу, а саме, після викликів ${\rm union\_sets}()$).

Наприклад, якщо виклик ${\rm find\_set}()$ для якихось двох елементів вернул одне і то ж значення, то це означає, що ці елементи знаходяться в одному і тому ж множині, а в іншому випадку - в різних множинах.

Описываемая нижче структура данних дозваляє робити кожну з цих операцій майже за $O(1)$ в середньому (більш детально про асимптотиці див. нижче після опису алгоритму).

Також в одному з подразделов статті описаний альтернативний різновид реалізації DSU, дозволяє домогтися асимптотики $O(\log n)$ в середньому на один запит при $m \ge n$; а при $m >> n$ (тобто $m$ значно більше $n$) - і зовсім часу $O(1)$ в середньому на запит (див. "Зберігання DSU в вигляді явного списку множин").

## Побудова ефективної структури данних

Определимся спочатку, в якому вигляді ми будемо зберігати всю інформацію.

Множества елементів ми будемо зберігати в вигляді **дерев**: одне дерево відповідає одному безлічі. Корень дерева - це представник (лідер) множини.

При реалізації це означає, що ми заводим масив ${\rm parent}$, в якому для кожного елементу ми зберігаємо посилання на його предка в дерева. Для коренів дерев будемо вважати, що їх предок - вони самі (тобто посилання зацикливается в цим місці).

### Наивная реалізація

Ми вже можемо написати першу реалізацію системи що не перетинаються множин. Вона буде досить неэффективной, але потім ми улучшим її з допомогою двох приёмов, отримавши в підсумку майже константне час роботи.

Отже, вся інформація про множинах елементів зберігається у нас з допомогою масиву ${\rm parent}$.

Щоб створити новий елемент (операція ${\rm make\_set}(v)$), ми просто створюємо дерево з коренем в вершині $v$, отмечая, що її предок - це вона сама.

Щоб об'єднати два множини (операція ${\rm union\_sets}(a,b)$), ми спочатку найдемо лидеров множини, в якому знаходиться $a$, і множини, в якому знаходиться $b$. Якщо лидеры збіглися, то нічого не робимо - це значить, що множини і так вже були объединены. В іншому випадку можна просто вказати, що предок вершини $b$ рівний $a$ (або навпаки) - тим самим присоединив одне дерево до іншому.

Нарешті, реалізація операції пошуку лідера (${\rm find\_set}(v)$) проста: ми піднімаємося по предкам від вершини $v$, поки не дійдемо до кореня, тобто поки посилання на предка не веде в собі. Цю операцію зручніше реалізувати рекурсивно (особливо це буде зручно пізніше, в зв'язку з добавляемыми оптимизациями).

<!--- TODO: specify code snippet id -->
``` cpp
void make_set(int v) { parent[v] = v; }

int find_set(int v) {
    if (v == parent[v])
        return v;
    return find_set(parent[v]);
}

void union_sets(int a, int b) {
    a = find_set(a);
    b = find_set(b);
    if (a != b)
        parent[b] = a;
}
```

Втім, така реалізація системи що не перетинаються множин вельми **неэффективна**. Легко побудувати приклад, коли після декількох объединений множин вийде ситуація, що множину - це дерево, выродившееся в довгу ланцюжок. В результаті кожний виклик ${\rm find\_set}()$ буде працювати на такому тесті за час порядку глибини дерева, тобто за $O(n)$.

Це вельми далеко від тією асимптотики, яку ми собирались получити (константне час роботи). Тому розглянемо дві оптимізації, які позволят (навіть применённые по окремо) значно прискорити роботу.

### Евристика стиснення шляхи

Ця евристика предназначена для прискорення роботи ${\rm find\_set}()$.

Вона полягає в тому, що коли після виклику ${\rm find\_set}(v)$ ми найдемо шуканого лідера $p$ множини, то запам'ятаємо, що у вершини $v$ і всіх пройдених по шляхи вершин - саме цей лідер $p$. Простіше всього це зробити, перенаправив їх ${\rm parent}[]$ на цю вершину $p$.

Таким чином, у масиву предків ${\rm parent}[]$ сенс декілька змінюється: тепер це **сжатый масив предків**, тобто для кожної вершини там можливо зберігатися не непосредственный предок, а предок предка, предок предка предка, і т.д.

З іншої сторони, зрозуміло, що не можна зробити, аби ці вказівники ${\rm parent}$ завжди указывали на лідера: інакше при виконанні операції ${\rm union\_sets}()$ довелося б оновлювати лидеров у $O(n)$ елементів.

Таким чином, до масиву ${\rm parent}[]$ випливає подходить саме як до масиву предків, можливо, частково сжатому.

Новая реалізація операції ${\rm find\_set}()$ виглядає наступним чином:

<!--- TODO: specify code snippet id -->
``` cpp
int find_set(int v) {
    if (v == parent[v])
        return v;
    return parent[v] = find_set(parent[v]);
}
```

Така проста реалізація робить усе, що задумывалось: спочатку шляхом рекурсивних викликів знаходиться лідера множини, а потім, в процесі раскрутки стека, цей лідер присваивается посиланням ${\rm parent}$ для всіх пройдених елементів.

Реалізувати цю операцію можна і нерекурсивно, але тоді доведеться осуществлять два проходу по дереву: перший знайде шуканого лідера, другий - проставит його всім вершин шляхи. Втім, на практиці нерекурсивная реалізація не дає существенного выигрыша.

#### Оцінка асимптотики при застосуванні евристики стиснення шляхи

Покажемо, що застосування однієї евристики стиснення шляхи **дозваляє досягти логарифмическую асимптотику**: $O(\log n)$ на один запит в середньому.

Зауважимо, що, оскільки операція ${\rm union\_sets}()$ представляє з собі два виклику операції ${\rm find\_set}()$ і ще $O(1)$ операцій, то ми можемо сосредоточиться в доведенні тільки на оцінку часу роботи $O(m)$ операцій ${\rm find\_set}()$.

Назвемо **вагою** $w[v]$ вершини $v$ число нащадків цій вершини (включаючи її саму). Веса вершин, очевидно, можуть тільки збільшуватися в процесі роботи алгоритму.

Назвемо **размахом ребра** $(a,b)$ різницю ваг кінців цього ребра: $|w[a] - w[b]|$ (очевидно, у вершини-предка вага завжди більше, ніж у вершини-нащадка). Можна замітити, що размах какого-або фіксованого ребра $(a,b)$ можливо тільки збільшуватися в процесі роботи алгоритму.

Крім того, розіб'ємо ребра на **класи**: будемо говорити, що ребро має клас $k$, якщо його размах належить відрізку $[2^k; 2^{k+1}-1]$. Таким чином, клас ребра - це число від $0$ до $\lceil \log n \rceil$.

Зафіксуємо тепер довільну вершину $x$ і будемо следить, як змінюється ребро в її предка: спочатку воно відсутній (поки вершина $x$ є лідером), потім проводиться ребро з $x$ в якусь вершину (коли множину з вершиною $x$ приєднується до іншому безлічі), і потім можливо змінюватися при стисканні шляхів в процесі викликів ${\rm find\_path}$. Зрозуміло, що нас цікавить асимптотика тільки останнього випадку (при стисканні шляхів): всі інші випадки требуют $O(1)$ часу на один запит.

Розглянемо роботу деякого виклику операції ${\rm find\_set}$: він проходити в дереві уздовж деякого **шляхи**, стирая всі ребра цього шляхи і перенаправляючи їх в лідера.

Розглянемо цей шлях і **исключим** з розгляду останнє ребро кожного класу (тобто не більш ніж по одному ребру з класу $0, 1, \ldots \lceil \log n \rceil$). Тим самим ми исключили $O(\log n)$ ребер з кожного запиту.

Розглянемо тепер всі **інші** ребра цього шляхи. Для кожного такого ребра, якщо воно має клас $k$, виходить, що в цим шляхи є ще одне ребро класу $k$ (інакше ми були б зобов'язані виключити поточний ребро, як єдиного представника класу $k$). Таким чином, після стиснення шляхи це ребро заменится на ребро класу як мінімум $k+1$. Враховуючи, що зменшуватися вага ребра не можливо, ми отримуємо, що для кожної вершини, затронутой запитом $\rm find\_path$, ребро в її предка або було исключено, або строго увеличило свій клас.

Звідси ми остаточно отримуємо асимптотику роботи $m$ запитів: $O((n+m) \log n)$, що (при $m \ge n$) означає логарифмічна час роботи на один запит в середньому.

### Евристика про'єднання по рангу

Розглянемо тут іншу евристику, яка сама по собі здатна прискорити час роботи алгоритму, а в сочетании з евристикою стиснення шляхів і зовсім здатна досягти практично константного часу роботи на один запит в середньому.

Ця евристика полягає в небольшом зміні роботи ${\rm union\_sets}$: якщо в наивной реалізації то, яке дерево буде присоединено до якого, визначається випадково, то тепер ми будемо це робити на основі **рангов**.

Є два варіанти рангової евристики: в одному варіанті рангом дерева називається **кількість вершин** в ньому, в другом - **глибина дерева** (точніше, верхняя межа на глибину дерева, оскільки при совместном застосуванні евристики стиснення шляхів реальная глибина дерева можливо зменшуватися).

В обох вариантах суть евристики одна і та ж: при виконанні $\rm union\_sets$ будемо присоединять дерево з меншим рангом до дереву з великим рангом.

Наведемо реалізацію **рангової евристики на основі розмірів дерев**:

<!--- TODO: specify code snippet id -->
``` cpp
void make_set(int v) {
    parent[v] = v;
    size[v] = 1;
}

void union_sets(int a, int b) {
    a = find_set(a);
    b = find_set(b);
    if (a != b) {
        if (size[a] < size[b])
            swap(a, b);
        parent[b] = a;
        size[a] += size[b];
    }
}
```

Наведемо реалізацію **рангової евристики на основі глибини дерев**:

<!--- TODO: specify code snippet id -->
``` cpp
void make_set(int v) {
    parent[v] = v;
    rank[v] = 0;
}

void union_sets(int a, int b) {
    a = find_set(a);
    b = find_set(b);
    if (a != b) {
        if (rank[a] < rank[b])
            swap(a, b);
        parent[b] = a;
        if (rank[a] == rank[b])
            ++rank[a];
    }
}
```

Обидва варіанти рангової евристики є еквівалентними з точки зору асимптотики, тому на практиці можна застосовувати будь-яку з них.

#### Оцінка асимптотики при застосуванні рангової евристики

Покажемо, що асимптотика роботи системи що не перетинаються множин при використанні тільки рангової евристики, без евристики стиснення шляхів, буде **логарифмічною** на один запит в середньому: $O(\log n)$.

Тут ми покажемо, що при будь-якому з двох варіантів рангової евристики глибина кожного дерева буде величиною $O(\log n)$, що автоматично буде означати логарифмическую асимптотику для запиту $\rm find\_set$, і, отже, запиту $\rm union\_sets$.

Розглянемо **рангову евристику по глубине дерева**. Покажемо, що якщо ранг дерева рівний $k$, то це дерево містить як мінімум $2^k$ вершин (звідси буде автоматично дотримуватися, що ранг, а, значить, і глибина дерева, є величина $O(\log n)$). Доводити будемо по індукції: для $k=0$ це очевидно. При стисканні шляхів глибина можливо тільки зменшитися. Ранг дерева збільшується з $k-1$ до $k$, коли до нього приєднується дерево рангу $k-1$; застосовуючи до цим двом деревам розміру $k-1$ припущення індукції, отримуємо, що нове дерево рангу $k$ дійсно буде мати як мінімум $2^k$ вершин, що і потрібно довести.

Розглянемо тепер **рангову евристику по размерам дерев**. Покажемо, що якщо розмір дерева рівний $k$, то його висота не більш $\lfloor \log k \rfloor$. Доводити будемо по індукції: для $k=1$ твердження вірно. При стисканні шляхів глибина можливо тільки зменшитися, тому стиснення шляхів нічого не нарушает. Нехай тепер об'єднуються два дерева розмірів $k_1$ і $k_2$; тоді по припущенням індукції їх висоти менше або рівні, відповідно, $\lfloor \log k_1 \rfloor$ і $\lfloor \log k_2 \rfloor$. Чи Не втрачаючи спільності, припустимо, що перший дерево - більше ($k_1 \ge k_2$), тому після про'єднання глибина отриманого дерева з $k_1+k_2$ вершин стане рівна:

$$
h = \max ( \lfloor \log k_1 \rfloor, 1 + \lfloor \log k_2 \rfloor ).
$$

Щоб завершити доведення, треба показати, що:

$$
h ~ \stackrel{?}{\le} ~ \lfloor \log (k_1+k_2) \rfloor,
$$

$$
2^h = \max ( 2 ^ {\lfloor \log k_1 \rfloor}, 2 ^ {\lfloor \log 2 k_2 \rfloor} ) ~ \stackrel{?}{\le} ~ 2 ^ {\lfloor \log (k_1+k_2) \rfloor},
$$

що є майже очевидне нерівність, оскільки $k_1 \le k_1+k_2$ і $2 k_2 \le k_1+k_2$.

### Объединение евристик: стиснення шляхи плюс ранговая евристика

Як вже згадувалося вище, совместное застосування цих евристик дає особливо наилучший результат, в підсумку достигая практично константного часу роботи.

Ми не будемо приводити тут доведення асимптотики, оскільки воно вельми объёмно (див., наприклад, Кормен, Лейзерсон, Рівест, Штайн "Алгоритми. Побудова і аналіз"). Впервые це доведення було проведено Тарьяном (1975 г)..

Окончательный результат такий: при совместном застосуванні евристик стиснення шляхи і про'єднання по рангу час роботи на один запит виходить $O(\alpha(n))$ в середньому, де $\alpha(n)$ - **зворотна функція Аккермана**, яка растёт дуже повільно, настільки повільно, що для всіх розумних обмежень $n$ вона **не перевершує 4** (приблизно для $n \le 10^{600}$).

Саме тому про асимптотику роботи системи що не перетинаються множин уместно говорити "майже константне час роботи".

Наведемо тут **підсумкову реалізацію системи що не перетинаються множин**, реализующую обидві зазначені евристики (використовується ранговая евристика щодо глубин дерев):

<!--- TODO: specify code snippet id -->
``` cpp
void make_set (int v) {
    parent[v] = v;
    rank[v] = 0;
}

int find_set(int v) {
    if (v == parent[v])
        return v;
    return parent[v] = find_set(parent[v]);
}

void union_sets (int a, int b) {
    a = find_set (a);
    b = find_set (b);
    if (a != b) {
        if (rank[a] < rank[b])
            swap (a, b);
        parent[b] = a;
        if (rank[a] == rank[b])
            ++rank[a];
    }
}
```

## Застосування в завданнях і різних поліпшення

В цим розділі ми розглянемо декілька застосувань структури данних "система що не перетинаються множин", як тривіальних, так і использующих деякі поліпшення структури данних.

### Підтримка компонент зв'язності графа

Це одне з очевидных додатків структури данних "система що не перетинаються множин", яке, по всій видимості, і стимулировало вивчення цій структури.

**Формально** задачу можна сформулировать таким чином: спершу дано порожній граф, поступово в цей граф можуть додаватися вершини і неориентированные ребра, а також надходять запити $(a,b)$ - "в однакових або компонентах зв'язності лежати вершини $a$ і $b$?".

Безпосередньо застосовуючи тут описану вище структуру данних, ми отримуємо розв'язок, яке обробляє один запит на додавання вершини/ребра або запит на перевірку двох вершин - за майже константне час в середньому.

Враховуючи, що практично в точності така ж задача ставиться при використанні [**алгоритму Крускала знаходження мінімального остовного дерева**](mst_kruskal), ми зразу ж отримуємо [улучшенную версію цього алгоритму](mst_kruskal_with_dsu), работающую практично за лінійне час.

Іноді на практиці зустрічається **инвертированная версія цій задачі**: спершу є граф з якимись вершинами і ребрами, і надходять запити на видалення ребер. Якщо задача дана в офлайн, тобто ми заздалегідь можемо дізнатися всі запити, то розв'язувати цю задачу можна наступним чином: перевернём задачу задом наперёд: будемо вважати, що у нас є порожній граф, в який можуть додаватися ребра (спочатку додамо ребро останнього запиту, потім предпоследнего, і т.д).. Тим самим в результаті инвертирования цій задачі ми прийшли до звичайної задачі, розв'язок якій описывалось вище.

### Пошук компонент зв'язності на изображении

Одне з лежачих на поверхні застосувань DSU полягає в рішенні наступного задачі: є зображення $n \times m$ пикселей. Cпершу усе зображення белое, але потім на ньому малюється декілька чорних пикселей. Потрібно визначити розмір кожної "білою" компоненти зв'язності на итоговом изображении.

Для розв'язку ми просто перебираємо всі білі клітини изображения, для кожної клітини перебираємо її чотирьох сусідів, і якщо сосед теж белый - то викликаємо ${\rm union\_sets}()$ від цих двох вершин. Таким чином, у нас буде DSU з $nm$ вершинами, відповідними пикселям изображения. Получившиеся в підсумку дерева DSU - і є шукані компоненти зв'язності.

Дану задачу можна розв'язати простіше з використанням [обходу в глибину](dfs) (або [обходу в ширину](bfs)), однак у описаного тут методу є певне преимущество: воно можливо обробляти матрицю построчно (оперируя тільки з поточній рядком, попередньою рядком і системою що не перетинаються множин, побудованої для елементів однієї рядка), тобто використовуючи порядку $O(\min (n, m))$ пам'яті.

### Підтримка додаткової інформації для кожного множини

"Система що не перетинаються множин" дозваляє легко зберігати будь-яку додаткову інформацію, относящуюся до безлічам.

Простий приклад - це **розміри множин**: як їх зберігати, було описано при описі рангової евристики (інформація там записывалась для поточного лідера множини).

Таким чином, разом з лідером кожного множини можна зберігати будь-яку додаткову необхідну в конкретної задачі інформацію.

### Застосування DSU для стиснення "прыжков" по відрізку. Задача про фарбування підвідрізків в офлайні

Одне з поширених застосувань DSU полягає в тому, що якщо є набір елементів, і з кожного елементу виходить по одному ребру, то ми можемо швидко (за майже константне час) знаходити конечную точку, в яку ми попадём, якщо будемо рухатися уздовж ребер з заданої початкової точки.

Наглядным прикладом цього застосування є **задача про фарбування підвідрізків**: є відрізок довжини $L$, кожна клітина якого (тобто кожний кусочек довжини $1$) має нульовий колір. Надходять запити увазі $(l,r,c)$ - перекрасить відрізок $[l;r]$ в колір $c$. Потрібно знайти підсумковий колір кожної клітини. Запросы вважаються известными заздалегідь, тобто задача - в офлайні.

Для розв'язку ми можемо завести DSU-структуру, яка для кожної клітини буде зберігати посилання на найближчу справа непокрашенную клітинку. Таким чином, спершу кожна клітина вказує на саму собі, а після фарбування першого підвідрізку - клітина перед початком підвідрізку буде указывать на клітинку після кінця підвідрізку.

Тепер, аби розв'язати задачу, ми розглядаємо запити перекраски **в зворотньому порядку**: від останнього до першого. Для виконання запиту ми просто кожний раз з допомогою нашого DSU знаходимо саму ліву непокрашенную клітинку всередині відрузку, перекрашиваем її, і перебрасываем вказівник з її на наступну справа пусту клітинку.

Таким чином, ми тут фактично використовуємо DSU з евристикою стиснення шляхів, але без рангової евристики (т.до. нам важливо, хто стане лідером після про'єднання). Отже, підсумкова асимптотика складе $O(\log n)$ на запит (втім, з маленької по порівняно з іншими структурами данних константою).

Реалізація:

<!--- TODO: specify code snippet id -->
``` cpp
void init() {
    for (int i = 0; i < L; ++i)
        make_set(i);
}

void process_query(int l, int r, int c) {
    for (int v = l;;) {
        v = find_set(v);
        if (v >= r)
            break;
        answer[v] = c;
        parent[v] = v + 1;
    }
}
```

Втім, можна реалізувати це розв'язок **з рангової евристикою**: будемо зберігати для кожного множини в деякому масиві ${\rm end}[]$, де це множину закінчується (тобто саму праву точку). Значить можна буде об'єднувати два множини в одне по їх рангової евристиці, проставляя потім получившемуся безлічі нову праву кордон. Тим самим ми отримаємо розв'язок за $O(\alpha(n))$.

### Підтримка відстаней до лідера

Іноді в конкретних приложениях системи що не перетинаються множин всплывает вимога підтримувати відстань до лідера (тобто довжину шляхи в ребрах в дереві від поточній вершини до кореня дерева).

Якщо б не було евристики стиснення шляхів, то ніяких складнощів б не возникало - відстань до кореня просто равнялось б числу рекурсивних викликів, які сделала функція $\rm find\_set$.

Однак в результаті стиснення шляхів декілька ребер шляхи могли сжаться в одне ребро. Таким чином, разом з кожної вершиною доведеться зберігати додаткову інформацію: **довжину поточного ребра з вершини в предка**.

При реалізації зручно представляти, що масив ${\rm parent}[]$ і функція $\rm find\_set$ тепер возвращают не одне число, а пару чисел: вершину-лідера і відстань до її:

<!--- TODO: specify code snippet id -->
``` cpp
void make_set(int v) {
    parent[v] = make_pair(v, 0);
    rank[v] = 0;
}

pair<int, int> find_set(int v) {
    if (v != parent[v].first) {
        int len = parent[v].second;
        parent[v] = find_set(parent[v].first);
        parent[v].second += len;
    }
    return parent[v];
}

void union_sets(int a, int b) {
    a = find_set(a).first;
    b = find_set(b).first;
    if (a != b) {
        if (rank[a] < rank[b])
            swap(a, b);
        parent[b] = make_pair(a, 1);
        if (rank[a] == rank[b])
            ++rank[a];
    }
}
```

### Підтримка парності довжини шляхи і задача про перевірці дводольні графа в онлайн

За аналогії з довжиною шляхи до лідера, так ж можна підтримувати парність довжини шляхи до нього. Чому ж це застосування було выделено в окремий пункт?

Справа в тому, що зазвичай вимога хранение парності шляхи всплывает в зв'язку зі наступного **завданням**: спершу дано порожній граф, в нього можуть додаватися ребра, а також поступать запити увазі "є або компонента зв'язності, що містить дану вершину, **двудольной**?".

Для розв'язку цій задачі ми можемо завести систему що не перетинаються множин для зберігання компонент зв'язності, і зберігати у кожної вершини парність довжини шляхи до її лідера. Тим самим, ми можемо швидко перевіряти, приведе або додавання зазначеного ребра до нарушению дводольні графа або ні: а саме, якщо кінці ребра лежати в однієї і тією ж компоненті зв'язності, і при цим мають однакові парності довжини шляхи до лідера, то додавання цього ребра приведе до образованию циклу непарної довжини і превращению поточній компоненти в недвудольную.

Главная **складність**, з якій ми сталкиваемся при цим, - це то, що ми повинні акуратно, з урахуванням чётностей, виробляти об'єднання двох дерев в функції $\rm union\_sets$.

Якщо ми додаємо ребро $(a,b)$, связывающее дві компоненти зв'язності в одну, то при присоединении одного дерева до іншому ми повинні вказати йому таку парність, аби в результаті у вершин $a$ і $b$ получались б різні парності довжини шляхи.

Выведём **формулу**, по якій повинна виходити ця парність, выставляемая лідерові одного множини при присоединении його до лідерові іншого множини. Позначимо через $x$ парність довжини шляхи від вершини $a$ до лідера її множини, через $y$ - парність довжини шляхи від вершини $b$ до лідера її множини, а через $t$ - шукану парність, яку ми повинні поставити присоединяемому лідерові. Якщо множину з вершиною $a$ приєднується до безлічі з вершиною $b$, становясь під деревом, то після присоединения у вершини $b$ її парність не зміниться і залишиться рівній $y$, а у вершини $a$ парність стане рівній $x \oplus t$ (символом $\oplus$ тут позначена операція XOR (симметрическая різницю)). Нам потрібно, аби ці дві парності различались, тобто їх XOR був рівний одиниці. тобто. отримуємо рівняння на $t$:

$$
x \oplus t \oplus y = 1,
$$

решая яке, знаходимо:

$$
t = x \oplus y \oplus 1.
$$

Таким чином, незалежно від того, яке множину приєднується до якого, треба використовувати указанную формулу для завдання парності ребра, проводимого з одного лідера до іншому.

Наведемо **реалізацію** DSU з поддержкой чётностей. Як і в попередньому пункті, в цілях зручності ми використовуємо пари для зберігання предків і результату операції $\rm find\_set$. Крім того, для кожного множини ми зберігаємо в масиві ${\rm bipartite}[]$, є або воно усе ще дводольним або ні.

<!--- TODO: specify code snippet id -->
``` cpp
void make_set(int v) {
    parent[v] = make_pair(v, 0);
    rank[v] = 0;
    bipartite[v] = true;
}

pair<int, int> find_set(int v) {
    if (v != parent[v].first) {
        int parity = parent[v].second;
        parent[v] = find_set(parent[v].first);
        parent[v].second ^= parity;
    }
    return parent[v];
}

void add_edge(int a, int b) {
    pair<int, int> pa = find_set(a);
    a = pa.first;
    int x = pa.second;

    pair<int, int> pb = find_set(b);
    b = pb.first;
    int y = pb.second;

    if (a == b) {
        if (x == y)
            bipartite[a] = false;
    } else {
        if (rank[a] < rank[b])
            swap(a, b);
        parent[b] = make_pair(a, x ^ y ^ 1);
        bipartite[a] &= bipartite[b];
        if (rank[a] == rank[b])
            ++rank[a];
    }
}

bool is_bipartite(int v) { return bipartite[find_set(v).first]; }
```

### Алгоритм знаходження RMQ (мінімум на відрізку) за $O(\alpha(n))$ в середньому в офлайні

**Формально** задача ставиться наступним чином: потрібно реалізувати структуру данних, яка підтримує два увазі запитів: додавання зазначеного числа ${\rm insert}(i)$ ($i = 1 \ldots n$) і пошук і витяг поточного мінімального числа ${\rm extract\_min}()$. Будемо вважати, що кожне число додається рівне один раз.

Крім того, припустимо, що вся послідовність запитів відома нам заздалегідь, тобто задача - в офлайні.

**Ідея розв'язку** наступна. Замість того, аби по черги відповідати на кожний запит, переберемо число $i = 1 \ldots n$, і визначимо, відповіддю на який запит це число має бути. Для цього нам треба знайти перший неотвеченный запит, идущий після  додавання ${\rm insert}(i)$ цього числа - легко зрозуміти, що це і є той запит, відповіддю на який є число $i$.

Таким чином, тут виходить ідея, похожая на **задачу про фарбування відрізків**.

Можна получити розв'язок за $O(\log n)$ в середньому на запит, якщо ми откажемся від рангової евристики і будемо просто зберігати в кожному елементі посилання на найближчий справа запит ${\rm extract\_min}()$, і використовувати стиснення шляхи для підтримки цих посилань після объединений.

Також можна получити розв'язок і за $O(\alpha(n))$, якщо ми будемо використовувати рангову евристику і будемо зберігати в кожному множині номер позиції, де воно закінчується (то, що в попередньому варіанті розв'язку досягалося автоматично за рахунок того, що посилання завжди шли тільки вправо, - тепер треба буде зберігати явно).

### Алгоритм знаходження LCA (найменшого загального предка в дереві) за $O(\alpha(n))$ в середньому в офлайні

Алгоритм Тар'яна знаходження LCA за $O(1)$ в середньому в режимі онлайн описаний в [відповідної статті](lca_linear_offline). Цей алгоритм вигідно відрізняється від інших алгоритмів пошуку LCA своєї простотою (особливо по порівняно з [оптимальним алгоритмом Фарах-Колтона-Бендера](lca_linear)).

### Зберігання DSU в вигляді явного списку множин. Застосування цій ідеї при слиянии різних структур данних

Одним з альтернативных способів зберігання DSU є сохранение кожного множини в вигляді **явно хранящегося списку його елементів**. При цим, у кожного елементу також зберігається посилання на представника (лідера) його множини.

На перший погляд здається, що це неэффективная структура данних: при об'єднанні двох множин ми повинні будемо додати один список в кінець іншого, а також оновити лідера у всіх елементів одного з двох списків.

Однак, як виявляється, застосування **ваговій евристики**, аналогичной описаної вище, дозваляє істотно знизити асимптотику роботи: до $O(m + n \log n)$ для виконання $m$ запитів над $n$ елементами.

Під ваговій евристикою мається на увазі, що ми завжди **будемо додавати менше з двох множин в більше**. Додавання ${\rm union\_sets}()$ одного множини в інше легко реалізувати за час порядку розміру додається множини, а пошук лідера ${\rm find\_set}()$ - за час $O(1)$ при такому способе зберігання.

Доведемо **асимптотику** $O(m + n \log n)$ для виконання $m$ запитів. Зафіксуємо довільний елемент $x$ і проследим, як на нього впливали операції про'єднання ${\rm union\_sets}$. Коли на елемент $x$ впливали перший раз, ми можемо стверджувати, що розмір його нового множини буде як мінімум $2$. Коли на $x$ впливали другий раз - можна стверджувати, що він потрапить в множину розміру не менш $4$ (т.до. ми додаємо менше множину в більше). І так далі - отримуємо, що на елемент $x$ могло воздействовать максимум $\lceil \log n \rceil$ операцій про'єднання. Таким чином, в сумі по всім вершин це становить $O(n \log n)$, плюс по $O(1)$ на кожний запит - що і потрібно довести.

Наведемо приклад **реалізації**:

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> lst[MAXN];
int parent[MAXN];

void make_set(int v) {
    lst[v] = vector<int>(1, v);
    parent[v] = v;
}

int find_set(int v) { return parent[v]; }

void union_sets(int a, int b) {
    a = find_set(a);
    b = find_set(b);
    if (a != b) {
        if (lst[a].size() < lst[b].size())
            swap(a, b);
        while (!lst[b].empty()) {
            int v = lst[b].back();
            lst[b].pop_back();
            parent[v] = a;
            lst[a].push_back(v);
        }
    }
}
```

Також цю ідею додавання елементів меншого множини в більше можна використовувати і поза рамок DSU, при рішенні інших задач.

Наприклад, розглянемо наступну **задачу**: дано дерево, кожному листу якого приписано яке-або число (одне і то ж число можливо зустрічатися декілька раз у різних листя). Потрібно для кожної вершини дерева дізнатися кількість різних чисел в її піддереві.

Применив в цій задачі цю ж ідею, можна получити таке розв'язок: пустимо [обхід в глибину](dfs) по дереву, який буде повертати вказівник на ${\rm set}$ чисел - список всіх чисел в піддереві цій вершини. Значить, аби получити відповідь для поточній вершини (якщо, звісно, вона не лист) - треба викликати обхід в глибину від всіх дітей цій вершини, і об'єднати всі отримані ${\rm set}$ в один, розмір якого і буде відповіддю для поточній вершини. Для ефективного про'єднання декількох ${\rm set}$ в один як раз застосуємо описаний вище прийом: будемо об'єднувати два множини, просто добавляя по одному елементи меншого множини в більше. В результаті ми отримаємо розв'язок за $O(n \log^2 n)$, оскільки додавання одного елементу в ${\rm set}$ виготовляється за $O(\log n)$.

### Зберігання DSU з сохранением явной структури дерев. Переподвешивание. Алгоритм пошуку мостів в графі за $O(\alpha(n))$ в середньому в онлайне

Одне з мощных застосувань структури данних "системи що не перетинаються множин" полягає в тому, що вона дозваляє зберігати одночасно **як стислу, так і несжатую структуру дерев**. Сжатая структура можливо використовуватися для швидкого про'єднання дерев і перевірки на належність двох вершин одному дереву, а несжатая - наприклад, для пошуку шляхи між двома заданными вершинами, або прочих обходів структури дерева.

При реалізації це означає, що крім звичайного для DSU масиву сжатых предків ${\rm parent}[]$ ми заведемо масив звичайних, несжатых, предків ${\rm real\_parent}[]$. Зрозуміло, що поддержание такого масиву ніяк не ухудшает асимптотику: зміни в ньому відбуваються тільки при об'єднанні двох дерев, і лише в одному елементі.

З іншої сторони, при застосуванні на практиці нерідко потрібно навчитися з'єднувати два дерева зазначеним ребром, не обов'язково выходящим з їх коренів. Це означає, що у нас ні іншого виходу, крім як **переподвесіть** одне з дерев за указанную вершину, аби потім ми змогли присоединить це дерево до іншому, зробивши корінь цього дерева дочерней вершиною до другого кінця додається ребра.

На перший погляд здається, що операція переподвешіванія - дуже затратна і сильно ухудшит асимптотику. Дійсно, для переподвешіванія дерева за вершину $v$ ми повинні пройтися від цій вершини до кореня дерева, обновляя всюди вказівники ${\rm parent}[]$ і ${\rm real\_parent}[]$.

Однак насправді усе не так плохо: достатньо лише переподвешівать то з двох дерев, яке менше, аби получити асимпотику одного про'єднання, рівну $O(\log n)$ в середньому.

Більш детально (включаючи доведення асимптотики) див. [алгоритм пошуку мостів в графі за $O(\log n)$ в середньому в онлайне](bridge_searching_online).

## Историческая ретроспектива

Структура данних "система що не перетинаються множин" була відома порівняно давно.

Спосіб зберігання цій структури в вигляді **ліси дерев** був, по всій видимості, вперше описаний Галлером і Фишером в 1964 р. (Galler, Fisher "An Improved Equivalence Algorithm"), однак повний аналіз асимптотики був проведён набагато пізніше.

**Эвристики** стиснення шляхів і про'єднання по рангу, мабуть, разработали МакИлрой (McIlroy) і Моррис (Morris), і, незалежно від них, Триттер (Tritter).

Некоторое час була відома лише оцінка $O(\log^* n)$ на одну операцію в середньому, дана Хопкрофтом і Ульманом в 1973 р. (Hopcroft, Ullman "Set-merging algomthms") - тут $\log^* n$ - **итерированный логарифм** (це повільно растущая функція, але усе ж не настільки повільно, як зворотна функція Аккермана).

Впервые оцінку $O(\alpha(n))$, де $\alpha(n)$ - **зворотна функція Аккермана** - отримав Тарьян в своєї статті 1975 р. (Tarjan "Efficiency of a Good But Not Linear Set Union Algorithm"). Позже в 1985 р. він разом з Льювеном отримав цю временную оцінку для декількох різних ранговых евристик і способів стиснення шляхи (Tarjan, Leeuwen "Worst-Case Analysis of Set Union Algorithms").

Нарешті, Фредман і Сакс в 1989 р. довели, що в принятой модели обчислень **будь-який** алгоритм для системи що не перетинаються множин повинен працювати як мінімум за $O(\alpha(n))$ в середньому (Fredman, Saks "The cell probe complexity of dynamic data structures").

Втім, випливає також відзначити, що є декілька статей, **оспаривающих** цю временную оцінку і утверждающих, що система що не перетинаються множин з эвристиками стиснення шляхи і про'єднання по рангу працює за $O(1)$ в середньому: Zhang "The Union-Find Problem Is Linear", Wu, Otoo "A Simpler Proof of the Average Case Complexity of Union-Find with Path Compression".

## Задачі в online judges

Список задач, які можна розв'язати з допомогою системи що не перетинаються множин:

* [TIMUS #1671 **"Паутина Ананси"** [складність: низька]](http://acm.timus.ru/problem.aspx?space=1&num=1671)

* [CODEFORCES 25D **"Дороги не тільки в Берляндии"** [складність: середня]](http://codeforces.ru/contest/25/problem/D)
* [TIMUS #1003 **"Чётность"** [складність: середня]](http://acm.timus.ru/problem.aspx?space=1&num=1003)

* [SPOJ #1442 **"Chain"** [складність: середня]](http://www.spoj.pl/problems/CHAIN/)

## Література

* \book{Томас Кормен, Чарльз Лейзерсон, Рональд Рівест, Кліффорд Штайн}{Алгоритми: Побудова і аналіз}{2005}{cormen.djvu}
* \book{Kurt Mehlhorn, Peter Sanders}{Algorithms and Data Structures: The Basic Toolbox}{2008}{algorithms_toolbox_mehlhorn.pdf}
* \book{Robert Endre Tarjan}{Efficiency of a Good But Not Linear Set Union Algorithm}{1975}{dsu/Efficiency of a Good But Not Linear Set Union Algorithm. Tarjan.pdf}
* \book{Robert Endre Tarjan, Jan van Leeuwen}{Worst-Case Analysis of Set Union Algorithms}{1985}{dsu/Worst-Case Analysis of Set Union Algorithms. Tarjan, Leeuwen.pdf}
