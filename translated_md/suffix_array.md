# Суфіксний масив

Дана стрічка $s[0 \ldots n-1]$ довжини $n$.

$i$-им **суфіксом** стрічки називається підстрічка $s[i \ldots n-1]$, $i=0 \ldots n-1$.

Значить **суфіксним масивом** стрічки $s$ називається перестановка індексів суфіксів $p[0 \ldots n-1]$, $p[i] \in [0;n-1]$, яка задаёт порядок суфіксів в порядку лексикографической сортування. Іншими словами, потрібно виконати сортування всіх суфіксів заданої стрічки.

Наприклад, для стрічки $s=abaab$ суфіксний масив буде рівний:

$$
(2,3,0,4,1)
$$

## Побудова за $O(n \log n)$

Строго кажучи, описаний нижче алгоритм буде виконувати сортування не суфіксів, а **циклічних зрушень** стрічки. Однак з цього алгоритму легко получити і алгоритм сортування суфіксів: достатньо приписать в кінець стрічки довільний символ, який свідомо менше будь-якого символу, з якого можливо складатися стрічка (наприклад, це можливо бути доллар або шарп; в мові C в цих цілях можна використовувати вже наявний нульовий символ).

Відразу зауважимо, що оскільки ми сортуємо циклічні зрушення, то і підстрічки ми будемо розглядати **циклічні**: під підрядком $s[i \ldots j]$, коли $i > j$, розуміється підстрічка $s[i \ldots n-1] + s[0 \ldots j]$. Крім того, попередньо всі індекси берутся за модулем довжини стрічки (в цілях спрощення формул я буду опускать явные взятия індексів за модулем).

Рассматриваемый нами алгоритм складається з приблизно $\log n$ фаз. На $k$-ой фазі ($k = 0 \ldots \lceil \log n \rceil$) упорядковано циклічні підстрічки довжини $2^k$. На останньої, $\lceil \log n \rceil$-ой фазі, будуть сортироваться підстрічки довжини $2^{\lceil \log n \rceil} > n$, що еквівалентно сортування циклічних зрушень.

На кожної фазі алгоритм крім перестановки $p[0 \ldots n-1]$ індексів циклічних підстрічок буде підтримувати для кожної циклической підстрічки, що починається в позиції $i$ з довжиною $2^k$, **номер $c[i]$ класу еквівалентності**, якому ця підстрічка належить. Насправді, серед підстрічок можуть бути однакові, і алгоритму знадобиться інформація про цим. Крім того, номера $c[i]$ класів еквівалентності будемо давать таким чином, аби вони сохраняли і інформацію про порядку: якщо один суфікс менше іншого, то і номер класу він повинен получити менший. Классы будемо для зручності нумерувати з нуля. Кількість класів еквівалентності будемо зберігати в змінній $\rm classes$.

Наведемо **приклад**. Розглянемо стрічку $s=aaba$. Значения масивів $p[]$ і $c[]$ на кожної стадії з нульовий по одному такі:

$$
\matrix{
0: & p=(0,1,3,2) & c=(0,0,1,0) \cr
1: & p=(0,3,1,2) & c=(0,1,2,0) \cr
2: & p=(3,0,1,2) & c=(1,2,3,0) \cr
}
$$

Варто відзначити, що в масиві $p[]$ можливі неоднозначности. Наприклад, на нульовий фазі масив міг равняться: $p=(3,1,0,2)$. Те, який саме різновид вийде, залежить від конкретної реалізації алгоритму, але всі варіанти одинаково правильны. В то ж час, в масиві $c[]$ ніяких неоднозначностей бути не могло.

Перейдемо тепер до побудови **алгоритму**. Входные дані:

<!--- TODO: specify code snippet id -->
``` cpp
char *s; // вхідні стрічка
int n; // довжина стрічки

// константи
const int maxlen = ...; // максимальна довжина стрічки
const int alphabet = 256; // розмір алфавіту, <= maxlen
```

На **нульовий фазі** ми повинні відсортувати циклічні підстрічки довжини $1$, тобто окремі символи стрічки, і розділити їх на класи еквівалентності (просто однакові символи повинні бути отнесены до одному класу еквівалентності). Це можна зробити тривіально, наприклад, сортуванням підрахунком. Для кожного символу порахуємо, скільки раз він встретился. Потом по цій інформації восстановим масив $p[]$. Після цього, проходом по масиву $p[]$ і сравнением символів, будується масив $c[]$.

<!--- TODO: specify code snippet id -->
``` cpp
int p[maxlen], cnt[maxlen], c[maxlen];
memset (cnt, 0, alphabet * sizeof(int));
for (int i=0; i<n; ++i)
    ++cnt[s[i]];
for (int i=1; i<alphabet; ++i)
    cnt[i] += cnt[i-1];
for (int i=0; i<n; ++i)
    p[--cnt[s[i]]] = i;
c[p[0]] = 0;
int classes = 1;
for (int i=1; i<n; ++i) {
    if (s[p[i]] != s[p[i-1]])  ++classes;
    c[p[i]] = classes-1;
}
```

Далі, нехай ми выполнили $k-1$-ю фазу (тобто вирахували значення масивів $p[]$ і $c[]$ для її), тепер навчимося за $O(n)$ виконувати **наступну, $k$-ю, фазу**. Оскільки фаз всього $O(\log n)$, це дасть нам необхідний алгоритм з часом $O(n \log n)$.

Для цього зауважимо, що циклическая підстрічка довжини $2^k$ складається з двох підстрічок довжини $2^{k-1}$, які ми можемо порівнювати між собою за $O(1)$, використовуючи інформацію з попередньою фази - номера $c[]$ класів еквівалентності. Таким чином, для підстрічки довжини $2^k$, що починається в позиції $i$, вся необходимая інформація міститься в пари чисел $(c[i], c[i+2^{k-1}])$ (повторимося, ми використовуємо масив $c[]$ з попередньою фази).

$$
\ldots \overbrace{ \underbrace{ s_i \ldots s_{i+2^{k-1}-1} }_{{\rm length}=2^{k-1},{\rm class}=c[i]}\ \ \underbrace{ s_{i+2^{k-1}} \ldots s_{i+2^k-1} }_{{\rm length}=2^{k-1},\ {\rm class}=c[i+2^{k-1}]} }^{{\rm length}=2^k} \ldots \overbrace{ \underbrace{ s_j \ldots s_{j+2^{k-1}-1} }_{{\rm length}=2^{k-1},{\rm class}=c[j]}\ \ \underbrace{ s_{j+2^{k-1}} \ldots s_{j+2^k-1} }_{{\rm length}=2^{k-1},{\rm class}=c[j+2^{k-1}]} }^{{\rm length}=2^k} \ldots
$$

Це дає нам вельми просте розв'язок: **відсортувати** підстрічки довжини $2^k$ просто **по** цим **парам чисел**, це і дасть нам необхідний порядок, тобто масив $p[]$. Однак обычная сортування, выполняющаяся за час $O(n \log n)$, нас не устроит - це дасть алгоритм побудови суфіксного масиву з часом $O(n \log^2 n)$ (зате цей алгоритм декілька простіше в написании, ніж описаний нижче).

Як швидко виконати таку сортування пар? Оскільки елементи пар не перевершують $n$, то можна виконати сортування підрахунком. Однак для досягнення лучшей прихованої в асимптотиці константи замість сортування пар прийдемо до сортування просто чисел.

Скористаємося тут прийомом, на якому заснована так называемая **цифровая сортування**: аби відсортувати пари, відсортуємо їх спочатку по іншим елементам, а потім - по першим елементам (але вже обов'язково стабильной сортуванням, тобто не нарушающей относительного порядку елементів при рівності). Однак окремо другі елементи вже впорядковані - цей порядок завдань в масиві $p[]$ від попередньою фази. Значить, аби упорядочить пари по іншим елементам, треба просто від кожного елементу масиву $p[]$ відняти $2^{k-1}$ - це дасть нам порядок сортування пар по іншим елементам (адже $p[]$ дає упорядочение підстрічок довжини $2^{k-1}$, і при переході до стрічки вдвічі більшої довжини ці підстрічки стають їх вторыми половинками, тому від позиції другий половинки віднімається довжина першо] половинки).

Таким чином, з допомогою всього лише вычитаний від елементів масиву $p[]$ ми виробляємо сортування по іншим елементам пар. Тепер треба провести стабильную сортування по першим елементам пар, її вже можна виконати за $O(n)$ з допомогою сортування підрахунком.

Залишилося тільки перерахувати номера $c[]$ класів еквівалентності, але їх вже легко получити, просто пройшовши по отриманої нової перестановки $p[]$ і порівнюючи сусідні елементи (знову ж, порівнюючи як пари двох чисел).

Наведемо **реалізацію** виконання всіх фаз алгоритму, крім нульовий. Вводятся додатково временные масиви $pn$ і $cn$ ($pn$ - містить перестановку в порядку сортування по іншим елементам пар, $cn$ - нові номера класів еквівалентності).

<!--- TODO: specify code snippet id -->
``` cpp
int pn[maxlen], cn[maxlen];
for (int h=0; (1<<h)<n; ++h) {
    for (int i=0; i<n; ++i) {
        pn[i] = p[i] - (1<<h);
        if (pn[i] < 0)  pn[i] += n;
    }
    memset (cnt, 0, classes * sizeof(int));
    for (int i=0; i<n; ++i)
        ++cnt[c[pn[i]]];
    for (int i=1; i<classes; ++i)
        cnt[i] += cnt[i-1];
    for (int i=n-1; i>=0; --i)
        p[--cnt[c[pn[i]]]] = pn[i];
    cn[p[0]] = 0;
    classes = 1;
    for (int i=1; i<n; ++i) {
        int mid1 = (p[i] + (1<<h)) % n,  mid2 = (p[i-1] + (1<<h)) % n;
        if (c[p[i]] != c[p[i-1]] || c[mid1] != c[mid2])
            ++classes;
        cn[p[i]] = classes-1;
    }
    memcpy (c, cn, n * sizeof(int));
}
```

Цей алгоритм вимагає $O(n \log n)$ часу і $O(n)$ пам'яті. Втім, якщо враховувати ще розмір $k$ алфавіту, то час роботи стає $O((n+k) \log n)$, а розмір пам'яті - $O(n+k)$.

## Застосування

### Знаходження найменшого циклічного зсуву стрічки

Вышеописанный алгоритм виробляє сортування циклічних зрушень (якщо до стрічки не приписывать доллар), а тому $p[0]$ дасть шукану позицію найменшого циклічного зсуву. Час роботи - $O(n \log n)$.

### Пошук підстрічки в стрічки

Нехай потрібно в тексті $t$ шукати стрічку $s$ в режимі онлайн (тобто заздалегідь стрічку $s$ потрібно вважати неизвестной). Побудуємо суфіксний масив для тексту $t$ за $O(|t| \log |t|)$. Тепер підстрічку $s$ будемо шукати наступним чином: зауважимо, що шукане входження має бути префіксом какого-або суфікса $t$. Оскільки суфікси у нас впорядковані (це дає нам суфіксний масив), то підстрічку $s$ можна шукати бінарним пошуком по суфіксам стрічки. Сравнение поточного суфікса і підстрічки $s$ всередині бінарного пошуку можна виробляти тривіально, за $O(|p|)$. Значить асимптотика пошуку підстрічки в тексті стає $O(|p| \log |t|)$.

### Сравнение двох підстрічок стрічки

Потрібно по заданої стрічки $s$, провівши деякий її препроцесинг, навчитися за $O(1)$ відповідати на запити порівняння двох довільних підстрічок (тобто перевірка, що перша підстрічка рівна/менше/більше другий).

Побудуємо суфіксний масив за $O(|s| \log |s|)$, при цим збережемо проміжні результати: нам знадобляться масиви $c[]$ від кожної фази. Тому пам'яті буде потрібно теж $O(|s| \log |s|)$.

Використовуючи цю інформацію, ми можемо за $O(1)$ порівнювати будь-які дві підстрічки довжини, рівній степені двійки: для цього достатньо порівняти номера класів еквівалентності з відповідної фази. Тепер треба узагальнити цей спосіб на підстрічки довільної довжини.

Нехай тепер надійшов черговий запит порівняння двох підстрічок довжини $l$ з началами в индексах $i$ і $j$. Знайдемо найбільшу довжину блоку, помещающегося всередині підстрічки такий довжини, тобто найбільше $k$ таке, що $2^k \le l$. Значить порівняння двох підстрічок можна замінити сравнением двох пар перекрывающихся блоків довжини $2^k$: спочатку треба порівняти два блоку, починаються в позиціях $i$ і $j$, а при рівності - порівняти два блоку, закінчуються в позиціях $i+l-1$ і $j+l-1$:

$$
\ldots \overbrace{ \underbrace{ s_i \ldots s_{i+l-2^k} \ldots s_{i+2^k-1} }_{2^k} \ldots s_{i+l-1} }^{\rm first} \ldots \overbrace{ \underbrace{ s_j \ldots s_{j+l-2^k} \ldots s_{j+2^k-1} }_{2^k} \ldots s_{j+l-1} }^{\rm second} \ldots
$$

$$
\ldots \overbrace{ s_i \ldots \underbrace{ s_{i+l-2^k} \ldots s_{i+2^k-1} \ldots s_{i+l-1} }_{2^k} }^{\rm first} \ldots \overbrace{ s_j \ldots \underbrace{ s_{j+l-2^k} \ldots s_{j+2^k-1} \ldots s_{j+l-1} }_{2^k} }^{\rm second} \ldots
$$

Таким чином, реалізація виходить приблизно такий (тут вважається, що вызывающая процедура сама обчислює $k$, оскільки зробити це за константне час не так легко (мабуть, швидше всього - предпосчётом), але в будь-якому випадку це не має отношения до применению суфіксного масиву):

<!--- TODO: specify code snippet id -->
``` cpp
int compare (int i, int j, int l, int k) {
    pair<int,int> a = make_pair (c[k][i], c[k][i+l-(1<<k)]);
    pair<int,int> b = make_pair (c[k][j], c[k][j+l-(1<<k)]);
    return a == b ? 0 : a < b ? -1 : 1;
}
```

### Найбільший загальний префікс двох підстрічок: спосіб з додаткової пам'яттю

Потрібно по заданої стрічки $s$, провівши деякий її препроцесинг, навчитися за $O(\log |s|)$ відповідати на запити найбільшого загального префікса (longest common prefix, lcp) для двох довільних суфіксів з позиціями $i$ і $j$.

Спосіб, описаний тут, вимагає $O(|s| \log |s|)$ додаткової пам'яті; іншої спосіб, использующий лінійний об'єм пам'яті, але неконстантное час відповіді на запит, описаний в наступному розділі.

Побудуємо суфіксний масив за $O(|s| \log |s|)$, при цим збережемо проміжні результати: нам знадобляться масиви $c[]$ від кожної фази. Тому пам'яті буде потрібно теж $O(|s| \log |s|)$.

Нехай тепер надійшов черговий запит: пара індексів $i$ і $j$. Скористаємося тим, що ми можемо за $O(1)$ порівнювати будь-які дві підстрічки довжини, є степенем двійки. Для цього будемо перебирати ступінь двійки (від більшої до меншої), і для поточній степені перевіряти: якщо підстрічки такий довжини збігаються, то до відповіді додати цю ступінь двійки, а найбільший загальний префікс продовжимо шукати справа від однаковою частини, тобто до $i$ і $j$ треба додати поточну ступінь двійки.

Реалізація:

<!--- TODO: specify code snippet id -->
``` cpp
int lcp (int i, int j) {
    int ans = 0;
    for (int k=log_n; k>=0; --k)
        if (c[k][i] == c[k][j]) {
            ans += 1<<k;
            i += 1<<k;
            j += 1<<k;
        }
    return ans;
}
```

Тут через $\rm log\_n$ позначена константа, рівна логарифму $n$ по основи 2, округлённому вниз.

### Найбільший загальний префікс двох підстрічок: спосіб без додаткової пам'яті. Найбільший загальний префікс двох сусідніх суфіксів

Потрібно по заданої стрічки $s$, провівши деякий її препроцесинг, навчитися відповідати на запити найбільшого загального префікса (longest common prefix, lcp) для двох довільних суфіксів з позиціями $i$ і $j$.

В відміну від попереднього методу, описаний тут буде виконувати препроцесинг стрічки за $O(n \log n)$ часу з $O(n)$ пам'яті. Результатом цього препроцесингу буде бути масив (який сам по собі є важливим источником інформації про стрічки, і тому використовуватися для розв'язку інших задач). Ответы ж на запит будуть производиться як результат виконання запиту RMQ (мінімум на відрізку, range minimum query) в цим масиві, тому при різних реализациях можна получити як логарифмічна, так і константне часи роботи.

Базой для цього алгоритму є наступна ідея: найдемо яким-нибудь чином наибольшие загальні префікси для кожної **соседней в порядку сортування пари суфіксів**. Іншими словами, побудуємо масив ${\rm lcp}[0 \ldots n-2]$, де ${\rm lcp}[i]$ рівний найбільшому загальному префиксу суфіксів $p[i]$ і $p[i+1]$. Цей масив дасть нам відповідь для будь-яких двох сусідніх суфіксів стрічки. Значить відповідь для будь-яких двох суфіксів, не обов'язково сусідніх, можна получити по цьому масиву. Насправді, нехай надійшов запит з деякими номерами суфіксів $i$ і $j$. Знайдемо ці індекси в суфіксном масиві, тобто нехай $k_1$ і $k_2$ - їх позиції в масиві $p[]$ (упорядочим їх, тобто нехай $k_1 < k_2$). Значить відповіддю на даний запит буде мінімум в масиві $\rm lcp$, взятый на відрізку $[k_1; k_2-1]$. Насправді, перехід від суфікса $i$ до суфіксу $j$ можна замінити цілої ланцюжком переходів, що починається з суфікса $i$ і заканчивающейся в суфікс $j$, але включающей в собі всі проміжні суфікси, що знаходяться в порядку сортування між ними.

Таким чином, якщо ми маємо такий масив $\rm lcp$, то відповідь на будь-який запит найбільшого загального префікса зводиться до запросу **мінімуму на відрізку** масиву $\rm lcp$. Ця классическая задача мінімуму на відрізку (range minimum query, RMQ) має множину рішень з різними асимптотиками, описані [тут](rmq).

Отже, основна наша задача - **побудова** цього масиву $\rm lcp$. Строить його ми будемо по ходу алгоритму побудови суфіксного масиву: на кожної поточній ітерації будемо будувати масив $\rm lcp$ для циклічних підстрічок поточній довжини.

Після нульовий ітерації масив $\rm lcp$, очевидно, повинен бути нульовим.

Нехай тепер ми выполнили $k-1$-ю ітерацію, отримали від її масив $\rm lcp^\prime$, і повинні на поточній $k$-й ітерації перерахувати цей масив, отримавши нове його значення $\rm lcp$. Як ми пам'ятаємо, в алгоритмі побудови суфіксного масиву циклічні підстрічки довжини $2^k$ разбивались навпіл на дві підстрічки довжини $2^{k-1}$; скористаємось цим ж прийомом і для побудови масиву $\rm lcp$.

Отже, нехай на поточній ітерації алгоритм обчислення суфіксного масиву выполнил свою роботу, нашёл нове значення перестановки $p[]$ підстрічок. Будемо тепер йти по цьому масиву і смотреть пари сусідніх підстрічок: $p[i]$ і $p[i+1]$, $i=0 \ldots n-2$. Разбивая кожну підстрічку навпіл, ми отримуємо дві різних ситуації: 1) перші половинки підстрічок в позиціях $p[i]$ і $p[i+1]$ розрізняються, і 2) перші половинки збігаються (нагадаємо, таке порівняння можна легко виробляти, просто порівнюючи номера класів $c[]$ з попередньою ітерації). Розглянемо кожний з цих випадків окремо.

1) Перші половинки підстрічок различались. Зауважимо, що тоді на попередньому кроці ці перші половинки необхідно були сусідніми. Насправді, класи еквівалентності не могли исчезать (а можуть тільки з'являтися), тому всі різні підстрічки довжини $2^{k-1}$ дадуть (в якості перших половинок) на поточній ітерації різні підстрічки довжини $2^k$, і в тому ж порядку. Таким чином, для визначення ${\rm lcp}[i]$ в цим випадку треба просто взяти відповідне значення з масиву $\rm lcp^\prime$.

2) Перші половинки збігалися. Значить другі половинки могли як збігатися, так і различаться; при цим, якщо вони розрізняються, то вони зовсім не обов'язково повинні були бути сусідніми на попередньою ітерації. Тому в цим випадку ні простого способу визначити ${\rm lcp}[i]$. Для його визначення треба вступити так ж, як ми і собираемся потім обчислювати найбільший загальний префікс для будь-яких двох суфіксів: треба виконати запит мінімуму (RMQ) на відповідному відрізку масиву $\rm lcp^\prime$.

Оцінимо **асимптотику** такого алгоритму. Як ми видели при разборе цих двох випадків, тільки другий випадок дає збільшення числа класів еквівалентності. Іншими словами, можна говорити про тому, що кожний новий клас еквівалентності з'являється разом з одним запитом RMQ. Оскільки всього класів еквівалентності можливо бути до $n$, то і шукати мінімум ми повинні за асимптотику $O(\log n)$. А для цього треба використовувати вже якусь структуру данних для мінімуму на відрізку; цю структуру данних треба буде будувати заново на кожної ітерації (яких всього $O(\log n)$). Хорошим варіантом структури данних буде **[Дерево відрізків](segment_tree)**: його можна побудувати за $O(n)$, а потім виконувати запити за $O(\log n)$, що як раз і дає нам підсумкову асимптотику $O(n \log n)$.

**Реалізація:**

<!--- TODO: specify code snippet id -->
``` cpp
int lcp[maxlen], lcpn[maxlen], lpos[maxlen], rpos[maxlen];
memset (lcp, 0, sizeof lcp);
for (int h=0; (1<<h)<n; ++h) {
    for (int i=0; i<n; ++i)
        rpos[c[p[i]]] = i;
    for (int i=n-1; i>=0; --i)
        lpos[c[p[i]]] = i;

    ... всі дії по побудови суфф. масиву, крім останньої стрічки (memcpy) ...

    rmq_build (lcp, n-1);
    for (int i=0; i<n-1; ++i) {
        int a = p[i],  b = p[i+1];
        if (c[a] != c[b])
            lcpn[i] = lcp[rpos[c[a]]];
        else {
            int aa = (a + (1<<h)) % n,  bb = (b + (1<<h)) % n;
            lcpn[i] = (1<<h) + rmq (lpos[c[aa]], rpos[c[bb]]-1);
            lcpn[i] = min (n, lcpn[i]);
        }
    }
    memcpy (lcp, lcpn, (n-1) * sizeof(int));

    memcpy (c, cn, n * sizeof(int));
}
```

Тут крім масиву $\rm lcp[]$ вводиться временный масив $\rm lcpn[]$ з його новим значенням. Також підтримується масив $\rm pos[]$, який для кожної підстрічки зберігає її позицію в перестановки $p[]$. Функція $\rm rmq\_build$ - деяка функція, строящая структуру данних для мінімуму по масиву-першого аргументу, розмір його передається іншим аргументом. Функція $\rm rmq$ повертає мінімум на відрізку: з першого аргументу по другий включно.

З самого алгоритму побудови суфіксного масиву довелося тільки вынести копирование масиву $c[]$, оскільки у час обчислення $\rm lcp$ нам знадобляться старі значення цього масиву.

Варто відзначити, що наша реалізація знаходить довжину загального префікса для **циклічних підстрічок**, в то час як на практиці частіше буває потрібної довжина загального префікса для суфіксів в їх звичайному понимании. В цим випадку треба просто ограничить значення $\rm lcp$ по закінченні роботи алгоритму:

<!--- TODO: specify code snippet id -->
``` cpp
for (int i=0; i<n-1; ++i)
    lcp[i] = min (lcp[i], min (n-p[i], n-p[i+1]));
```

Для **будь-яких** двох суфіксів довжину їх найбільшого загального префікса тепер можна знайти як мінімум на відповідному відрізку масиву $\rm lcp$:

<!--- TODO: specify code snippet id -->
``` cpp
for (int i=0; i<n; ++i)
    pos[p[i]] = i;
rmq_build (lcp, n-1);

... надійшов запит (i,j) на знаходження LCP ...
int result = rmq (min(i,j), max(i,j)-1);
```

### Кількість різних підстрічок

Выполним **препроцесинг**, описаний в попередньому розділі: за $O(n \log n)$ часу і $O(n)$ пам'яті ми для кожної пари сусідніх в порядку сортування суфіксів найдемо довжину їх найбільшого загального префікса. Знайдемо тепер по цій інформації кількість різних підстрічок в стрічки.

Для цього будемо розглядати, які нові підстрічки починаються в позиції $p[0]$, потім в позиції $p[1]$, і т.д. Фактично, ми беремо черговий в порядку сортування суфікс і дивимося, які його префікси дають нові підстрічки. Тим самим ми, очевидно, не упустим з увазі ніякі з підстрічок.

Користуючись тим, що суфікси у нас вже відсортовані, неважко зрозуміти, що поточний суфікс $p[i]$ дасть в якості нових підстрічок всі свои префікси, крім співпадаючих з префиксами суфікса $p[i-1]$. тобто. всі його префікси, крім ${\rm lcp}[i-1]$ перших, дадуть нові підстрічки. Оскільки довжина поточного суфікса рівна $n-p[i]$, то остаточно отримуємо, що поточний суфікс $p[i]$ дає $n-p[i]-{\rm lcp}[i-1]$ нових підстрічок. Суммируя це по всім суфіксам (для самого першого, $p[0]$, віднімати нечего - прибавится просто $n-p[0]$), отримуємо **відповідь** на задачу:

$$
\sum_{i=0}^n (n - p[i]) - \sum_{i=0}^{n-1} {\rm lcp}[i]
$$

## Задачі в online judges

Задачі, які можна розв'язати, використовуючи суфіксний масив:

* [UVA #10679 **"I Love Strings!!!"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1620)
