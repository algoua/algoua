# Покриття шляхами орієнтованого ациклічного графа

Дан орієнтований ациклічний граф $G$. Потрібно покрити його найменшим числом шляхів, тобто знайти найменше по потужності множину що не перетинаються по вершин простих шляхів, таких, що кожна вершина належить якого-або шляхи.

## Сведение до двудольному графу

Нехай дано граф $G$ з $n$ вершинами. Побудуємо відповідний йому дводольний граф $H$ стандартним чином, тобто: в кожної частці графа $H$ буде по $n$ вершин, позначимо їх через $a_i$ і $b_i$ відповідно. Значить для кожного ребра $(i, j)$ вихідного графа $G$ проведемо відповідне ребро $(a_i, b_j)$.

Кожному ребру $G$ відповідає одне ребро $H$, і навпаки. Якщо ми розглянемо в $G$ будь-який шлях $P = (v_1, v_2, \ldots, v_k)$, то йому ставиться в відповідність набір ребер $(a_{v_1}, b_{v_2}), (a_{v_2}, b_{v_3}), ..., (a_{v_{k-1}}, b_{v_k}) $.

Більш просто для розуміння буде, якщо ми додамо "зворотні" ребра, тобто образуем граф $\overline H$ з графа $H$ додаванням ребер увазі $(b_i, a_i), i=1 \ldots N$. Значить шляхи $P = (v_1, v_2, \ldots, v_k)$ в графі $\overline H$ буде відповідати шлях $\overline Q = (a_{v_1}, b_{v_2}, a_{v_2}, b_{v_3}, ..., a_{v_{k-1}}, b_{v_k})$.

Обратно, розглянемо будь-який шлях $\overline Q$ в графі $\overline H$, що починається в першо] частці і заканчивающийся у другий частці. Очевидно, $\overline Q$ знову буде мати вид $\overline Q = (a_{v_1}, b_{v_2}, a_{v_2}, b_{v_3}, ..., a_{v_{k-1}}, b_{v_k})$, і йому можна поставити в відповідність в графі $G$ шлях $P = (v_1, v_2, \ldots, v_k)$. Однак тут є одна тонкість: $v_1$ могло збігатися з $v_k$, тому шлях $P$ вийшов б циклом. Однак по умові граф $G$ ациклічний, тому це взагалі неможливо (це єдине місце, де використовується ациклічності графа $G$; тим не менш, на циклічні графи описаний тут метод взагалі не можна узагальнити).

Отже, всякому простому шляхи в графі $\overline H$, начинающемуся в першо] частці і заканчивающемуся у другий, можна поставити в відповідність простий шлях в графі $G$, і навпаки. Але зауважимо, що такий шлях в графі $\overline H$ - це **паросполука** в графі $H$. Таким чином, будь-якого шляхи з $G$ можна поставити в відповідність паросполука в графі $H$, і навпаки. Більш того, непересекающимся шляхах в $G$ відповідають непересекающиеся паросполука в $H$.

Останній крок. Зауважимо, що ніж більше шляхів є в нашому наборе, тим менше всі ці шляхи містять ребер. А саме, якщо є $p$ що не перетинаються шляхів, покривають всі $n$ вершин графа, то вони разом містять $r = n - p$ ребер. Отже, аби мінімізувати число шляхів, ми повинні **максимізувати число ребер** в них.

Отже, ми звели задачу до нахождению максимального паросполука в дводольному графі $H$. Після знаходження цього паросполука (див. [Алгоритм Куна](kuhn_matching)) ми повинні преобразовать його в набір шляхів в $G$ (це робиться тривіальним алгоритмом, неоднозначностей тут не виникає). Деякі вершини можуть остаться ненасиченими паросполукою, в такому випадку в відповідь треба додати шляхи нульовий довжини з кожної з цих вершин.

## Взвешенный випадок

Взвешенный випадок не сильно відрізняється від невзвешенного, просто в графі $H$ на ребрах з'являються ваги, і потрібно знайти вже паросполука найменшого ваги. Восстанавливая відповідь аналогічно невзвешенному нагоди, ми отримаємо покрытие графа найменшим числом шляхів, а при рівності - найменшим по вартості.
