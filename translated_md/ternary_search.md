# Тернарный пошук

## Постановка задачі

Нехай дана функція $f(x)$, **унимодальная** на деякому відрізку $[l;r]$. Під унимодальностью розуміється один з двох варіантів. Перший: функція спочатку строго зростає, потім досягає максимуму (в однієї точці або цілому відрізку), потім строго зменшується. Другий різновид, симметричный: функція спочатку зменшується убывает, досягає мінімуму, зростає. В надалі ми будемо розглядати перший різновид, другий буде абсолютно симметричен йому.

Потрібно **знайти максимум** функції $f(x)$ на відрізку $[l;r]$.

## Алгоритм

Візьмемо будь-які дві точки $m_1$ і $m_2$ в цим відрізку: $l < m_1 < m_2 < r$. Порахуємо значення функції $f(m_1)$ і $f(m_2)$. Далі у нас виходить три варіанти:

* Якщо виявиться, що $f(m_1) < f(m_2)$, то шуканий максимум не можливо перебувати в лівої частини, тобто в частини $[l;m_1]$. В цим легко переконатися: якщо в лівої точці функція менше, ніж в правою, то або ці дві точки знаходяться в області "підйому" функції, або тільки ліва точка знаходиться там. В будь-якому випадку, це означає, що максимум далі має сенс шукати тільки в відрізку $[m_1;r]$.

* Якщо, навпаки, $f(m_1) > f(m_2)$, то ситуація аналогічна попередньою з точністю до симетрії. Тепер шуканий максимум не можливо перебувати в правою частини, тобто в частини $[m_2;r]$, тому переходимо до відрізку $[l;m_2]$.

* Якщо $f(m_1) = f(m_2)$, то або обидві ці точки знаходяться в області максимуму, або ліва точка знаходиться в області зростання, а права - в області зменшення (тут істотно використовується то, що возрастание/убывание строгие). Таким чином, в надалі пошук має сенс виробляти в відрізку $[m_1;m_2]$, але (в цілях спрощення коду) цей випадок можна отнести до будь-якого з двох попередніх.

Таким чином, по результату порівняння значень функції в двох внутрішніх точках ми замість поточного відрузку пошуку $[l;r]$ знаходимо новий відрізок $[l^\prime;r^\prime]$. Повторим тепер всі дії для цього нового відрузку, знову отримаємо новий, строго менший, відрізок, і т.д.

Рано або пізно довжина відрузку стане маленької, меншої заздалегідь певної константи-точності, і процес можна зупиняти. Цей метод чисельний, тому після остановки алгоритму можна приближённо вважати, що у всіх точках відрузку $[l;r]$ досягається максимум; в якості відповіді можна взяти, наприклад, точку $l$.

Залишилося замітити, що ми не накладывали ніяких обмежень на вибір точок $m_1$ і $m_2$. Від цього способу, зрозуміло, буде залежати швидкість збіжності (але і що виникає похибка). Найбільш распространённый спосіб - вибирати точки так, аби відрізок $[l;r]$ делился ними на 3 рівні частини:

$$
m_1 = l + \frac{r-l}{3}
$$

$$
m_2 = r - \frac{r-l}{3}
$$

Втім, при другом виборі, коли $m_1$ і $m_2$ ближче один до одному, швидкість збіжності декілька збільшиться.

### Випадок цілочисельного аргументу

Якщо аргумент функції $f$ целочисленный, то відрізок $[l;r]$ теж стає дискретным, однак, оскільки ми не накладывали ніяких обмежень на вибір точок $m_1$ і $m_2$, то на коректність алгоритму це ніяк не впливає. Можна як і раніше вибирати $m_1$ і $m_2$ так, аби вони делили відрізок $[l;r]$ на 3 частини, але вже рівні тільки приблизно.

Другий отличающийся момент - критерій остановки алгоритму. В даному випадку тернарний пошук треба буде зупиняти, коли стане $r-l<3$, адже в такому випадку вже неможливо буде вибрати точки $m_1$ і $m_2$ так, аби були різними і отличались від $l$ і $r$, і це можливо привести до зацикливанию. Після того, як алгоритм тернарного пошуку зупиниться і стане $r-l<3$, з залишилися декількох точок-кандидатов $(l,l+1,\ldots,r)$ треба вибрати точку з максимальним значенням функції.

## Реалізація

Реалізація для непрерывного випадку (тобто функція $f$ має вид: $\rm double\ f\ (double\ x)$):

<!--- TODO: specify code snippet id -->
``` cpp
double l = ..., r = ..., EPS = ...; // вхідні дані
while (r - l > EPS) {
   double m1 = l + (r - l) / 3,
      m2 = r - (r - l) / 3;
   if (f (m1) < f (m2))
      l = m1;
   else
      r = m2;
}
```

Тут $\rm EPS$ - фактично, **абсолютная похибка** відповіді (не вважаючи похибок, пов'язаних з неточным вычислением функції).

Замість критерію "while (r - l > EPS)" можна вибрати і такий критерій останова:
<!--- TODO: specify code snippet id -->
``` cpp
for (int it=0; it<iterations; ++it)
```

З однієї сторони, доведеться подобрать константу $\rm iterations$, аби обеспечить необхідну точність (зазвичай достатньо декількох сотен, аби досягти максимальної точності). Але зате, з іншої сторони, число ітерацій перестаёт залежати від абсолютных величин $l$ і $r$, тобто ми фактично з допомогою $\rm iterations$ задаём необхідну **относительную похибка**.
