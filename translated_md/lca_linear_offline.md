# Найменший загальний предок. Знаходження за $O(1)$ в офлайн (алгоритм Тар'яна)

Дано дерево $G$ з $n$ вершинами і дано $m$ запитів увазі $(a_i, b_i)$. Для кожного запиту $(a_i, b_i)$ потрібно знайти найменшого загального предка вершин $a_i$ і $b_i$, тобто таку вершину $c_i$, яка найбільш удалена від кореня дерева, і при цим є предком обох вершин $a_i$ і $b_i$.

Ми розглядаємо задачу в режимі офлайн, тобто вважаючи, що всі запити відомі заздалегідь. Описаний нижче алгоритм дозваляє відповісти на всі $m$ запитів за сумарне час $O(n+m)$, тобто при достатньо великому $m$ за $O(1)$ на запит.

## Алгоритм Тар'яна

Основой для алгоритму є структура данних ["Система що не перетинаються множин"](dsu), яка і була изобретена Тарьяном (Tarjan).

Алгоритм фактично представляє собою обхід в глибину з кореня дерева, в процесі якого поступово знаходяться відповіді на запити. А саме, відповідь на запит $(v,u)$ знаходиться, коли обхід в глибину знаходиться в вершині $u$, а вершина $v$ вже була переглянуло, або навпаки.

Отже, нехай обхід в глибину знаходиться в вершині $v$ (і вже були виконані переходи в її синів), і виявилося, що для якогось запиту $(v,u)$ вершина $u$ вже була переглянуло обходом в глибину. Навчимося тоді знаходити $\rm LCA$ цих двох вершин.

Зауважимо, що ${\rm LCA}(v,u)$ є або самою вершиною $v$, або одним з її предків. Получается, нам треба знайти саму нижню вершину серед предків $v$ (включаючи її саму), для якій вершина $u$ є потомком. Зауважимо, що при фіксованому $v$ по такому признаку (тобто який найменший предок $v$ є і предком якийсь вершини) вершини дерева дерева розпадаються на совокупность що не перетинаються класів. Для кожного предка $p \not= v$ вершини $v$ її клас містить саму цю вершину, а також всі піддерева з корнями в тих її синах, які лежати "ліворуч" від шляхи до $v$ (тобто які були обработаны раніше, ніж була досягнута $v$).

Нам треба навчитися ефективно підтримувати всі ці класи, для чого ми і застосуємо структуру данних "Система що не перетинаються множин". Кожному класу буде відповідати в цій структурі множину, причому для представника цього множини ми визначимо величину $\rm ANCESTOR$ - ту вершину $p$, яка і утворює цей клас.

Розглянемо детально реалізацію обходу в глибину. Нехай ми стоїмо в деякої вершині $v$. Поместим її в окремий клас в структурі що не перетинаються множин, ${\rm ANCESTOR}[v] = v$. Як зазвичай в обході в глибину, перебираємо всі вихідні ребра $(v, to)$. Для кожного такого $to$ ми спочатку повинні викликати обхід в глибину з цій вершини, а потім додати цю вершину зі всім її під деревом в клас вершини $v$. Це реалізується операцією $\rm Union$ структури данних "система що не перетинаються множин", з последующей установкой ${\rm ANCESTOR} = v$ для представника множини (т.до. після про'єднання представник класу міг змінитися). Нарешті, після обробки всіх ребер ми перебираємо всі запити увазі $(v,u)$, і якщо $u$ була позначена як посещённая обходом в глибину, то відповіддю на цей запит буде вершина ${\rm LCA}(v,u) = {\rm ANCESTOR}[{\rm FindSet}(u)]$. Неважко замітити, що для кожного запиту це умова (що одна вершина запиту є поточній, а інша була переглянуло раніше) виконається рівне один раз.

Оцінимо **асимптотику**. Вона складається з декількох частин. По-перше, це асимптотика обходу в глибину, яка в даному випадку становить $O(n)$. По-друге, це операції по объединению множин, які в сумі для всіх розумних $n$ затрачивают $O(n)$ операцій. По-третє, це для кожного запиту перевірка умови (два рази на запит) і визначення результату (один раз на запит), кожне, знову ж, для всіх розумних $n$ виконується за $O(1)$. Підсумкова асимптотика виходить $O(n+m)$, що означає для достатньо великих $m$ ($n = O(m)$) відповідь за $O(1)$ на один запит.

## Реалізація

Наведемо повну реалізацію даного алгоритму, включаючи слегка изменённую (з поддержкой $\rm ANCESTOR$) реалізацію системи пересічних множин (рандомизированный варіанти).

<!--- TODO: specify code snippet id -->
``` cpp
const int MAXN = максимальне кількість вершин в графі;
vector<int> g[MAXN], q[MAXN]; // граф і всі запити
int dsu[MAXN], ancestor[MAXN];
bool u[MAXN];

int dsu_get (int v) {
    return v == dsu[v] ? v : dsu[v] = dsu_get (dsu[v]);
}

void dsu_unite (int a, int b, int new_ancestor) {
    a = dsu_get (a),  b = dsu_get (b);
    if (rand() & 1)  swap (a, b);
    dsu[a] = b,  ancestor[b] = new_ancestor;
}

void dfs (int v) {
    dsu[v] = v,  ancestor[v] = v;
    u[v] = true;
    for (size_t i=0; i<g[v].size(); ++i)
        if (!u[g[v][i]]) {
            dfs (g[v][i]);
            dsu_unite (v, g[v][i], v);
        }
    for (size_t i=0; i<q[v].size(); ++i)
        if (u[q[v][i]]) {
            printf ("%d %d -> %d\n", v+1, q[v][i]+1,
                ancestor[ dsu_get(q[v][i]) ]+1);
}

int main() {
    ... читання графа ...

    // читання запитів
    for (;;) {
        int a, b = ...; // черговий запит
        --a, --b;
        q[a].push_back (b);
        q[b].push_back (a);
    }

    // обхід в глибину і відповідь на запити
    dfs (0);
}
```
