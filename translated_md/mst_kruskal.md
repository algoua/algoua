# Мінімальна каркасне дерево. Алгоритм Крускала

Дан зважений неорієнтований граф. Потрібно знайти таке піддерево цього графа, яке б соединяло всі його вершини, і при цим обладало найменшим вагою (тобто сумою ваг ребер) з всіх можливих. Таке піддерево називається мінімальним остовным деревом або простому мінімальним каркасом.

Тут будуть розглянуті декілька важных фактов, пов'язаних з минимальными остовами, потім буде розглянуто алгоритм Крускала в його найпростішої реалізації.

### Властивості мінімального острови

* Мінімальний каркас **уникален, якщо ваги всіх ребер різні**. В іншому випадку, можливо існувати декілька мінімальних кістяків (конкретные алгоритми зазвичай отримують один з можливих кістяків).
* Мінімальний каркас є також і **каркасом з мінімальним твором** ваг ребер.
(доводиться це легко, достатньо замінити ваги всіх ребер на їх логарифмы)
* Мінімальний каркас є також і **каркасом з мінімальним вагою самого тяжелого ребра**.
(це твердження випливає з справедливости алгоритму Крускала)
* **Остов максимального ваги** шукається аналогічно каркасу мінімального ваги, достатньо поміняти знаки всіх ребер на протилежні і виконати будь-який з алгоритм мінімального острови.

### Алгоритм Крускала

Даний алгоритм був описаний Крускалом (Kruskal) в 1956 р.

Алгоритм Крускала спершу помещает кожну вершину в своє дерево, а потім поступово об'єднує ці дерева, об'єднуючи на кожної ітерації два деяких дерева деяким ребром. Перед початком виконання алгоритму, всі ребра упорядковано по вазі (в порядку неубывания). Потім починається процес про'єднання: перебираются всі ребра від першого до останнього (в порядку сортування), і якщо у поточного ребра його кінці належать різним поддеревьям, то ці піддерева об'єднуються, а ребро додається до відповіді. За закінченні перебору всіх ребер всі вершини окажутся принадлежащими одному поддереву, і відповідь знайдений.

### Найпростіша реалізація

Цей код самим безпосереднім чином реализует описаний вище алгоритм, і виконується за **O (M log N + N<sup>2</sup>)**. Сортировка ребер зажадає O (M log N) операцій. Принадлежность вершини тому або иному поддереву зберігається просто з допомогою масиву tree_id - в ньому для кожної вершини зберігається номер дерева, якому вона належить. Для кожного ребра ми за O (1) визначаємо, належать або його кінці різним деревам. Нарешті, об'єднання двох дерев здійснюється за O (N) простим проходом по масиву tree_id. Враховуючи, що всього операцій про'єднання буде N-1, ми і отримуємо асимптотику **O (M log N + N<sup>2</sup>)**.

<!--- TODO: specify code snippet id -->
``` cpp
int m;
vector < pair < int, pair<int,int> > > g (m); // вага - вершина 1 - вершина 2

int cost = 0;
vector < pair<int,int> > res;

sort (g.begin(), g.end());
vector<int> tree_id (n);
for (int i=0; i<n; ++i)
    tree_id[i] = i;
for (int i=0; i<m; ++i)
{
    int a = g[i].second.first,  b = g[i].second.second,  l = g[i].first;
    if (tree_id[a] != tree_id[b])
    {
        cost += l;
        res.push_back (make_pair (a, b));
        int old_id = tree_id[b],  new_id = tree_id[a];
        for (int j=0; j<n; ++j)
            if (tree_id[j] == old_id)
                tree_id[j] = new_id;
    }
}
```

### Покращена реалізація

З використанням структури данних ["Система що не перетинаються множин"](dsu) можна написати більш быструю реалізацію [алгоритму Крускала з асимптотикою O (M log N)](mst_kruskal_with_dsu).
