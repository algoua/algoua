# Модифікація методу Проштовхування предпотока для знаходження максимального потоку за O (N<sup>3</sup>)

Передбачається, що вы вже прочитали [Метод Проштовхування предпотока знаходження максимального потоку за O (N<sup>4</sup>)](preflow_push).

## Опис

Модифікація надзвичайно проста: на кожної ітерації серед всіх переповнених вершин ми вибираємо тільки ті вершини, які мають **набольшую висоту**, і застосовуємо проштовхування/поднятие тільки до цим вершин. Більш того, для вибору вершин з найбільшою висотою нам не знадобляться ніякі структури данних, достатньо просто зберігати список вершин з найбільшою висотою і просто перераховувати його, якщо всі вершини з цього списку були обработаны (тоді в список добавятся вершини з вже меншої висотою), а при появі нової переповненій вершини з більшої висотою, ніж в списку, очищать список і додавати вершину в список.

Незважаючи на простоту, ця модифікація дозваляє знизити асимптотику на цілий порядок. Якщо бути точним, асимптотика получившего алгоритму рівна **O (N M + N<sup>2</sup> sqrt (M))**, що в гіршому випадку становить **O (N<sup>3</sup>)**.

Ця модифікація була предложена Черияном (Cheriyan) і Махешвари (Maheshvari) в 1989 р.

## Реалізація

Тут наведено готовая реалізація цього алгоритму.

Отличие від звичайного алгоритму проштовхування - тільки в наявності масиву maxh, в якому будуть зберігатися номера переповнених вершин з максимальної висотою. Размер масиву вказано в змінній sz. Якщо на якийсь ітерації виявляється, що цей масив порожній (sz==0), то ми заполняем його (просто проходячи по всім вершин); якщо після цього масив як і раніше порожній, то переповнених вершин ні, і алгоритм зупиняється. Інакше ми проходимо по вершин в цим списку, застосовуючи до ним проштовхування або поднятие. Після виконання операції проштовхування поточна вершина можливо перестать бути переповненій, в цим випадку видаляємо її з списку maxh. Якщо після якийсь операції поднятия висота поточній вершини стає більше висоти вершин в списку maxh, то ми очищаем список (sz=0), і зразу переходимо до наступного ітерації алгоритму проштовхування (на якій буде побудований новий список maxh).

<!--- TODO: specify code snippet id -->
``` cpp
const int INF = 1000*1000*1000;

int main() {

    int n;
    vector < vector<int> > c (n, vector<int> (n));
    int s, t;
    ... читання n, c, s, t ...

    vector<int> e (n);
    vector<int> h (n);
    h[s] = n-1;
    vector < vector<int> > f (n, vector<int> (n));

    for (int i=0; i<n; ++i) {
        f[s][i] = c[s][i];
        f[i][s] = -f[s][i];
        e[i] = c[s][i];
    }

    vector<int> maxh (n);
    int sz = 0;
    for (;;) {
        if (!sz)
            for (int i=0; i<n; ++i)
                if (i != s && i != t && e[i] > 0) {
                    if (sz && h[i] > h[maxh[0]])
                        sz = 0;
                    if (!sz || h[i] == h[maxh[0]])
                        maxh[sz++] = i;
                }
        if (!sz)  break;
        while (sz) {
            int i = maxh[sz-1];
            bool pushed = false;
            for (int j=0; j<n && e[i]; ++j)
                if (c[i][j]-f[i][j] > 0 && h[i] == h[j]+1) {
                    pushed = true;
                    int addf = min (c[i][j]-f[i][j], e[i]);
                    f[i][j] += addf,  f[j][i] -= addf;
                    e[i] -= addf,  e[j] += addf;
                    if (e[i] == 0)  --sz;
                }
            if (!pushed) {
                h[i] = INF;
                for (int j=0; j<n; ++j)
                    if (c[i][j]-f[i][j] > 0 && h[j]+1 < h[i])
                        h[i] = h[j]+1;
                if (h[i] > h[maxh[0]]) {
                    sz = 0;
                    break;
                }
            }
        }
    }

    ... висновок потоку f ...

}
```
