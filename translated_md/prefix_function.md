# Префикс-функція. Алгоритм Кнута-Морріса-Пратта

## Префикс-функція. Визначення

Дано рядок $s[0 \ldots n-1]$. Потрібно обчислити для її префікс-функцію, тобто масив чисел $\pi[0 \ldots n-1]$, де $\pi[i]$ визначається наступним чином: це така наибольшая довжина найбільшого власного суфікса підрядки $s[0 \ldots i]$, збігається з її префіксом (власний суфікс - значить не збігається зі всій рядком). В зокрема, значення $\pi[0]$ покладається рівним нулю.

Математически визначення префікс-функції можна записати наступним чином:

$$
\pi[i] = \max_{k=0 \ldots i} ~ \{ ~ k ~ : ~ s[0 \ldots k-1] = s[i-k+1 \ldots i] ~ \}.
$$

Наприклад, для рядка "abcabcd" префікс-функція рівна: $[0, 0, 0, 1, 2, 3, 0]$, що означає:

* у рядка "a" ні нетривіального префікса, збігається з суфіксом;
* у рядка "ab" ні нетривіального префікса, збігається з суфіксом;
* у рядка "abc" ні нетривіального префікса, збігається з суфіксом;
* у рядка "abca" префікс довжини $1$ збігається з суфіксом;
* у рядка "abcab" префікс довжини $2$ збігається з суфіксом;
* у рядка "abcabc" префікс довжини $3$ збігається з суфіксом;
* у рядка "abcabcd" ні нетривіального префікса, збігається з суфіксом.

Інший приклад - для рядка "aabaaab" вона рівна: $[0, 1, 0, 1, 2, 2, 3]$.

## Тривіальний алгоритм

Безпосередньо следуя визначенню, можна написати такий алгоритм обчислення префікс-функції:

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> prefix_function(string s) {
    int n = (int)s.length();
    vector<int> pi(n);
    for (int i = 0; i < n; ++i)
        for (int k = 0; k <= i; ++k)
            if (s.substr(0, k) == s.substr(i - k + 1, k))
                pi[i] = k;
    return pi;
}
```

Як неважко замітити, працювати він буде за $O(n^3)$, що занадто повільно.

## Эффективный алгоритм

Цей алгоритм був разработан Кнутом (Knuth) і Праттом (Pratt) і незалежно від них Моррисом (Morris) в 1977 р. (як основний елемент для алгоритму пошуку підрядки в рядка).

### Перша оптимізація

Первое важное замечание - що значення $\pi[i+1]$ не більш ніж на одиницю перевершує значення $\pi[i]$ для будь-якого $i$.

Дійсно, в іншому випадку, якщо б $\pi[i+1] > \pi[i] + 1$, то розглянемо цей суфікс, закінчується в позиції $i+1$ і має довжину $\pi[i+1]$ - видаливши з нього останній символ, ми отримаємо суфікс, закінчується в позиції $i$ і має довжину $\pi[i+1]-1$, що краще $\pi[i]$, тобто прийшли до протиріччя. Ілюстрація цього противоречия (в цим прикладі $\pi[i-1]$ має бути рівне 3):

$$
\underbrace{ \overbrace{s_0 \ s_1}^{\pi[i-1]=2} \ s_2 \ s_3}_{\pi[i]=4} \ \ldots\ \underbrace{ s_{i-3}\ \overbrace{s_{i-2}\ s_{i-1}}^{\pi[i-1]=2} \ s_i}_{\pi[i]=4}
$$

(на цій схемою верхние фігурні дужки позначають дві однакові підрядки довжини 2, нижние фігурні дужки - дві однакові підрядки довжини 4)

Таким чином, при переході до наступного позиції черговий елемент префікс-функції міг або збільшитися на одиницю, або не змінитися, або зменшитися на яку-або величину. Уже цей факт дозваляє нам знизити асимптотику до $O(n^2)$ - оскільки за один крок значення могло вырасти максимум на одиницю, то сумарно для всій рядка могло статися максимум $n$ збільшень на одиницю, і, як наслідок (т.до. значення ніколи не могло стать менше нуля), максимум $n$ зменшень. В результаті вийде $O(n)$ порівнянь стрічок, тобто ми вже досягли асимптотики $O(n^2)$.

### Друга оптимізація

Пойдём далі - **избавимся від явних порівнянь підрядків**. Для цього постараемся максимально використовувати інформацію, обчислену на попередніх кроках.

Отже, нехай ми вирахували значення префікс-функції $\pi[i]$ для деякого $i$. Тепер, якщо $s[i+1] = s[\pi[i]]$, то ми можемо з уверенностью сказати, що $\pi[i+1] = \pi[i] + 1$, це иллюстрирует схема:

$$
\underbrace{ \overbrace{s_0 \ s_1 \ s_2}^{\pi[i]} \ \overbrace{s_3}^{s_3=s_{i+1}}}_{\pi[i+1]=\pi[i]+1} \ \ldots\ \underbrace{ \overbrace{s_{i-2}\ s_{i-1}\ s_i}^{\pi[i]} \ \overbrace{s_{i+1}}^{s_3=s_{i+1}}}_{\pi[i+1]=\pi[i]+1}
$$

(на цій схемою знову однакові фігурні дужки позначають однакові підрядки)

Нехай тепер, навпаки, виявилося, що $s[i+1] \ne s[\pi[i]]$. Значить нам треба спробувати спробувати підрядок меншої довжини. В цілях оптимізації хотелось б зразу перейти до такий (найбільшою) довжині $j < \pi[i]$, що як і раніше виконується префікс-властивість в позиції $i$, тобто $s[0 \ldots j-1] = s[i-j+1 \ldots i]$:

$$
\overbrace{\underbrace{s_0 \ s_1}_{j} \ s_2 \ s_3}^{\pi[i]} \ \ldots\ \overbrace{ s_{i-3}\ s_{i-2} \underbrace{s_{i-1}\ s_{i}}_{j}}^{\pi[i]} \ s_{i+1}
$$

Дійсно, коли ми найдемо таку довжину $j$, то нам буде знову достатньо порівняти символи $s[i+1]$ і $s[j]$ - якщо вони совпадут, то можна стверджувати, що $\pi[i+1] = j+1$. Інакше нам треба буде знову знайти менше (випливає по величині) значення $j$, для якого виконується префікс-властивість, і так далі. Может случиться, що такі значення $j$ кончатся - це відбувається, коли $j=0$. В цим випадку, якщо $s[i+1]=s[0]$, то $\pi[i+1]=1$, інакше $\pi[i+1]=0$.

Отже, загальна схема алгоритму у нас вже є, нерешённым остался тільки питання про эффективном знаходженні таких довжин $j$. Поставимо цей питання формально: по поточній довжині $j$ і позиції $i$ (для яких виконується префікс-властивість, тобто $s[0 \ldots j-1] = s[i-j+1 \ldots i]$) потрібно знайти найбільше $k < j$, для якого як і раніше виконується префікс-властивість:

$$
\overbrace{\underbrace{s_0 \ s_1}_{k} \ s_2 \ s_3}^{j} \ \ldots\ \overbrace{ s_{i-3}\ s_{i-2} \underbrace{s_{i-1}\ s_{i}}_{k}}^{j} \ s_{i+1}
$$

Після настільки подробного опису вже практично напрашивается, що це значення $k$ є не що інше, як значення префікс-функції $\pi[j-1]$, яке вже було обчислено нами раніше (віднімання одиниці з'являється з-за 0-індексації стрічок). Таким чином, знаходити ці довжини $k$ ми можемо за $O(1)$ кожну.

### Итоговый алгоритм

Отже, ми остаточно побудували алгоритм, який не містить явних порівнянь стрічок і виконує $O(n)$ дій.

Наведемо тут підсумкову схему алгоритму:

* Вважати значення префікс-функції $\pi[i]$ будемо по черги: від $i=1$ до $i=n-1$ (значення $\pi[0]$ просто дамо рівним нулю).

* Для підрахунку поточного значення $\pi[i]$ ми заводим змінну $j$, позначає довжину поточного рассматриваемого зразка. Cпершу $j = \pi[i-1]$.

* Тестируем образец довжини $j$, для чого порівнюємо символи $s[j]$ і $s[i]$. Якщо вони збігаються - то вважаємо $\pi[i] = j+1$ і переходимо до наступного индексу $i+1$. Якщо ж символи відрізняються, то зменшуємо довжину $j$, полагая її рівній $\pi[j-1]$, і повторюємо цей крок алгоритму з початку.

* Якщо ми дійшли до довжини $j=0$ і так і не знайшли збіги, то зупиняємо процес перебору зразків і вважаємо $\pi[i] = 0$ і переходимо до наступного индексу $i+1$.

### Реалізація

Алгоритм в підсумку вийшов дивовижно простим і лаконичным:

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> prefix_function(string s) {
    int n = (int)s.length();
    vector<int> pi(n);
    for (int i = 1; i < n; ++i) {
        int j = pi[i - 1];
        while (j > 0 && s[i] != s[j])
            j = pi[j - 1];
        if (s[i] == s[j])
            ++j;
        pi[i] = j;
    }
    return pi;
}
```

Як неважко замітити, цей алгоритм є **онлайновим** алгоритмом, тобто він обробляє дані по ходу поступления - можна, наприклад, считывать рядок по одному символу і зразу обробляти цей символ, знаходячи відповідь для черговий позиції. Алгоритм вимагає зберігання самою рядка і попередніх вычисленных значень префікс-функції, однак, як неважко замітити, якщо нам заздалегідь відомо максимальне значення, яке можливо приймати префікс-функція на всій рядка, то достатньо буде зберігати лише на одиницю більше кількість перших символів рядка і значень префікс-функції.

## Застосування

### Пошук підрядки в рядка. Алгоритм Кнута-Морріса-Пратта

Ця задача є класичним застосуванням префікс-функції (і, власне, вона і була відкрита в зв'язку з цим).

Дан текст $t$ і рядок $s$, потрібно знайти і вивести позиції всіх входжень рядка $s$ в текст $t$.

Позначимо для зручності через $n$ довжину рядка $s$, а через $m$ - довжину тексту $t$.

Образуем рядок $s + \# + t$, де символ $\#$ - це роздільник, який не повинен ніде більш зустрічатися. Порахуємо для цій рядка префікс-функцію. Тепер розглянемо її значення, крім перших $n+1$ (які, як видно, відносяться до рядка $s$ і разделителю). За визначенню, значення $\pi[i]$ показує найдовшу довжину підрядки, оканчивающейся в позиції $i$ і збігається з префіксом. Але в нашому випадку це $\pi[i]$ - фактично довжина найбільшого блоку збіги зі рядком $s$ і оканчивающегося в позиції $i$. Больше, ніж $n$, ця довжина бути не можливо - за рахунок разделителя. А ось рівність $\pi[i] = n$ (там, де воно досягається), означає, що в позиції $i$ закінчується шукане входження рядка $s$ (тільки не треба забувати, що всі позиції отсчитываются в склеенной рядка $s+\#+t$).

Таким чином, якщо в якийсь позиції $i$ виявилося $\pi[i] = n$, то в позиції $i - (n + 1) - n + 1 = i - 2 n$ рядка $t$ починається чергове входження рядка $s$ в рядок $t$.

Як вже згадувалося при описі алгоритму обчислення префікс-функції, якщо відомо, що значення префікс-функції не будуть превышать деякої величини, то достатньо зберігати не всю рядок і префікс-функцію, а тільки її початок. В нашому випадку це означає, що потрібно зберігати в пам'яті лише рядок $s + \#$ і значення префікс-функції на ній, а потім вже считывать по одному символу рядок $t$ і перераховувати поточний значення префікс-функції.

Отже, алгоритм Кнута-Морріса-Пратта вирішує цю задачу за $O(n+m)$ часу і $O(n)$ пам'яті.

### Підрахунок числа входжень кожного префікса

Тут ми розглянемо зразу дві задачі. Дано рядок $s$ довжини $n$. В першому варіанті потрібно для кожного префікса $s[0 \ldots i]$ порахувати, скільки раз він зустрічається в самою ж рядка $s$. У іншому варіанті задачі дана іншо рядок $t$, і потрібно для кожного префікса $s[0 \ldots i]$ порахувати, скільки раз він зустрічається в $t$.

Вирішимо спочатку першу задачу. Розглянемо в який-або позиції $i$ значення префікс-функції в ній $\pi[i]$. За визначенню, воно означає, що в позиції $i$ закінчується входження префікса рядка $s$ довжини $\pi[i]$, і ніякий більший префікс оканчиваться в позиції $i$ не можливо. В то ж час, в позиції $i$ могло оканчиваться і входження префіксів менших довжин (і, очевидно, зовсім не обов'язково довжини $\pi[i]-1$). Однак, як неважко замітити, ми прийшли до тому ж питання, на який ми вже отвечали при розгляді алгоритму обчислення префікс-функції: по даній довжині $j$ треба сказати, який наідліннейшій її власний суфікс збігається з її префіксом. Ми вже выяснили, що відповіддю на цей питання буде $\pi[j-1]$. Але тоді і в цій задачі, якщо в позиції $i$ закінчується входження підрядки довжини $\pi[i]$, збігається з префіксом, то в $i$ також закінчується входження підрядки довжини $\pi[\pi[i]-1]$, збігається з префіксом, а для її застосовні ті ж міркування, тому в $i$ також закінчується і входження довжини $\pi[\pi[\pi[i]-1]-1]$ і так далі (поки індекс не стане нульовим). Таким чином, для обчислення відповіді ми повинні виконати такий цикл:

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> ans(n + 1);
for (int i = 0; i < n; ++i)
    ++ans[pi[i]];
for (int i = n - 1; i > 0; --i)
    ans[pi[i - 1]] += ans[i];
```

Тут ми для кожного значення префікс-функції спочатку порахували, скільки раз він зустрічався в масиві $\pi[]$, а потім порахували таку в деякому роде динаміку: якщо ми знаємо, що префікс довжини $i$ зустрічався рівне ${\rm ans}[i]$ раз, то саме таке кількість треба додати до числу входжень його длиннейшего власного суфікса, збігається з його префіксом; потім вже з цього суфікса (звісно, меншої ніж $i$ довжини) виконається "пробрасывание" цього кількості до своему суфіксу, і т.д.

Тепер розглянемо одному задачу. Застосуємо стандартний прийом: пріпішем до рядка $s$ рядок $t$ через роздільник, тобто отримаємо рядок $s+\#+t$, і порахуємо для її префікс-функцію. Єдине відміну від першо] задачі буде в тому, що враховувати треба тільки ті значення префікс-функції, які відносяться до рядка $t$, тобто всі $\pi[i]$ для $i \ge n+1$.

### Кількість різних підрядків в рядка

Дано рядок $s$ довжини $n$. Потрібно порахувати кількість її різних підрядків.

Будемо розв'язувати цю задачу ітеративно. А саме, навчимося, знаючи поточний кількість різних підрядків, перераховувати це кількість при додаванні в кінець одного символу.

Отже, нехай $k$ - поточний кількість різних підрядків рядка $s$, і ми додаємо в кінець символ $c$. Очевидно, в результаті могли з'явитися деякі нові підрядки, оканчивавшиеся на цим новому символі $c$. А саме, додаються в якості нових ті підрядки, оканчивающиеся на символі $c$ і не встречавшиеся раніше.

Візьмемо рядок $t = s + c$ і інвертуємо її (запишемо символи в зворотньому порядку). Наша задача - порахувати, скільки у рядка $t$ таких префіксів, які не зустрічаються в ній більш ніде. Але якщо ми порахуємо для рядка $t$ префікс-функцію і найдемо її максимальне значення $\pi_{\rm max}$, то, очевидно, в рядка $t$ зустрічається (не в початку) її префікс довжини $\pi_{\rm max}$, але не більшої довжини. Зрозуміло, префікси меншої довжини уж точно зустрічаються в ній.

Отже, ми отримали, що число нових підрядків, з'являються при дописуванні символу $c$, рівне $s.{\rm length}() + 1 - \pi_{\rm max}$.

Таким чином, для кожного дописываемого символу ми за $O(n)$ можемо перерахувати кількість різних підрядків рядка. Отже, за $O(n^2)$ ми можемо знайти кількість різних підрядків для будь-який заданої рядка.

Варто замітити, що цілковито аналогічно можна перераховувати кількість різних підрядків і при дописуванні символу в початок, а також при видаленні символу з кінця або з початку.

### Стиснення рядка

Дано рядок $s$ довжини $n$. Потрібно знайти саме короткий її "стислий" уявлення, тобто знайти таку рядок $t$ найменшою довжини, що $s$ можна уявити в вигляді конкатенації однієї або декількох копій $t$.

Зрозуміло, що проблема є в знаходженні довжини шуканої рядка $t$. Знаючи довжину, відповіддю на задачу буде, наприклад, префікс рядка $s$ цій довжини.

Порахуємо по рядка $s$ префікс-функцію. Розглянемо її останнє значення, тобто $\pi[n-1]$, і введемо позначення $k = n - \pi[n-1]$. Покажемо, що якщо $n$ ділиться на $k$, то це $k$ і буде довжиною відповіді, інакше ефективного стиснення не існує, і відповідь рівний $n$.

Дійсно, нехай $n$ ділиться на $k$. Значить рядок можна уявити в вигляді декількох блоків довжини $k$, причому, по визначенню префікс-функції, префікс довжини $n-k$ буде збігатися з її суфіксом. Але тоді останній блок повинен буде збігатися з предпоследним, предпоследний - з предпредпоследним, і т.д. В результаті вийде, що всі блоки блоки збігаються, і таке $k$ дійсно підходить під відповідь.

Покажемо, що цей відповідь оптимальний. Дійсно, в іншому випадку, якщо б знайшлося менше $k$, то і префікс-функція на наприкінці була б більше, ніж $n-k$, тобто прийшли до протиріччя.

Нехай тепер $n$ не ділиться на $k$. Покажемо, що звідси випливає, що довжина відповіді рівна $n$. Доведемо від противного - припустимо, що відповідь існує, і має довжину $p$ ($p$ дільник $n$). Зауважимо, що префікс-функція необхідно повинна бути більше $n - p$, тобто цей суфікс повинен частково накрывать перший блок. Тепер розглянемо другий блок рядка; т.до. префікс збігається з суфіксом, і и префікс, і суфікс покрывают цей блок, і їх смещение один щодо одного $k$ не ділить довжину блоку $p$ (а інакше б $k$ делило $n$), то всі символи блоку збігаються. Але тоді рядок складається з одного і того ж символу, звідси $k=1$, і відповідь повинен існувати, тобто так ми прийдемо до протиріччя.

$$
\overbrace{s_0\ s_1\ s_2\ s_3}^{p}\ \overbrace{s_4\ s_5\ s_6\ s_7}^{p}
$$

$$
s_0\ s_1\ s_2\ \underbrace{\overbrace{s_3\ s_4\ s_5\ s_6}^{p}\ s_7}_{\pi[7]=5}
$$

$$
s_4=s_3,\ \ s_5=s_4,\ \ s_6=s_5,\ \ s_7=s_6\ \ \ \ \Longrightarrow\ \ \ \ s_0=s_1=s_2=s_3
$$

### Побудова автомата по префікс-функції

Вернёмся до вже неоднократно использованному приёму конкатенації двох стрічок через роздільник, тобто для данних стрічок $s$ і $t$ обчислення префікс-функції для рядка $s+\#+t$. Очевидно, що т.до. символ $\#$ є разделителем, то значення префікс-функції ніколи не превысит $s.{\rm length}()$. Звідси випливає, що, як згадувалося при описі алгоритму обчислення префікс-функції, достатньо зберігати тільки рядок $s+\#$ і значення префікс-функції для її, а для всіх подальших символів префікс-функцію обчислювати на лету:

$$
\underbrace{s_0\ s_1\ \ldots\ s_{n-1}\ \#}_{\rm need\ to\ save} \underbrace{t_0\ t_1\ \ldots\ t_{m-1}}_{\rm need\ not\ to\ save}
$$

Дійсно, в такий ситуації, знаючи черговий символ $c \in t$ і значення префікс-функції в попередньою позиції, можна буде обчислити нове значення префікс-функції, ніяк при цим не використовуючи всі попередні символи рядка $t$ і значення префікс-функції в них.

Другими словами, ми можемо побудувати **автомат**: станом в ньому буде поточний значення префікс-функції, переходи з одного стан в інше будуть осуществляться під действием символу:

$$
s_0\ s_1\ \ldots\ s_{n-1}\ \# \underbrace{\ldots}_{\pi[i-1]}\ \ \Longrightarrow\ \ s_0\ s_1\ \ldots\ s_{n-1}\ \# \underbrace{\ldots}_{\pi[i-1]} + t_i\ \ \Longrightarrow\ \ s_0\ s_1\ \ldots\ s_{n-1}\ \# \ldots \underbrace{t_i}_{\pi[i]}
$$

Таким чином, навіть ще не маючи рядка $t$, ми можемо попередньо побудувати таку таблицю переходів $({\rm old}\_\pi,c) \rightarrow {\rm new}\_\pi$ з допомогою того ж алгоритму обчислення префікс-функції:

<!--- TODO: specify code snippet id -->
``` cpp
string s;                 // вхідні рядок
const int alphabet = 256; // потужність алфавіту символів, зазвичай менше

s += '#';

int n = (int)s.length();
vector<int> pi = prefix_function(s);
vector<vector<int>> aut(n, vector<int>(alphabet));
for (int i = 0; i < n; ++i)
    for (char c = 0; c < alphabet; ++c) {
        int j = i;
        while (j > 0 && c != s[j])
            j = pi[j - 1];
        if (c == s[j])
            ++j;
        aut[i][c] = j;
    }
```

Правда, в такому вигляді алгоритм буде працювати за $O(n^2 k)$ ($k$ - потужність алфавіту). Але зауважимо, що замість внутрішнього циклу $\rm while$, який поступово укорачивает відповідь, ми можемо скористатися вже вычисленной частью таблиці: переходячи від значення $j$ до значенням $\pi[j-1]$, ми фактично говорим, що перехід з стан $(j, c)$ приведе в то ж стан, що і перехід $(\pi[j-1], c)$, а для нього відповідь вже точно посчитан (т.до. $\pi[j-1] < j$):

<!--- TODO: specify code snippet id -->
``` cpp
string s;                 // вхідні рядок
const int alphabet = 256; // потужність алфавіту символів, зазвичай менше

s += '#';

int n = (int)s.length();
vector<int> pi = prefix_function(s);
vector<vector<int>> aut(n, vector<int>(alphabet));
for (int i = 0; i < n; ++i)
    for (char c = 0; c < alphabet; ++c)
        if (i > 0 && c != s[i])
            aut[i][c] = aut[pi[i - 1]][c];
        else
            aut[i][c] = i + (c == s[i]);
```

В результаті вийшла вкрай проста реалізація побудови автомата, работающая за $O(n k)$.

Коли можливо бути полезен такий автомат? Для початку згадаємо, що ми припустимо префікс-функцію для рядка $s+\#+t$, і її значення зазвичай використовують з єдиною целью: знайти всі входження рядка $s$ в рядок $t$.

Тому сама очевидна польза від побудови такого автомата - **прискорення обчислення префікс-функції** для рядка $s+\#+t$. Построив по рядка $s+\#$ автомат, нам вже більше не потрібна ні рядок $s$, ні значення префікс-функції в ній, не потрібні і ніякі обчислення - всі переходи (тобто то, як буде змінюватися префікс-функція) вже предпосчитаны в таблице.

Але є і друге, менш очевидне застосування. Це випадок, коли рядок $t$ **є гигантской рядком, побудованої по якого-або правилу**. Це можливо бути, наприклад, рядок Грея або рядок, образованная рекурсивної комбинацией декількох коротких стрічок, поданных на вхід.

Нехай для определённости ми вирішуємо **таку задачу**: дано номер $k \le 10^5$ рядка Грея, і дано рядок $s$ довжини $n \le 10^5$. Потрібно порахувати кількість входжень рядка $s$ в $k$-ю рядок Грея. Нагадаємо, рядка Грея визначаються таким чином:

$$
g_1 = "a"
$$

$$
g_2 = "aba"
$$

$$
g_3 = "abacaba"
$$

$$
g_4 = "abacabadabacaba"
$$

$$
\ldots
$$

В таких випадках навіть просто побудова рядка $t$ буде невозможным з-за її астрономической довжини (наприклад, $k$-ая рядок Грея має довжину $2^k-1$). Тим не менш, ми зможемо порахувати значення префікс-функції на наприкінці цій рядка, знаючи значення префікс-функції, яке було перед початком цій рядка.

Отже, крім самого автомата також порахуємо такі величини: $G[i][j]$ - значення автомата, достигаемое після "згодовування" йому рядка $g_i$, якщо до цього автомат находился в стані $j$. Друга величина - $K[i][j]$ - кількість входжень рядка $s$ в рядок $g_i$, якщо до "згодовування" цій рядка $g_i$ автомат находился в стані $j$. Фактично, $K[i][j]$ - це кількість раз, яке автомат принимал значення $s.{\rm length}()$ за час "згодовування" рядка $g_i$. Зрозуміло, що відповіддю на задачу буде величина $K[k][0]$.

Як вважати ці величини? По-перше, базовыми значеннями є $G[0][j] = j$, $K[0][j] = 0$. А всі наступні значення можна обчислювати по попереднім значенням і використовуючи автомат. Отже, для обчислення цих значень для деякого $i$ ми вспоминаем, що рядок $g_i$ складається з $g_{i-1}$ плюс $i$-ый символ алфавіту плюс знову $g_{i-1}$. Значить після "згодовування" першого куска ($g_{i-1}$) автомат перейде в стан $G[i-1][j]$, потім після "згодовування" символу ${\rm char}_i$ він перейде в стан:

$$
{\rm mid} = {\rm aut}[\ G[i-1][j]\ ][{\rm char}_i]
$$

Після цього автомату "скармливается" останній шматок, тобто $g_{i-1}$:

$$
G[i][j] = G[i-1][{\rm mid}]
$$

Количества $K[i][j]$ легко вважаються як сума количеств по трём кускам $g_i$: рядок $g_{i-1}$, символ ${\rm char}_i$, і знову рядок $g_{i-1}$:

$$
K[i][j] = K[i-1][j] + ({\rm mid} == s.{\rm length}()) + K[i-1][mid]
$$

Отже, ми вирішили задачу для стрічок Грея, аналогічно можна розв'язати цілий клас таких задач. Наприклад, точно таким ж методом вирішується **наступна задача**: дано рядок $s$, і зразки $t_i$, кожний з яких задається наступним чином: це рядок з звичайних символів, серед яких можуть зустрічатися рекурсивні вставки інших стрічок в формі $t_k[\rm cnt]$, яка означає, що в це місце має бути вставлено $\rm cnt$ экземпляров рядка $t_k$. Приклад такий схемы:

$$
t_1 = "abdeca"
$$

$$
t_2 = "abc" + t_1[30] + "abd"
$$

$$
t_3 = t_2[50] + t_1[100]
$$

$$
t_4 = t_2[10] + t_3[100]
$$

Гарантируется, що це опис не містить в собі циклічних зависимостей. Ограничения такі, що якщо явним чином раскрывать рекурсію і знаходити рядка $t_i$, то їх довжини можуть достигать порядку $100^{100}$.

Потрібно знайти кількість входжень рядка $s$ в кожну з стрічок $t_i$.

Задача вирішується так ж, построением автомата префікс-функції, потім треба обчислювати і додавати в нього переходи по цілим рядках $t_i$. В загалом-то, це просто більш загальний випадок по порівняно з завданням про рядках Грея.

## Задачі в online judges

Список задач, які можна розв'язати, використовуючи префікс-функцію:

* [UVA #455 **"Periodic Strings"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=396)

* [UVA #11022 **"String Factoring"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1963)

* [UVA #11452 **"Dancing the Cheeky-Cheeky"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2447)
