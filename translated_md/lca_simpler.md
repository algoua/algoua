# Найменший загальний предок. Знаходження за O (log N) (метод двійкового підйому)

Нехай дано дерево G. На вхід надходять запити увазі (V1, V2), для кожного запиту потрібно знайти їх найменшого загального предка, тобто вершину V, яка лежить на шляхи від кореня до V1, на шляхи від кореня до V2, і з всіх таких вершин випливає вибирати саму нижню. Іншими словами, шукана вершина V - предок і V1, і V2, і серед всіх таких загальних предків вибирається нижній. Очевидно, що найменший загальний предок вершин V1 і V2 - це їх загальний предок, що лежить на найкоротшому шляхи з V1 в V2. В зокрема, наприклад, якщо V1 є предком V2, то V1 є їх найменшим загальним предком.

На англійською ця задача називається завданням LCA - Least Common Ancestor.

Тут буде розглянуто алгоритм, який пишеться набагато швидше, ніж описаний [тут](lca).

Асимптотика полученного алгоритму буде рівна: препроцесинг за **O (N log N)** і відповідь на кожний запит за **O (log N)**.

## Алгоритм

Предпосчитаем для кожної вершини її 1-го предка, 2-го предка, 4-го, і т.д. Позначимо цей масив через P, тобто P[i][j] - це 2<sup>j</sup>-й предок вершини i, i = 1..N, j = 0..&lceil;logN&rceil;. Також для кожної вершини найдемо часи заходу в її і виходу пошуку в глибину (див. ["Пошук в глибину"](dfs)) - це нам знадобиться, аби визначати за O (1), є або одна вершина предком іншої (не обов'язково безпосереднім). Такий препроцесинг можна виконати за **O (N log N)**.

Нехай тепер надійшов черговий запит - пара вершин (A,B). Відразу перевіримо, не є або одна вершина предком іншої - в такому випадку вона і є результатом. Якщо A не предок B, і B не предок A, то будемо подниматься по предкам A, поки не найдемо саму высокую (тобто найбільш близкую до корені) вершину, яка ще не є предком (не обов'язково безпосереднім) B (тобто таку вершину X, що X не предок B, а P[X][0] - предок B). При цим знаходити цю вершину X будемо за O (log N), користуючись масивом P.

Опишемо цей процес подробнее. Нехай L = &lceil;logN&rceil;. Нехай спочатку I = L. Якщо P[A][I] не є предком B, то присвоюємо A = P[A][I], і зменшуємо I. Якщо ж P[A][I] є предком B, то просто зменшуємо I. Очевидно, що коли I стане менше нуля, вершина A як раз і буде бути шуканої вершиною - тобто такий, що A не предок B, але P[A][0] - предок B.

Тепер, очевидно, відповіддю на LCA буде бути P[A][0] - тобто найменша вершина серед предків вихідної вершини A, являющаяся також і предком B.

Асимптотика. Весь алгоритм відповіді на запит складається з зміни I від L = &lceil;logN&rceil; до 0, а також перевірки на кожному кроці за O(1), є або одна вершина предком іншої. Отже, на кожний запит буде знайдений відповідь за O (log N).

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
int n, l;
vector < vector<int> > g;
vector<int> tin, tout;
int timer;
vector < vector<int> > up;

void dfs (int v, int p = 0) {
    tin[v] = ++timer;
    up[v][0] = p;
    for (int i=1; i<=l; ++i)
        up[v][i] = up[up[v][i-1]][i-1];
    for (size_t i=0; i<g[v].size(); ++i) {
        int to = g[v][i];
        if (to != p)
            dfs (to, v);
    }
    tout[v] = ++timer;
}

bool upper (int a, int b) {
    return tin[a] <= tin[b] && tout[a] >= tout[b];
}

int lca (int a, int b) {
    if (upper (a, b))  return a;
    if (upper (b, a))  return b;
    for (int i=l; i>=0; --i)
        if (! upper (up[a][i], b))
            a = up[a][i];
    return up[a][0];
}

int main() {

    ... читання n і g ...

    tin.resize (n),  tout.resize (n),  up.resize (n);
    l = 1;
    while ((1<<l) <= n)  ++l;
    for (int i=0; i<n; ++i)  up[i].resize (l+1);
    dfs (0);

    for (;;) {
        int a, b; // поточний запит
        int res = lca (a, b); // відповідь на запит
    }

}
```
