# Решето Ератосфена з лінійним часом роботи

Дано число $n$. Потрібно знайти **всі прості** в відрізку $[2; n]$.

Классический спосіб розв'язку цій задачі - **[решето Ератосфена](eratosthenes_sieve)**. Цей алгоритм дуже простий, але працює за час $O(n \log \log n)$.

Хоча в настоящий момент відомо достатньо багато алгоритмів, працюючих за сублинейное час (тобто за $o(n)$), описаний нижче алгоритм интересен своєї **простотою** - він практично не складніше класичного решета Ератосфена.

Крім того, приводимый тут алгоритм в якості "побочного эффекта" фактично обчислює **факторизацію всіх чисел** в відрізку $[2; n]$, що можливо бути полезно у багатьох практических применениях.

Недоліком приводимого алгоритму є то, що він використовує **більше пам'яті**, ніж классическое решето Ератосфена: потрібно заводить масив з $n$ чисел, в то час як классическому решету Ератосфена достатньо лише $n$ біт пам'яті (що виходить в $32$ рази менше).

Таким чином, описаний алгоритм має сенс застосовувати тільки до чисел порядку $10^7$, не більш.

Авторство алгоритму, по всій видимості, належить Грайсу і Мисра (Gries, Misra, 1978 р. - див. список літератури в наприкінці). (І, власне кажучи, називати даний алгоритм "решетом Ератосфена" некоректно: занадто відрізняються ці два алгоритму).

## Опис алгоритму

Наша мета - порахувати для кожного числа $i$ від в відрізку $[2; n]$ його **мінімальний простий дільник** $lp[i]$.

Крім того, нам буде потрібно зберігати список всіх знайдених простих чисел - назвемо його масивом $pr[]$.

Cпершу всі величини $lp[i]$ заполним нулями, що означає, що ми поки припускаємо всі числа простими. В під час роботи алгоритму цей масив буде поступово заполняться.

Будемо тепер перебирати поточний число $i$ від $2$ до $n$. У нас можливо бути два випадку:

* $lp[i] = 0$ - це означає, що число $i$ - просте, т.до. для нього так і не обнаружилось інших подільників.

Отже, треба присвоїти $lp[i] = i$ і додати $i$ в кінець списку $pr[]$.

* $lp[i] \ne 0$ - це означає, що поточний число $i$ - складене, і його мінімальним простим дільником є $lp[i]$.

В обох випадках далі починається процес **расстановки значень** в масиві $lp[]$: ми будемо брати числа, **кратні** $i$, і оновлювати у них значення $lp[]$. Однак наша мета - навчитися робити це таким чином, аби в підсумку у кожного числа значення $lp[]$ було б встановлено не більш одного рази.

Стверджується, що для цього можна вступити таким чином. Розглянемо числа увазі:

$$
x_j = i \cdot p_j,
$$

де послідовність $p_j$ - це всі прості, не превосходящие $lp[i]$ (як раз для цього нам понадобилось зберігати список всіх простих чисел).

У всіх чисел такого увазі проставимо нове значення $lp[x_j]$ - очевидно, воно буде рівне $p_j$.

Чому такий алгоритм корректен, і чому він працює за лінійне час - див. нижче, поки ж наведемо його реалізацію.

## Реалізація

Решето виконується до зазначеного в константі числа $N$.

<!--- TODO: specify code snippet id -->
``` cpp
const int N = 10000000;
int lp[N+1];
vector<int> pr;

for (int i=2; i<=N; ++i) {
    if (lp[i] == 0) {
        lp[i] = i;
        pr.push_back (i);
    }
    for (int j=0; j<(int)pr.size() && pr[j]<=lp[i] && i*pr[j]<=N; ++j)
        lp[i * pr[j]] = pr[j];
}
```

Цю реалізацію можна трохи прискорити, позбувшись від вектора $pr$ (замінивши його на звичайний масив зі счётчиком), а також позбувшись від дублирующегося множення у вложенном циклі $for$ (для чого результат твори треба просто запам'ятати в який-або змінній).

## Доведення коректності

Доведемо **коректність** алгоритму, тобто що він правильно расставляет всі значення $lp[]$, причому кожне з них буде встановлено рівне один раз. Звідси буде дотримуватися, що алгоритм працює за лінійне час - оскільки всі інші дії алгоритму, очевидно, працюють за $O(n)$.

Для цього зауважимо, що у будь-якого числа $i$ **єдино уявлення** такого увазі:

$$
i = lp[i] \cdot x,
$$

де $lp[i]$ - (як і раніше) мінімальний простий дільник числа $i$, а число $x$ не має подільників, менших $lp[i]$, тобто:

$$
lp[i] \le lp[x].
$$

Тепер порівняємо це з тим, що робить наш алгоритм - він фактично для кожного $x$ перебирает всі прості, на які його можна домножить, тобто прості до $lp[x]$ включно, аби получити числа в зазначеному вище поданні.

Отже, алгоритм дійсно пройдёт по кожному составному числу рівне один раз, поставивши у нього правильное значення $lp[]$.

Це означає коректність алгоритму і то, що він працює за лінійне час.

## Час роботи і необхідна пам'ять

Хоча асимптотика $O(n)$ краще асимптотики $O(n \log \log n)$ класичного решета Ератосфена, разница між ними невелика. На практиці це означає лише двукратную різницю в швидкості, а оптимизированные варіанти решета Ератосфена і зовсім не проигрывают приведённому тут алгоритму.

Враховуючи затраты пам'яті, які вимагає цей алгоритм - масив чисел $lp[]$ довжини $n$ і масив всіх простих $pr[]$ довжини приблизно $n / \ln n$ - цей алгоритм здається уступающим классическому решету по всім статьям.

Однак спасает його то, що масив $lp[]$, вычисляемый цим алгоритмом, дозваляє шукати факторизацію будь-якого числа в відрізку $[2; n]$ за час порядку розміру цій факторизації. Більш того, ціною ще одного дополнительного масиву можна зробити, аби в цій факторизації не требовались операції ділення.

Знание факторизації всіх чисел - дуже полезная інформація для деяких задач, і цей алгоритм є одним з немногих, які дозволяють шукати її за лінійне час.

## Література

* David Gries, Jayadev Misra. **A Linear Sieve Algorithm for Finding Prime Numbers** [1978]
