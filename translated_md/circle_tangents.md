# Пошук загальних дотичних до двом окружностям

Дано дві кола. Потрібно знайти всі їх загальні дотичні, тобто всі такі прямі, які стосуються обох кіл одночасно.

Описанный алгоритм буде працювати також в випадку, коли одна (або обидві) кола вироджуються в точки. Таким чином, цей алгоритм можна використовувати також для знаходження дотичних до кола, проходять через задану точку.

## Кількість загальних дотичних

Відразу відзначимо, що ми не розглядаємо **вырожденные** випадки: коли кола збігаються (в цим випадку у них нескінченно багато загальних дотичних), або одна коло лежить всередині іншої (в цим випадку у них ні загальних дотичних, або, якщо кола стосуються, є одна загальна касательная).

В більшості випадків, дві кола мають **чотири** загальних дотичних.

Якщо кола **стосуються**, то у них буде три обших дотичних, але це можна розуміти як вироджених випадок: так, як ніби дві дотичні збіглися.

Більш того, описаний нижче алгоритм буде працювати і в випадку, коли одна або обидві кола мають нульовий радіус: в цим випадку буде, відповідно, дві або одна загальна касательная.

Подводя підсумок, ми, за винятком описаних в початку випадків, завжди будемо шукати **чотири дотичні**. В вырожденных випадках деякі з них будуть збігатися, однак тим не менш ці випадки також будуть вписываться в загальну картину.

## Алгоритм

В цілях простоти алгоритму, будемо вважати, не втрачаючи спільності, що центр першо] кола має координати $(0;0)$. (Якщо це не так, то цього можна домогтися простим сдвигом всій картины, а після знаходження розв'язку - сдвигом отриманих прямих назад).

Позначимо через $r_1$ і $r_2$ радиусы першо] і другий кіл, а через $v$ - координати центру другий кола (точка $v$ відмінна від початку координат, т.до. ми не розглядаємо випадку, коли кола збігаються, або одна коло знаходиться всередині іншої).

Для розв'язку задачі підійдемо до ній чисто **алгебраически**. Нам потрібно знайти всі прямі увазі $ax+by+c=0$, які лежати на відстані $r_1$ від початку координат, і на відстані $r_2$ від точки $v$. Крім того, наложим умова нормированности прямої: сума квадратів коефіцієнтів $a$ і $b$ повинна бути рівна одиниці (це необхідно, інакше однієї і тією ж прямої буде відповідати нескінченно багато уявлень увазі $ax+by+c=0$). Разом отримуємо таку систему рівнянь на шукані $a,b,c$:

$$
\begin{cases}
a^2 + b^2 = 1, \\
| a \cdot 0 + b \cdot 0 + c | = r_1, \\
| a \cdot v_x + b \cdot v_y + c | = r_2.
\end{cases}
$$

Щоб позбутися від модулів, зауважимо, що всього є чотири способу раскрыть модулі в цій системі. Усе ці способы можна розглянути загальним випадком, якщо розуміти раскрытие модуля як то, що коефіцієнт в правою частини, можливо, множиться на $-1$.

Іншими словами, ми переходимо до такий системі:

$$
\begin{cases}
a^2 + b^2 = 1, \\
c = \pm r_1, \\
a \cdot v_x + b \cdot v_y + c = \pm r_2.
\end{cases}
$$

Введя позначення $d_1 = \pm r_1$ і $d_2 = \pm r_2$, ми приходимо до тому, що чотири рази повинні розв'язувати систему:

$$
\begin{cases}
a^2 + b^2 = 1, \\
c = d_1, \\
a \cdot v_x + b \cdot v_y + c = d_2.
\end{cases}
$$

Розв'язок цій системи зводиться до розв'язку квадратного рівняння. Ми опустим всі громоздкие выкладки, і зразу наведемо готовый відповідь:

$$
\begin{cases}
a = \frac{ (d_2-d_1)v_x \pm v_y \sqrt{ v_x^2 + v_y^2 - (d_2-d_1)^2 } }{ v_x^2 + v_y^2 }, \\
b = \frac{ (d_2-d_1)v_y \mp v_x \sqrt{ v_x^2 + v_y^2 - (d_2-d_1)^2 } }{ v_x^2 + v_y^2 }, \\
c = d_1.
\end{cases}
$$

Разом у нас вийшло $8$ рішень замість $4$. Однак легко зрозуміти, в якому місці виникають зайві розв'язку: насправді, в останньої системі достатньо брати тільки одне розв'язок (наприклад, перший). Насправді, геометричний сенс того, що ми беремо $\pm r_1$ і $\pm r_2$, зрозумілий: ми фактично перебираємо, по яку сторону від кожної з кіл буде пряма. Тому два способу, виникають при рішенні останньої системи, избыточны: достатньо вибрати одне з двох рішень (тільки, звісно, у всіх чотирьох випадках треба вибрати одне і то ж сімейство рішень).

Останнє, що ми ще не розглянули - це **як сдвигать прямі** в тому випадку, коли перша коло не находилась спершу в початку координат. Однак тут усе просто: з лінійності рівняння прямої випливає, що від коефіцієнта $c$ треба відняти величину $a \cdot x_0 + b \cdot y_0$ (де $x_0$ і $y_0$ - координати первоначального центру першо] кола).

## Реалізація

Опишемо спочатку всі необхідні структури данних і інші допоміжні визначення:

<!--- TODO: specify code snippet id -->
``` cpp
struct pt {
    double x, y;

    pt operator-(pt p) {
        pt res = {x - p.x, y - p.y};
        return res;
    }
};

struct circle : pt {
    double r;
};

struct line {
    double a, b, c;
};

const double EPS = 1E-9;

double sqr(double a) { return a * a; }
```

Значить саме розв'язок можна записати таким чином (де основна функція для виклику - друга; а перша функція - вспомогательная):

<!--- TODO: specify code snippet id -->
``` cpp
void tangents(pt c, double r1, double r2, vector<line> &ans) {
    double r = r2 - r1;
    double z = sqr(c.x) + sqr(c.y);
    double d = z - sqr(r);
    if (d < -EPS)
        return;
    d = sqrt(abs(d));
    line l;
    l.a = (c.x * r + c.y * d) / z;
    l.b = (c.y * r - c.x * d) / z;
    l.c = r1;
    ans.push_back(l);
}

vector<line> tangents(circle a, circle b) {
    vector<line> ans;
    for (int i = -1; i <= 1; i += 2)
        for (int j = -1; j <= 1; j += 2)
            tangents(b - a, a.r * i, b.r * j, ans);
    for (size_t i = 0; i < ans.size(); ++i)
        ans[i].c -= ans[i].a * a.x + ans[i].b * a.y;
    return ans;
}
```
