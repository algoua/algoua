# Задача про покрытии відрізків точками

Дано N відрізків на прямої. Потрібно покрити їх найменшим числом точок, тобто знайти найменше множину точок таке, що кожному відрізку належить хоча б одна точка.

Також розглянемо усложнённый різновид цій задачі - коли додатково вказано "запрещённое" множину відрізків, тобто ніяка точка з відповіді не повинна належати ні одному запрещённому відрізку.

Слід також замітити, що цю задачу можна розглядати і як задачу в теорії расписаний - потрібно покрити завдань набір мероприятий-відрізків найменшим числом точок.

Нижче буде описаний жадібний алгоритм, решающий обидві задачі за **O (N log N)**.

## Розв'язок першо] задачі

Зауважимо спочатку, що можна розглядати тільки ті розв'язку, в яких кожна з точок знаходиться на правом наприкінці какого-або відрузку. Дійсно, неважко зрозуміти, що будь-яке розв'язок, якщо воно не задовольняє цьому властивості, можна привести до нього, сдвигая його точки вправо настільки, наскільки це можливо.

Спробуємо тепер побудувати розв'язок, удовлетворяющее указанному властивості. Візьмемо точки-праві кінці відрізків, відсортуємо їх, і будемо рухатися по ним ліворуч направо. Якщо поточна точка є правим кінцем вже покрытого відрузку, то ми пропускаємо її. Нехай тепер поточна точка є правим кінцем поточного відрузку, який ще не був покритий до цього. Значить ми повинні додати в відповідь поточну точку, і відзначити всі відрізки, яким належить ця точка, як покрытые. Дійсно, якщо б ми пропустили поточну точку і не стали б додавати її в відповідь, то, так як вона є правим кінцем поточного відрузку, то ми вже не змогли б покрити поточний відрізок.

Однак при наивной реалізації цей метод буде працювати за O (N<sup>2</sup>). Опишемо **эффективную реалізацію** цього методу.

Візьмемо всі точки-кінці відрізків (як ліві, так і праві) і відсортуємо їх. При цим для кожної точки збережемо разом з ній номер відрузку, а також то, яким кінцем його вона є (лівим або правим). Крім того, відсортуємо точки таким чином, що, якщо є декілька точок з однієї координатою, то спочатку будуть йти ліві кінці, і тільки потім - праві. Заведемо стек, в якому будуть зберігатися номера відрізків, розглянутих в даний момент; спершу стек порожній. Будемо рухатися по точкам в відсортованому порядку. Якщо поточна точка - лівий кінець, то просто додаємо номер її відрузку в стек. Якщо ж вона є правим кінцем, то перевіряємо, не був або покритий цей відрізок (для цього можна просто завести масив булевых змінних). Якщо він вже був покритий, то нічого не робимо і переходимо до наступного точці (забегая вперед, ми утверждаем, що в цим випадку в стеці поточного відрузку вже ні). Якщо ж він ще не був покритий, то ми додаємо поточну точку в відповідь, і тепер ми хочемо відзначити для всіх поточних відрізків, що вони стають покрытыми. Оскільки в стеці як раз зберігаються номера непокрытых ще відрізків, то будемо доставать з стека по одному відрізку і відзначати, що він вже покритий, поки стек повністю не опустеет. За закінченні роботи алгоритму всі відрізки будуть покрыты, і притому найменшим числом точок (повторимося, тут важливо вимога, що при рівності координат спочатку йдуть ліві кінці, і тільки потім праві).

Таким чином, весь алгоритм виконується за O (N), не вважаючи сортування точок, а підсумкова складність алгоритму як раз рівна **O (N log N)**.

## Розв'язок другий задачі

Тут вже з'являються запрещённые відрізки, тому, у-перших, розв'язку взагалі можливо не існувати, а у-вторых, вже не можна стверджувати, що відповідь можна скласти тільки з правих кінців відрізків. Однак описаний вище алгоритм можна відповідним чином модифікувати.

Знову візьмемо всі точки-кінці відрізків (як цільових відрізків, так і заборонених), відсортуємо їх, сохранив разом з кожної точкою її тип і відрізок, кінцем якого вона є. Знову ж, відсортуємо відрізки так, аби при рівності координат ліві кінці шли перед правыми, а якщо і типи кінців рівні, то ліві кінці заборонених повинні йти перед левыми концами цільових, а праві кінці заборонених - після цільових (аби запрещённые відрізки учитывались як можна дольше при рівності координат). Заведемо лічильник заборонених відрізків, який буде рівний числу заборонених відрізків, покривають поточну точку. Заведемо чергу (queue), в якій будуть зберігатися номера поточних цільових відрізків. Будемо перебирати точки в відсортованому порядку. Якщо поточна точка - лівий кінець целевого відрузку, то просто додамо номер її відрузку в чергу. Якщо поточна точка - правий кінець целевого відрузку, то, якщо лічильник заборонених відрізків рівний нулю, то ми чинимо аналогічно попередньою задачі - ставимо точку в поточну точку, і выталкиваем всі відрізки з черги, отмечая, що вони покрыты. Якщо ж лічильник заборонених відрізків більше нуля, то в поточну точку ми стрелять не можемо, а тому ми повинні знайти саму останню точку, вільну від заборонених відрізків; для цього треба підтримувати відповідний вказівник last_free, який буде обновляться при поступлении заборонених відрізків. Значить ми стреляем в last_free-EPS (тому що прямо в її не можна стрелять - ця точка належить запрещённому відрізку), і виштовхувати відрізки з черги, поки точка last_free-EPS належить їм. А саме, якщо поточна точка - лівий кінець запрещённого відрузку, то ми збільшуємо лічильник, і якщо перед цим лічильник був рівний нулю, то присвоюємо last_free поточну координату. Якщо поточна точка - правий кінець запрещённого відрузку, то просто зменшуємо лічильник.
