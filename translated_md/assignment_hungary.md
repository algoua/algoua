# Угорський алгоритм розв'язку задачі про призначеннях

## Постановка задачі про призначеннях

Задача про призначеннях ставиться вельми природно.

Наведемо декілька **варіантів постановки** (як легко бачити, всі вони еквівалентні один одному):

* Є $n$ рабочих і $n$ завдань. Для кожного рабочего відомо, скільки денег він запросит за виконання того або іншого завдання. Кожен рабочий можливо взяти собі тільки одне завдання. Потрібно розподілити завдання по рабочим так, аби мінімізувати суммарные расходы.

* Дана матриця $a$ розміру $n \times n$. Потрібно в кожної її стрічки вибрати по одному числу так, аби в будь-якому стовпці також було вибрано рівне по одному числу, і при цим сума обраних чисел була б мінімальної.

* Дана матриця $a$ розміру $n \times n$. Потрібно знайти таку перестановку $p$ довжини $n$, що величина $\sum a[i][p[i]]$ - минимальна.

* Дан повний дводольний граф з $n$ вершинами; кожному ребру приписан деякий вага. Потрібно знайти вчинене паросполука мінімального ваги.

Відзначимо, що всі наведені вище постановки "**квадратны**": в них обидві розмірності завжди збігаються (і рівні $n$). На практиці часто зустрічаються аналогічні "**прямоугольные**" постановки, коли $n \ne m$, і треба вибрати $\min(n,m)$ елементів. Втім, як легко замітити, від "прямоугольной" задачі завжди можна перейти до "квадратной", додавши стрічки/стовпці з нулевыми/бесконечными значеннями відповідно.

Також зауважимо, що по аналогії з пошуком **мінімального** розв'язку також можна ставити задачу пошуку **максимального** розв'язку. Втім, ці дві задачі еквівалентні один одному: достатньо всі ваги помножити на $-1$.

## Угорський алгоритм

### Историческая справка

Алгоритм був разработан і опубліковано Гарольдом **Куном** (Harold Kuhn) в 1955 р. Сам Кун дал алгоритму назва "угорський", тому що він був в значительной степені заснований на більш ранних работах двох венгерских математиков: Денеша **Кёнига** (Dénes Kőnig) і Эйгена **Эгервари** (Jenő Egerváry).

В 1957 р. Джеймс **Манкрес** (James Munkres) показав, що цей алгоритм працює за (строго) полиномиальное час (тобто за час порядку полінома від $n$, не зависящего від величини вартостей).

Тому в літературі даний алгоритм відомий не тільки як "угорський", але і як "алгоритм Куна-Манкреса" або "алгоритм Манкреса".

Втім, недавно (в 2006 г). выяснилось, що точно такий ж алгоритм був изобретён **за век до Куна** немецким математиком Карлом Густавом **Якобі** (Carl Gustav Jacobi). Справа в тому, що його робота "About the research of the order of a system of arbitrary ordinary differential equations", напечатанная посмертно в 1890 р., содержавшая крім прочих результатів і полиномиальный алгоритм розв'язку задачі про призначеннях, була написана на латыни, а її публікація **пройшла непоміченою** серед математиков.

Також варто відзначити, що первоначальный алгоритм Куна имел асимптотику $O(n^4)$, і лише пізніше Джек **Эдмондс** (Jack Edmonds) і Ричард **Карп** (Richard Karp) (і незалежно від них **Томидзава** (Tomizawa)) показали, яким чином покращити його до асимптотики $O(n^3)$.

### Побудова алгоритму за $O(n^4)$

Відразу відзначимо у уникнути неоднозначностей, що ми в основному розглядаємо тут задачу про призначеннях в матричної постановці (тобто дана матриця $a$, і треба вибрати з її $n$ осередків, находящихся в різних рядках і шпальтах). Индексацию масивів ми починаємо з одиниці, тобто, наприклад, матриця $a$ має індекси $a[1 \ldots n][1 \ldots n]$.

Також ми будемо вважати, що всі числа в матриці $a[][]$ **невід'ємні** (якщо це не так, то завжди можна перейти до неотрицательной матриці, додавши до всім числах деякий число).

Назвемо **потенціалом** два довільних масиву чисел $u[1 \ldots n]$ і $v[1 \ldots n]$ таких, що виконується умова:

$$
u[i] + v[j] \le a[i][j] (i = 1 \ldots n, ~~ j = 1 \ldots n).
$$

(Як видно, числа $u[i]$ відповідають рядках, а числа $v[j]$ - стовпчиках матриці).

Назвемо **значенням $f$ потенціалу** суму його чисел:

$$
f = \sum_{i=1}^n u[i] + \sum_{i=1}^n v[i].
$$

З однієї сторони, легко замітити, що вартість шуканого розв'язку $sol$ **не менше** значення будь-якого потенціалу:

$$
sol \ge f.
$$

(Доведення. Искомое розв'язок задачі представляє з собі $n$ осередків матриці, і для кожної з них виконується умова $u[i] + v[j] \le a[i][j]$. Оскільки всі елементи знаходяться в різних рядках і шпальтах, то, підсумовуючи ці нерівності по всім выбранным $a[i][j]$, в лівої частини нерівності отримуємо $f$, а в правою - $sol$, що і потрібно довести).

З іншої сторони, виявляється, що завжди існує розв'язок і потенціал, на яких це нерівність **обращается в рівність**. Угорський алгоритм, описаний нижче, буде конструктивним доказательством цього факту. Поки Що ж лише обратим увага на то, що якщо яке-або розв'язок має вартість, рівну по величині якого-або потенциалу, то це розв'язок - **оптимально**.

Зафіксуємо деякий потенціал. Назвемо ребро $(i,j)$ **жорстким**, якщо виконується:

$$
u[i] + v[j] = a[i][j].
$$

Згадаймо про альтернативной постановці задачі про призначеннях, з допомогою дводольного графа. Позначимо через $H$ дводольний граф, составленный тільки з жорстких ребер. Фактично, угорський алгоритм підтримує для поточного потенціалу **максимальне по кількості ребер паросполука $M$** графа $H$: і як тільки це паросполука стане містити $n$ ребер, ребра цього паросполука і будуть бути шуканим оптимальним розв'язком (адже це буде розв'язок, вартість якого збігається з величиною потенціалу).

Перейдемо безпосередньо до **опису алгоритму**.

* В початку алгоритму потенціал покладається рівним нулю $u[i] = v[i] = 0$, і паросполука $M$ покладається порожнім.

* Далі, на кожному кроці алгоритму ми намагаємося, не меняя потенціалу, збільшити потужність поточного паросполука $M$ на одиницю (напоминаем, паросполука шукається в графі жорстких ребер $H$).

Для цього фактично використовується звичайний [алгоритм Куна пошуку максимального паросполука в дводольних графах](kuhn_matching). Нагадаємо тут цей алгоритм.

Усе ребра паросполука $M$ ориентируются по напрямку від другий частки до першо], всі інші ребра графа $H$ ориентируются в протилежну сторону.

Нагадаємо (з терминологии пошуку паросочетание), що вершина називається насыщенной, якщо їй смежно ребро з поточного паросполука. Вершина, якій не смежно ні одне ребро з поточного паросполука, називається ненасиченої. Шлях непарної довжини, в якому перший ребро не належить паросполуці, а для всіх подальших ребер відбувається чергування (належить/не належить) - називається збільшує шляхом.

З всіх ненасыщенных вершин першо] частки запускується обхід [в глибину](dfs)/[в ширину](bfs). Якщо в результаті обходу вдалося досягти ненасиченої вершини другий частки, то це означає, що ми знайшли збільшує шлях з першо] частки у одному. Якщо прочередовать ребра уздовж цього шляхи (тобто перший ребро включить в паросполука, друге виключити, третій включить, і т.д)., то тим самим ми збільшимо потужність паросполука на одиницю.

Якщо ж збільшує шляхи не було, то це означає, що поточний паросполука $M$ - максимально в графі $H$, тому в такому випадку переходимо до наступного пункту.

* Якщо на поточному кроці не вдалося збільшити потужність поточного паросполука, то виготовляється якийсь перерахунок потенціалу таким чином, аби на наступних кроках з'явилося більше возможностей для збільшення паросполука.

Позначимо через $Z_1$ множину вершин першо] частки, які були відвідані обходом алгоритму Куна при попытке пошуку збільшоючим ланцюги; через $Z_2$ - множину відвіданих вершин другий частки.

Порахуємо величину $\Delta$:

$$
\Delta = \min_{i \in Z_1, j \notin Z_2} \{ a[i][j] - u[i] - v[j] \}.
$$

Ця величина строго позитивна.

(Доведення. Припустимо, що $\Delta = 0$. Значить існує жорстке ребро $(i,j)$, причому $i \in Z_1$ і $j \notin Z_2$. З цього випливає, що ребро $(i,j)$ має було бути орієнтованим від другий частки до першо], тобто це жорстке ребро $(i,j)$ має входити в паросполука $M$. Однак це неможливо, т.до. ми не могли потрапити в насыщенную вершину $i$, крім як пройшовши по ребру з $j$ в $i$. Пришли до протиріччя, значить, $\Delta > 0$).

Тепер **пересчитаем потенціал** таким чином: для всіх вершин $i \in Z_1$ зробимо $u[i] += \Delta$, а для всіх вершин $j \in Z_2$ - зробимо $v[j] -= \Delta$. Получившийся потенціал як і раніше залишиться корректным потенціалом.

(Доведення. Для цього треба показати, що як і раніше для всіх $i$ і $j$ виконується: $u[i] + v[j] \le a[i][j]$. Для випадків, коли $i \in Z_1 \& j \in Z_2$ або $i \notin Z_1 \& j \notin Z_2$ - це так, оскільки для них сума $u[i]$ і $v[j]$ не изменилась. Коли $i \notin Z_1 \& j \in Z_2$ - нерівність тільки усилилось. Нарешті, для випадку $i \in Z_1 \& j \notin Z_2$ - хоча ліва частина нерівності і збільшується, нерівність усе рівне зберігається, оскільки величина $\Delta$, як видно по її визначенню - це як раз максимальне збільшення, не приводящее до нарушению нерівності).

Крім того, старе паросполука $M$ з жорстких ребер можна буде залишити, тобто всі ребра паросполука залишаться жёсткими.

(Доведення. Щоб деякий жорстке ребро $(i,j)$ перестало бути жорстким в результаті зміни потенціалу, треба, аби рівність $u[i] + v[j] = a[i][j]$ превратилось в нерівність $u[i] + v[j] < a[i][j]$. Однак ліва частина могла зменшитися тільки в одному випадку: коли $i \notin Z_1 \& j \in Z_2$. Але раз $i \notin Z_1$, то це означає, що ребро $(i,j)$ не могло бути ребром паросполука, що і потрібно довести).

Нарешті, аби показати, що зміни потенціалу **не можуть відбуватися нескінченно**, зауважимо, що при кожному такому зміні потенціалу кількість вершин, досяжних обходом, тобто $|Z_1|+|Z_2|$, строго збільшується. (При цим не можна стверджувати, що збільшується кількість жорстких ребер).

(Доведення. По-перше, будь-яка вершина, яка була досяжною, досяжною і залишиться. Насправді, якщо деяка вершина досяжна, то до її є деякий шлях з досяжних вершин, що починається в ненасиченої вершині першо] частки; а оскільки для ребер увазі $(i,j), i \in Z_1 \& j \in Z_2$ сума $u[i] + v[j]$ не змінюється, то весь цей шлях сохранится і після зміни потенціалу, що і потрібно довести. По-друге, покажемо, що в результаті перерахунку потенціалу появилась хоча б одна нова досяжна вершина. Але це майже очевидно, якщо вернуться до визначенню $\Delta$: то ребро $(i,j)$, на якому був досягнутий мінімум, тепер стане жорстким, а, значить, вершина $j$ стане досяжною завдяки цьому ребру і вершині $i$).

Таким чином, всього можливо відбуватися не більш $n$ перерахунків потенціалу, перш ніж обнаружится збільшує ланцюжок і потужність паросполука $M$ буде увеличена.

Таким чином, рано або пізно буде знайдений потенціал, якому відповідає вчинене паросполука $M$, є відповіддю на задачу.

Якщо говорити про **асимптотиці** алгоритму, то вона становить $O(n^4)$, оскільки всього має статися $n$ збільшень паросполука, перед кожним з яких відбувається не більш $n$ перерахунків потенціалу, кожний з яких виконується за час $O(n^2)$.

Реализацию за $O(n^4)$ ми тут приводити не будемо, оскільки вона усе рівне вийде не коротше, ніж описана нижче реалізація за $O(n^3)$.

### Побудова алгоритму за $O(n^3)$ ($O(n^2 m)$)

Навчимося тепер реалізовувати той ж алгоритм за асимптотику $O(n^3)$ (для прямокутних задач $n \times m$ - $O(n^2 m)$).

Ключова ідея: тепер ми будемо **додавати в розгляд стрічки матриці одну за однієї**, а не розглядати їх всі зразу. Таким чином, описаний вище алгоритм примет вид:

* Добавляем в розгляд чергову стрічку матриці $a$.

* Поки Що ні збільшоючим ланцюги, що починається в цій стрічки, пересчитываем потенціал.

* Як тільки з'являється збільшує ланцюг, чередуем паросполука уздовж її (включаючи тим самим останню стрічку в паросполука), і переходимо до началу (до рассмотрению наступного стрічки).

Щоб досягти необхідної асимптотики, треба реалізувати шаги 2-3, выполняющиеся для кожної стрічки матриці, за час $O(n^2)$ (для прямокутних задач - за $O(n m)$).

Для цього ми згадаємо два факту, доказанных нами вище:

* При зміні потенціалу вершини, які були досяжні обходом Куна, достижимыми і залишаться.

* Всього могло статися лише $O(n)$ перерахунків потенціалу, перш ніж буде знайдена збільшує ланцюг.

Звідси вытекают **ключевые ідеї**, дозволяють досягти необхідної асимптотики:

* Для перевірки наявності збільшоючим ланцюжка ні необхідності запускати обхід Куна заново після кожного перерахунку потенціалу. Замість цього можна оформить обхід Куна в **итеративном** вигляді: після кожного перерахунку потенціалу ми просматриваем добавившиеся жёсткие ребра і, якщо їх ліві кінці були достижимыми, помічаємо їх праві кінці також як досяжні і продовжуємо обхід з них.

* Развивая цю ідею далі, можна прийти до такому представлению алгоритму: це цикл, на кожному кроці якого спочатку перераховується потенціал, потім знаходиться стовпець, ставший достижимым (а такий завжди знайдеться, оскільки після перерахунку потенціалу завжди з'являються нові досяжні вершини), і якщо цей стовпець був ненасыщен, то знайдена збільшує ланцюг, а якщо стовпець був насыщен - то відповідна йому в паросполуці стрічка також стає досяжною.

Тепер алгоритм приймає вид: цикл додавання стовпців, на кожному з яких спочатку перераховується потенціал, а потім якийсь новий стовпець позначається як досяжний.

* Щоб швидко перераховувати потенціал (швидше, ніж наивный різновид за $O(n^2)$), треба підтримувати допоміжні мінімуми по кожному з стовпців $j$:

$$
minv[j] = \min_{i \in Z_1} \{ a[i][j] - u[i] - v[j] \}.
$$

Як легко бачити, шукана величина $\Delta$ виражається через них наступним чином:

$$
\Delta = \min_{j \notin Z_2} \{ minv[j] \}.
$$

Таким чином, знаходження $\Delta$ тепер можна провести за $O(n)$.

Поддерживать цей масив $minv[]$ необхідно при появі нових відвіданих стрічок. Це, очевидно, можна зробити за $O(n)$ на одну добавляемую стрічку (що в сумі дасть $O(n^2)$). Також оновлювати масив $minv[]$ треба при пересчёте потенціалу, що також робиться за час $O(n)$ на один перерахунок потенціалу (оскільки $minv[]$ змінюється тільки для недостигнутых поки стовпців: а саме, зменшується на $\Delta$).

Таким чином, алгоритм приймає такий вид: у внешнем циклі ми додаємо в розгляд стрічки матриці одну за іншої. Кожна стрічка обробляється за час $O(n^2)$, оскільки при цим могло відбуватися лише $O(n)$ перерахунків потенціалу (кожний - за час $O(n)$), для чого за час $O(n^2)$ підтримується масив $minv[]$; алгоритм Куна сумарно відпрацює за час $O(n^2)$ (оскільки він представлен в формі $O(n)$ ітерацій, на кожної з яких посещается новий стовпець).

Підсумкова асимптотика становить $O(n^3)$ - або, якщо задача прямоугольна, $O(n^2 m)$.

### Реалізація угорського алгоритму за $O(n^3)$ ($O(n^2 m)$)

Наведена реалізація фактично була разработана **Андреем Лопатиным** декілька років назад. Її отличает удивительная лаконичность: весь алгоритм поміщається в **30 стрічок коду**.

Данная реалізація шукає розв'язок для прямоугольной вхідний матриці $a[1 \ldots n][1 \ldots m]$, де $n \le m$. Матриця зберігається в $1$-індексації в цілях зручності і стислості коду. Справа в тому, що в даній реалізації вводятся фиктивные нулевая стрічка і нульовий стовпець, що дозваляє написати багато цикли в загалом вигляді, без додаткових проверок.

Массивы $u[0 \ldots n]$ і $v[0 \ldots m]$ хранят потенціал. Cпершу він нульовий, що вірно для матриці, що складається з нуля стрічок. (Відзначимо, що для даній реалізації не важливо, є або ні в матриці $a[][]$ негативні числа).

Масив $p[0 \ldots m] $ містить паросполука: для кожного стовпчика $i = 1 \ldots m$ він зберігає номер відповідної обраної стрічки $p[i]$ (або $0$, якщо поки нічого не вибрано). При цим $p[0]$ для зручності реалізації покладається рівним номеру поточній розглянутої стрічки.

Масив $minv[1 \ldots m]$ містить для кожного стовпчика $j$ допоміжні мінімуми, необхідні для швидкого перерахунку потенціалу:

$$
minv[j] = \min_{i \in Z_1} \{ a[i][j] - u[i] - v[j] \}.
$$

Масив $way[1 \ldots m]$ містить інформацію про тому, де ці мінімуми достигаются, аби ми згодом змогли відновити збільшує ланцюжок. На перший погляд здається, що в масиві $way[]$ для кожного стовпчика треба зберігати номер стрічки, а також завести ще один масив: для кожної стрічки запам'ятати номер стовпчика, з якого ми в її прийшли. Однак замість цього можна замітити, що алгоритм Куна завжди потрапляє в стрічки, проходячи по ребру паросполука з стовпців, тому номера стрічок для відновлення ланцюжка завжди можна взяти з паросполука (тобто з масиву $p[]$). Таким чином, $way[j]$ для кожного стовпчика $j$ містить номер предшествующего стовпчика (або $0$, якщо такого ні).

Сам алгоритм представляє з собі зовнішній **цикл по рядках матриці**, всередині якого відбувається додавання в розгляд $i$-ой стрічки матриці. Внутренняя частина представляє собою цикл "do-while (p[j0] != 0)", який працює, поки не буде знайдений вільний стовпець $j0$. Кожна ітерація циклу позначає посещённым новий стовпець з номером $j0$ (посчитанным на прошлой ітерації; а спершу рівним нулю - тобто стартуємо ми з фіктивного стовпчика), а також нову стрічку $i0$ - суміжну йому в паросполуці (тобто $p[j0]$; а спершу при $j0=0$ береться $i$-ая стрічка). З-за появи нової посещённой стрічки $i0$ потрібно відповідним чином перерахувати масив $minv[]$, заодно ми знаходимо мінімум в ньому - величину $delta$, і в якому стовпці $j1$ цей мінімум був досягнутий (зауважимо, що при такий реалізації $delta$ могло виявитися рівній нулю, що означає, що на поточному кроці потенціал можна не змінювати: новий досяжний стовпець є і без того). Після цього виготовляється перерахунок потенціалу $u[], v[]$, відповідне зміна масиву $minv[]$. За закінченні циклу "do-while" ми знайшли збільшує ланцюжок, оканчивающуюся в стовпці $j0$, "раскрутить" яку можна, користуючись масивом предків $way[]$.

Константа $INF$ - це "нескінченність", тобто деякий число, свідомо більше всіх можливих чисел у вхідний матриці $a[][]$.

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> u (n+1), v (m+1), p (m+1), way (m+1);
for (int i=1; i<=n; ++i) {
    p[0] = i;
    int j0 = 0;
    vector<int> minv (m+1, INF);
    vector<char> used (m+1, false);
    do {
        used[j0] = true;
        int i0 = p[j0],  delta = INF,  j1;
        for (int j=1; j<=m; ++j)
            if (!used[j]) {
                int cur = a[i0][j]-u[i0]-v[j];
                if (cur < minv[j])
                    minv[j] = cur,  way[j] = j0;
                if (minv[j] < delta)
                    delta = minv[j],  j1 = j;
            }
        for (int j=0; j<=m; ++j)
            if (used[j])
                u[p[j]] += delta,  v[j] -= delta;
            else
                minv[j] -= delta;
        j0 = j1;
    } while (p[j0] != 0);
    do {
        int j1 = way[j0];
        p[j0] = p[j1];
        j0 = j1;
    } while (j0);
}
```

Відновлення відповіді в більш привычной формі, тобто знаходження для кожної стрічки $i = 1 \ldots n$ номера выбранного в ній стовпчика $ans[i]$, робиться наступним чином:

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> ans (n+1);
for (int j=1; j<=m; ++j)
    ans[p[j]] = j;
```

Стоимость знайденого паросполука можна просто взяти як потенціал нульового стовпчика (взятый з противоположным знаком). Насправді, як легко проследить по коду, $-v[0]$ містить в собі суму всіх величин $delta$, тобто сумарне зміна потенціалу. Хоча при кожному зміні потенціалу змінюватися могли зразу декілька величин $u[i]$ і $v[j]$, сумарне зміна величини потенціалу в точності рівне $delta$, оскільки поки ні збільшоючим ланцюги, число досяжних стрічок рівне на одиницю більше числа досяжних стовпців (тільки поточна стрічка $i$ не має собі "пари" в вигляді посещённого стовпчика):

<!--- TODO: specify code snippet id -->
``` cpp
int cost = -v[0];
```

## Приклади задач

Наведемо тут декілька прикладів на розв'язок задачі про призначеннях: починаючи від зовсім тривіальних, і закінчуючи менш очевидными завданнями:

* Дан дводольний граф, потрібно знайти в ньому паросполука **максимальне паросполука мінімального ваги** (тобто в першу чергу максимизируется розмір паросполука, у одному - минимизируется його вартість).

Для розв'язку просто будуємо задачу про призначеннях, ставя на місці отсутствующих ребер число "нескінченність". Після цього вирішуємо задачу венгерским алгоритмом, і видаляємо з відповіді ребра нескінченного ваги (вони могли войти в відповідь, якщо у задачі ні розв'язку в вигляді вчиненого паросполука).

* Дан дводольний граф, потрібно знайти в ньому паросполука **максимальне паросполука максимального ваги**.

Розв'язок знову ж очевидно, тільки всі ваги треба помножити на мінус одиницю (або в венгерском алгоритмі замінити всі мінімуми на максимуми, а нескінченності - на мінус нескінченності).

* Задача **детектирования движущихся об'єктів по снимкам**: було произведено два знімка, по итогам яких було отримано два набір координат. Потрібно соотнести объекты на першому і іншому снимке, тобто визначити для кожної точки іншого знімка, який точці першого знімка вона соответствовала. При цим потрібно мінімізувати суму відстаней між сопоставленными точками (тобто ми шукаємо розв'язок, в якому объекты сумарно пройшли найменший шлях).

Для розв'язку ми просто будуємо і вирішуємо задачу про призначеннях, де в якості ваг ребер выступают евклидовы відстані між точками.

* Задача **детектирования движущихся об'єктів по локаторам**: є два локатора, які умеют визначати не становище объекта в пространстве, а лише напрямок на нього. З обох локаторов (расположенных в різних точках) поступила інформація в вигляді $n$ таких напрямків. Потрібно визначити становище об'єктів, тобто визначити предполагаемые положения об'єктів і відповідні їм пари напрямків так, аби мінімізувати суму відстаней від об'єктів до лучей-напрямків.

Розв'язок - знову ж, просто будуємо і вирішуємо задачу про призначеннях, де вершинами першо] частки є $n$ напрямків з першого локатора, вершинами другий частки - $n$ напрямків зі іншого локатора, а вагами ребер - відстані між відповідними лучами.

* Покриття **орієнтованого ациклічного графа шляхами**: дано орієнтований ациклічний граф, потрібно знайти найменше число шляхів (при рівності - з найменшим суммарным вагою), аби кожна вершина графа лежала б рівне в одному шляхи.

Розв'язок - побудувати по даному графу відповідний дводольний граф, і знайти в ньому максимальне паросполука мінімального ваги. Більш детально див. [окрему статтю](path_cover).

* **Раскраска дерева**. Дано дерево, в якому кожна вершина, крім листя, має рівне $k-1$ синів. Потрібно вибрати для кожної вершини деякий колір з $k$ квітів так, аби ніякі дві смежные вершини не имели одинакового кольори. Крім того, для кожної вершини і кожного кольори відома вартість фарбування цій вершини в цей колір, і потрібно мінімізувати сумарну вартість.

Для розв'язку скористаємось методом динамічного програмування. А саме, навчимося вважати величину $d[v][c]$, де $v$ - номер вершини, $c$ - номер кольори, а саме значення $d[v][c]$ - це минимальная вартість раскраски вершини $v$ разом з її потомками, причому сама вершина $v$ має колір $c$. Щоб порахувати таку величину $d[v][c]$, треба розподілити інші $k-1$ квітів по синам вершини $v$, а для цього треба побудувати і розв'язати задачу про призначеннях (в якій вершини однієї частки - кольори, вершини іншої частки - вершини-сини, а ваги ребер - це значення відповідних динамик $d[][]$).

Таким чином, кожна величина $d[v][c]$ вважається з допомогою розв'язку задачі про призначеннях, що в підсумку дає асимптотику $O(n k^4)$.

* Якщо в задачі про призначеннях ваги задані не у ребер, а у вершин, причому тільки **у вершин однієї частки**, то можна обійтися без угорського алгоритму, а достатньо лише відсортувати вершини по вазі і запустити звичайний [алгоритм Куна](kuhn_matching) (більш детально див. [окрему статтю](vertex_weighted_matching)).

* Розглянемо наступного **приватний випадок**. Нехай кожної вершині першо] частки приписано деякий число $\alpha[i]$, а кожної вершині другий частки - $\beta[j]$. Нехай вага будь-якого ребра $(i,j)$ рівний $\alpha[i] \cdot \beta[j]$ (числа $\alpha[i]$ і $\beta[j]$ нам відомі). Решить задачу про призначеннях.

Для розв'язку без угорського алгоритму розглянемо спочатку випадок, коли в обох частках по дві вершини. В цим випадку, як неважко переконатися, вигідно з'єднувати вершини в зворотньому порядку: вершину з меншої $\alpha[i]$ з'єднати з вершиною з більшої $\beta[j]$. Це правило легко узагальнити на довільне кількість вершин: треба відсортувати вершини першо] частки в порядку збільшення $\alpha[i]$, другий частки - в порядку зменшення $\beta[j]$, і з'єднувати вершини попарно в такому порядку. Таким чином, ми отримуємо розв'язок з асимптотикою $O(n \log n)$.

* **Задача про потенциалах**. Дана матриця $a[1 \ldots n][1 \ldots m]$. Потрібно знайти два масиву $u[1 \ldots n]$ і $v[1 \ldots m]$ такі, що для будь-яких $i$ і $j$ виконується $u[i] + v[j] \le a[i][j]$, але при цим сума елементів масивів $u[]$ і $v[]$ максимальна.

Знаючи угорський алгоритм, розв'язок цій задачі не складе ніякого праці: угорський алгоритм як раз знаходить саме такий потенціал $u[], v[]$, який задовольняє умові задачі. З іншої сторони, без знання угорського алгоритму розв'язати таку задачу представляється майже невозможным.

## Література

* \book{Ravindra Ahuja, Thomas Magnanti, James Orlin}{Network Flows}{1993}{ahuja_flows.djvu}

* \book{Harold Kuhn}{The Hungarian Method for the Assignment Problem}{1955}

* \book{James Munkres}{Algorithms for Assignment and Transportation Problems}{1957}

## Задачі в online judges

Список задач на розв'язок задачі про призначеннях:

* [UVA #10746 **"Crime Wave – The Sequel"** [складність: низька]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1687)

* [UVA #10888 **"Warehouse"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1829)

* [UVA #3276 **"The Great Wall Game"** [складність: висока]](http://livearchive.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1277)

* [UVA #10296 **"Jogging Trails"** [складність: висока]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1237)
