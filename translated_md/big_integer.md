# Довга арифметика

Довга арифметика - це набір программных средств (структури данних і алгоритми), які дозволяють працювати з числами набагато великих величин, ніж це дозволяють стандартні типи данних.

## Виды цілочисельній довгою арифметики

Взагалі кажучи, навіть тільки в олимпиадных завданнях набір средств достатньо велик, тому зробимо классификацию різних видів довгою арифметики.

### Классическая довга арифметика

Основна ідея полягає в тому, що число зберігається в вигляді масиву його цифр.

Цифры можуть використовуватися з тією або інший системи числення, зазвичай застосовуються десятичная система числення і її степені (десять тысяч, миллиард), або двоичная система числення.

Операції над числами в цим вигляді довгою арифметики виробляються з допомогою "школьных" алгоритмів складання, вирахування, множення, ділення столбиком. Втім, до ним також застосовні алгоритми швидкого множення: [Швидке перетворення Фур'є](fft_multiply) і Алгоритм Карацубы.

Тут описана робота тільки з неотрицательными длинными числами. Для поддержки негативних чисел необхідно ввести і підтримувати додатковий прапор "отрицательности" числа, або ж працювати в дополняющих кодах.

#### Структура данних

Хранить длинные числа будемо в вигляді вектора чисел $int$, де кожний елемент - це одна цифра числа.

<!--- TODO: specify code snippet id -->
``` cpp
typedef vector<int> lnum;
```

Для повышения ефективності будемо працювати в системі по основи миллиард, тобто кожний елемент вектора $lnum$ містить не одну, а зразу $9$ цифр:

<!--- TODO: specify code snippet id -->
``` cpp
const int base = 1000*1000*1000;
```

Цифры будуть зберігатися в векторі в такому порядку, що спочатку йдуть наименее значимые цифры (тобто одиниці, десятки, сотни, і т.д)..

Крім того, всі операції будуть реалізовані таким чином, що після виконання будь-який з них лідируючі нулі (тобто зайві нулі в початку числа) відсутні (звісно, в припущенні, що перед кожної операцією лідируючі нулі також відсутні). Слід відзначити, що в представленной реалізації для числа нуль правильно підтримуються зразу два уявлення: порожній вектор цифр, і вектор цифр, що містить єдиний елемент - нуль.

#### Вывод

Самое просте - це висновок довгого числа.

Спочатку ми просто виводимо самий останній елемент вектора (або $0$, якщо вектор порожній), а потім виводимо всі залишилися елементи вектора, дополняя їх нулями до $9$ символів:

<!--- TODO: specify code snippet id -->
``` cpp
printf ("%d", a.empty() ? 0 : a.back());
for (int i=(int)a.size()-2; i>=0; --i)
    printf ("%09d", a[i]);
```

(тут невеликий тонкий момент: потрібно не забути записати приведение типу $(int)$, оскільки в іншому випадку число $a.size()$ будуть беззнаковым, і якщо $a.size() \le 1$, то при вычитании відбудеться переповнення)

#### Чтение

Считываем стрічку в $string$, і потім преобразовываем її в вектор:

<!--- TODO: specify code snippet id -->
``` cpp
for (int i=(int)s.length(); i>0; i-=9)
    if (i < 9)
        a.push_back (atoi (s.substr (0, i).c_str()));
    else
        a.push_back (atoi (s.substr (i-9, 9).c_str()));
```

Якщо використовувати замість $string$ масив $char$'ов, то код вийде ще компактнее:

<!--- TODO: specify code snippet id -->
``` cpp
for (int i=(int)strlen(s); i>0; i-=9) {
    s[i] = 0;
    a.push_back (atoi (i>=9 ? s+i-9 : s));
}
```

Якщо у вхідному числі вже можуть бути лідируючі нулі, то їх після читання можна вилучити таким чином:

<!--- TODO: specify code snippet id -->
``` cpp
while (a.size() > 1 && a.back() == 0)
    a.pop_back();
```

#### Сложение

Прибавляет до числу $a$ число $b$ і зберігає результат в $a$:

<!--- TODO: specify code snippet id -->
``` cpp
int carry = 0;
for (size_t i=0; i<max(a.size(),b.size()) || carry; ++i) {
    if (i == a.size())
        a.push_back (0);
    a[i] += carry + (i < b.size() ? b[i] : 0);
    carry = a[i] >= base;
    if (carry)  a[i] -= base;
}
```

#### Вычитание

Отнимает від числа $a$ число $b$ ($a \ge b$) і зберігає результат в $a$:

<!--- TODO: specify code snippet id -->
``` cpp
int carry = 0;
for (size_t i=0; i<b.size() || carry; ++i) {
    a[i] -= carry + (i < b.size() ? b[i] : 0);
    carry = a[i] < 0;
    if (carry)  a[i] += base;
}
while (a.size() > 1 && a.back() == 0)
    a.pop_back();
```

Тут ми після виконання вирахування видаляємо лідируючі нулі, аби підтримувати предикат про тому, що такі відсутні.

#### Умножение довгого на короткий

Примножує длинное $a$ на короткий $b$ ($b < {\rm base}$) і зберігає результат в $a$:

<!--- TODO: specify code snippet id -->
``` cpp
int carry = 0;
for (size_t i=0; i<a.size() || carry; ++i) {
    if (i == a.size())
        a.push_back (0);
    long long cur = carry + a[i] * 1ll * b;
    a[i] = int (cur % base);
    carry = int (cur / base);
}
while (a.size() > 1 && a.back() == 0)
    a.pop_back();
```

Тут ми після виконання ділення видаляємо лідируючі нулі, аби підтримувати предикат про тому, що такі відсутні.

(Зауваження: спосіб **додаткової оптимізації**. Якщо швидкість роботи надзвичайно важна, то можна спробувати замінити два ділення одним: порахувати тільки целую частина від ділення (в коді це змінна $carry$), а потім вже порахувати по ній залишок від ділення (з допомогою однієї операції множення). Як правило, цей прийом дозваляє прискорити код, хоча і не дуже значно).

#### Умножение двох довгих чисел

Примножує $a$ на $b$ і результат зберігає в $c$:

<!--- TODO: specify code snippet id -->
``` cpp
lnum c (a.size()+b.size());
for (size_t i=0; i<a.size(); ++i)
    for (int j=0, carry=0; j<(int)b.size() || carry; ++j) {
        long long cur = c[i+j] + a[i] * 1ll * (j < (int)b.size() ? b[j] : 0) + carry;
        c[i+j] = int (cur % base);
        carry = int (cur / base);
    }
while (c.size() > 1 && c.back() == 0)
    c.pop_back();
```

#### Деление довгого на короткий

Делит длинное $a$ на короткий $b$ ($b < {\rm base}$), приватна зберігає в $a$, залишок в $carry$:

<!--- TODO: specify code snippet id -->
``` cpp
int carry = 0;
for (int i=(int)a.size()-1; i>=0; --i) {
    long long cur = a[i] + carry * 1ll * base;
    a[i] = int (cur / b);
    carry = int (cur % b);
}
while (a.size() > 1 && a.back() == 0)
    a.pop_back();
```

### Довга арифметика в факторизованном вигляді

Тут ідея полягає в тому, аби зберігати не саме число, а його факторизацію, тобто степені кожного входящего в нього простого.

Цей метод також вельми простий для реалізації, і в ньому дуже легко виробляти операції множення і ділення, однак неможливо провести складання або віднімання. З іншої сторони, цей метод значно экономит пам'ять в порівняно з "класичним" подходом, і дозваляє виробляти множення і поділ значно (асимптотично) швидше.

Цей метод часто застосовується, коли необхідно виробляти поділ по непростому модулю: тоді достатньо зберігати число в вигляді степеней по простим дільникам цього модуля, і ще одного числа - залишку по цьому ж модулю.

### Довга арифметика по системі простих модулів (Китайська теорема або схема Гарнера)

Суть в тому, що вибирається деяка система модулів (зазвичай невеликих, помещающихся в стандартні типи данних), і число зберігається в вигляді вектора з остатков від його ділення на кожний з цих модулів.

Як стверджує Китайська теорема про залишки, цього достатньо, аби однозначно зберігати будь-яке число в діапазоні від 0 до твори цих модулів мінус один. При цим є [Алгоритм Гарнера](chinese_theorem), який дозваляє провести це відновлення з модульного увазі в звичайну, "класичну", форму числа.

Таким чином, цей метод дозваляє экономить пам'ять по порівняно з "классической" довгою арифметикой (хоча в деяких випадках не настільки радикально, як метод факторизації). Крому того, в модульном вигляді можна дуже швидко виробляти складання, вирахування і множення, - всі за асимптотично однаковое час, пропорциональное кількості модулів системи.

Однак усе це даётся ціною вельми трудоёмкого перекладу числа з цього модульного увазі в звичайний вид, для чого, крім немалых временных затрат, буде потрібно також реалізація "классической" довгою арифметики з множенням.

Крім цього, виробляти **поділ** чисел в такому поданні по системі простих модулів не представляється можливим.

## Виды дробової довгою арифметики

Операції над дробовими числами зустрічаються в олимпиадных завданнях набагато реже, і працювати з огромными дробовими числами значно складніше, тому в олимпиадах зустрічається тільки специфическое підмножина дробової довгою арифметики.

### Довга арифметика в несократимых дробях

Число представляється в вигляді несократимой дроби $\frac{a}{b}$, де $a$ і $b$ - цілі числа. Значить всі операції над дробовими числами неважко звести до операциям над числителями і знаменниками цих дробів.

Обычно при цим для зберігання числителя і знаменателя доводиться також використовувати довгу арифметику, але, втім, самий простий її вид - "классическая" довга арифметика, хоча іноді виявляється достатньо встроенного 64-битного числового типу.

### Выделение позиції плаваючою точки в окремий тип

Іноді в задачі потрібно виробляти расчёты з дуже великими або дуже маленькими числами, але при цим не допускать їх переповнення. Встроенный $8-10$-байтовый тип $double$, як відомо, допускає значення експоненти в діапазоні $[-308; 308]$, чого іноді можливо виявитися недостатньо.

Приём, власне, дуже простий - вводиться ще одна целочисленная змінна, отвечающая за экспоненту, а після виконання кожної операції дробове число "нормализуется", тобто повертається в відрізок $[0.1; 1)$, шляхом збільшення або зменшення експоненти.

При перемножении або делении двох таких чисел треба відповідно сложить або відняти їх експоненти. При сложении або вычитании перед виконанням цій операції числа випливає привести до однієї экспоненте, для чого одне з них домножается на $10$ в степені різниці экспонент.

Нарешті, зрозуміло, що не обов'язково вибирати $10$ в якості основания експоненти. Исходя з устройства встроенных типів з плаваючою точкою, самим выгодным представляється класти основание рівним $2$.
