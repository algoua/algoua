# Пошук в глибину

Це один з основних алгоритмів на графах.

В результаті пошуку в глибину знаходиться лексикографічно перший шлях в графі.

Алгоритм працює за **O (N+M)**.

## Застосування алгоритму

* Пошук будь-якого шляхи в графі.
* Пошук лексикографічно першого шляхи в графі.
* Перевірка, є або одна вершина дерева предком іншої:
В початку і наприкінці ітерації пошуку в глибину буде запам'ятовувати "час" заходу і виходу в кожної вершині. Тепер за O(1) можна знайти відповідь: вершина i є предком вершини j тоді і тільки тоді, коли start<sub>i</sub> < start<sub>j</sub> і end<sub>i</sub> > end<sub>j</sub>.
* [Задача LCA (найменший загальний предок)](lca).
* [Топологічна сортування](topological_sort):
Запускаем серію пошуків в глибину, аби обійти всі вершини графа. Відсортуємо вершини по часу виходу по зменшенням - це і буде відповіддю.
* [Перевірка графа на ациклічності і знаходження циклу](finding_cycle)
* [Пошук компонент сильної зв'язності](strong_connected_components):
Спочатку робимо топологічну сортування, потім транспонируем граф і проводимо знову серію пошуків в глибину в порядку, определяемом топологічної сортуванням. Кожне дерево пошуку - сильносвязная компонента.
* [Пошук мостів](bridge_searching):
Спочатку превращаем граф в орієнтований, роблячи серію пошуків в глибину, і ориентируя кожне ребро так, як ми намагалися по нього пройти. Потім знаходимо сильносвязные компоненти. Мостами є ті ребра, кінці яких належать різним сильносвязным компонентів.

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
vector < vector<int> > g; // граф
int n; // кількість вершин

vector<int> color; // колір вершини (0, 1, або 2)

vector<int> time_in, time_out; // "часи" заходу і виходу з вершини
int dfs_timer = 0; // "таймер" для визначення часів

void dfs (int v) {
    time_in[v] = dfs_timer++;
    color[v] = 1;
    for (vector<int>::iterator i=g[v].begin(); i!=g[v].end(); ++i)
        if (color[*i] == 0)
            dfs (*i);
    color[v] = 2;
    time_out[v] = dfs_timer++;
}
```
Це найбільш загальний код. У багатьох випадках часи заходу і виходу з вершини не важливі, так ж як і не важливі кольори вершин (але тоді треба буде ввести аналогічний по смыслу булевий масив used). Ось найбільш проста реалізація:

<!--- TODO: specify code snippet id -->
``` cpp
vector < vector<int> > g; // граф
int n; // кількість вершин

vector<char> used;

void dfs (int v) {
    used[v] = true;
    for (vector<int>::iterator i=g[v].begin(); i!=g[v].end(); ++i)
        if (!used[*i])
            dfs (*i);
}
```
