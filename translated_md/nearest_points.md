# Знаходження пари найближчих точок

## Постановка задачі

Дано $n$ точок $p_i$ на площині, задані своїми координатами $(x_i,y_i)$. Потрібно знайти серед них такі дві точки, відстань між якими минимально:

$$
\min_{\scriptstyle i,j=0 \ldots n-1, \atop \scriptstyle i \ne j} \rho (p_i,p_j).
$$

Расстояния ми беремо звичайні евклидовы:

$$
\rho(p_i,p_j) = \sqrt{ (x_i-x_j)^2 + (y_i-y_j)^2 }.
$$

Тривіальний алгоритм - перебор всіх пар і обчислення відстані для кожної - працює за $O(n^2)$. Нижче описується алгоритм, працюючий за час $O(n \log n)$. Цей алгоритм був запропонований Препаратой (Preparata) в 1975 р. Препарата і Шамос також показали, що в модели дерева рішень цей алгоритм асимптотично оптимальний.

## Алгоритм

Побудуємо алгоритм по загальної схемою алгоритмів **"разделяй-і-властвуй"**: алгоритм оформляем в вигляді рекурсивної функції, якій передається множину точок; ця рекурсивна функція розбиває це множину навпіл, викликає собі рекурсивно від кожної половини, а потім виконує які-то операції по объединению відповідей. Операція про'єднання полягає в обнаружении випадків, коли одна точка оптимального розв'язку попала в одну половину, а інша точка - в іншу (в цим випадку рекурсивні виклики від кожної з половинок окремо виявити цю пару, звісно, не смогут). Основна складність, як завжди, полягає в ефективної реалізації цій стадії про'єднання. Якщо рекурсивної функції передається множину з $n$ точок, то стадия про'єднання повинна працювати не більш, ніж $O(n)$, тоді асимптотика всього алгоритму $T(n)$ буде перебувати з рівняння:

$$
T(n) = 2 T(n/2) + O(n).
$$

Решением цього рівняння, як відомо, є $T(n) = O (n \log n)$.

Отже, перейдемо до побудови алгоритму. Щоб в будущем прийти до ефективної реалізації стадії про'єднання, розбивати множину точок на два будемо згідно їх $x$-координатам: фактично ми проводимо деяку вертикальну пряму, разбивающую множину точок на два підмножини приблизно однакових розмірів. Таке розбиття зручно провести наступним чином: відсортуємо точки стандартно як пари чисел, тобто:

$$
p_i < p_j \Longleftrightarrow (x_i < x_j) \lor \Bigl( (x_i = x_j) \land (y_i < y_j) \Bigr).
$$

Значить візьмемо среднюю після сортування точку $p_m$ ($m = \lfloor n/2 \rfloor$), і всі точки до її і саму $p_m$ віднесемо до першо] половині, а всі точки після її - до другий половині:

$$
A_1 = \{ p_i\ |\ i = 0 \ldots m \},
$$

$$
A_2 = \{ p_i\ |\ i = m+1 \ldots n-1 \}.
$$

Тепер, вызвавшись рекурсивно від кожного з множин $A_1$ і $A_2$, ми найдемо відповіді $h_1$ і $h_2$ для кожної з половинок. Візьмемо кращий з них: $h = \min (h_1, h_2)$.

Тепер нам треба провести **стадию про'єднання**, тобто спробувати виявити такі пари точок, відстань між якими менше $h$, причому одна точка лежить в $A_1$, а інша - в $A_2$. Очевидно, що для цього достатньо розглядати тільки ті точки, які отстоят від вертикальної прямої розділу на відстань, менше $h$, тобто множину $B$ розглянутих на цій стадії точок рівне:

$$
B = \{ p_i\ |\ | x_i - x_m | < h \}.
$$

Для кожної точки з множини $B$ треба спробувати знайти точки, що знаходяться до ній ближче, ніж $h$. Наприклад, достатньо розглядати тільки ті точки, координата $y$ яких відрізняється не більш ніж на $h$. Більш того, не має сенсу розглядати ті точки, у яких $y$-координата більше $y$-координати поточній точки. Таким чином, для кожної точки $p_i$ визначимо множину розглянутих точок $C(p_i)$ наступним чином:

$$
C(p_i) = \{ p_j\ |\ p_j \in B,\ \ y_i - h < y_j \le y_i \}.
$$

Якщо ми відсортуємо точки множини $B$ по $y$-координаті, то знаходити $C(p_i)$ буде дуже легко: це декілька точок поспіль до точки $p_i$.

Отже, в нових позначеннях **стадия про'єднання** виглядає наступним чином: побудувати множину $B$, відсортувати в ньому точки по $y$-координаті, потім для кожної точки $p_i \in B$ розглянути всі точки $p_j \in C(p_i)$, і кожної пари $(p_i,p_j)$ порахувати відстань і порівняти з поточним наилучшим відстанню.

На перший погляд, це як і раніше неоптимальный алгоритм: здається, що розміри множин $C(p_i)$ будуть порядку $n$, і необхідна асимптотика ніяк не вийде. Однак, як це ні дивовижно, можна довести, що розмір кожного з множин $C(p_i)$ є величина $O(1)$, тобто не перевершує деякої малої константи поза залежності від самих точок. Доведення цього факту наведено в наступному розділі.

Нарешті, обратим увага на сортування, яких вищеописаний алгоритм містить зразу дві: спочатку сортування по парам ($x$,$y$), а потім сортування елементів множини $B$ по $y$. Насправді, від обох цих сортировок всередині рекурсивної функції можна позбутися (інакше б ми не досягли оцінки $O(n)$ для стадії про'єднання, і загальна асимптотика алгоритму вийшла б $O(n \log^2 n)$). Від першо] сортування позбутися легко - достатньо попередньо, до запуску рекурсії, виконати цю сортування: адже всередині рекурсії самі елементи не змінюються, тому ні ніякий необхідності виконувати сортування заново. Со другий сортуванням трохи складніше, виконати її попередньо не вийде. Зато, вспомнив **сортування слиянием** (merge sort), яка теж працює по принципом разделяй-і-властвуй, можна просто встроить цю сортування в нашу рекурсію. Нехай рекурсія, принимая якесь множину точок (як ми пам'ятаємо, упорядоченное по парам $(x,y)$) повертає це ж множину, але отсортированное вже по координаті $y$. Для цього достатньо просто виконати злиття (за $O(n)$) двох результатів, возвращённых рекурсивными викликами. Тим самим вийде отсортированное по $y$ множину.

## Оцінка асимптотики

Щоб показати, що вищеописаний алгоритм дійсно виконується за $O(n \log n)$, нам залишилося довести наступного факт: $|C(p_i)| = O(1)$.

Отже, нехай ми розглядаємо якусь точку $p_i$; нагадаємо, що множину $C(p_i)$ - це множину точок, $y$-координата яких лежить в відрізку $[y_i-h; y_i]$, а, крім того, по координаті $x$ і сама точка $p_i$, і всі точки множини $C(p_i)$ лежати в полосе шириной $2h$. Іншими словами, рассматриваемые нами точки $p_i$ і $C(p_i)$ лежати в прямокутнику розміру $2h \times h$.

Наша задача - оцінити максимальне кількість точок, яке можливо лежати в цим прямокутнику $2h \times h$; тим самим ми оцінимо і максимальний розмір множини $C(p_i)$. При цим при оценке треба не забувати, що можуть зустрічатися повторювані точки.

Згадаймо, що $h$ виходило як мінімум з двох результатів рекурсивних викликів - від множин $A_1$ і $A_2$, причому $A_1$ містить точки ліворуч від лінії розділу і частково на ній, $A_2$ - залишилися точки лінії розділу і точки справа від її. Для будь-який пари точок з $A_1$, рівне як і з $A_2$, відстань не можливо виявитися менше $h$ - інакше б це означало некорректность роботи рекурсивної функції.

Для оцінки максимального кількості точок в прямокутнику $2h \times h$ розіб'ємо його на два квадрата $h \times h$, до першого квадрату віднесемо всі точки $C(p_i) \cap A_1$, а до другого - всі інші, тобто $C(p_i) \cap A_2$. З приведённых вище міркувань випливає, що в кожному з цих квадратів відстань між будь-якими двома точками не менш $h$.

Покажемо, що в кожному квадрате **не більш чотирьох** точок. Наприклад, це можна зробити наступним чином: розіб'ємо квадрат на 4 подквадрата зі сторонами $h/2$. Значить в кожному з цих подквадратов не можливо бути більше однієї точки (т.до. навіть діагональ рівна $h / \sqrt{2}$, що менше $h$). Отже, у усьому квадрате не можливо бути більш 4 точок.

Отже, ми довели, що в прямокутнику $2h \times h$ не можливо бути більше $4 \cdot 2 = 8$ точок, а, отже, розмір множини $C(p_i)$ не можливо перевершувати $7$, що і потрібно довести.

## Реалізація

Введемо структуру данних для зберігання точки (її координати і якийсь номер) і оператори порівняння, необхідні для двох видів сортування:

<!--- TODO: specify code snippet id -->
``` cpp
struct pt {
    int x, y, id;
};

inline bool cmp_x (const pt & a, const pt & b) {
    return a.x < b.x || a.x == b.x && a.y < b.y;
}

inline bool cmp_y (const pt & a, const pt & b) {
    return a.y < b.y;
}

pt a[MAXN];
```

Для удобной реалізації рекурсії введемо допоміжну функцію $upd\_ans()$, яка буде обчислювати відстань між двома точками і перевіряти, не краще або це поточного відповіді:

<!--- TODO: specify code snippet id -->
``` cpp
double mindist;
int ansa, ansb;

inline void upd_ans (const pt & a, const pt & b) {
    double dist = sqrt ((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y) + .0);
    if (dist < mindist)
        mindist = dist,  ansa = a.id,  ansb = b.id;
}
```

Нарешті, реалізація самою рекурсії. Передбачається, що перед її викликом масив $a[]$ вже отсортирован по $x$-координаті. Рекурсии передається просто два покажчика $l$, $r$, які указывают, що вона повинна шукати відповідь для $a[l \ldots r]$. Якщо відстань між $r$ і $l$ занадто мало, то рекурсію треба зупинити, і виконати тривіальний алгоритм пошуку найближчій пари і потім відсортувати подмассив по $y$-координаті.

Для злиття двох множин точок, отриманих від рекурсивних викликів, в одне (упорядоченное по $y$-координаті), ми використовуємо стандартну функцію STL $merge()$, і створюємо допоміжний буфер $t[]$ (один на всі рекурсивні виклики). (Использовать $inplace\_merge()$ недоцільно, т.до. вона в загалом випадку працює не за лінійне час).

Нарешті, множину $B$ зберігається в тому ж масиві $t$.

<!--- TODO: specify code snippet id -->
``` cpp
void rec (int l, int r) {
    if (r - l <= 3) {
        for (int i=l; i<=r; ++i)
            for (int j=i+1; j<=r; ++j)
                upd_ans (a[i], a[j]);
        sort (a+l, a+r+1, &cmp_y);
        return;
    }
    
    int m = (l + r) >> 1;
    int midx = a[m].x;
    rec (l, m),  rec (m+1, r);
    static pt t[MAXN];
    merge (a+l, a+m+1, a+m+1, a+r+1, t, &cmp_y);
    copy (t, t+r-l+1, a+l);

    int tsz = 0;
    for (int i=l; i<=r; ++i)
        if (abs (a[i].x - midx) < mindist) {
            for (int j=tsz-1; j>=0 && a[i].y - t[j].y < mindist; --j)
                upd_ans (a[i], t[j]);
            t[tsz++] = a[i];
        }
}
```

До Речі кажучи, якщо всі координати цілі, то на час роботи рекурсії можна взагалі не переходити до дробным величинам, і зберігати в $mindist$ квадрат мінімального відстані.

В основний програмі викликати рекурсію випливає так:

<!--- TODO: specify code snippet id -->
``` cpp
sort (a, a+n, &cmp_x);
mindist = 1E20;
rec (0, n-1);
```

## Узагальнення: пошук трикутника з мінімальним периметром

Описанный вище алгоритм цікаво узагальнюється і на цю задачу: серед заданого множини точок вибрати три різних точки так, аби сума попарных відстаней між ними була найменшою.

За суті, для розв'язку цій задачі алгоритм залишається прежним: ми разделяем поле на дві половинки вертикальної прямої, викликаємо розв'язок рекурсивно від обох половинок, вибираємо мінімум $minper$ з знайдених периметров, будуємо смужку толщиной $minper / 2$, і в ній перебираємо всі трикутники, способные покращити відповідь. (Відзначимо, що у трикутника з периметром $\le minper$ длиннейшая сторона $\le minper/2$).

## Задачі в online judges

Список задач, які зводяться до пошуку двох найближчих точок:

* [ UVA 10245 **"The Closest Pair Problem"** ~~~~~~ [складність: низька] ](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1186)

* [ SPOJ #8725 CLOPPAIR **"Closest Point Pair"** ~~~~~~ [складність: низька] ](http://www.spoj.pl/problems/CLOPPAIR/)

* [ CODEFORCES Командная олимпиада школьников Саратова - 2011 **"Минимальная сума"** ~~~~~~ [складність: середня] ](http://codeforces.ru/contest/120/problem/J)

* [ Google CodeJam 2009 Final **"Min Perimeter"** ~~~~~~ [складність: середня] ](http://code.google.com/codejam/contest/311101/dashboard#s=a&a=1)

* [ SPOJ #7029 CLOSEST **"Closest Triple"** ~~~~~~ [складність: середня] ](https://www.spoj.pl/problems/CLOSEST/)
