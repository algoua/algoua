# Пошук всіх тандемних повторів в стрічки. Алгоритм Мейн-Лоренца

Дана стрічка $s$ довжини $n$.

**Тандемным повтором** (tandem repeat) в ній називаються два входження який-або підстрічки поспіль. Іншими словами, тандемний повтор описується парою індексів $i < j$ такими, що підстрічка $s[i \ldots j]$ - це дві однакові стрічки, записані поспіль.

Задача полягає в тому, аби **знайти всі тандемні повтори**. Упрощённые варіанти цій задачі: знайти **будь-який** тандемний повтор або знайти **довжелезний** тандемний повтор.

**Зауваження**. Щоб уникнути путаницы всі стрічки в статті ми будемо вважати 0-индексированными, тобто перший символ стрічки має індекс 0.

Описаний тут алгоритм був опубліковано в 1982 р. Мейном і Лоренцем (див. список літератури).

## Приклад

Розглянемо тандемні повтори на прикладі який-нибудь простий стрічки, наприклад:

$$
"acababaee"
$$

В цій стрічки присутствуют наступні тандемні повтори:

* $[2;5] = "abab"$
* $[3;6] = "baba"$
* $[7;8] = "ee"$

Інший приклад:

$$
"abaaba"
$$

Тут є тільки два тандемних повтору:

* $[0;5] = "abaaba"$
* $[2;3] = "aa"$

## Число тандемних повторів

Взагалі кажучи, тандемних повторів в стрічки довжини $n$ можливо бути порядку $O(n^2)$.

Очевидным прикладом є стрічка, составленная з $n$ однакових букв - в такий стрічки тандемным повтором є будь-яка підстрічка парної довжини, яких приблизно $n^2 / 4$. Взагалі, будь-яка периодичная стрічка з коротким періодом буде містити дуже багато тандемних повторів

З іншої сторони, сам по собі цей факт ніяк не препятствует существованию алгоритму з асимптотикою $O(n \log n)$, оскільки алгоритм можливо выдавать тандемні повтори в тому або іншому стислому вигляді, группами по декілька штук зразу.

Більш того, існує поняття **серій** - четвірок чисел, які описывают целую групу периодических підстрічок. Было доведено, що число серій в будь-який стрічки линейно по відношенню до довжині стрічки.

Втім, описаний нижче алгоритм не використовує поняття серій, тому не будемо детализировать це поняття.

Наведемо тут і інші интересные результати, относящиеся до кількості тандемних повторів:

* Відомо, що якщо розглядати тільки примитивные тандемні повтори (тобто такі, половинки яких не є кратными рядками), то їх кількість в будь-який стрічки - $O(n \log n)$.

* Якщо кодировать тандемні повтори трійками чисел (называемыми трійками Крочемора (Crochemore)) $(i,p,r)$ (де $i$ - позиція початку, $p$ - довжина повторяющейся підстрічки, $r$ - кількість повторів), то всі тандемні повтори будь-який стрічки можна вивести з допомогою $O(n \log n)$ таких трійок. (Саме такий результат виходить на виході алгоритму Крочемора знаходження всіх тандемних повторів).

* Рядки Фібоначчі, определяемые наступним чином:

$$
t_0 = b,
$$

$$
t_1 = a,
$$

$$
t_i = t_{i-1} + t_{i-2},
$$

є "сильно" периодичными.

Число тандемних повторів в $i$-ой стрічки Фібоначчі довжини $f_i$, навіть сжатых з допомогою трійок Крочемора, становить $O(f_n \log f_n)$.

Число примитивных тандемних повторів в рядках Фібоначчі - також має порядок $O(f_n \log f_n)$.

## Алгоритм Мейн-Лоренца

Ідея алгоритму Мейн-Лоренца досить стандартна: це алгоритм **"разделяй-і-властвуй"**.

Кратко він полягає в тому, що исходная стрічка розбивається навпіл, розв'язок запускується від кожної з двох половинок по окремо (тим самим ми найдемо всі тандемні повтори, располагающиеся тільки в першо] або тільки у другий половинке). Далі йде сама сложная частина - це знаходження тандемних повторів, починаються в першо] половині і закінчуються у другий (назвемо такі тандемні повтори для зручності **пересекающими**). Як саме це робиться - і є сама суть алгоритму Мейн-Лоренца; це ми детально опишемо нижче.

Асимптотика алгоритму "разделяй-і-властвуй" добре исследована. В зокрема, для нас важливо, що якщо ми навчимося шукати пересекающие тандемні повтори в стрічки довжини $n$ за $O(n)$, то підсумкова асимптотика всього алгоритму вийде $O(n \log n)$.

### Пошук перетинають тандемних повторів

Отже, алгоритм Мейн-Лоренца свёлся до тому, аби по заданої стрічки $s$ навчитися шукати всі пересекающие тандемні повтори, тобто такі, які починаються в першо] половині стрічки, а заканчиваются - у другий.

Позначимо через $u$ і $v$ дві половинки стрічки $s$:

$$
s = u + v
$$

(їх довжини приблизно рівні довжині стрічки $s$, поділеній навпіл).

#### Правые і ліві тандемні повтори

Розглянемо довільний тандемний повтор і подивимося на його средний символ (точніше, на той символ, з якого починається друга половинка тандема; тобто якщо тандемний повтор - це підстрічка $s[i \ldots j]$, то середнім символом буде $(i+j+1)/2$.

Значить назвемо тандемний повтор **лівим або правим** в залежності від того, де знаходиться цей символ - в стрічки $u$ або в стрічки $v$. (Можна сказати і так: тандемний повтор називається лівим, якщо большая його частина лежить в лівої половині стрічки $s$; інакше - тандемний повтор називається правим).

Навчимося шукати **всі ліві тандемні повтори**; для правих усе буде аналогічно.

#### Центральная позиція $cntr$ тандемного повтору

Позначимо довжину шуканого лівого тандемного повтору через $2k$ (тобто довжина кожної половинки тандемного повтору - це $k$). Розглянемо перший символ тандемного повтору, попадающий в стрічку $v$ (він варто в стрічки $s$ в позиції $length(u)$). Він збігається з символом, стоящим на $k$ позицій раніше нього; позначимо цю позицію через $cntr$.

**Шукати всі тандемні повтори ми будемо, перебираючи цю позицію $cntr$**: тобто найдемо спочатку всі тандемні повтори з одним значенням $cntr$, потім з іншим значенням, і т.д. - перебираючи всі можливі значення $cntr$ від $0$ до $length(u)-1$.

**Наприклад**, розглянемо таку стрічку:

$$
s = "cac|ada"
$$

(символ вертикальної черты розділяє дві половинки $u$ і $v$)

Тандемный повтор $"caca"$, що міститься в цій стрічки, буде обнаружен, коли ми будемо переглядати значення $cntr = 1$ - тому що саме в позиції $1$ варто символ 'a', збігається з першим символом тандемного повтору, попавшим в половинку $v$.

#### Критерій наявності тандемного повтору з заданим центром $cntr$

Отже, ми повинні навчитися для зафиксированного значення $cntr$ швидко шукати всі тандемні повтори, відповідні йому.

Получаем таку схему (для абстрактной стрічки, в якій міститься тандемний повтор $"abcabc"$):

$$$
\setlength{\unitlength}{2mm}

\begin{picture}(30,20)

* nethickness{0.075mm}
\put(0,10)%
{\line(0,1){2}}
\put(30,10)%
{\line(0,1){2}}
\put(0,10)%
{\line(1,0){30}}
\put(0,12)%
{\line(1,0){30}}

\put(10.5,10)%
{\line(0,1){2}}
\put(12,10)%
{\line(0,1){2}}
\put(11.25,6.1)%
{\vector(0,1){3.4}}
\put(10.5,5)%
{$cntr$}

* nethickness{0.4mm}
\put(15,10)%
{\line(0,1){2}}
* nethickness{0.075mm}

\put(9.3,10.5)
{a}
\put(10.8,10.5)
{b}
\put(12.3,10.5)
{c}
\put(13.8,10.5)
{a}
\put(15.3,10.5)
{b}
\put(16.8,10.5)
{c}

\put(12,12.5)%
{\oval(3,0.6)[t]}
\put(11.5,13.5)%
{$l_2$}
\put(16.5,12.5)%
{\oval(3,0.6)[t]}
\put(16,13.5)%
{$l_2$}

\put(9.75,9.5)%
{\oval(1.5,0.6)[b]}
\put(9.1,7.5)%
{$l_1$}
\put(14.25,9.5)%
{\oval(1.5,0.6)[b]}
\put(13.6,7.5)%
{$l_1$}

\end{picture}
$$$

Тут через $l_1$ і $l_2$ ми обозначили довжини двох шматочків тандемного повтору: $l_1$ - це довжина частини тандемного повтору до позиції $cntr-1$, а $l_2$ - це довжина частини тандемного повтору від $cntr$ до кінця половинки тандемного повтору. Таким чином, $l_1+l_2+l_1+l_2$ - це довжина тандемного повтору.

Взглянув на цю картинку, можна зрозуміти, що **необхідне і достатню** умова того, що з центром в позиції $cntr$ знаходиться тандемний повтор довжини $2 l = 2 (l_1 + l_2) = 2 (length(u) - cntr)$, є випливає умова:

* Нехай $k_1$ - це найбільше число таке, що $k_1$ символів перед позицією $cntr$ збігаються з последними $k_1$ символами стрічки $u$:

$$
u[ cntr-k_1 \ldots cntr-1 ] == u[ length(u)-k_1 \ldots length(u)-1 ].
$$

* Нехай $k_2$ - це найбільше число таке, що $k_2$ символів, починаючи з позиції $cntr$, збігаються з першими $k_2$ символами стрічки $v$:

$$
u[ cntr \ldots cntr+k_2-1] == v[ 0 \ldots k_2-1 ].
$$

* Значить має виконуватися:

$$
\cases{
l_1 \le k_1, \cr
l_2 \le k_2.
}
$$

Цей критерій можна **переформулювати** таким чином. Зафіксуємо конкретне значення $cntr$, тоді:

* Усе тандемні повтори, які ми будемо зараз обнаруживать, будуть мати довжину $2 l = 2 (length(u) - cntr)$.

Однак таких тандемних повторів можливо бути **декілька**: усе залежить від вибору довжин шматочків $l_1$ і $l_2 = l - l_1$.

* Знайдемо $k_1$ і $k_2$, як було описано вище.

* Значить подходящими будуть бути тандемні повтори, для яких довжини шматочків $l_1$ і $l_2$ задовольняють умовами:

$$
\cases{
l_1 + l_2 = l = length(u) - cntr, \cr
l_1 \le k_1, \cr
l_2 \le k_2.
}
$$

#### Алгоритм знаходження довжин $k_1$ і $k_2$

Отже, вся задача зводиться до быстрому обчислення довжин $k_1$ і $k_2$ для кожного значення $cntr$.

Нагадаємо їх визначення:

* $k_1$ - максимальне невід'ємне число, для якого виконано:

$$
u[ cntr-k_1 \ldots cntr-1 ] == u[ length(u)-k_1 \ldots length(u)-1 ].
$$

* $k_2$ - максимальне невід'ємне число, для якого виконано:

$$
u[ cntr \ldots cntr+k_2-1] == v[ 0 \ldots k_2-1 ].
$$

На обидва цих запиту можна відповідати за $O(1)$, використовуючи **[алгоритм знаходження Z-функції](z_function)**:

* Для швидкого знаходження значень $k_1$ заздалегідь порахуємо Z-функцію для стрічки $\overline{u}$ (тобто стрічки $u$, выписанной в зворотньому порядку).

Значить значення $k_1$ для конкретного $cntr$ буде просто рівне соответствующему значенням масиву Z-функції.

* Для швидкого знаходження значень $k_2$ заздалегідь порахуємо Z-функцію для стрічки $v+\#+u$ (тобто стрічки $u$, приписанной до стрічки $v$ через символ-роздільник).

Знову ж, значення $k_2$ для конкретного $cntr$ треба буде просто взяти з відповідного елементу Z-функції.

#### Пошук правих тандемних повторів

До цього моменту ми работали тільки з левыми тандемными повторами.

Щоб шукати праві тандемні повтори, треба діяти аналогічно: ми визначаємо центр $cntr$ як символ, відповідний последнему символу тандемного повтору, попавшему в першу стрічку.

Значить довжина $k_1$ буде визначатися як найбільше число символів до позиції $cntr$ включно, співпадаючих з последними символами стрічки $u$. Довжина $k_2$ буде визначатися як максимальне число символів, починаючи з $cntr+1$, співпадаючих з першими символами стрічки $v$.

Таким чином, для швидкого знаходження $k_1$ і $k_2$ треба буде порахувати заздалегідь Z-функцію для стрічок $\overline{u} + \# + \overline{v}$ і $v$ відповідно. Після цього, перебираючи конкретне значення $cntr$, ми по тому ж самому критерию будемо знаходити всі праві тандемні повтори.

#### Асимптотика

Асмиптотика алгоритму Мейн-Лоренца складе, таким чином, $O(n \log n)$: оскільки цей алгоритм представляє собою алгоритм "разделяй-і-властвуй", кожний рекурсивний запуск якого працює за час, лінійне щодо довжини стрічки: для чотирьох стрічок за лінійне час шукається їх [Z-функція](z_function), а потім перебирається значення $cntr$ і виводяться всі групи виявлених тандемних повторів.

Тандемные повтори обнаруживаются алгоритмом Мейн-Лоренца в вигляді своеобразных **груп**: таких четвірок $(cntr, l, k_1, k_2)$, кожна з яких позначає групу тандемних повторів з довжиною $l$, центром $cntr$ і з всевозможными длинами шматочків $l_1$ і $l_2$, удовлетворяющими умовами:

$$
\cases{
l_1 + l_2 = l, \cr
l_1 \le k_1, \cr
l_2 \le k_2.
}
$$

## Реалізація

Наведемо реалізацію алгоритму Мейн-Лоренца, яка за час $O(n \log n)$ знаходить всі тандемні повтори даній стрічки в стислому вигляді (в вигляді груп, описываемых четвёрками чисел).

В цілях демонстрации обнаруженные тандемні повтори за час $O(n^2)$ "разжимаются" і виводяться по окремо. Цей висновок при рішенні реальных задач легко буде замінити на які-то інші, більш эффективные, дії, наприклад, на пошук наидлиннейшего тандемного повтору або подсчёт кількості тандемних повторів.

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> z_function (const string & s) {
    int n = (int) s.length();
    vector<int> z (n);
    for (int i=1, l=0, r=0; i<n; ++i) {
        if (i <= r)
            z[i] = min (r-i+1, z[i-l]);
        while (i+z[i] < n && s[z[i]] == s[i+z[i]])
            ++z[i];
        if (i+z[i]-1 > r)
            l = i,  r = i+z[i]-1;
    }
    return z;
}

void output_tandem (const string & s, int shift, bool left, int cntr, int l, int l1, int l2) {
    int pos;
    if (left)
        pos = cntr-l1;
    else
        pos = cntr-l1-l2-l1+1;
    cout << "[" << shift + pos << ".." << shift + pos+2*l-1 << "] = " << s.substr (pos, 2*l) << endl;
}

void output_tandems (const string & s, int shift, bool left, int cntr, int l, int k1, int k2) {
    for (int l1=1; l1<=l; ++l1) {
        if (left && l1 == l)  break;
        if (l1 <= k1 && l-l1 <= k2)
            output_tandem (s, shift, left, cntr, l, l1, l-l1);
    }
}

inline int get_z (const vector<int> & z, int i) {
    return 0<=i && i<(int)z.size() ? z[i] : 0;
}

void find_tandems (string s, int shift = 0) {
    int n = (int) s.length();
    if (n == 1)  return;

    int nu = n/2,  nv = n-nu;
    string u = s.substr (0, nu),
        v = s.substr (nu);
    string ru = string (u.rbegin(), u.rend()),
        rv = string (v.rbegin(), v.rend());

    find_tandems (u, shift);
    find_tandems (v, shift + nu);

    vector<int> z1 = z_function (ru),
        z2 = z_function (v + '#' + u),

        z3 = z_function (ru + '#' + rv),
        z4 = z_function (v);
    for (int cntr=0; cntr<n; ++cntr) {
        int l, k1, k2;
        if (cntr < nu) {
            l = nu - cntr;
            k1 = get_z (z1, nu-cntr);
            k2 = get_z (z2, nv+1+cntr);
        }
        else {
            l = cntr - nu + 1;
            k1 = get_z (z3, nu+1 + nv-1-(cntr-nu));
            k2 = get_z (z4, (cntr-nu)+1);
        }
        if (k1 + k2 >= l)
            output_tandems (s, shift, cntr<nu, cntr, l, k1, k2);
    }
}
```

## Література

* [Michael Main, Richard J. Lorentz. **An O (n log n) Algorithm for Finding All Repetitions in a String** [1982]](http://www.cs.colorado.edu/department/publications/reports/docs/CU-CS-241-82.pdf)

* Bill Smyth. **Computing Patterns in Strings** [2003]

* Билл Смит. **Методы і алгоритми обчислень на рядках** [2006]
