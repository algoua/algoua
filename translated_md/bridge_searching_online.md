# Пошук мостів в режимі онлайн

Нехай дано неорієнтований граф. Мостом називається таке ребро, видалення якого робить граф незв'язним (або, точніше, збільшує число компонент зв'язності). Потрібно знайти всі мости в заданому графі.

Неформально ця задача ставиться наступним чином: потрібно знайти на заданої мапі доріг всі "важливі" дороги, тобто такі дороги, що видалення будь-який з них приведе до исчезновению шляхи між якийсь парою міст.

Описаний тут алгоритм є **онлайновим**, що означає, що вхідний граф не є відомим заздалегідь, а ребра в нього додаються по одному, і після кожного такого додавання алгоритм пересчитывает всі мости в поточному графі. Іншими словами, алгоритм предназначен для ефективної роботи на динамическом, изменяющемся графі.

Більш строго, **постановка задачі** наступна. Cпершу граф порожній і складається з $n$ вершин. Потім надходять запити, кожний з яких - це пара вершин $(a,b)$, які позначають ребро, добавляемое в граф. Потрібно після кожного запиту, тобто після додавання кожного ребра, виводити поточний кількість мостів в графі. (При бажанні можна підтримувати і список всіх ребер-мостів, а також явно підтримувати компоненти реберної двохзвязності).

Описаний нижче алгоритм працює за час $O(n \log n + m)$, де $m$ - число запитів. Алгоритм заснований на [структурі данних "система що не перетинаються множин"](dsu).

Наведена реалізація алгоритму, втім, працює за час $O(n \log n + m \log n)$, оскільки використовує в одному місці упрощённую версію [системи що не перетинаються множин](dsu) без рангової евристики.

## Алгоритм

Відомо, що ребра-мости разбивают вершини графа на компоненти, называемые компонентами реберної двохзвязності. Якщо кожну компоненту реберної двохзвязності стиснути в одну вершину, і залишити тільки ребра-мости між цими компонентами, то вийде ациклічний граф, тобто лес.

Описаний нижче алгоритм підтримує в явному вигляді цей **лес компонент реберної двохзвязності**.

Зрозуміло, що спершу, коли граф порожній, він містить $n$ компонент реберної двохзвязності, не пов'язаних ніяк між собою.

При додаванні чергового ребра $(a,b)$ можливо возникнуть три ситуації:

* Обидва кінця $a$ і $b$ знаходяться в однієї і тією ж компоненті реберної двохзвязності - тоді це ребро не є мостом, і нічого не змінює в структурі ліси, тому просто пропускаємо це ребро.

Таким чином, в цим випадку число мостів не змінюється.

* Вершини $a$ і $b$ знаходяться в різних компонентах зв'язності, тобто соединяют два дерева. В цим випадку ребро $(a,b)$ стає новим мостом, а ці два дерева об'єднуються в одне (а всі старі мости остаются).

Таким чином, в цим випадку число мостів збільшується на одиницю.

* Вершини $a$ і $b$ знаходяться в однієї компоненті зв'язності, але в різних компонентах реберної двохзвязності. В цим випадку це ребро утворює цикл разом з деякими з старих мостів. Усе ці мости перестають бути мостами, а образовавшийся цикл треба об'єднати в нову компоненту реберної двохзвязності.

Таким чином, в цим випадку число мостів зменшується на два або більш.

Отже, вся задача зводиться до ефективної реалізації всіх цих операцій над лесом компонент.

### Структуры данних для зберігання ліси

Всё, що нам знадобиться з структур данних, - це [система що не перетинаються множин](dsu). Насправді, нам знадобиться робити два экземпляра цій структури: одна буде для підтримки **компонент зв'язності**, інша - для підтримки **компонент реберної двохзвязності**.

Крім того, для зберігання структури дерев в лесу компонент двохзвязності для кожної вершини будемо зберігати вказівник ${\rm par}[]$ на її предка в дереві.

Будемо тепер послідовно розбирати кожну операцію, яку нам треба навчитися реалізовувати:

* **Перевірка, лежати або дві зазначені вершини в однієї компоненті зв'язності/двохзвязності**. Делается звичайним запитом до структурі "система що не перетинаються множин".

* **Соединение двох дерев в одне** по деякого ребру $(a,b)$. Оскільки могло вийти, що ні вершина $a$, ні вершина $b$ не є корнями своїх дерев, то єдиний спосіб з'єднати ці два дерева - **переподвесіть** одне з них. Наприклад, можна переподвесіть одне дерево за вершину $a$, і потім присоединить це до іншому дереву, зробивши вершину $a$ дочерней до $b$.

Однак встаёт питання про ефективності операції переподвешіванія: аби переподвесіть дерево з коренем в $r$ за вершину $v$, треба пройти по шляхи з $v$ в $r$, перенаправляючи вказівники ${\rm par}[]$ в зворотню сторону, а також меняя посилання на предка в системі що не перетинаються множин, отвечающей за компоненти зв'язності.

Таким чином, вартість операції переподвешіванія є $O(h)$, де $h$ - висота дерева. Можна оцінити її ще вище, сказав, що це є величина $O({\rm size})$, де $\rm size$ - кількість вершин в дереві.

Застосуємо тепер такий стандартний прийом: скажімо, що з двох дерев **переподвешівать будемо то, в якому менше вершин**. Значить інтуїтивно зрозуміло, що худший випадок - коли об'єднуються два дерева приблизно рівного розміру, але тоді в результаті виходить дерево вдвічі більшого розміру, що не дозваляє такий ситуації відбуватися багато раз. Формально це можна записати в вигляді рекуррентного співвідношення:

$$
T(n) = \max_{k = 1 \ldots n-1} \left\{ ~ T(k) + T(n-k) + O(n) ~ \right\},
$$

де через $T(n)$ ми обозначили число операцій, необхідне для отримання дерева з $n$ вершин з допомогою операцій переподвешіванія і про'єднання дерев. Це известное рекуррентное співвідношення, і воно має розв'язок $T(n) = O(n \log n)$.

Таким чином, сумарне час, затрачиваемое на всіх переподвешіванія, складе $O(n \log n)$, якщо ми завжди будемо переподвешівать менше з двох дерево.

Нам доведеться підтримувати розміри кожної компоненти зв'язності, але структура данних "система що не перетинаються множин" дозваляє робити це без праці.

* **Пошук циклу**, утвореного додаванням нового ребра $(a,b)$ в якесь дерево. Фактично це означає, що нам треба знайти найменшого загального предка (LCA) вершин $a$ і $b$.

Зауважимо, що потім ми сожмём всі вершини виявленого циклу в одну вершину, тому нас устроит будь-який алгоритму пошуку LCA, працюючий за час порядку його довжини.

Оскільки вся інформація про структурі дерева, яка у нас є, - це посилання $par[]$ на предків, то єдино можливим представляється наступного алгоритм пошуку LCA: помічаємо вершини $a$ і $b$ як посещённые, потім переходимо до їх предкам ${\rm par}[a]$ і ${\rm par}[b]$ і помічаємо їх, потім до їх предкам, і так далі, поки не случится, що хоча б одна з двох поточних вершин вже позначена. Це буде означати, що поточна вершина - і є шуканий LCA, і треба буде заново повторити шлях до її від вершини $a$ і від вершини $b$ - тим самим ми найдемо шуканий цикл.

Очевидно, що цей алгоритм працює за час порядку довжини шуканого циклу, оскільки кожний з двох покажчиків не міг пройти відстань, більше цій довжини.

* **Стиснення циклу**, утвореного додаванням нового ребра $(a,b)$ в якесь дерево.

Нам потрібно створити нову компоненту реберної двохзвязності, яка буде складатися з всіх вершин виявленого циклу (зрозуміло, що обнаруженный цикл сам міг складатися з якихось компонент двохзвязності, але це нічого не змінює). Крім того, треба провести стиснення таким чином, аби не нарушилась структура дерева, і всі вказівники ${\rm par}[]$ і дві системи що не перетинаються множин були корректными.

Самий простий спосіб домогтися цього - **стиснути всі вершини знайденого циклу в їх LCA**. Насправді, вершина-LCA - це сама висока з сжимаемых вершин, тобто її ${\rm par}$ залишається без змін. Для всіх інших сжимаемых вершин оновлювати теж нічого не треба, оскільки ці вершини просто перестають існувати - в системі що не перетинаються множин для компонент двохзвязності всі ці вершини будуть просто указывать на вершину-LCA.

Але тоді вийде, що система що не перетинаються множин для компонент двохзвязності працює без евристики про'єднання по рангу: якщо ми завжди присоединяем вершини циклу до їх LCA, то цій евристиці ні місця. В цим випадку в асимптотиці возникнет $O(\log n)$, оскільки без евристики по рангу будь-яка операція з системою що не перетинаються множин працює саме за таке час.

**Для досягнення асимптотики $O(1)$** на один запит необхідно об'єднувати вершини циклу згідно рангової евристиці, а потім присвоїти ${\rm par}$ нового лідера в ${\rm par}[{\rm LCA}]$.

## Реалізація

Наведемо тут підсумкову реалізацію всього алгоритму.

В цілях простоти система що не перетинаються множин для компонент двохзвязності написана **без рангової евристики**, тому підсумкова асимптотика складе $O(\log n)$ на запит в середньому. (Про тому, як досягти асимптотики $O(1)$, написано вище в пункті "Стиснення циклу").

Також в даній реалізації не зберігаються самі ребра-мости, а зберігається тільки їх кількість - див. змінна $\rm bridges$. Втім, при бажанні не складе ніякого праці завести ${\rm set}$ з всіх мостів.

Cпершу випливає викликати функцію ${\rm init}()$, яка инициализирует дві системи що не перетинаються множин (выделяя кожну вершину в окреме множину, і проставляя розмір, рівний одиниці), проставляє предків ${\rm par}$.

Основна функція - це ${\rm add\_edge}(a,b)$, яка обробляє запит на додавання нового ребра.

Константі $\rm MAXN$ випливає задати значення, рівне максимально можливого кількості вершин у вхідному графі.

Більш подробные пояснения до даній реалізації див. нижче.

<!--- TODO: specify code snippet id -->
``` cpp
const int MAXN = ...;

int n, bridges, par[MAXN], bl[MAXN], comp[MAXN], size[MAXN];

void init() {
    for (int i=0; i<n; ++i) {
        bl[i] = comp[i] = i;
        size[i] = 1;
        par[i] = -1;
    }
    bridges = 0;
}

int get (int v) {
    if (v==-1)  return -1;
    return bl[v]==v ? v : bl[v]=get(bl[v]);
}

int get_comp (int v) {
    v = get(v);
    return comp[v]==v ? v : comp[v]=get_comp(comp[v]);
}

void make_root (int v) {
    v = get(v);
    int root = v,
        child = -1;
    while (v != -1) {
        int p = get(par[v]);
        par[v] = child;
        comp[v] = root;
        child=v;  v=p;
    }
    size[root] = size[child];
}

int cu, u[MAXN];

void merge_path (int a, int b) {
    ++cu;

    vector<int> va, vb;
    int lca = -1;
    for(;;) {
        if (a != -1) {
            a = get(a);
            va.pb (a);

            if (u[a] == cu) {
                lca = a;
                break;
            }
            u[a] = cu;
    
            a = par[a];
        }

        if (b != -1) {
            b = get(b);
            vb.pb (b);

            if (u[b] == cu) {
                lca = b;
                break;
            }
            u[b] = cu;
    
            b = par[b];
        }
    }

    for (size_t i=0; i<va.size(); ++i) {
        bl[va[i]] = lca;
        if (va[i] == lca)  break;
        --bridges;
    }
    for (size_t i=0; i<vb.size(); ++i) {
        bl[vb[i]] = lca;
        if (vb[i] == lca)  break;
        --bridges;
    }
}

void add_edge (int a, int b) {
    a = get(a);   b = get(b);
    if (a == b)  return;

    int ca = get_comp(a),
        cb = get_comp(b);
    if (ca != cb) {
        ++bridges;
        if (size[ca] > size[cb]) {
            swap (a, b);
            swap (ca, cb);
        }
        make_root (a);
        par[a] = comp[a] = b;
        size[cb] += size[a];
    }
    else
        merge_path (a, b);
}
```

Прокоментуємо код більш детально.

**Система що не перетинаються множин для компонент двохзвязності** зберігається в масиві ${\rm bl}[]$, а функція, возвращающая лідера компоненти двохзвязності - це ${\rm get}(v)$. Цю функцію використовується багато раз в остальном коді, оскільки потрібно пам'ятати про тому, що після стиснення декількох вершин в одну всі ці вершини перестають існувати, а замість них існує тільки їх лідер, у якого і зберігаються корректные дані (предок ${\rm par}$, предок в системі що не перетинаються множин для компонент зв'язності, і т.д)..

**Система що не перетинаються множин для компонент зв'язності** зберігається в масиві ${\rm comp}[]$, також є додатковий масив ${\rm size}[]$ для зберігання розмірів компонент. Функція ${\rm get\_comp}(v)$ повертає лідера компоненти зв'язності (який насправді є коренем дерева).

**Функція переподвешіванія дерева** ${\rm make\_root}(v)$ працює, як і було описано вище: вона йде від вершини $v$ по предкам до кореня, кожний раз перенаправляючи предка $\rm par$ в зворотню сторону (вниз, по напрямку до вершині $v$). Також оновлюється вказівник ${\rm comp}$ в системі що не перетинаються множин для компонент зв'язності, аби він указывал на новий корінь. Після переподвешіванія у нового кореня проставляется розмір ${\rm size}$ компоненти зв'язності. Звернемо увага, що при реалізації ми кожний раз викликаємо функцію ${\rm get}()$, аби получити доступ саме до лідерові компоненти сильної зв'язності, а не до якийсь вершині, яка можливо вже була сжата.

**Функція обнаружения і стиснення шляхи** ${\rm merge\_path}(a,b)$, як і було описано вище, шукає LCA вершин $a$ і $b$, для чого поднимается від них паралельно вгору, поки якась вершина не встретится у другий раз. В цілях ефективності пройденные вершини помечаются з допомогою техніки "числового used", що працює за $O(1)$ замість застосування $\rm set$. Пройденные шляхи сохраняются в векторах $\rm va$ і $\rm vb$, аби потім пройтися по ним другий раз до LCA, отримавши тим самим всі вершини циклу. Усе вершини циклу сжимаются, шляхом присоединения їх до LCA (тут виникає асимптотика $O(\log n)$, оскільки при стисканні ми не використовуємо рангову евристику). Попутно вважається число пройдених ребер, яке рівне кількості мостів в обнаруженном циклі (це кількість віднімається від $\rm bridges$).

Нарешті, **функція обробки запитів** ${\rm add\_edge}(a,b)$ визначає компоненти зв'язності, в яких лежати вершини $a$ і $b$, і якщо вони лежати в різних компонентах зв'язності, то менше дерево переподвешивается за новий корінь і потім приєднується до большему дереву. Інакше ж, якщо вершини $a$ і $b$ лежати в одному дереві, але в різних компонентах двохзвязності, то вызывается функція ${\rm merge\_path}(a,b)$, яка обнаружит цикл і сожмёт його в одну компоненту двохзвязності.
