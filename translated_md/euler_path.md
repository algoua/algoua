# Знаходження Ейлерового шляхи за O (M)

Ейлерів шлях - це шлях в графі, проходить через всі його ребра. Ейлерів цикл - це ейлерів шлях, є циклом.

Задача полягає в тому, аби знайти ейлерів шлях в **неориентированном мультиграфе з петлями**.

## Алгоритм

Спочатку перевіримо, існує або ейлерів шлях. Потім найдемо всі прості цикли і об'єднаємо їх в один - це і буде эйлеровым циклом. Якщо граф такий, що ейлерів шлях не є циклом, то, додамо недостающее ребро, найдемо ейлерів цикл, потім видалимо лишнее ребро.

Щоб перевірити, існує або ейлерів шлях, потрібно скористатися наступного теоремою. Ейлерів цикл існує тоді і тільки тоді, коли степені всіх вершин чётны. Ейлерів шлях існує тоді і тільки тоді, коли кількість вершин з непарними степенями рівне двом (або нулю, в випадку існування ейлерового циклу).

Крім того, звісно, граф повинен бути достатньо зв'язним (тобто якщо вилучити з нього всі изолированные вершини, то повинен вийти зв'язний граф).

Шукати всі цикли і об'єднувати їх будемо однієї рекурсивної процедурою:

<pre>procedure FindEulerPath (V)
    1. перебрати всі ребра, выходящие з вершини V;
        кожне таке ребро видаляємо з графа, і
        викликаємо FindEulerPath з іншого кінця цього ребра ;
    2. додаємо вершину V в відповідь.</pre>
Сложность цього алгоритму, очевидно, є лінійної щодо числа ребер.

Але цей ж алгоритм ми можемо записати в **нерекурсивном** варіанті:

<pre>stack St;
в St кладемо будь-яку вершину (стартова вершина);
поки St не порожній
    нехай V - значення на вершині St;
    якщо ступінь(V) = 0, то
        додаємо V до відповіді;
        снимаем V з вершини St;
    інакше
        знаходимо будь-яке ребро, выходящее з V;
        видаляємо його з графа ;
        другий кінець цього ребра кладемо в St;
</pre>
Несложно перевірити эквивалентность цих двох форм алгоритму. Однак друга форма, очевидно, швидше працює, причому коду буде не більше.

## Задача про домино

Наведемо тут класичну задачу на ейлерів цикл - задачу про домино.

Є N доминошек, як відомо, на двох концах доміношки записано по одному числу (зазвичай від 1 до 6, але в нашому випадку не важливо). Потрібно выложить всі доміношки в ряд так, аби у будь-яких двох сусідніх доминошек числа, записані на їх загальної стороні, збігалися. Доминошки дозволяється перевертати.

Переформулюємо задачу. Нехай числа, записані на донимошках, - вершини графа, а доміношки - ребра цього графа (кожна доминошка з числами (a,b) - це ребра (a,b) і (b,a)). Значить наша задача **зводиться до** задачі знаходження **ейлерового шляхи** в цим графі.

## Реалізація

Приведенная нижче програма шукає і виводить ейлерів цикл або шлях в графі, або виводить -1, якщо його не існує.

Спочатку програма проверяет степені вершин: якщо вершин з непарної степенем ні, то в графі є ейлерів цикл, якщо є 2 вершини з непарної степенем, то в графі є тільки ейлерів шлях (ейлерового циклу ні), якщо ж таких вершин більше 2, то в графі ні ні ейлерового циклу, ні ейлерового шляхи. Щоб знайти ейлерів шлях (не цикл), вчинимо таким чином: якщо V1 і V2 - це дві вершини непарної степені, то просто додамо ребро (V1,V2), в отриманому графі найдемо ейлерів цикл (він, очевидно, буде існувати), а потім видалимо з відповіді "фіктивне" ребро (V1,V2). Ейлерів цикл будемо шукати в точності так, як описано вище (нерекурсивною версией), і заодно по закінченні цього алгоритму перевіримо, зв'язний був граф або ні (якщо граф був не зв'язний, то по закінченні роботи алгоритму в графі залишаться деякі ребра, і в цим випадку нам треба вивести -1). Нарешті, програма враховує, що в графі можуть бути изолированные вершини.

<!--- TODO: specify code snippet id -->
``` cpp
int main() {

    int n;
    vector < vector<int> > g (n, vector<int> (n));
    ... читання графа в матрицю суміжності ...

    vector<int> deg (n);
    for (int i=0; i<n; ++i)
        for (int j=0; j<n; ++j)
            deg[i] += g[i][j];

    int first = 0;
    while (!deg[first])  ++first;

    int v1 = -1,  v2 = -1;
    bool bad = false;
    for (int i=0; i<n; ++i)
        if (deg[i] & 1)
            if (v1 == -1)
                v1 = i;
            else if (v2 == -1)
                v2 = i;
            else
                bad = true;

    if (v1 != -1)
        ++g[v1][v2],  ++g[v2][v1];

    stack<int> st;
    st.push (first);
    vector<int> res;
    while (!st.empty())
    {
        int v = st.top();
        int i;
        for (i=0; i<n; ++i)
            if (g[v][i])
                break;
        if (i == n)
        {
            res.push_back (v);
            st.pop();
        }
        else
        {
            --g[v][i];
            --g[i][v];
            st.push (i);
        }
    }

    if (v1 != -1)
        for (size_t i=0; i+1<res.size(); ++i)
            if (res[i] == v1 && res[i+1] == v2 || res[i] == v2 && res[i+1] == v1)
            {
                vector<int> res2;
                for (size_t j=i+1; j<res.size(); ++j)
                    res2.push_back (res[j]);
                for (size_t j=1; j<=i; ++j)
                    res2.push_back (res[j]);
                res = res2;
                break;
            }

    for (int i=0; i<n; ++i)
        for (int j=0; j<n; ++j)
            if (g[i][j])
                bad = true;

    if (bad)
        puts ("-1");
    else
        for (size_t i=0; i<res.size(); ++i)
            printf ("%d ", res[i]+1);

}
```
