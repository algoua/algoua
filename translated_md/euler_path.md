# Знаходження Ейлерового шляхи за O (M)

Ейлерів шлях - це шлях в графі, проходить через всі його ребра. Ейлерів цикл - це ейлерів шлях, є циклом.

Задача полягає в тому, аби знайти ейлерів шлях в **неориентированном мультиграфе з петлями**.

## Алгоритм

Спочатку перевіримо, існує або ейлерів шлях. Потім найдемо всі прості цикли і об'єднаємо їх в один - це і буде эйлеровым циклом. Якщо граф такий, що ейлерів шлях не є циклом, то, додамо недостающее ребро, найдемо ейлерів цикл, потім видалимо лишнее ребро.

Щоб перевірити, існує або ейлерів шлях, потрібно скористатися наступного теоремою. Ейлерів цикл існує тоді і тільки тоді, коли степені всіх вершин чётны. Ейлерів шлях існує тоді і тільки тоді, коли кількість вершин з непарними степенями рівне двом (або нулю, в випадку існування ейлерового циклу).

Крім того, звісно, граф повинен бути достатньо зв'язним (тобто якщо вилучити з нього всі изолированные вершини, то повинен вийти зв'язний граф).

Шукати всі цикли і об'єднувати їх будемо однієї рекурсивної процедурою:

<pre>procedure FindEulerPath (V)
    1. перебрати всі ребра, выходящие з вершини V;
        кожне таке ребро видаляємо з графа, і
        викликаємо FindEulerPath з іншого кінця цього ребра ;
    2. додаємо вершину V в відповідь.</pre>
Сложность цього алгоритму, очевидно, є лінійної щодо числа ребер.

Але цей ж алгоритм ми можемо записати в **нерекурсивном** варіанті:

<pre>stack St;
в St кладемо будь-яку вершину (стартова вершина);
поки St не порожній
    нехай V - значення на вершині St;
    якщо ступінь(V) = 0, то
        додаємо V до відповіді;
        снимаем V з вершини St;
    інакше
        знаходимо будь-яке ребро, выходящее з V;
        видаляємо його з графа ;
        другий кінець цього ребра кладемо в St;
</pre>
Несложно перевірити эквивалентность цих двох форм алгоритму. Однак друга форма, очевидно, швидше працює, причому коду буде не більше.

## Задача про домино

Наведемо тут класичну задачу на ейлерів цикл - задачу про домино.

Є N доминошек, як відомо, на двох концах доміношки записано по одному числу (зазвичай від 1 до 6, але в нашому випадку не важливо). Потрібно выложить всі доміношки в ряд так, аби у будь-яких двох сусідніх доминошек числа, записані на їх загальної стороні, збігалися. Доминошки дозволяється перевертати.

Переформулюємо задачу. Нехай числа, записані на донимошках, - вершини графа, а доміношки - ребра цього графа (кожна доминошка з числами (a,b) - це ребра (a,b) і (b,a)). Значить наша задача **зводиться до** задачі знаходження **ейлерового шляхи** в цим графі.

## Реалізація

Приведенная нижче програма шукає і виводить ейлерів цикл або шлях в графі, або виводить -1, якщо його не існує.

Спочатку програма проверяет степені вершин: якщо вершин з непарної степенем ні, то в графі є ейлерів цикл, якщо є 2 вершини з непарної степенем, то в графі є тільки ейлерів шлях (ейлерового циклу ні), якщо ж таких вершин більше 2, то в графі ні ні ейлерового циклу, ні ейлерового шляхи. Щоб знайти ейлерів шлях (не цикл), вчинимо таким чином: якщо V1 і V2 - це дві вершини непарної степені, то просто додамо ребро (V1,V2), в отриманому графі найдемо ейлерів цикл (він, очевидно, буде існувати), а потім видалимо з відповіді "фіктивне" ребро (V1,V2). Ейлерів цикл будемо шукати в точності так, як описано вище (нерекурсивною версией), і заодно по закінченні цього алгоритму перевіримо, зв'язний був граф або ні (якщо граф був не зв'язний, то по закінченні роботи алгоритму в графі залишаться деякі ребра, і в цим випадку нам треба вивести -1). Нарешті, програма враховує, що в графі можуть бути изолированные вершини.

<!--- TODO: specify code snippet id -->
``` cpp
int main() {
    int n;
    vector<vector<int>> g(n, vector<int>(n));
    ... читання графа в матрицю суміжності...

        vector<int>
            deg(n);
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            deg[i] += g[i][j];

    int first = 0;
    while (!deg[first])
        ++first;

    int v1 = -1, v2 = -1;
    bool bad = false;
    for (int i = 0; i < n; ++i)
        if (deg[i] & 1)
            if (v1 == -1)
                v1 = i;
            else if (v2 == -1)
                v2 = i;
            else
                bad = true;

    if (v1 != -1)
        ++g[v1][v2], ++g[v2][v1];

    stack<int> st;
    st.push(first);
    vector<int> res;
    while (!st.empty()) {
        int v = st.top();
        int i;
        for (i = 0; i < n; ++i)
            if (g[v][i])
                break;
        if (i == n) {
            res.push_back(v);
            st.pop();
        } else {
            --g[v][i];
            --g[i][v];
            st.push(i);
        }
    }

    if (v1 != -1)
        for (size_t i = 0; i + 1 < res.size(); ++i)
            if (res[i] == v1 && res[i + 1] == v2 || res[i] == v2 && res[i + 1] == v1) {
                vector<int> res2;
                for (size_t j = i + 1; j < res.size(); ++j)
                    res2.push_back(res[j]);
                for (size_t j = 1; j <= i; ++j)
                    res2.push_back(res[j]);
                res = res2;
                break;
            }

    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            if (g[i][j])
                bad = true;

    if (bad)
        puts("-1");
    else
        for (size_t i = 0; i < res.size(); ++i)
            printf("%d ", res[i] + 1);
}
```
