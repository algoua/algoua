# Швидке перетворення Фур'є за O (N log N). Застосування до множенню двох поліномів або довгих чисел

Тут ми розглянемо алгоритм, який дозваляє перемножити два полінома довжиною $n$ за час $O(n \log n)$, що значно краще часу $O(n^2)$, достигаемого тривіальним алгоритмом множення. Очевидно, що множення двох довгих чисел можна звести до множенню поліномів, тому два довгих числа також можна перемножити за час $O(n \log n)$.

Изобретение Быстрого перетворення Фур'є приписується Кули (Coolet) і Таки (Tukey) - 1965 р. Насправді ШПФ неоднократно изобреталось до цього, але важность його в повної міру не осознавалась до появи сучасних компьютеров. Деякі исследователи приписывают открытие ШПФ Рунге (Runge) і Кёнигу (Konig) в 1924 р. Нарешті, открытие цього методу приписується ще Гауссу (Gauss) в 1805 р.

## Дискретне перетворення Фур'є (ДПФ)

Нехай є багаточлен $n$-ой степені:

$$
A(x) = a_0 x^0 + a_1 x^1 + \ldots + a_{n-1} x^{n-1}.
$$

Чи Не втрачаючи спільності, можна вважати, що $n$ є степенем 2. Якщо в действительности $n$ не є степенем 2, то ми просто додамо недостающие коефіцієнти, положив їх рівними нулю.

З теорії функцій комплексного переменного відомо, що комплексних коренів $n$-ой степені з одиниці існує рівне $n$. Позначимо ці коріння через $w_{n,k}, k = 0 \ldots {n-1}$, тоді відомо, що $w_{n,k} = e^{ i \frac{ 2 \pi k }{ n } }$. Крім того, один з цих коренів $w_n = w_{n,1} = e^{ i \frac{ 2 \pi }{ n } }$ (званий главным значенням кореня $n$-ой степені з одиниці) такий, що всі інші коріння є його степенями: $w_{n,k} = (w_n)^k$.

Значить **дискретным перетворенням Фур'є (ДПФ)** (discrete Fourier transform, DFT) багаточлена $A(x)$ (або, що то ж саме, ДПФ вектора його коефіцієнтів $(a_0, a_1, \dots, a_{n-1})$) називаються значення цього багаточлена в точках $x = w_{n,k}$, тобто це вектор:

$$
{\rm DFT}(a_0, a_1, \ldots, a_{n-1}) = (y_0, y_1, \ldots, y_{n-1}) = (A(w_{n,0}), A(w_{n,1}), \ldots, A(w_{n,n-1})) =
$$

$$
= (A(w_n^0), A(w_n^1), \ldots, A(w_n^{n-1})).
$$

Аналогічно визначається і **зворотнє дискретное перетворення Фур'є** (InverseDFT). Зворотне ДПФ для вектора значень багаточлена $(y_0, y_1, \ldots y_{n-1})$ - це вектор коефіцієнтів багаточлена $(a_0, a_1, \ldots, a_{n-1})$:

$$
{\rm InverseDFT}(y_0, y_1, \ldots, y_{n-1}) = (a_0, a_1, \ldots, a_{n-1}).
$$

Таким чином, якщо пряме ДПФ переходити від коефіцієнтів багаточлена до його значенням в комплексних корнях $n$-ой степені з одиниці, то зворотнє ДПФ - навпаки, по значенням багаточлена восстанавливает коефіцієнти багаточлена.

## Застосування ДПФ для швидкого множення поліномів

Нехай дані два багаточлена $A$ і $B$. Порахуємо ДПФ для кожного з них: ${\rm DFT}(A)$ і ${\rm DFT}(B)$ - це два вектора-значення багаточленів.

Тепер, що відбувається при умножении багаточленів? Очевидно, в кожної точці їх значення просто перемножаются, тобто

$$
(A \times B)(x) = A(x) \times B(x).
$$

Але це означає, що якщо ми перемножим вектора ${\rm DFT}(A)$ і ${\rm DFT}(B)$, просто помноживши кожний елемент одного вектора на відповідний йому елемент іншого вектора, то ми отримаємо не що інше, як ДПФ від багаточлена $A \times B$:

$$
{\rm DFT} (A \times B) = {\rm DFT} (A) \times {\rm DFT} (B).
$$

Нарешті, застосовуючи зворотнє ДПФ, отримуємо:

$$
A \times B = {\rm InverseDFT}( {\rm DFT} (A) \times {\rm DFT} (B) ),
$$

де, повторимося, справа під твором двох ДПФ розуміється попарные твори елементів векторів. Таке добуток, очевидно, вимагає для обчислення тільки $O(n)$ операцій. Таким чином, якщо ми навчимося обчислювати ДПФ і зворотнє ДПФ за час $O(n \log n)$, то і добуток двох поліномів (а, отже, і двох довгих чисел) ми зможемо знайти за ту ж асимптотику.

Слід замітити, що, у-перших, два багаточлена випливає привести до однієї степені (просто дополнив коефіцієнти одного з них нулями). По-друге, в результаті твори двох багаточленів степені $n$ виходить багаточлен степені $2n-1$, тому, аби результат вийшов корректным, попередньо потрібно удвоить степені кожного багаточлена (знову ж, дополнив їх нулевыми коефіцієнтами).

## Швидке перетворення Фур'є

**Швидке перетворення Фур'є** (fast Fourier transform) - це метод, дозволяє обчислювати ДПФ за час $O(n \log n)$. Цей метод базується на свойствах комплексних коренів з одиниці (а саме, на тому, що степені одних коренів дають інші коріння).

Основна ідея ШПФ полягає в разделении вектора коефіцієнтів на два вектора, рекурсивном обчисленні ДПФ для них, і об'єднанні результатів в одне ШПФ.

Отже, нехай є багаточлен $A(x)$ степені $n$, де $n$ - ступінь двійки, і $n>1$:

$$
A(x) = a_0 x^0 + a_1 x^1 + \ldots + a_{n-1} x^{n-1}.
$$

Разделим його на два багаточлена, один - з парними, а іншої - з непарними коефіцієнтами:

$$
A_0(x) = a_0 x^0 + a_2 x^1 + \ldots + a_{n-2} x^{n/2-1},
$$

$$
A_1(x) = a_1 x^0 + a_3 x^1 + \ldots + a_{n-1} x^{n/2-1}.
$$

Неважко переконатися, що:

$$
A(x) = A_0(x^2) + x A_1(x^2). ~~~~~~~(1)
$$

Многочлены $A_0$ і $A_1$ мають вдвічі меншу ступінь, ніж багаточлен $A$. Якщо ми зможемо за лінійне час по вычисленным ${\rm DFT}(A_0)$ і ${\rm DFT}(A_1)$ обчислити ${\rm DFT}(A)$, то ми і отримаємо шуканий алгоритм швидкого перетворення Фур'є (т.до. це стандартна схема алгоритму "разделяй і властвуй", і для її відома асимптотическая оцінка $O(n \log n)$).

Отже, нехай ми маємо обчислені вектора $\{ y_k^0 \}_{k=0}^{n/2-1} = {\rm DFT}(A_0)$ і $\{ y_k^1 \}_{k=0}^{n/2-1} = {\rm DFT}(A_1)$. Знайдемо вираження для $\{ y_k \}_{k=0}^{n-1} = {\rm DFT}(A)$.

По-перше, згадуючи (1), ми зразу отримуємо значення для першо] половини коефіцієнтів:

$$
y_k = y_k^0 + w_n^k y_k^1, ~~~~k = 0 \ldots n/2-1.
$$

Для другий половини коефіцієнтів після перетворень також отримуємо просту формулу:

$$
y_{k+n/2} = A(w_n^{k+n/2}) = A_0(w_n^{2k+n}) + w_n^{k+n/2} A_1(w_n^{2k+n}) = A_0(w_n^{2k} w_n^n) + w_n^k w_n^{n/2} A_1(w_n^{2k} w_n^n) =
$$

$$
= A_0(w_n^{2k}) - w_n^k A_1(w_n^{2k}) = y_k^0 - w_n^k y_k^1.
$$

(Тут ми скористалися (1), а також тождествами $w_n^n = 1$, $w_n^{n/2} = -1$).

Отже, в результаті ми отримали формули для обчислення всього вектора $\{ y_k \}$:

$$
y_k = y_k^0 + w_n^k y_k^1, \ \ \ \ k = 0 \ldots n/2-1,
$$

$$
y_{k+n/2} = y_k^0 - w_n^k y_k^1, \ \ \ \ k = 0 \ldots n/2-1.
$$

(ці формули, тобто дві формули увазі $a+bc$ і $a-bc$, іноді називають "перетворення метелики" ("butterfly operation"))

Тим самим, ми остаточно побудували алгоритм ШПФ.

## Зворотне ШПФ

Отже, нехай дано вектор $(y_0, y_1, \ldots, y_{n-1})$ - значення багаточлена $A$ степені $n$ в точках $x = w_n^k$. Потрібно відновити коефіцієнти $(a_0, a_1, \ldots, a_{n-1})$ багаточлена. Ця відома задача називається **интерполяцией**, для цій задачі є і загальні алгоритми розв'язку, однак в даному випадку буде отриманий дуже простий алгоритм (простий тим, що він практично не відрізняється від прямого ШПФ).

ДПФ ми можемо записати, згідно його визначенню, в матричном вигляді:

$$
\begin{pmatrix}w_n^0 & w_n^0 & w_n^0 & w_n^0 & \cdots & w_n^0 \cr w_n^0 & w_n^1 & w_n^2 & w_n^3 & \cdots & w_n^{n-1} \cr w_n^0 & w_n^2 & w_n^4 & w_n^6 & \cdots & w_n^{2(n-1)} \cr w_n^0 & w_n^3 & w_n^6 & w_n^9 & \cdots & w_n^{3(n-1)} \cr \vdots & \vdots & \vdots & \vdots & \ddots & \vdots \cr w_n^0 & w_n^{n-1} & w_n^{2(n-1)} & w_n^{3(n-1)} & \cdots & w_n^{(n-1)(n-1)}\end{pmatrix} \begin{pmatrix}a_0 \cr a_1 \cr a_2 \cr a_3 \cr \vdots \cr a_{n-1}\end{pmatrix} =  \begin{pmatrix}y_0 \cr y_1 \cr y_2 \cr y_3 \cr \vdots \cr y_{n-1}\end{pmatrix}.
$$

Значить вектор $(a_0, a_1, \ldots, a_{n-1})$ можна знайти, помноживши вектор $(y_0, y_1, \ldots, y_{n-1})$ на зворотню матрицю до матриці, стоящей ліворуч (яка, до речі, називається матрицею Вандермонда):

$$
\begin{pmatrix}a_0 \cr a_1 \cr a_2 \cr a_3 \cr \vdots \cr a_{n-1}\end{pmatrix} = \begin{pmatrix}w_n^0 & w_n^0 & w_n^0 & w_n^0 & \cdots & w_n^0 \cr w_n^0 & w_n^1 & w_n^2 & w_n^3 & \cdots & w_n^{n-1} \cr w_n^0 & w_n^2 & w_n^4 & w_n^6 & \cdots & w_n^{2(n-1)} \cr w_n^0 & w_n^3 & w_n^6 & w_n^9 & \cdots & w_n^{3(n-1)} \cr \vdots & \vdots & \vdots & \vdots & \ddots & \vdots \cr w_n^0 & w_n^{n-1} & w_n^{2(n-1)} & w_n^{3(n-1)} & \cdots & w_n^{(n-1)(n-1)}\end{pmatrix}^{-1} \begin{pmatrix}y_0 \cr y_1 \cr y_2 \cr y_3 \cr \vdots \cr y_{n-1}\end{pmatrix}.
$$

Непосредственной перевіркою можна переконатися в тому, що ця зворотна матриця така:

$$
\frac{1}{n} \begin{pmatrix}w_n^0 & w_n^0 & w_n^0 & w_n^0 & \cdots & w_n^0 \cr w_n^0 & w_n^{-1} & w_n^{-2} & w_n^{-3} & \cdots & w_n^{-(n-1)} \cr w_n^0 & w_n^{-2} & w_n^{-4} & w_n^{-6} & \cdots & w_n^{-2(n-1)} \cr w_n^0 & w_n^{-3} & w_n^{-6} & w_n^{-9} & \cdots & w_n^{-3(n-1)} \cr \vdots & \vdots & \vdots & \vdots & \ddots & \vdots \cr w_n^0 & w_n^{-(n-1)} & w_n^{-2(n-1)} & w_n^{-3(n-1)} & \cdots & w_n^{-(n-1)(n-1)}\end{pmatrix}.
$$

Таким чином, отримуємо формулу:

$$
a_k = \frac{1}{n} \sum_{j=0}^{n-1} y_j w_n^{-kj}.
$$

Порівнюючи її з формулою для $y_k$:

$$
y_k = \sum_{j=0}^{n-1} a_j w_n^{kj},
$$

ми замечаем, що ці дві задачі майже нічим не відрізняються, тому коефіцієнти $a_k$ можна знаходити таким ж алгоритмом "разделяй і властвуй", як і пряме ШПФ, тільки замість $w_n^k$ всюди треба використовувати $w_n^{-k}$, а кожний елемент результату треба розділити на $n$.

Таким чином, обчислення зворотнього ДПФ майже не відрізняється від обчислення прямого ДПФ, і його також можна виконувати за час $O(n \log n)$.

## Реалізація

Розглянемо просту рекурсивну **реалізацію ШПФ** і зворотнього ШПФ, реалізуємо їх в вигляді однієї функції, оскільки различия між прямим і зворотним ШПФ минимальны. Для зберігання комплексних чисел скористаємось стандартним в C++ STL типом complex (определённым в заголовочном файле <complex>).

<!--- TODO: specify code snippet id -->
``` cpp
typedef complex<double> base;

void fft (vector<base> & a, bool invert) {
    int n = (int) a.size();
    if (n == 1)  return;

    vector<base> a0 (n/2),  a1 (n/2);
    for (int i=0, j=0; i<n; i+=2, ++j) {
        a0[j] = a[i];
        a1[j] = a[i+1];
    }
    fft (a0, invert);
    fft (a1, invert);

    double ang = 2*PI/n * (invert ? -1 : 1);
    base w (1),  wn (cos(ang), sin(ang));
    for (int i=0; i<n/2; ++i) {
        a[i] = a0[i] + w * a1[i];
        a[i+n/2] = a0[i] - w * a1[i];
        if (invert)
            a[i] /= 2,  a[i+n/2] /= 2;
        w *= wn;
    }
}
```

В аргумент $\rm a$ функції передається вхідний вектор коефіцієнтів, в ньому ж і буде міститися результат. Аргумент $\rm invert$ показує, пряме або зворотнє ДПФ випливає обчислити. Усередині функції спочатку перевіряється, що якщо довжина вектора $\rm a$ рівна одиниці, то нічого робити не треба - він сам і є відповіддю. Інакше вектор $\rm a$ разделяется на два вектора $\rm a0$ і $\rm a1$, для яких рекурсивно обчислюється ДПФ. Потім обчислюється величина $w_n$, і заводиться змінна $w$, що містить поточну ступінь $w_n$. Потім обчислюються елементи результирующего ДПФ по вищеописаним формулами.

Якщо вказано прапор $\rm invert = true$, то $w_n$ замінюється на $w_n^{-1}$, а кожний елемент результату ділиться на 2 (враховуючи, що ці ділення на 2 произойдут в кожному рівні рекурсії, то в підсумку як раз вийде, що всі елементи поделятся на $n$).

Значить функція для **перемноження двох багаточленів** буде выглядеть наступним чином:

<!--- TODO: specify code snippet id -->
``` cpp
void multiply (const vector<int> & a, const vector<int> & b, vector<int> & res) {
    vector<base> fa (a.begin(), a.end()),  fb (b.begin(), b.end());
    size_t n = 1;
    while (n < max (a.size(), b.size()))  n <<= 1;
    n <<= 1;
    fa.resize (n),  fb.resize (n);

    fft (fa, false),  fft (fb, false);
    for (size_t i=0; i<n; ++i)
        fa[i] *= fb[i];
    fft (fa, true);

    res.resize (n);
    for (size_t i=0; i<n; ++i)
        res[i] = int (fa[i].real() + 0.5);
}
```

Ця функція працює з многочленами з цілочисельними коефіцієнтами (хоча, зрозуміло, теоретично ничто не заважає їй працювати і з дробовими коефіцієнтами). Однак тут проявляется проблема великий похибки при обчисленні ДПФ: похибка можливо виявитися значительной, тому округлять числа краще самим надёжным способом - додатком 0.5 і последующим округлением вниз (**увага**: це буде працювати неправильно для негативних чисел, якщо такі можуть з'явитися в вашем застосуванні).

Нарешті, функція для **перемноження двох довгих чисел** практично нічим не відрізняється від функції для перемноження багаточленів. Єдина особливість - що після виконання множення чисел як многочлени їх випливає нормализовать, тобто виконати всі переносы розрядів:

<!--- TODO: specify code snippet id -->
``` cpp
    int carry = 0;
    for (size_t i=0; i<n; ++i) {
        res[i] += carry;
        carry = res[i] / 10;
        res[i] %= 10;
    }
```

(Оскільки довжина твори двох чисел ніколи не превзойдёт сумарної довжини чисел, то розміру вектора $\rm res$ вистачить, аби виконати всі переносы).

## Покращена реалізація: обчислення "на місці" без додаткової пам'яті

Для збільшення ефективності откажемся від рекурсії в явному вигляді. В наведеної вище рекурсивної реалізації ми явно разделяли вектор $\rm a$ на два вектора - елементи на парних позиціях отнесли до одному временно созданному вектору, а на непарних - до іншому. Однак, якщо б ми переупорядочили елементи определённым чином, то необхідність в создании временных векторів тоді б отпала (тобто всі обчислення ми могли б виробляти "на місці", прямо в самому векторі $a$).

Зауважимо, що на першому рівні рекурсії елементи, младшие (перші) біти позицій яких рівні нулю, відносяться до вектору $a_0$, а младшие біти позицій яких рівні одиниці - до вектору $a_1$. На іншому рівні рекурсії виконується то ж саме, але вже для вторых бітів, і т.д. Тому якщо ми в позиції $i$ кожного елементу $a[i]$ інвертуємо порядок бітів, і переупорядочим елементи масиву $a$ в відповідно з новыми індексами, то ми і отримаємо шуканий порядок (він називається **порозрядно зворотного перестановкой** (bit-reversal permutation)).

Наприклад, для $n=8$ цей порядок має вид:

$$
a = \biggl\{ \Bigl[ (a_0,a_4), (a_2, a_6) \Bigr] , \Bigl[ (a_1, a_5), (a_3, a_7) \Bigr] \biggr\}.
$$

Дійсно, на першому рівні рекурсії (окружено фигурными дужками) звичайного рекурсивного алгоритму відбувається поділ вектора на дві частини: $[a_0,a_2,a_4,a_6]$ і $[a_1,a_3,a_5,a_7]$. Як ми видим, в порозрядно зворотного перестановки цьому відповідає просто поділ вектора на дві половинки: перші $n/2$ елементів, і останні $n/2$ елементів. Потім відбувається рекурсивний виклик від кожної половинки; нехай результирующее ДПФ від кожної з них було возвращено на місці самих елементів (тобто в першо] і другий половинах вектора $a$ відповідно):

$$
a = \biggl\{ \Bigl[ y_0^0,\ y_1^0,\ y_2^0,\ y_3^0 \Bigr], \Bigl[ y_0^1,\ y_1^1,\ y_2^1,\ y_3^1 \Bigr] \biggr\}.
$$

Тепер нам треба виконати об'єднання двох ДПФ в одне для всього вектора. Але елементи встали так удачно, що і об'єднання можна виконати прямо в цим масиві. Дійсно, візьмемо елементи $y_0^0$ і $y_0^1$, застосуємо до ним перетворення метелики, і результат поставимо на їх місці - і це місце і виявиться тим самим, яке і має було вийти:

$$
a = \biggl\{ \Bigl[ y_0^0+w_n^0y_0^1,\ y_1^0,\ y_2^0,\ y_3^0 \Bigr], \Bigl[ y_0^0-w_n^0y_0^1,\ y_1^1,\ y_2^1,\ y_3^1 \Bigr] \biggr\}.
$$

Аналогічно, застосовуємо перетворення метелики до $y_1^0$ і $y_1^1$ і результат ставимо на їх місце, і т.д. В результаті отримуємо:

$$
a = \biggl\{ \Bigl[ y_0^0+w_n^0y_0^1,\ y_1^0+w_n^1y_1^1,\ y_2^0+w_n^2y_2^1,\ y_3^0+w_n^3y_3^1 \Bigr],
$$

$$
~~~~~~~~ \Bigl[ y_0^0-w_n^0y_0^1,\ y_1^0-w_n^1y_1^1,\ y_2^0-w_n^2y_2^1,\ y_3^0-w_n^3y_3^1 \Bigr] \biggr\}.
$$

тобто. ми отримали саме шукане ДПФ від вектора $a$.

Ми описали процес обчислення ДПФ на першому рівні рекурсії, але зрозуміло, що ті ж самі міркування вірні і для всіх інших уровней рекурсії. Таким чином, **після застосування порозрядно зворотного перестановки обчислювати ДПФ можна на місці**, без привлечения додаткових масивів.

Але тепер можна **позбутися і від рекурсії** в явному вигляді. Отже, ми применили порозрядно зворотню перестановку елементів. Тепер виконаємо всю роботу, выполняемую нижнім уровнем рекурсії, тобто вектор $a$ розділимо на пари елементів, для кожного застосуємо перетворення метелики, в результаті в векторі $a$ будуть перебувати результати роботи нижнего рівня рекурсії. На наступному кроці розділимо вектор $a$ на четвірки елементів, до кожної застосуємо перетворення метелики, в результаті отримаємо ДПФ для кожної четвірки. І так далі, нарешті, на последнем кроці ми, отримавши результати ДПФ для двох половинок вектора $a$, застосуємо до ним перетворення метелики і отримаємо ДПФ для всього вектора $a$.

Отже, реалізація:

<!--- TODO: specify code snippet id -->
``` cpp
typedef complex<double> base;

int rev (int num, int lg_n) {
    int res = 0;
    for (int i=0; i<lg_n; ++i)
        if (num & (1<<i))
            res |= 1<<(lg_n-1-i);
    return res;
}

void fft (vector<base> & a, bool invert) {
    int n = (int) a.size();
    int lg_n = 0;
    while ((1 << lg_n) < n)  ++lg_n;

    for (int i=0; i<n; ++i)
        if (i < rev(i,lg_n))
            swap (a[i], a[rev(i,lg_n)]);

    for (int len=2; len<=n; len<<=1) {
        double ang = 2*PI/len * (invert ? -1 : 1);
        base wlen (cos(ang), sin(ang));
        for (int i=0; i<n; i+=len) {
            base w (1);
            for (int j=0; j<len/2; ++j) {
                base u = a[i+j],  v = a[i+j+len/2] * w;
                a[i+j] = u + v;
                a[i+j+len/2] = u - v;
                w *= wlen;
            }
        }
    }
    if (invert)
        for (int i=0; i<n; ++i)
            a[i] /= n;
}

```

На Початку до вектору $a$ застосовується порозрядно зворотна перестановка, для чого обчислюється кількість значащих біт ($\rm lg\_n$) в числі $n$, і для кожної позиції $i$ знаходиться відповідна їй позиція, бітовий запис якій є бітовий запис числа $i$, записана в зворотньому порядку. Якщо получившаяся в результаті позиція оказалась більше $i$, то елементи в цих двох позиціях треба обміняти (якщо не це умова, то кожна пара обменяется двічі, і в підсумку нічого не відбудеться).

Потім виконується $\lg n - 1$ стадий алгоритму, на $k$-ой з яких ($k=2 \ldots \lg n$) обчислюються ДПФ для блоків довжини $2^k$. Для всіх цих блоків буде одне і то ж значення первісного кореня $w_{2^k}$, яке і запоминается в змінній $\rm wlen$. Цикл по $i$ итерируется по блокам, а вкладений в нього цикл по $j$ применяет перетворення метелики до всім елементам блоку.

Можна виконати дальнейшую **оптимизацию реверса бітів**. В попередньою реалізації ми явно проходили по всім бітам числа, попутно строя порозрядно инвертированное число. Однак реверс бітів можна виконувати і по-іншому.

Наприклад, нехай $j$ - вже подсчитанное число, рівне зворотного перестановки бітів числа $i$. Значить, при переході до наступного числу $i+1$ ми повинні і до числу $j$ додати одиницю, але додати її в такий "інвертованою" системі числення. В звичайної двоичной системі числення додати одиницю - значить вилучити всі одиниці, стоять на наприкінці числа (тобто групу младших одиниць), а перед ними поставити одиницю. Відповідно, в "інвертованою" системі ми повинні йти по бітам числа, починаючи зі старших, і поки там стоять одиниці, видаляти їх і переходити до наступного біту; коли ж встретится перший нульовий біт, поставити в нього одиницю і зупинитися.

Отже, отримуємо таку реалізацію:

<!--- TODO: specify code snippet id -->
``` cpp
typedef complex<double> base;

void fft (vector<base> & a, bool invert) {
    int n = (int) a.size();

    for (int i=1, j=0; i<n; ++i) {
        int bit = n >> 1;
        for (; j>=bit; bit>>=1)
            j -= bit;
        j += bit;
        if (i < j)
            swap (a[i], a[j]);
    }

    for (int len=2; len<=n; len<<=1) {
        double ang = 2*PI/len * (invert ? -1 : 1);
        base wlen (cos(ang), sin(ang));
        for (int i=0; i<n; i+=len) {
            base w (1);
            for (int j=0; j<len/2; ++j) {
                base u = a[i+j],  v = a[i+j+len/2] * w;
                a[i+j] = u + v;
                a[i+j+len/2] = u - v;
                w *= wlen;
            }
        }
    }
    if (invert)
        for (int i=0; i<n; ++i)
            a[i] /= n;
}
```

## Дополнительные оптимізації

Наведемо також список інших оптимизаций, які в сукупності дозволяють помітно прискорити приведённую вище "улучшенную" реалізацію:

* **Предпосчитать реверс бітів** для всіх чисел в деякої глобальной таблице. Особливо легко це, коли розмір $n$ при всіх викликах одинаков.

Ця оптимізація стає заметной при великому кількості викликів $fft()$. Втім, эффект від її можна замітити навіть при трьох викликах (три виклику - найбільш распространённая ситуація, тобто коли потрібно один раз перемножити два багаточлена).

* Отказаться від використання $\rm vector$ (**перейти на звичайні масиви**).

Эффект від цього залежить від конкретного компилятора, однак зазвичай він присутній і становить приблизно 10%-20%.

* Предпосчитать **всі степені** числа $wlen$. Насправді, в цим циклі алгоритму раз за разом виготовляється прохід по всім степеням числа $wlen$ від $0$ до $len/2-1$:

<!--- TODO: specify code snippet id -->
``` cpp
        for (int i=0; i<n; i+=len) {
            base w (1);
            for (int j=0; j<len/2; ++j) {
                [...]
                w *= wlen;
            }
        }
```

Відповідно, перед цим циклом ми можемо предпосчітать в деякому масиві всі необхідні степені, і позбутися тим самим від зайвих множень у вложенном циклі.

Ориентировочное прискорення - 5-10%.

* Избавиться від **обращений до масивам по індексам**, використовувати замість цього вказівники на поточні елементи масивів, продвигая їх на 1 вправо на кожної ітерації.

На перший погляд, оптимизирующие компілятори повинні бути способны самостоятельно справиться з цим, однак на практиці виявляється, що заміна обращений до масивам $a[i+j]$ і $a[i+j+len/2]$ на вказівники ускоряет програму в поширених компіляторах. Выигрыш становить 5-10%.

* **Отказаться від стандартного типу комплексних чисел** $\rm complex$, переписав його на собственную реалізацію.

Знову ж, це можливо здатися удивительным, але навіть в сучасних компіляторах выигрыш від такого переписывания можливо составлять до декількох десятків процентов! Це косвенно подтверждает расхожее твердження, що компілятори гірше справляются з шаблонными типами данних, оптимизируя роботу з ними набагато гірше, ніж з не-шаблонными типами.

* Інший корисної оптимизацией є **отсечение по довжині**: коли довжина рабочего блоку стає маленької (скажімо, 4), обчислювати ДПФ для нього "вручну". Якщо расписать ці випадки в вигляді явних формул при довжині, рівній $4/2$, то значення синусов-косинусов примут целочисленные значення, за рахунок чого можна получити прирост швидкості ще на декілька десятків процентов.

Наведемо тут реалізацію з описанными улучшениями (за винятком двох останніх пунктов, які призводять до чрезмерному разрастанию коду):

<!--- TODO: specify code snippet id -->
``` cpp
int rev[MAXN];
base wlen_pw[MAXN];

void fft (base a[], int n, bool invert) {
    for (int i=0; i<n; ++i)
        if (i < rev[i])
            swap (a[i], a[rev[i]]);
 
    for (int len=2; len<=n; len<<=1) {
        double ang = 2*PI/len * (invert?-1:+1);
        int len2 = len>>1;

        base wlen (cos(ang), sin(ang));
        wlen_pw[0] = base (1, 0);
        for (int i=1; i<len2; ++i)
            wlen_pw[i] = wlen_pw[i-1] * wlen;

        for (int i=0; i<n; i+=len) {
            base t,
                *pu = a+i,
                *pv = a+i+len2, 
                *pu_end = a+i+len2,
                *pw = wlen_pw;
            for (; pu!=pu_end; ++pu, ++pv, ++pw) {
                t = *pv * *pw;
                *pv = *pu - t;
                *pu += t;
            }
        }
    }

    if (invert)
        for (int i=0; i<n; ++i)
            a[i] /= n;
}

void calc_rev (int n, int log_n) {
    for (int i=0; i<n; ++i) {
        rev[i] = 0;
        for (int j=0; j<log_n; ++j)
            if (i & (1<<j))
                rev[i] |= 1<<(log_n-1-j);
    }
}
```

На поширених компіляторах дана реалізація швидше попереднього "улучшенного" варіанти в 2-3 рази.

## Дискретне перетворення Фур'є в модульної арифметиці

В основі дискретного перетворення Фур'є лежати комплексные числа, коріння $n$-ой степені з одиниці. Для ефективного його обчислення использовались такі особенности коренів, як існування $n$ різних коренів, утворюють групу (тобто ступінь одного кореня - завжди іншої корінь; серед них є один елемент - генератор групи, званий примитивным коренем).

Але то ж саме вірно і в відношенні коренів $n$-ой степені з одиниці в модульної арифметиці. Точнее, не для будь-якого модуля $p$ знайдеться $n$ різних коренів з одиниці, однак такі модулі усе ж існують. За-прежнему нам важливо знайти серед них примітивний корінь, тобто:

$$
(w_n)^n = 1 \pmod p,
$$

$$
(w_n)^k \ne 1 {\pmod p}, ~~~~~1 \le k < n.
$$

Усе інші $n-1$ коренів $n$-ой степені з одиниці за модулем $p$ можна получити як степені примитивного кореня $w_n$ (як і в комплексном випадку).

Для застосування в алгоритмі Быстрого перетворення Фур'є нам було потрібно, аби примивный корінь существовал для деякого $n$, являвшегося степенем двійки, а також всіх менших степеней. І якщо в комплексном випадку примітивний корінь существовал для будь-якого $n$, то в випадку модульної арифметики це, взагалі кажучи, не так. Однак, зауважимо, що якщо $n = 2^k$, тобто $k$-ая ступінь двійки, то за модулем $m = 2^{k-1}$ маємо:

$$
(w_n^2)^m = (w_n)^n = 1 \pmod p,
$$

$$
(w_n^2)^k = w_n^{2k} \ne 1 {\pmod p}, ~~~~~1 \le k < m.
$$

Таким чином, якщо $w_n$ - примітивний корінь $n=2^k$-ой степені з одиниці, то $w_n^2$ - примітивний корінь $2^{k-1}$-ой степені з одиниці. Отже, для всіх степеней двійки, менших $n$, примитивные коріння потрібної степені також існують, і можуть бути обчислені як відповідні степені $w_n$.

Останній штрих - для зворотнього ДПФ ми использовали замість $w_n$ зворотний йому елемент: $w_n^{-1}$. Але по простому модулю $p$ зворотний елемент також завжди знайдеться.

Таким чином, всі потрібні нам властивості соблюдаются і в випадку модульної арифметики, при умови, що ми вибрали деякий достатньо великий модуль $p$ і знайшли в ньому примітивний корінь $n$-ой степені з одиниці.

Наприклад, можна взяти такі значення: модуль $p = 7340033$, $w_{2^{20}} = 5$. Якщо цього модуля буде недостатньо, для знаходження іншої пари можна скористатися фактом, що для модулів увазі $c 2^k + 1$ (але як і раніше обов'язково простих) завжди знайдеться примітивний корінь степені $2^k$ з одиниці.

<!--- TODO: specify code snippet id -->
``` cpp
const int mod = 7340033;
const int root = 5;
const int root_1 = 4404020;
const int root_pw = 1<<20;

void fft (vector<int> & a, bool invert) {
    int n = (int) a.size();

    for (int i=1, j=0; i<n; ++i) {
        int bit = n >> 1;
        for (; j>=bit; bit>>=1)
            j -= bit;
        j += bit;
        if (i < j)
            swap (a[i], a[j]);
    }

    for (int len=2; len<=n; len<<=1) {
        int wlen = invert ? root_1 : root;
        for (int i=len; i<root_pw; i<<=1)
            wlen = int (wlen * 1ll * wlen % mod);
        for (int i=0; i<n; i+=len) {
            int w = 1;
            for (int j=0; j<len/2; ++j) {
                int u = a[i+j],  v = int (a[i+j+len/2] * 1ll * w % mod);
                a[i+j] = u+v < mod ? u+v : u+v-mod;
                a[i+j+len/2] = u-v >= 0 ? u-v : u-v+mod;
                w = int (w * 1ll * wlen % mod);
            }
        }
    }
    if (invert) {
        int nrev = reverse (n, mod);
        for (int i=0; i<n; ++i)
            a[i] = int (a[i] * 1ll * nrev % mod);
    }
}
```

Тут функція $\rm reverse$ знаходить зворотний до $n$ елемент за модулем $\rm mod$ (див. [Обратный елемент в поле за модулем](reverse_element)). Константы $\rm mod$, $\rm root$ $\rm root\_pw$ определяют модуль і примітивний корінь, а $\rm root\_1$ - зворотний до $\rm root$ елемент за модулем $\rm mod$.

Як показує практика, реалізація цілочисельного ДПФ працює навіть медленней реалізації з комплексными числами (з-за огромного кількості операцій взятия за модулем), однак вона має такі преимущества, як менше використання пам'яті і отсутствие похибок округления.

## Деякі застосування

Крім безпосереднього застосування для перемноження багаточленів або довгих чисел, опишемо тут деякі інші приложения дискретного перетворення Фур'є.

### Всевозможные суми

Задача: дані два масиву $a[]$ і $b[]$. Потрібно знайти всілякі числа увазі $a[i]+b[j]$, і для кожного такого числа вивести кількість способів получити його.

Наприклад, для $a = (1,2,3)$ і $b = (2,4)$ отримуємо: число 3 можна получити 1 способом, 4 - також одним, 5 - 2, 6 - 1, 7 - 1.

Побудуємо по масивам $a$ і $b$ два багаточлена $A$ і $B$. В якості степеней в многочлене будуть выступать самі числа, тобто значення $a[i]$ ($b[i]$), а в якості коефіцієнтів при них - скільки раз це число зустрічається в масиві $a$ ($b$).

Значить, перемножив ці два багаточлена за $O(n \log n)$, ми отримаємо багаточлен $C$, де в якості степеней будуть всілякі числа увазі $a[i]+b[j]$, а коефіцієнти при них будуть як раз искомыми количествами

### Всевозможные скалярные твори

Дано два масиву $a[]$ і $b[]$ однієї довжини $n$. Потрібно вивести значення кожного скалярного твори вектора $a$ на черговий циклічний зсув вектора $b$.

Инвертируем масив $a$ і пріпішем до нього в кінець $n$ нулів, а до масиву $b$ - просто пріпішем самого собі. Потім перемножим їх як многочлени. Тепер розглянемо коефіцієнти твори $c[n \ldots 2n-1]$ (як завжди, всі індекси в 0-індексації). Маємо:

$$
c[k] = \sum_{i+j=k} a[i] b[j].
$$

Оскільки всі елементи $a[i]=0,\ i=n \ldots 2n-1$, то ми отримуємо:

$$
c[k] = \sum_{i=0}^{n-1} a[i] b[k-i].
$$

Неважко побачити в цій сумі, що це саме скалярний добуток вектора $a$ на $k-n-1$-ый циклічний зсув. Таким чином, ці коефіцієнти (починаючи з $n-1$-го і закачивая $2n-2$-им) - і є відповідь на задачу.

Розв'язок вийшло з асимптотикою $O(n \log n)$.

### Две смужки

Дано дві смужки, задані як два булевских (тобто числовых зі значеннями 0 або 1) масиву $a[]$ і $b[]$. Потрібно знайти всі такі позиції на першо] смужці, що якщо приложить, починаючи з цій позиції, одному смужку, ні в якому місці не вийде $\rm true$ зразу на обох полосках. Цю задачу можна переформулювати таким чином: дана карта смужки, в вигляді 0/1 - можна вставать в цю клітинку або ні, і дана деяка фигурка в вигляді шаблона (в вигляді масиву, в якому 0 - ні клітини, 1 - є), потрібно знайти всі позиції в смужці, до яким можна приложить фігурку.

Ця задача фактично нічим не відрізняється від попередньою задачі - задачі про скалярном произведении. Дійсно, скалярний добуток двох 0/1 масивів - це кількість елементів, в яких одночасно виявилися одиниці. Наша задача в тому, аби знайти всі циклічні зрушення другий смужки так, аби не знайшлося ні одного елементу, в якому б в обох полосках виявилися одиниці. тобто. ми повинні знайти всі циклічні зрушення іншого масиву, при яких скалярний добуток рівне нулю.

Таким чином, цю задачу ми вирішили за $O(n \log n)$.
