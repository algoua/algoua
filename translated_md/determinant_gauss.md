<h2>Обчислення визначника матриці методом Гауса
Нехай дана квадратна матриця A розміром NxN. Потрібно обчислити її визначник.

## Алгоритм

Скористаємося идеями [методу Гауса розв'язку систем лінійних рівнянь](linear_systems_gauss).

Будемо виконувати ті ж самі дії, що і при рішенні системи лінійних рівнянь, исключив тільки поділ поточній рядка на a[i][i] (точніше, саме поділ можна виконувати, але подразумевая, що число выносится за знак визначника). Значить всі операції, які ми будемо виробляти з матрицею, не будуть змінювати величину визначника матриці, за винятком, бути можливо, знака (ми тільки обмінюємо місцями дві рядка, що змінює знак на протилежний, або додаємо одну рядок до іншої, що не змінює величину визначника).

Але матриця, до якій ми приходимо після виконання алгоритму Гауса, є диагональной, і визначник її рівний произведению елементів, стоящих на діагоналі. Знак, як вже говорилося, буде визначатися кількістю обмінів стрічок (якщо їх непарне, то знак визначника випливає змінити на протилежний). Таким чином, ми можемо з допомогою алгоритму Гауса обчислювати визначник матриці за O (N<sup>3</sup>).

Залишилося тільки замітити, що якщо в якийсь момент ми не найдемо в поточному стовпці ненульового елементу, то алгоритм випливає зупинити і повернути 0.

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
const double EPS = 1E-9;
int n;
vector<vector<double>> a(n, vector<double>(n));
... читання n і a...

    double det = 1;
for (int i = 0; i < n; ++i) {
    int k = i;
    for (int j = i + 1; j < n; ++j)
        if (abs(a[j][i]) > abs(a[k][i]))
            k = j;
    if (abs(a[k][i]) < EPS) {
        det = 0;
        break;
    }
    swap(a[i], a[k]);
    if (i != k)
        det = -det;
    det *= a[i][i];
    for (int j = i + 1; j < n; ++j)
        a[i][j] /= a[i][i];
    for (int j = 0; j < n; ++j)
        if (j != i && abs(a[j][i]) > EPS)
            for (int k = i + 1; k < n; ++k)
                a[j][k] -= a[i][k] * a[j][i];
}

cout << det;
```
