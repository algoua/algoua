# Знаходження мінімального розрізу. Алгоритм Штор-Вагнера

## Постановка задачі

Дан неорієнтований зважений граф $G$ з $n$ вершинами і $m$ ребрами. Разрезом $C$ називається деякий підмножина вершин (фактично, розріз - розбиття вершин на два множини: належать $C$ і всі інші). Весом розрізу називається сума ваг ребер, проходять через розріз, тобто таких ребер, рівне один кінець яких належить $C$:

$$
w(C) = \sum_{(v,u) \in E, \atop u \in C, v \not\in C} c(v,u),
$$

де через $E$ обозначено множину всіх ребер графа $G$, а через $c(v,u)$ - вага ребра $(v,u)$.

Потрібно знайти **розріз мінімального ваги**.

Іноді цю задачу називають "глобальным мінімальним розрізом" - по контрасту з завданням, коли задані вершини-стік і джерело, і потрібно знайти мінімальний розріз $C$, що містить стік і не що містить джерело. Глобальный мінімальний розріз рівний мінімуму серед разрезов мінімальної вартості по всіляких парам джерело-стік.

Хоча цю задачу можна розв'язати з допомогою алгоритму знаходження максимального потоку (запуская його $O(n^2)$ раз для всіляких пар джерела і стоку), однак нижче описаний набагато більш простий і швидкий алгоритм, запропонований Матильдой Штор (Mechthild Stoer) і Франком Вагнером (Frank Wagner) в 1994 р.

В загалом випадку допускаються петлі і кратні ребра, хоча, зрозуміло, петлі абсолютно ніяк не впливають на результат, а всі кратні ребра можна замінити одним ребром з їх суммарным вагою. Тому ми для простоти будемо вважати, що у вхідному графі петлі і кратні ребра відсутні.

## Опис алгоритму

**Базовая ідея** алгоритму дуже проста. Будемо ітеративно повторювати наступного процес: знаходити мінімальний розріз між який-нибудь парою вершин $s$ і $t$, а потім об'єднувати ці дві вершини в одну (соединяя списки суміжності). В наприкінці кінців, після $n-1$ ітерації, граф стиснеться в єдину вершину і процес зупиниться. Після цього відповіддю буде бути мінімальний серед всіх $n-1$ знайдених разрезов. Дійсно, на кожної $i$-ой стадії знайдений мінімальний розріз $C_i$ між вершинами $s_i$ і $t_i$ або виявиться шуканим глобальным мінімальним розрізом, або ж, напротив, вершини $s_i$ і $t_i$ не вигідно относить до різним безлічам, тому ми нічого не ухудшаем, об'єднуючи ці дві вершини в одну.

Таким чином, ми звели задачу до наступного: для даного графа знайти **мінімальний розріз між який-нибудь, довільної, парою вершин** $s$ і $t$. Для розв'язку цій задачі був запропонований наступного, теж итеративный процес. Вводим деякий множину вершин $A$, яке спершу містить єдину довільну вершину. На кожному кроці знаходиться вершина, **найбільш сильно связанная** з безліччю $A$, тобто вершина $v \not\in A$, для якій наступна величина максимальна:

$$
w(v,A) = \sum_{(v,u) \in E, \atop u \in A} c(v,u)
$$

(тобто максимальна сума ваг ребер, один кінець яких $v$, а іншої належить $A$).

Знову ж, цей процес завершиться через $n-1$ ітерацію, коли всі вершини перейдут в множину $A$ (до речі кажучи, цей процес дуже нагадує [алгоритм Прима](mst_prim)). Значить, як стверджує **теорема Штор-Вагнера**, якщо ми позначимо через $s$ і $t$ останні дві добавленные в $A$ вершини, то мінімальний розріз між вершинами $s$ і $t$ буде складатися з єдиною вершини - $t$. Доведення цій теореми буде наведено в наступному розділі (як це часто буває, саме по собі воно ніяк не способствует пониманию алгоритму).

Таким чином, загальна **схема алгоритму** Штор-Вагнера така. Алгоритм складається з $n-1$ фази. На кожної фазі множину $A$ спочатку покладається що складається з який-або вершини; подсчитываются стартові ваги вершин $w(v,A)$. Потім відбувається $n-1$ ітерація, на кожної з яких вибирається вершина $u$ з найбільшим значенням $w(v,A)$ і додається в множину $A$, після чого перераховуються значення $w$ для залишилися вершин (для чого, очевидно, треба пройтися по всім ребрам списку суміжності обраної вершини $u$). Після виконання всіх ітерацій ми запоминаем в $s$ і $t$ номера останніх двох добавленных вершин, а в якості вартості знайденого мінімального розрізу між $s$ і $t$ можна взяти значення $w(t,A \setminus t)$. Потім треба порівняти знайдений мінімальний розріз з поточним відповіддю, якщо менше, то оновити відповідь. Перейти до наступного фазі.

Якщо не використовувати ніяких складних структур данних, то самою критичной частью буде знаходження вершини з найбільшою величиною $w$. Якщо виробляти це за $O(n)$, то, враховуючи, що всього фаз $n-1$, і по $n-1$ ітерації в кожної, підсумкова **асимптотика алгоритму** виходить $O(n^3)$.

Якщо для знаходження вершини з найбільшою величиною $w$ використовувати **Фібоначчових купи** (які дозволяють збільшувати значення ключа за $O(1)$ в середньому і витягувати максимум за $O(\log n)$ в середньому), то всі пов'язані з безліччю $A$ операції на однієї фазі выполнятся за $O(m + n \log n)$. Підсумкова асимптотика алгоритму в такому випадку складе $O(n m + n^2 \log n)$.

## Доведення теореми Штор-Вагнера

Нагадаємо умова цій теореми. Якщо додати в множину $A$ по черги всі вершини, кожний раз добавляя вершину, найбільш сильно связанную з цим безліччю, то позначимо предпоследнюю добавленную вершину через $s$, а останню - через $t$. Значить мінімальний $s$-$t$ розріз складається з єдиною вершини - $t$.

Для доведення розглянемо довільний $s$-$t$ розріз $C$ і покажемо, що його вага не можливо бути менше ваги розрізу, що складається з єдиною вершини $t$:

$$
w(\{t\}) \le w(C).
$$

Для цього доведемо наступного факт. Нехай $A_v$ - стан множини $A$ безпосередньо перед додаванням вершини $v$. Нехай $C_v$ - розріз множини $A_v \cup v$, индуцированный розрізом $C$ (простіше кажучи, $C_v$ рівне пересечению цих двох множин вершин). Далі, вершина $v$ називається активної (по відношенню до разрезу $C$), якщо вершина $v$ і предыдущая добавленная в $A$ вершина належать різним частям розрізу $C$. Значить, затверджується, для будь-який активної вершини $v$ виконується нерівність:

$$
w(v,A_v) \le w(C_v).
$$

В зокрема, $t$ є активної вершиною (т.до. перед ним добавлялась вершина $s$), і при $v = t$ це нерівність перетворюється в твердження теореми:

$$
w(t,A_t) = w(\{t\}) \le w(C_t) = w(C).
$$

Отже, будемо доказывать нерівність, для чого скористаємось методом математичної індукції.

Для першо] активної вершини $v$ це нерівність вірно (більш того, воно обращается в рівність) - оскільки всі вершини $A_v$ належать однієї частини розрізу, а $v$ - іншої.

Нехай тепер це нерівність виконано для всіх активных вершин аж до деякої вершини $v$, доведемо його для наступного активної вершини $u$. Для цього перетворимо ліву частина:

$$
w(u,A_u) \equiv w(u,A_v) + w(u,A_u \setminus A_v).
$$

По-перше, зауважимо, що:

$$
w(u,A_v) \le w(v,A_v),
$$

- це випливає з того, що коли множину $A$ було рівне $A_v$, в нього була добавлена саме вершина $v$, а не $u$, значить, вона мала найбільше значення $w$.

Далі, оскільки $w(v,A_v) \le w(C_v)$ по припущенням індукції, то отримуємо:

$$
w(u,A_v) \le w(C_v),
$$

звідки маємо:

$$
w(u,A_u) \le w(C_v) + w(u,A_u \setminus A_v).
$$

Тепер зауважимо, що вершина $u$ і всі вершини $A_u \setminus A_v$ знаходяться в різних частях розрізу $C$, тому ця величина $w(u,A_u \setminus A_v)$ позначає суму ваг ребер, які враховані в $w(C_u)$, але ще не були враховані в $w(C_v)$, звідки отримуємо:

$$
w(u,A_u) \le w(C_v) + w(u,A_u \setminus A_v) \le w(C_u),
$$

що і потрібно довести.

Ми довели співвідношення $w(v,A_v) \le w(C_v)$, а з нього, як вже говорилося вище, випливає і вся теорема.

## Реалізація

Для найбільш простий і ясной реалізації (з асимптотикою $O(n^3)$) було вибрано уявлення графа в вигляді матриці суміжності. Відповідь зберігається в змінних $\rm best\_cost$ і $\rm best\_cut$ (шукані вартість мінімального розрізу і самі вершини, содержащиеся в ньому).

Для кожної вершини в масиві $\rm exist$ зберігається, існує або вона, або вона була объединена з якийсь іншої вершиною. В списку ${\rm v}[i]$ для кожної сжатой вершини $i$ зберігаються номера вихідних вершин, які були сжаты в цю вершину $i$.

Алгоритм складається з $n-1$ фази (цикл по змінній $\rm ph$). На кожної фазі спочатку всі вершини знаходяться поза множини $A$, для чого масив $\rm in\_a$ заповнюється нулями, і зв'язності $w$ всіх вершин нулевые. На кожної з $n-{\rm ph}$ ітерації знаходиться вершина $\rm sel$ з найбільшою величиною $w$. Якщо це ітерація остання, то відповідь, якщо треба, оновлюється, а предпоследняя $\rm prev$ і остання $\rm sel$ выбранные вершини об'єднуються в одну. Якщо ітерація не остання, то $\rm sel$ додається в множину $A$, після чого перераховуються ваги всіх інших вершин.

Слід замітити, що алгоритм в під час своєї роботи "портит" граф $\rm g$, тому, якщо він ще знадобиться пізніше, треба зберігати його копию перед викликом функції.

<!--- TODO: specify code snippet id -->
``` cpp
const int MAXN = 500;
int n, g[MAXN][MAXN];
int best_cost = 1000000000;
vector<int> best_cut;

void mincut() {
    vector<int> v[MAXN];
    for (int i=0; i<n; ++i)
        v[i].assign (1, i);
    int w[MAXN];
    bool exist[MAXN], in_a[MAXN];
    memset (exist, true, sizeof exist);
    for (int ph=0; ph<n-1; ++ph) {
        memset (in_a, false, sizeof in_a);
        memset (w, 0, sizeof w);
        for (int it=0, prev; it<n-ph; ++it) {
            int sel = -1;
            for (int i=0; i<n; ++i)
                if (exist[i] && !in_a[i] && (sel == -1 || w[i] > w[sel]))
                    sel = i;
            if (it == n-ph-1) {
                if (w[sel] < best_cost)
                    best_cost = w[sel],  best_cut = v[sel];
                v[prev].insert (v[prev].end(), v[sel].begin(), v[sel].end());
                for (int i=0; i<n; ++i)
                    g[prev][i] = g[i][prev] += g[sel][i];
                exist[sel] = false;
            }
            else {
                in_a[sel] = true;
                for (int i=0; i<n; ++i)
                    w[i] += g[sel][i];
                prev = sel;
            }
        }
    }
}
```

## Література

* \book{Mechthild Stoer, Frank Wagner}{A Simple Min-Cut Algorithm}{1997}{stoer_wagner_mincut.pdf}
* \book{Kurt Mehlhorn, Christian Uhrig}{The minimum cut algorithm of Stoer and Wagner}{1995}{mehlhorn_mincut_stoer_wagner.pdf}
