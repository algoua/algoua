# Оптимальный вибір завдань при відомих временах завершення і длительностях виконання

Нехай дано набір завдань, у кожного завдання відомий момент часу, до якому це завдання потрібно завершити, і длительность виконання цього завдання. Процес виконання какого-або завдання не можна прерывать до його завершення. Потрібно скласти таке розклад, аби виконати найбільше число завдань.

## Розв'язок

Алгоритм розв'язку - **жадібний** (greedy). Відсортуємо всі завдання по їх крайнему сроку, і будемо розглядати їх по черги в порядку зменшення крайнего срока. Також створимо чергу $q$, в яку ми будемо поступово поміщати завдання, і витягувати з черги завдання з найменшим часом виконання (наприклад, можна використовувати set або priority_queue). Cпершу $q$ пустая.

Нехай ми розглядаємо $i$-е завдання. Спочатку поместим його в $q$. Розглянемо відрізок часу між сроком завершення $i$-го завдання і сроком завершення $i-1$-го завдання - це відрізок деякої довжини $T$. Будемо витягувати з $q$ завдання (в порядку збільшення оставшегося часу їх виконання) і поміщати на виконання в цим відрізку, поки не заполним весь відрізок $T$. Важный момент - якщо в якийсь момент часу чергове извлечённое з структури завдання можна успеть частково виконати в відрізку $T$, то ми виконуємо це завдання частково - саме настільки, наскільки це можливо, тобто в течение $T$ одиниць часу, а оставшуюся частина завдання поміщаємо назад в $q$.

За закінченні цього алгоритму ми виберемо оптимальне розв'язок (або, по крайньої міру, одне з декількох рішень). Асимптотика розв'язку - $O(n \log n)$.

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
int n;
vector < pair<int,int> > a; // завдання в вигляді пар (крайний срок, длительность)
... читання n і a ...

sort (a.begin(), a.end());

typedef set < pair<int,int> > t_s;
t_s s;
vector<int> result;
for (int i=n-1; i>=0; --i) {
    int t = a[i].first - (i ? a[i-1].first : 0);
    s.insert (make_pair (a[i].second, i));
    while (t && !s.empty()) {
        t_s::iterator it = s.begin();
        if (it->first <= t) {
            t -= it->first;
            result.push_back (it->second);
        }
        else {
            s.insert (make_pair (it->first - t, it->second));
            t = 0;
        }
        s.erase (it);
    }
}

for (size_t i=0; i<result.size(); ++i)
    cout << result[i] << ' ';
```
