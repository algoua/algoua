# Потік мінімальної вартості (min-cost-flow). Алгоритм збільшують шляхів

Дана мережа G, що складається з N вершин і M ребер. У кожного ребра (взагалі кажучи, орієнтованому, але по цьому приводу див. нижче) вказана пропускна здатність (ціле невід'ємне число) і вартість одиниці потоку уздовж цього ребра (деякий ціле число). В графі вказано джерело S і стік T. Даётся деяка величина K потоку, потрібно знайти потік цій величини, причому серед всіх потоків цій величини вибрати потік з найменшою вартістю ("задача min-cost-flow").

Іноді задачу ставят трохи по-іншому: потрібно знайти максимальний потік найменшою вартості ("задача min-cost-max-flow").

Обе ці задачі достатньо ефективно решаются описаним нижче алгоритмом збільшують шляхів.

## Опис

Алгоритм дуже похож на [алгоритм Едмондса-Карпа обчислення максимального потоку](edmonds_karp).

### Найпростіший випадок

Розглянемо для початку найпростіший випадок, коли граф - орієнтований, і між будь-який парою вершин не більш одного ребра (якщо є ребро (i,j), то ребра (j,i) бути не має).

Нехай U<sub>ij</sub> - пропускна здатність ребра (i,j), якщо це ребро існує. Нехай C<sub>ij</sub> - вартість одиниці потоку уздовж ребра (i,j). Нехай F<sub>ij</sub> - величина потоку уздовж ребра (i,j), спершу всі величини потоків рівні нулю.

**Модифицируем** мережа наступним чином: для кожного ребра (i,j) додамо в мережа так зване **зворотнє** ребро (j,i) з пропускною здатністю U<sub>ji</sub> = 0 і вартістю C<sub>ji</sub> = - C<sub>ij</sub>. Оскільки, по нашому припущенням, ребра (j,i) до цього в мережі не було, то модифікована таким чином мережа як і раніше не буде мультиграфом. Крім того, на усьому протяжении роботи алгоритму будемо підтримувати верным умова: F<sub>ji</sub> = - F<sub>ij</sub>.

Визначимо **залишкову мережа** для деякого зафиксированного потоку F наступним чином (власне, так ж, як і в алгоритмі Форда-Фалкерсона): залишкової мережі належать тільки ненасыщенные ребра (тобто у яких F<sub>ij</sub> < U<sub>ij</sub>), а залишкову пропускну здатність кожного такого ребра як UPI<sub>ij</sub> = U<sub>ij</sub> - F<sub>ij</sub>.

Власне **алгоритм** min-cost-flow полягає в наступному. На кожної ітерації алгоритму знаходимо найкоротший шлях в залишкової мережі з S в T (найкоротший щодо вартостей C<sub>ij</sub>). Якщо шлях не був знайдений, то алгоритм завершується, потік F - шуканий. Якщо ж шлях був знайдений, то ми збільшуємо потік уздовж нього настільки, наскільки це можливо (тобто проходимо уздовж цього шляхи, знаходимо мінімальну залишкову пропускну здатність MIN_UPI серед ребер цього шляхи, і потім збільшуємо потік уздовж кожного ребра шляхи на величину MIN_UPI, не забывая зменшувати на таку ж величину потік уздовж зворотних ребер). Якщо в якийсь момент величина потоку достигла величини K (даній нам по умові величини потоку), то ми також зупиняємо алгоритм (випливає врахувати, що тоді на останньої ітерації алгоритму при збільшенні потоку уздовж шляхи потрібно збільшувати потік на таку величину, аби підсумковий потік не превзошёл K, але це виконати легко).

Неважко замітити, що якщо покласти K рівним нескінченності, то алгоритм знайде максимальний потік мінімальної вартості, тобто один і той ж алгоритм без змін вирішує обидві задачі min-cost-flow і min-cost-max-flow.

### Випадок неориентированных графів, мультиграфов

Випадок неориентированных графів і мультиграфов в концептуальном плане нічим не відрізняється від вищеописаного, тому власне алгоритм буде працювати і на таких графах. Однак виникають деякі складності в реалізації, на які випливає звернути увага.

**Неориентированное** ребро (i,j) - це фактично два орієнтованих ребра (i,j) і (j,i) з однаковими пропускними здібностями і стоимостями. Оскільки вищеописаний алгоритм min-cost-flow вимагає для кожного неориентированного ребра створити зворотнє йому ребро, то в підсумку виходить, що неорієнтоване ребро расщепляется на 4 орієнтованих ребра, і ми фактично отримуємо випадок **мультиграфа**.

Які проблеми вызывают **кратні ребра**? По-перше, потік по кожному з кратних ребер повинен сохраняться окремо. По-друге, при пошуку найкоротшого шляхи потрібно враховувати, що важливо то, яке саме з кратних ребер вибрати при відновленні шляхи по предкам. тобто. замість звичайного масиву предків для кожної вершини ми повинні зберігати вершину-предка і номер ребра, по якому ми з її прийшли. По-третє, при збільшенні потоку уздовж деякого ребра потрібно, згідно алгоритму, зменшити потік уздовж зворотнього ребра. Оскільки у нас можуть бути кратні ребра, то доведеться для кожного ребра зберігати номер ребра, зворотнього йому.

Інших складнощів з неориентированными графами і мультиграфами ні.

### Анализ часу роботи

За аналогії з анализом алгоритму Едмондса-Карпа, ми отримуємо таку оцінку: O (N M) * T (N, M), де T (N, M) - час, необхідне для знаходження найкоротшого шляхи в графі з N вершинами і M ребрами. Якщо це реалізувати з допомогою [простейшего варіанти алгоритму Дейкстри](dijkstra), то для всього алгоритму min-cost-flow вийде оцінка **O (N<sup>3</sup> M)**, правда, алгоритм Дейкстри доведеться модифікувати, аби він працював на графах з негативними вагами (це називається алгоритм Дейкстри з потенциалами).

Замість цього можна використовувати [алгоритм Левіта](levit_algorithm), який, хоча і асимптотично набагато гірше, але на практиці працює дуже швидко (приблизно за то ж час, що і алгоритм Дейкстри).

## Реалізація

Тут наведено реалізація алгоритму min-cost-flow, базирующаяся на [алгоритмі Левіта](levit_algorithm).

На вхід алгоритму подається мережа (неорієнтований мультиграф) з N вершинами і M ребрами, і K - величина потоку, який потрібно знайти. Алгоритм знаходить потік величини K мінімальної вартості, якщо такий існує. Інакше він знаходить потік максимальної величини мінімальної вартості.

В програмі є специальная функція для додавання орієнтованого ребра. Якщо потрібно додати неорієнтоване ребро, то цю функцію потрібно викликати для кожного ребра (i,j) двічі: від (i,j) і від (j,i).

<!--- TODO: specify code snippet id -->
``` cpp
const int INF = 1000*1000*1000;

struct rib {
    int b, u, c, f;
    size_t back;
};

void add_rib (vector < vector<rib> > & g, int a, int b, int u, int c) {
    rib r1 = { b, u, c, 0, g[b].size() };
    rib r2 = { a, 0, -c, 0, g[a].size() };
    g[a].push_back (r1);
    g[b].push_back (r2);
}

int main()
{
    int n, m, k;
    vector < vector<rib> > g (n);
    int s, t;
    ... читання графа ...

    int flow = 0,  cost = 0;
    while (flow < k) {
        vector<int> id (n, 0);
        vector<int> d (n, INF);
        vector<int> q (n);
        vector<int> p (n);
        vector<size_t> p_rib (n);
        int qh=0, qt=0;
        q[qt++] = s;
        d[s] = 0;
        while (qh != qt) {
            int v = q[qh++];
            id[v] = 2;
            if (qh == n)  qh = 0;
            for (size_t i=0; i<g[v].size(); ++i) {
                rib & r = g[v][i];
                if (r.f < r.u && d[v] + r.c < d[r.b]) {
                    d[r.b] = d[v] + r.c;
                    if (id[r.b] == 0) {
                        q[qt++] = r.b;
                        if (qt == n)  qt = 0;
                    }
                    else if (id[r.b] == 2) {
                        if (--qh == -1)  qh = n-1;
                        q[qh] = r.b;
                    }
                    id[r.b] = 1;
                    p[r.b] = v;
                    p_rib[r.b] = i;
                }
            }
        }
        if (d[t] == INF)  break;
        int addflow = k - flow;
        for (int v=t; v!=s; v=p[v]) {
            int pv = p[v];  size_t pr = p_rib[v];
            addflow = min (addflow, g[pv][pr].u - g[pv][pr].f);
        }
        for (int v=t; v!=s; v=p[v]) {
            int pv = p[v];  size_t pr = p_rib[v],  r = g[pv][pr].back;
            g[pv][pr].f += addflow;
            g[v][r].f -= addflow;
            cost += g[pv][pr].c * addflow;
        }
        flow += addflow;
    }

    ... висновок результату ...

}
```
