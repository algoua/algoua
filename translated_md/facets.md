# Знаходження всіх граней, зовнішньої грані планарного графа

Дан планарний, уложенный на площині граф $G$ з $n$ вершинами. Потрібно знайти всі його грані. Гранью називається частина площині, ограниченная ребрами цього графа.

Одна з граней буде відрізнятися від інших тим, що буде мати бесконечную площа, така грань називається зовнішньої гранню. В деяких завданнях потрібно знаходити тільки зовнішню грань, алгоритм знаходження якій, як ми побачимо, по суті нічим не відрізняється від алгоритму для всіх граней.

## Теорема Ейлера

Наведемо тут теорему Ейлера і декілька следствий з її, з яких буде дотримуватися, що число ребер і граней планарного простого (без петель і кратних ребер) графа є величинами порядку $O(n)$.

Нехай планарний граф $G$ є зв'язним. Позначимо через $n$ кількість вершин в графі, $m$ - число ребер, $f$ - число граней. Значить справедлива **теорема Ейлера**:

$$
f + n - m = 2
$$

Довести цю формулу легко наступним чином. В випадку дерева ($m=n-1$) формула легко перевіряється. Якщо граф - не дерево, то видалимо будь-яке ребро, принадлежащее якого-або циклу; при цим величина $f+n-m$ не зміниться. Будемо повторювати цей процес, поки не прийдемо до дереву, для якого тотожність $f+n-m=2$ вже встановлено. Таким чином, теорема доведена.

**Слідство**. Для довільного планарного графа нехай $k$ - кількість компонент зв'язності. Значить виконується:

$$
f + n - m = 1 + k
$$

**Слідство**. Число ребер $m$ простого планарного графа є величиною $O(n)$.

Доведення. Нехай граф $G$ є зв'язним і $n \ge 3$ (в випадку $n < 3$ твердження отримуємо автоматично). Значить, з однієї сторони, кожна грань обмежена як мінімум тремя ребрами. З іншої сторони, кожне ребро ограничивает максимум дві грані. Отже, $3f \le 2m$, звідки, підставляючи це в формулу Ейлера, отримуємо:

$$
f + n - m = 2\ \ \Leftrightarrow\ \ 3f = 6 - 3n + 3m\ \ \Leftrightarrow\ \ 6 - 3n + 3m \le 2m\ \ \Leftrightarrow\ \ m \le 3n - 6
$$

тобто. $m = O(n)$.

Якщо граф не є зв'язним, то, підсумовуючи отримані оцінки по його компонентів зв'язності, знову отримуємо $m = O(n)$, що і потрібно довести.

**Слідство**. Число граней $f$ простого планарного графа є величиною $O(n)$.

Це наслідок випливає з попереднього следствия і зв'язку $f = 2 - n + m$.

## Обход всіх граней

Всегда будемо вважати, що граф, якщо він не є зв'язним, уложен на площині таким чином, що ніяка компонента зв'язності не лежить всередині іншої (наприклад, квадрат з лежащим строго всередині нього відрізком - некорректный для нашого алгоритму тест).

Зрозуміло, вважається, що граф правильно уложен на площині, тобто ніякі дві вершини не збігаються, а ребра не перетинаються в "несанкционированных" точках. Якщо у вхідному графі допускаються такі пересічні ребра, то попередньо треба позбутися від них, вводя в кожну точку перетину додаткову вершину (треба замітити, що в результаті цього процесу замість $n$ точок ми можемо получити порядку $n^2$ точок). Більш детально про цим процесі див. нижче в відповідному розділі.

Нехай для кожної вершини всі вихідні з її ребра впорядковані по полярному розі. Якщо це не так, то їх випливає упорядочить, провівши сортування кожного списку суміжності (т.до. $m = O(n)$, на це буде потрібно $O(n \log n)$ операцій).

Тепер виберемо довільне ребро $(a,b)$ і пустимо наступного обхід. Приходя в якусь вершину $v$ по деякого ребру, виходити з цій вершини ми обов'язково повинні по наступного в порядку сортування ребру.

Наприклад, на першому кроці ми знаходимося в вершині $b$, і повинні знайти вершину $a$ в списку суміжності вершини $b$, тоді позначимо через $c$ наступну вершину в списку суміжності (якщо $a$ була останньої, то в якості $c$ візьмемо першу вершину), і пройдемо по ребру $(b,c)$.

Повторюючи цей процес багато раз, ми рано або пізно прийдемо назад до стартовому ребру $(a,b)$, після чого треба зупинитися. Неважко замітити, що при такому обході ми обойдём рівне одну грань. Причому напрямок обходу буде проти годинний стрілки для зовнішньої грані, і по годинний стрілкою - для внутрішніх граней. Іншими словами, при такому обході внутренность грані буде завжди по праву сторону від поточного ребра.

Отже, ми навчилися обходити одну грань, стартуя з будь-якого ребра на її кордоні. Залишилося навчитися вибирати стартові ребра таким чином, аби одержувані грані не повторялись. Зауважимо, що у кожного ребра розрізняються два напрямку, в яких його можна обходити: при кожному з них будуть виходити свои грані. З іншої сторони, ясно, що одне таке ориентированное ребро належить рівне однієї грані. Таким чином, якщо ми буде помечать всі ребра кожної обнаруженной грані в деякому масиві $\rm used$, і не запускати обхід з вже помічених ребер, то ми обойдём всі грані (включаючи зовнішню), притому рівне по одному разу.

Наведемо зразу **реалізацію** цього обходу. Будемо вважати, що в графі $G$ списки суміжності вже впорядковані по розі, а кратні ребра і петлі відсутні.

Перший різновид реалізації упрощённый, наступну вершину в списку суміжності він шукає простим пошуком. Така реалізація теоретично працює за $O(n^2)$, хоча на практиці на багатьох тестах вона працює вельми швидко (зі прихованої константою, значно меншої одиниці).

<!--- TODO: specify code snippet id -->
``` cpp
int n; // кількість вершин
vector < vector<int> > g; // граф

vector < vector<char> > used (n);
for (int i=0; i<n; ++i)
    used[i].resize (g[i].size());
for (int i=0; i<n; ++i)
    for (size_t j=0; j<g[i].size(); ++j)
        if (!used[i][j]) {
            used[i][j] = true;
            int v = g[i][j],  pv = i;
            vector<int> facet;
            for (;;) {
                facet.push_back (v);
                vector<int>::iterator it = find (g[v].begin(), g[v].end(), pv);
                if (++it == g[v].end())  it = g[v].begin();
                if (used[v][it-g[v].begin()])  break;
                used[v][it-g[v].begin()] = true;
                pv = v,  v = *it;
            }
            ... висновок facet - поточній грані ...
        }
```

Інший, більш оптимизированный різновид реалізації - пользуется тим, що вершині в списку суміжності впорядковані по розі. Якщо реалізувати функцію $\rm cmp\_ang$ порівняння двох точок по полярному розі щодо третьої точки (наприклад, оформив її в вигляді класу, як в прикладі нижче), то при пошуку точки в списку суміжності можна скористатися бінарним пошуком. В результаті отримуємо реалізацію за $O(n \log n)$.

<!--- TODO: specify code snippet id -->
``` cpp
class cmp_ang {
    int center;
public:
    cmp_ang (int center) : center(center)
        { }
    bool operator() (int a, int b) const {
        ... повинна повертати true, якщо точка a має
        менший ніж b полярний кут щодо center ...
    }
};

int n; // кількість вершин
vector < vector<int> > g; // граф

vector < vector<char> > used (n);
for (int i=0; i<n; ++i)
    used[i].resize (g[i].size());
for (int i=0; i<n; ++i)
    for (size_t j=0; j<g[i].size(); ++j)
        if (!used[i][j]) {
            used[i][j] = true;
            int v = g[i][j],  pv = i;
            vector<int> facet;
            for (;;) {
                facet.push_back (v);
                vector<int>::iterator it = lower_bound (g[v].begin(), g[v].end(),
                    pv, cmp_ang(v));
                if (++it == g[v].end())  it = g[v].begin();
                if (used[v][it-g[v].begin()])  break;
                used[v][it-g[v].begin()] = true;
                pv = v,  v = *it;
            }
            ... висновок facet - поточній грані ...
        }
```

Возможен і різновид, заснований на контейнере $map$, адже нам потрібно всього лише швидко дізнаватися позиції чисел в масиві. Зрозуміло, така реалізація також буде працювати $O(n \log n)$.

Слід відзначити, що алгоритм не зовсім правильно працює з **изолированными** вершинами - такі вершини він просто не обнаружит як окремі грані, хоча, з математичної точки зору, вони повинні представляти собою окремі компоненти зв'язності і грані.

Крім того, особой гранню є **зовнішня грань**. Як її отличать від "звичайних" граней, описано в наступному розділі. Слід замітити, що якщо граф є не зв'язним, то зовнішня грань буде складатися з декількох контурів, і кожний з цих контурів буде знайдений алгоритмом окремо.

## Выделение зовнішньої грані

Приведённый вище код виводить всі грані, не роблячи различия між зовнішньої гранню і внутренними гранями. На практиці зазвичай, навпаки, потрібно знайти або тільки зовнішню грань, або тільки внутренние. Є декілька приёмов выделения зовнішньої грані.

Наприклад, її можна визначати по площі - зовнішня грань повинна мати найбільшу площа (випливає тільки врахувати, що внутрішня грань можливо мати ту ж площа, що і зовнішня). Цей спосіб не буде працювати, якщо даний планарний граф $G$ не є зв'язним.

Інший, більш надёжный критерій - по напрямку обходу. Як вже отмечалось вище, всі грані, крім зовнішньої, обходятся в напрямку по годинний стрілки. Внешняя грань, навіть якщо вона складається з декількох контурів, обойдётся алгоритмом проти годинний стрілки. Определить напрямок обходу можна, просто вважаючи [знаковую площа багатокутника](polygon_area). Площадь можна вважати прямо по ходу внутрішнього циклу. Однак і у цього методу є своя тонкість - обробка граней нульовий площі. Наприклад, якщо граф складається з єдиного ребра, то алгоритм знайде єдину грань, площа якій буде нульовий. За-видимому, якщо грань має нульову площа, то вона є зовнішньої гранню.

В деяких випадках буває застосуємо і такий критерій, як кількість вершин. Наприклад, якщо граф представляє собою опуклий багатокутник з проведёнными в ньому непересічними диагоналями, то його зовнішня грань буде містити всі вершини. Але знову треба бути акуратним зі випадком, коли і зовнішня, і внутрішня грані мають однакове кількість вершин.

Нарешті є і наступного метод знаходження зовнішньої грані: можна специально запуститися від такого ребра, що найденная в результаті грань буде зовнішньої. Наприклад, можна взяти саму ліву вершину (якщо таких декілька, то підійде будь-яка) і вибрати з її ребро, идущее першим в порядку сортування. В результаті обхід з цього ребра знайде зовнішню грань. Цей спосіб можна распространить і на випадок незв'язного графа: потрібно в кожної компоненті зв'язності знайти саму ліву вершину і запускати обхід з першого ребра з її.

Наведемо реалізацію самого простого методу, основанного на знаке площі (сам обхід я для прикладу взял за $O(n^2)$, тут це неважно). Якщо граф не зв'язний, то код "... грань є зовнішньої ..." виконається окремо для кожного контура, составляющего зовнішню грань.

<!--- TODO: specify code snippet id -->
``` cpp
            ... звичайний код по обнаружению граней ...
            ... зразу після циклу, обнаруживающего чергову грань: ...

            // припустимо площа
            double area = 0;
            // додаємо фиктивную точку для простоти підрахунку площі
            facet.push_back (facet[0]);
            for (size_t k=0; k+1<facet.size(); ++k)
                area += (p[facet[k]].first + p[facet[k+1]].first)
                    * (p[facet[k]].second - p[facet[k+1]].second);
            if (area < EPS)
                ... грань є зовнішньої ...
        }
```

## Побудова планарного графа

Для вищеописаних алгоритмів істотно то, що вхідний граф є правильно уложенным планарним графом. Однак на практиці часто на вхід програмі подається набір відрізків, можливо, пересічних між собою в "несанкционированных" точках, і потрібно по цим відрізках побудувати планарний граф.

Реалізувати побудова планарного графа можна наступним чином. Зафіксуємо який-або вхідний відрізок. Тепер пересечём цей відрізок зі усіма остальными відрізками. Найденные точки перетину, а також кінці самого відрузку покладемо в вектор, і його відсортуємо стандартним чином (тобто спочатку по однієї координаті, при рівності - по іншої). Потом пройдемося по цьому вектору і буде додавати ребра між сусідніми в цим векторі точками (звісно, следя, аби ми не додали петлі). Выполнив цей процес для всіх відрізків, тобто за $O(n^2 \log n)$, ми побудуємо відповідний планарний граф (в якому буде $O(n^2)$ точок).

Реалізація:

<!--- TODO: specify code snippet id -->
``` cpp
const double EPS = 1E-9;

struct point {
    double x, y;
    bool operator< (const point & p) const {
        return x < p.x - EPS || abs (x - p.x) < EPS && y < p.y - EPS;
    }
};

map<point,int> ids;
vector<point> p;
vector < vector<int> > g;

int get_point_id (point pt) {
    if (!ids.count(pt)) {
        ids[pt] = (int)p.size();
        p.push_back (pt);
        g.resize (g.size() + 1);
    }
    return ids[p];
}

void intersect (pair<point,point> a, pair<point,point> b, vector<point> & res) {
    ... стандартна процедура, перетинає два відрузку a і b і закидывает результат в res ...
    ... якщо відрізки перекрываются, то закидывает ті кінці, які потрапили всередину першого відрузку ...
}

int main() {
    // вхідні дані
    int m;
    vector < pair<point,point> > a (m);
    ... читання ...

    // побудова графа
    for (int i=0; i<m; ++i) {
        vector<point> cur;
        for (int j=0; j<m; ++j)
            intersect (a[i], a[j], cur);
        sort (cur.begin(), cur.end());
        for (size_t j=0; j+1<cur.size(); ++j) {
            int x = get_id (cur[j]),  y = get_id (cur[j+1]);
            if (x != y) {
                g[x].push_back (y);
                g[y].push_back (x);
            }
        }
    }
    int n = (int) g.size();
    // сортування по розі і видалення кратних ребер
    for (int i=0; i<n; ++i) {
        sort (g[i].begin(), g[i].end(), cmp_ang (i));
        g[i].erase (unique (g[i].begin(), g[i].end()), g[i].end());
    }
}
```
