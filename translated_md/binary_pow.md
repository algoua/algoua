# Бинарное піднесення в ступінь

Бинарное (двоичное) піднесення в ступінь - це прийом, дозволяє возводить будь-яке число в $n$-ую ступінь за $O(\log n)$ множень (замість $n$ множень при звичайному підході).

Більш того, описаний тут прийом застосуємо до будь-який **ассоциативной** операції, а не тільки до множенню чисел. Нагадаємо, операція називається ассоциативной, якщо для будь-яких $a, b, c$ виконується:

$$
(a \cdot b) \cdot c = a \cdot (b \cdot c)
$$

Найбільш очевидне узагальнення - на остатки по деякого модулю (очевидно, асоціативність зберігається). Следующим по "популярности" є узагальнення на добуток матриць (його асоціативність общеизвестна).

## Алгоритм

Зауважимо, що для будь-якого числа $a$ і **парного** числа $n$ выполнимо очевидне тотожність (випливає з ассоциативности операції множення):

$$
a^n = (a^{n/2})^2 = a^{n/2} \cdot a^{n/2}
$$

Воно і є основным в методе бінарного піднесення в ступінь. Дійсно, для парного $n$ ми показали, як, потратив всього одну операцію множення, можна звести задачу до вдвічі меншої степені.

Залишилося зрозуміти, що робити, якщо ступінь $n$ **нечётна**. Тут ми чинимо дуже просто: перейдемо до степені $n-1$, яка буде вже парної:

$$
a^n = a^{n-1} \cdot a
$$

Отже, ми фактично знайшли рекурентну формулу: від степені $n$ ми переходимо, якщо вона чётна, до $n/2$, а інакше - до $n-1$. Зрозуміло, що всього буде не більш $2 \log n$ переходів, перш ніж ми прийдемо до $n = 0$ (базі рекуррентной формули). Таким чином, ми отримали алгоритм, працюючий за $O(\log n)$ множень.

## Реалізація

Найпростіша рекурсивна реалізація:

<!--- TODO: specify code snippet id -->
``` cpp
int binpow(int a, int n) {
    if (n == 0)
        return 1;
    if (n % 2 == 1)
        return binpow(a, n - 1) * a;
    else {
        int b = binpow(a, n / 2);
        return b * b;
    }
}
```

Нерекурсивная реалізація, також оптимизированная (ділення на 2 заменены бітовими операціями):

<!--- TODO: specify code snippet id -->
``` cpp
int binpow(int a, int n) {
    int res = 1;
    while (n)
        if (n & 1) {
            res *= a;
            --n;
        } else {
            a *= a;
            n >>= 1;
        }
    return res;
}
```

Цю реалізацію можна ще декілька спростити, заметив, що піднесення $a$ в квадрат здійснюється завжди, незалежно від того, сработало умова нечётности $n$ або ні:

<!--- TODO: specify code snippet id -->
``` cpp
int binpow(int a, int n) {
    int res = 1;
    while (n) {
        if (n & 1)
            res *= a;
        a *= a;
        n >>= 1;
    }
    return res;
}
```

Нарешті, варто відзначити, що бінарне піднесення в ступінь вже реализовано в мові Java, але тільки для класу довгою арифметики BigInteger (функція pow цього класу працює саме по алгоритму бінарного піднесення).

## Приклади розв'язку задач

### Эффективное обчислення чисел Фібоначчі

**Умова**. Дано число $n$. Потрібно обчислити $F_n$, де $F_i$ - [послідовність чисел Фібоначчі](fibonacci_numbers).

**Розв'язок**. Більш детально це розв'язок описано в [статті про послідовності Фібоначчі](fibonacci_numbers). Тут ж ми лише коротко наведемо суть цього розв'язку.

Основна ідея наступна. Обчислення чергового числа Фібоначчі базується на знании двох попередніх чисел Фібоначчі: а саме, кожне випливає число Фібоначчі виходить як сума двох попередніх. Це означає, що ми можемо побудувати матрицю $2 \times 2$, яка буде відповідати цьому преобразованию: як по двом числах Фібоначчі $F_i$ і $F_{i+1}$ обчислити випливає число, тобто перейти до пари $F_{i+1}$, $F_{i+2}$. Наприклад, застосовуючи це перетворення $n$ раз до пари $F_0$ і $F_1$, ми отримаємо пару $F_n$ і $F_{n+1}$. Таким чином, возведя матрицю цього перетворення в $n$-ую ступінь, ми тим самим найдемо шукане $F_n$ за час $O(\log n)$, що нам і потрібно.

### Возведение перестановки в $k$-ую ступінь

**Умова**. Дана перестановка $p$ довжини $n$. Потрібно звести її в $k$-ую ступінь, тобто знайти, що вийде, якщо до тождественной перестановки $k$ раз застосувати перестановку $p$.

**Розв'язок**. Просто застосуємо до перестановки $p$ описаний вище алгоритм бінарного піднесення в ступінь. Никаких відмінностей по порівняно з возведением чисел в ступінь - ні. Розв'язок виходить з асимптотикою $O(n \log k)$.

(Зауваження. Дану задачу можна розв'язати і більш ефективно, **за лінійне час**. Для цього достатньо виділити в перестановки всі цикли, після чого розглянути по окремо кожний цикл і, взявши $k$ за модулем довжини поточного циклу, знайти відповідь для цього циклу).

### Швидке застосування набору геометричних операцій до точкам

**Умова**. Дано $n$ точок $p_i$, і дані $m$ перетворень, які треба застосувати до кожної з цих точок. Кожне перетворення - це або зсув на завдань вектор, або масштабирование (множення координат на задані коефіцієнти), або вращение навколо заданої осі на завдань кут. Крім того, є составная операція циклічного повторення: вона має вид "повторити заданий число раз завдань список перетворень" (операції циклічного повторення можуть вкладываться один в одного).

Потрібно обчислити результат застосування указанных операцій до всім точкам (ефективно, тобто за час, менше ніж $O(n \cdot length)$, де $length$ - загальне кількість операцій, які необхідно зробити).

**Розв'язок**. Подивимося на різні виды перетворень з точки зору того, як вони изменяют координати:

* Операція зсуву - вона просто додає до всім координатам одиницю, домноженную на деякі константи.

* Операція масштабирования - вона примножує кожну координату на деяку константу.

* Операція обертання навколо осі - її можна уявити наступним чином: нові одержувані координати можна записати як лінійну комбинацию старих.

(Ми не будемо тут уточнять, яким чином це виготовляється. Наприклад, можна для простоти уявити це в вигляді комбінації пяти двумерных поворотов: спочатку в плоскостях $OXY$ і $OXZ$ так, аби вісь обертання совпала з позитивним направлением осі $OX$, потім необхідний поворот навколо осі в площині $YZ$, потім зворотні повороты в плоскостях $OXZ$ і $OXY$ так, аби вісь обертання вернулась в своє вихідне становище).

Як легко бачити, кожне з цих перетворень - це перерахунок координат по лінійним формулами. Таким чином, будь-яке таке перетворення можна записати в вигляді матриці $4 \times 4$:

$$
\begin{pmatrix}
a_11 & a_{12} & a_{13} & a_{14} \\
a_21 & a_{22} & a_{23} & a_{24} \\
a_31 & a_{32} & a_{33} & a_{34} \\
a_41 & a_{42} & a_{43} & a_{44} \\
\end{pmatrix},
$$

яке при умножении (ліворуч) на рядок з старих координат і константи-одиниці дає рядок з нових координат і константи-одиниці:

$$
\begin{pmatrix} x & y & z & 1 \end{pmatrix} \cdot \begin{pmatrix}
a_{11} & a_{12} & a_{13} & a_{14} \\
a_{21} & a_{22} & a_{23} & a_{24} \\
a_{31} & a_{32} & a_{33} & a_{34} \\
a_{41} & a_{42} & a_{43} & a_{44} \\
\end{pmatrix} = \begin{pmatrix} x' & y' & z' & 1 \end{pmatrix}.
$$

(Чому понадобилось вводить фиктивную четвёртую координату, завжди рівну одиниці? Без цього не вийшло б реалізувати операцію зсуву: адже зсув - це як раз додаток до координатам одиниці, домноженной на деякі коефіцієнти. Без фиктивной одиниці ми б змогли тільки реалізовувати линейные комбінації самих координат, а додавати до ним задані константи - не змогли б).

Тепер розв'язок задачі стає майже тривіальним. Раз кожна элементарная операція описується матрицею, то послідовність операцій описується твором цих матриць, а операція циклічного повторення - возведением цій матриці в ступінь. Таким чином, ми за час $O(m \cdot \log repetition)$ можемо предпосчітать матрицю $4 \times 4$, описывающую всі перетворення, і потім просто помножити кожну точку $p_i$ на цю матрицю - тим самим, ми ответим на всі запити за час $O(n)$.

### Кількість шляхів фіксованою довжини в графі

**Умова**. Дан неорієнтований граф $G$ з $n$ вершинами, і дано число $k$. Потрібно для кожної пари вершин $i$ і $j$ знайти кількість шляхів між ними, містять рівне $k$ ребер.

**Розв'язок**. Більш детально ця задача розглядається в [окремої статті](fixed_length_paths). Тут ж лише нагадаємо суть цього розв'язку: ми просто возводим в $k$-ую ступінь матрицю суміжності цього графа, і елементи цій матриці і будуть бути розв'язками. Підсумкова асимптотика - $O(n^3 \log k)$.

(Зауваження. В [тією ж статті](fixed_length_paths) розглядається і інша вариация цій задачі: коли граф зважений, і потрібно знайти шлях мінімального ваги, що містить рівне $k$ ребер. Як показано в цій статті, дана задача також вирішується з допомогою бінарного піднесення в ступінь матриці суміжності графа, однак замість звичайної операції перемноження двох матриць випливає використовувати модифіковану: замість множень береться сума, а замість підсумовування - взяття мінімуму).

### Вариация бінарного піднесення в ступінь: перемножение двох чисел за модулем

Наведемо тут цікаву вариацию бінарного піднесення в ступінь.

Нехай перед нами варто така **задача**: перемножити два числа $a$ і $b$ за модулем $m$:

$$
a \cdot b \pmod m
$$

Припустимо, що числа можуть бути достатньо велики: настільки, що самі числа помещаются у встроенные типи данних, а ось їх безпосереднє добуток $a \cdot b$ - вже ні (відзначимо, що нам також буде потрібно, аби сума чисел помещалась у встроенный тип данних). Відповідно, задача в тому, аби порахувати шукану величину $(a \cdot b) \pmod m$, не прибегая до допомоги [довгою арифметики](big_integer).

**Розв'язок** таке. Ми просто застосовуємо алгоритм бінарного піднесення, описаний вище, тільки замість операції множення ми будемо виробляти складання. Іншими словами, перемножение двох чисел ми звели до $O(\log m)$ операцій складання і множення на два (що теж, по суті, є складання).

(Зауваження. Дану задачу можна розв'язати і **по-іншому**, прибегнув до допомоги операцій з числами з плаваючою точкою. А саме, порахуємо в числах з плаваючою точкою вираз $a \cdot b / m$, і округлим його до ближайшему цілому. Так ми найдемо **приблизне** приватна. Отняв його від твори $a \cdot b$ (проигнорировав переповнення), ми, швидше всього, отримаємо щодо невелике число, яке можна взяти за модулем $m$ - і повернути його в якості відповіді. Це розв'язок виглядає досить ненадёжным, але воно вельми швидке, і дуже коротко реалізується).

## Задачі в online judges

Список задач, які можна розв'язати, використовуючи бінарне піднесення в ступінь:

TODO
