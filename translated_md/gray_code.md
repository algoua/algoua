# Код Грея

## Визначення

Кодом Грея називається така система нумерования невід'ємних чисел, коли коди двох сусідніх чисел відрізняються рівне в одному біті.

Наприклад, для чисел довжини 3 біта маємо таку послідовність кодів Грея: $000$, $001$, $011$, $010$, $110$, $111$, $101$, $100$. Наприклад, $G(4)=6$.

Цей код був изобретен Фрэнком Грэем (Frank Gray) в 1953 році.

## Знаходження коду Грея

Розглянемо біти числа $n$ і біти числа $G(n)$. Зауважимо, що $i$-ый біт $G(n)$ рівний одиниці тільки в тому випадку, коли $i$-ый біт $n$ рівний одиниці, а $i+1$-ий біт рівний нулю, або навпаки ($i$-ый біт рівний нулю, а $i+1$-ий рівний одиниці). Таким чином, маємо: $G(n) = n \oplus (n>>1)$:

<!--- TODO: specify code snippet id -->
``` cpp
int g (int n) {
    return n ^ (n >> 1);
}
```

## Знаходження зворотнього коду Грея

Потрібно по коду Грея $g$ відновити вихідне число $n$.

Будемо йти від старших бітів до младшим (нехай самий молодший біт має номер 1, а самий старший - $k$). Получаем такі співвідношення між бітами $n_i$ числа $n$ і бітами $g_i$ числа $g$:

$$
n_k = g_k,
$$

$$
n_{k-1} = g_{k-1} \oplus n_k = g_k \oplus g_{k-1},
$$

$$
n_{k-2} = g_{k-2} \oplus n_{k-1} = g_k \oplus g_{k-1} \oplus g_{k-2},
$$

$$
n_{k-3} = g_{k-3} \oplus n_{k-2} = g_k \oplus g_{k-1} \oplus g_{k-2} \oplus g_{k-3},
$$

$$
\ldots
$$

В вигляді программного коду це простіше всього записати так:

<!--- TODO: specify code snippet id -->
``` cpp
int rev_g (int g) {
    int n = 0;
    for (; g; g>>=1)
        n ^= g;
    return n;
}
```

## Застосування

Коди Грея мають декілька застосувань в різних областях, іноді достатньо неожиданных:

* $n$-битный код Грея відповідає гамильтонову циклу по $n$-мерному кубу.

* В техніці, коди Грея використовуються для **минимизации ошибок** при перетворенні аналоговых сигналов в цифровые (наприклад, в датчиках). В зокрема, коди Грея і були открыты в зв'язку з цим застосуванням.

* Коди Грея застосовуються в рішенні задачі про **Ханойских башнях**.

Нехай $n$ - кількість дисков. Почнемо з коду Грея довжини $n$, що складається з одних нулів (тобто $G(0)$), і будемо рухатися по кодам Грея (від $G(i)$ переходити до $G(i+1)$). Поставимо в відповідність кожному $i$-ому біту поточного коду Грея $i$-ый диск (причому самому младшему біту відповідає найменший по размеру диск, а самому старшему біту - найбільший). Оскільки на кожному кроці змінюється рівне один біт, то ми можемо розуміти зміна біта $i$ як перемещение $i$-го диска. Зауважимо, що для всіх дисков, крім найменшого, на кожному кроці є рівне один різновид ходу (за винятком стартової і финальной позицій). Для найменшого диска завжди є два варіанти ходу, однак є стратегія вибору ходу, завжди приводящая до відповіді: якщо $n$ непарне, то послідовність перемещений найменшого диска має вид $f \rightarrow t \rightarrow r \rightarrow f \rightarrow t \rightarrow r \rightarrow \ldots$ (де $f$ - стартовый стрижень, $t$ - финальный стрижень, $r$ - залишився стрижень), а якщо $n$ парне, то $f \rightarrow r \rightarrow t \rightarrow f \rightarrow r \rightarrow t \rightarrow \ldots$.

* Коди Грея також находят застосування в теорії **генетических алгоритмів**.

## Задачі в online judges

Список задач, які можна здати, використовуючи коди Грея:

TODO
