# Перебір всіх підмасок даній маски

## Перебір підмасок фіксованою маски

Дана битовая маска $m$. Потрібно ефективно перебрати всі її подмаскі, тобто такі маски $s$, в яких можуть бути включені тільки ті біти, які були включені в маске $m$.

Відразу розглянемо реалізацію цього алгоритму, основанную на трюках з бітовими операціями:

<!--- TODO: specify code snippet id -->
``` cpp
int s = m;
while (s > 0) {
    ... можна використовувати s... s = (s - 1) & m;
}
```

або, використовуючи більш компактный оператор $for$:

<!--- TODO: specify code snippet id -->
``` cpp
for (int s = m; s; s = (s - 1) & m)
... можна використовувати s...
```

Єдине виняток для обох варіантів коду - подмаска, рівна нулю, обработана не буде. Її обробку доведеться выносить з циклу, або використовувати менш изящную конструкцию, наприклад:

<!--- TODO: specify code snippet id -->
``` cpp
for (int s = m;; s = (s - 1) & m) {
    ... можна використовувати s... if (s == 0) break;
}
```

Разберём, чому наведений вище код дійсно знаходить всі подмаскі даній маски, причому без повторений, за O (їх кількості), і в порядку зменшення.

Нехай у нас є поточна подмаска $s$, і ми хочемо перейти до наступного подмаске. Отнимем від маски $s$ одиницю, тим самим ми снимем самий правий единичный біт, а всі біти правіше нього поставятся в $1$. Потім видалимо всі "зайві" единичные біти, які не входять в маску $m$ і тому не можуть входити в подмаску. Видалення здійснюється битовой операцією $\& m$. В результаті ми "обрежем" маску $s-1$ до того найбільшого значення, яке вона можливо прийняти, тобто до наступного подмаскі після $s$ в порядку зменшення.

Таким чином, цей алгоритм генерує всі подмаскі даній маски в порядку строгого зменшення, затрачивая на кожний перехід по дві елементарні операції.

Особливо розглянемо момент, коли $s = 0$. Після виконання $s-1$ ми отримаємо маску, в якій всі біти включені (бітове уявлення числа $-1$), і після видалення зайвих бітів операцією $(s-1) \& m$ вийде не що інше, як маска $m$. Тому з маской $s = 0$ випливає бути осторожным - якщо вовремя не зупинитися на нульовий маске, то алгоритм можливо войти в нескінченний цикл.

## Перебір всіх масок з їх подмасками. Оцінка $3^n$

У багатьох завданнях, особливо на динамическое програмування по маскам, потрібно перебирати всі маски, і для кожної маски - всі подмаскі:

<!--- TODO: specify code snippet id -->
``` cpp
for (int m = 0; m < (1 << n); ++m)
    for (int s = m; s; s = (s - 1) & m)
... використання s і m...
```

Доведемо, що внутрішній цикл сумарно виконає $O(3^n)$ ітерацій.

**Доведення: 1 спосіб**. Розглянемо $i$-ый біт. Для нього, взагалі кажучи, є рівне три варіанти: він не входити в маску $m$ (і тому в подмаску $s$); він входити в $m$, але не входити в $s$; він входити в $m$ і в $s$. Всього бітів $n$, тому всього різних комбинаций буде $3^n$, що і потрібно довести.

**Доведення: 2 спосіб**. Зауважимо, що якщо маска $m$ має $k$ включённых бітів, то вона буде мати $2^k$ підмасок. Оскільки масок довжини $n$ з $k$ включёнными бітами є $C_n^k$ (див. ["биномиальные коефіцієнти"](binomial_coeff)), то всього комбинаций буде:

$$
\sum_{k=0}^n C_n^k 2^k.
$$

Порахуємо цю суму. Для цього зауважимо, що вона є не що інше, як розкладання в біном Ньютона вираження $(1+2)^n$, тобто $3^n$, що і потрібно довести.
