# Алгоритм Флойда-Уоршелла знаходження найкоротших шляхів між усіма парами вершин

Дан орієнтований або неорієнтований зважений граф $G$ з $n$ вершинами. Потрібно знайти значення всіх величин $d_{ij}$ - довжини найкоротшого шляхи з вершини $i$ в вершину $j$.

Передбачається, що граф не містить циклів негативного ваги (тоді відповіді між деякими парами вершин можливо просто не існувати - він буде нескінченно маленьким).

Цей алгоритм був одночасно опубліковано в статьях Роберта Флойда (Robert Floyd) і Стивена Уоршелла (Варшалла) (Stephen Warshall) в 1962 р., по імені яких цей алгоритм і називається в настоящее час. Втім, в 1959 р. Бернард Рой (Bernard Roy) опублікував практично такий ж алгоритм, але його публікація осталась непоміченою.

## Опис алгоритму

Ключова ідея алгоритму - розбиття процесу пошуку найкоротших шляхів на **фази**.

Перед $k$-ой фазою ($k = 1 \ldots n$) вважається, що в матриці відстаней $d[][]$ сохранены довжини таких найкоротших шляхів, які містять в якості внутрішніх вершин тільки вершини з множини $\{ 1, 2, \ldots, k-1 \}$ (вершини графа ми нумеруем, починаючи з одиниці).

Іншими словами, перед $k$-ой фазою величина $d[i][j]$ рівна довжині найкоротшого шляхи з вершини $i$ в вершину $j$, якщо цьому шляхи дозволяється заходити тільки в вершини з номерами, меньшими $k$ (початок і кінець шляхи не вважаються).

Легко переконатися, що аби це властивість виповнилося для першо] фази, достатньо в матрицю відстаней $d[][]$ записати матрицю суміжності графа: $d[i][j] = g[i][j]$ - вартості ребра з вершини $i$ в вершину $j$. При цим, якщо між якимись вершинами ребра ні, то записати випливає величину "нескінченність" $\infty$. З вершини в саму собі завжди випливає записувати величину $0$, це критично для алгоритму.

Нехай тепер ми знаходимося на $k$-ой фазі, і хочемо **перерахувати** матрицю $d[][]$ таким чином, аби вона соответствовала требованиям вже для $k+1$-ої фази. Зафіксуємо які-то вершини $i$ і $j$. У нас виникає два принципово різних випадку:

* Кратчайший шлях з вершини $i$ в вершину $j$, якому разрешено додатково проходити через вершини $\{ 1, 2, \ldots, k \}$, **збігається** з найкоротшим шляхом, якому разрешено проходити через вершини множини $\{ 1, 2, \ldots, k-1 \}$.

В цим випадку величина $d[i][j]$ не зміниться при переході з $k$-ой на $k+1$-ую фазу.

* "Новый" найкоротший шлях став **краще** "старого" шляхи.

Це означає, що "новий" найкоротший шлях проходити через вершину $k$. Відразу відзначимо, що ми не потеряем спільності, рассматривая далі тільки прості шляхи (тобто шляхи, не проходящие по якийсь вершині двічі).

Значить зауважимо, що якщо ми розіб'ємо цей "новий" шлях вершиною $k$ на дві половинки (одна идущая $i \Rightarrow k$, а інша - $k \Rightarrow j$), то кожна з цих половинок вже не заходить в вершину $k$. Але тоді виходить, що довжина кожної з цих половинок була посчитана ще на $k-1$-ой фазі або ще раніше, і нам достатньо взяти просто суму $d[i][k] + d[k][j]$, вона і дасть довжину "нового" найкоротшого шляхи.

**Об'єднуючи** ці два випадку, отримуємо, що на $k$-ой фазі потрібно перерахувати довжини найкоротших шляхів між усіма парами вершин $i$ і $j$ наступним чином:

<!--- TODO: specify code snippet id -->
``` cpp
new_d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
```

Таким чином, вся робота, яку потрібно провести на $k$-ой фазі - це перебрати всі пари вершин і перерахувати довжину найкоротшого шляхи між ними. В результаті після виконання $n$-ой фази в матриці відстаней $d[i][j]$ буде записана довжина найкоротшого шляхи між $i$ і $j$, або $\infty$, якщо шляхи між цими вершинами не існує.

Останнє замечание, яке випливає зробити, - то, що можна **не создавать окрему матрицю** $\rm new\_d[][]$ для временной матриці найкоротших шляхів на $k$-ой фазі: всі зміни можна робити зразу в матриці $d[][]$. Насправді, якщо ми улучшили (уменьшили) якесь значення в матриці відстаней, ми не могли ухудшить тим самим довжину найкоротшого шляхи для якихось інших пар вершин, обработанных позднее.

**Асимптотика** алгоритму, очевидно, становить $O(n^3)$.

## Реалізація

На вхід програмі подається граф, завдань в вигляді матриці суміжності - двовимірного масиву $d[][]$ розміру $n \times n$, в якому кожний елемент задаёт довжину ребра між відповідними вершинами.

Потрібно, аби виконувалося $d[i][i] = 0$ для будь-яких $i$.

<!--- TODO: specify code snippet id -->
``` cpp
for (int k = 0; k < n; ++k)
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
```

Передбачається, що якщо між двома якимись вершинами **ні ребра**, то в матриці суміжності було записано якесь велике число (достатньо велике, аби воно було більше довжини будь-якого шляхи в цим графі); тоді це ребро завжди буде не вигідно брати, і алгоритм сработает правильно.

Правда, якщо не прийняти специальных мер, то при наявності в графі ребер **негативного ваги**, в результуючій матриці можуть з'явитися числа увазі $\infty-1$, $\infty-2$, і т.д., які, звісно, як і раніше означают, що між відповідними вершинами взагалі ні шляхи. Тому при наявності в графі негативних ребер алгоритм Флойда краще написати так, аби він не выполнял переходи з тих станів, в яких вже варто "ні шляхи":

<!--- TODO: specify code snippet id -->
``` cpp
for (int k = 0; k < n; ++k)
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            if (d[i][k] < INF && d[k][j] < INF)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
```

## Відновлення самих шляхів

Легко підтримувати додаткову інформацію - так называемых "предків", по яким можна буде відновлювати сам найкоротший шлях між будь-якими двома заданными вершинами **в вигляді послідовності вершин**.

Для цього достатньо крім матриці відстаней $d[][]$ підтримувати також **матрицю предків** $p[][]$, яка для кожної пари вершин буде містити номер фази, на якій було отримано найкоротший відстань між ними. Зрозуміло, що цей номер фази є не ніж иным, як "середньою" вершиною шуканого найкоротшого шляхи, і тепер нам просто треба знайти найкоротший шлях між вершинами $i$ і $p[i][j]$, а також між $p[i][j]$ і $j$. Звідси виходить простий рекурсивний алгоритм відновлення найкоротшого шляхи.

## Випадок речових ваг

Якщо ваги ребер графа не целочисленные, а вещественные, то випливає враховувати похибки, неизбежно виникають при роботі з типами з плаваючою точкою.

Применительно до алгоритму Флойда неприятным спецэффектом цих похибок стає то, що знайдені алгоритмом відстані можуть уйти сильно в мінус з-за **накопившихся ошибок**. Насправді, якщо на першо] фазі мала місце ошибка $\Delta$, то на другий ітерації ця ошибка вже можливо превратиться в $2 \Delta$, на третьої - в $4 \Delta$, і так далі.

Щоб цього не происходило, порівняння в алгоритмі Флойда випливає робити з урахуванням похибки:

<!--- TODO: specify code snippet id -->
``` cpp
if (d[i][k] + d[k][j] < d[i][j] - EPS)
    d[i][j] = d[i][k] + d[k][j];
```

## Випадок негативних циклів

Якщо в графі є цикли негативного ваги, то формально алгоритм Флойда-Уоршелла не застосовується до такому графу.

На самому ж справі, для тих пар вершин $i$ і $j$, між якими не можна зайти в цикл негативного вага, алгоритм відпрацює правильно.

Для тих ж пар вершин, відповіді для яких не існує (по причини наявності негативного циклу на шляхи між ними), алгоритм Флойда знайде в якості відповіді якесь число (можливо, сильно отрицательное, але не обов'язково). Тим не менш, можна покращити алгоритм Флойда, аби він акуратно обрабатывал такі пари вершин і виводив для них, наприклад, $- \infty$.

Для цього можна зробити, наприклад, наступного **критерій** "не існування шляхи". Отже, нехай на даному графі отработал звичайний алгоритм Флойда. Значить між вершинами $i$ і $j$ не існує найкоротшого шляхи тоді і тільки тоді, коли знайдеться така вершина $t$, досяжна з $i$ і з якій досяжна $j$, для якій виконується $d[t][t] < 0$.

Крім того, при використанні алгоритму Флойда для графів з негативними циклами випливає пам'ятати, що виникають в процесі роботи відстані можуть сильно уходить в мінус, експоненціально з кожної фазою. Тому випливає прийняти меры проти цілочисельного переповнення, ограничив всі відстані знизу який-нибудь величиною (наприклад, $- {\rm INF}$).

Більш детально про цій задачі див. окрему статтю: [**"Знаходження негативного циклу в графі"**](negative_cycle).
