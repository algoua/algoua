# Алгоритм Форда-Беллмана

Нехай дано орієнтований зважений граф $G$ з $n$ вершинами і $m$ ребрами, і вказана деяка вершина $v$. Потрібно знайти **довжини найкоротших шляхів** від вершини $v$ до всіх інших вершин.

В відміну від [алгоритму Дейкстри](dijkstra), цей алгоритм застосуємо також і до графам, содержащим ребра негативного ваги. Втім, якщо граф містить негативний цикл, то, зрозуміло, найкоротшого шляхи до деяких вершин можливо не існувати (по причини того, що вага найкоротшого шляхи повинен бути рівний мінус нескінченності); втім, цей алгоритм можна модифікувати, аби він сигнализировал про наявності циклу негативного ваги, або навіть виводив сам цей цикл.

Алгоритм носит имя двох американских учёных: Ричарда **Беллмана** (Richard Bellman) і Лестера **Форда** (Lester Ford). Форд фактично винайшов цей алгоритм в 1956 р. при изучении іншої математичної задачі, подзадача якій звелася до пошуку найкоротшого шляхи в графі, і Форд дал набросок решающего цю задачу алгоритму. Беллман в 1958 р. опублікував статтю, посвящённую конкретно задачі знаходження найкоротшого шляхи, і в цій статті він чётко сформулировал алгоритм в тому вигляді, в якому він відомий нам зараз.

## Опис алгоритму

Ми припустимо, що граф не містить циклу негативного ваги. Випадок наявності негативного циклу буде розглянуто нижче в окремому розділі.

Заведемо масив відстаней $d[0 \ldots n-1]$, який після отработки алгоритму буде містити відповідь на задачу. В початку роботи ми заполняем його наступним чином: $d[v] = 0$, а всі інші елементи $d[]$ рівні нескінченності $\infty$.

Сам алгоритм Форда-Беллмана представляє з собі декілька фаз. На кожної фазі проглядаються всі ребра графа, і алгоритм намагається провести **релаксацію** (relax, ослабление) уздовж кожного ребра $(a,b)$ вартості $c$. Релаксация уздовж ребра - це спроба покращити значення $d[b]$ значенням $d[a] + c$. Фактично це значить, що ми намагаємося покращити відповідь для вершини $b$, користуючись ребром $(a,b)$ і поточним відповіддю для вершини $a$.

Стверджується, що достатньо $n-1$ фази алгоритму, аби правильно порахувати довжини всіх найкоротших шляхів в графі (повторимося, ми припустимо, що цикли негативного ваги відсутні). Для недостижимых вершин відстань $d[]$ залишиться рівним нескінченності $\infty$.

## Реалізація

Для алгоритму Форда-Беллмана, в відміну від багатьох інших графовых алгоритмів, більш зручно представляти граф в вигляді одного списку всіх ребер (а не $n$ списків ребер - ребер з кожної вершини). В наведеної реалізації заводиться структура данних $\rm edge$ для ребра. Входными даними для алгоритму є числа $n, m$, список $e$ ребер, і номер стартової вершини $v$. Усе номера вершин нумеруються з $0$ по $n-1$.

### Найпростіша реалізація

Константа $\rm INF$ позначає число "нескінченність" - її треба подобрать таким чином, аби вона свідомо превосходила всі можливі довжини шляхів.

<!--- TODO: specify code snippet id -->
``` cpp
struct edge {
    int a, b, cost;
};

int n, m, v;
vector<edge> e;
const int INF = 1000000000;

void solve() {
    vector<int> d (n, INF);
    d[v] = 0;
    for (int i=0; i<n-1; ++i)
        for (int j=0; j<m; ++j)
            if (d[e[j].a] < INF)
                d[e[j].b] = min (d[e[j].b], d[e[j].a] + e[j].cost);
    // висновок d, наприклад, на екран
}
```

Перевірка "if (d[e[j].a] < INF)" потрібна, тільки якщо граф містить ребра негативного ваги: без такий перевірки б происходили релаксації з вершин, до яких шляхи ще не знайшли, і появлялись б некорректные відстані увазі $\infty - 1$, $\infty - 2$, і т.д.

### Покращена реалізація

Цей алгоритм можна декілька прискорити: найчастіше відповідь знаходиться вже за декілька фаз, а залишилися фази ніякий корисної роботи не відбувається, лише впустую проглядаються всі ребра. Тому будемо зберігати прапор того, змінилося що-то на поточній фазі або ні, і якщо на якийсь фазі нічого не відбулося, то алгоритм можна зупиняти. (Ця оптимізація не покращує асимптотику, тобто на деяких графах як і раніше будуть потрібні всі $n-1$ фаза, але значно ускоряет поведение алгоритму "в середньому", тобто на випадкових графах).

З такий оптимизацией стає взагалі непотрібним ограничивать вручну число фаз алгоритму числом $n-1$ - він сам зупиниться через потрібне число фаз.

<!--- TODO: specify code snippet id -->
``` cpp
void solve() {
    vector<int> d (n, INF);
    d[v] = 0;
    for (;;) {
        bool any = false;
        for (int j=0; j<m; ++j)
            if (d[e[j].a] < INF)
                if (d[e[j].b] > d[e[j].a] + e[j].cost) {
                    d[e[j].b] = d[e[j].a] + e[j].cost;
                    any = true;
                }
        if (!any)  break;
    }
    // висновок d, наприклад, на екран
}
```

### Відновлення шляхів

Розглянемо тепер, як можна модифікувати алгоритм Форда-Беллмана так, аби він не тільки находил довжини найкоротших шляхів, але і позволял відновлювати самі найкоротші шляхи.

Для цього заведемо ще один масив $p[0 \ldots n-1]$, в якому для кожної вершини будемо зберігати її "предка", тобто предпоследнюю вершину в найкоротшому шляхи, ведущем в її. Насправді, найкоротший шлях до якийсь вершини $a$ є найкоротшим шляхом до якийсь вершини $p[a]$, до якому приписали в кінець вершину $a$.

Зауважимо, що алгоритм Форда-Беллмана працює по такий ж логике: він, предполагая, що найкоротший відстань до однієї вершини вже пораховано, намагається покращити найкоротший відстань до іншої вершини. Отже, в момент поліпшення нам треба просто запам'ятовувати в $p[]$, з який вершини це поліпшення відбулося.

Наведемо реалізацію Форда-Беллмана з восстановлением шляхи до якийсь заданої вершини $t$:

<!--- TODO: specify code snippet id -->
``` cpp
void solve() {
    vector<int> d (n, INF);
    d[v] = 0;
    vector<int> p (n, -1);
    for (;;) {
        bool any = false;
        for (int j=0; j<m; ++j)
            if (d[e[j].a] < INF)
                if (d[e[j].b] > d[e[j].a] + e[j].cost) {
                    d[e[j].b] = d[e[j].a] + e[j].cost;
                    p[e[j].b] = e[j].a;
                    any = true;
                }
        if (!any)  break;
    }

    if (d[t] == INF)
        cout << "No path from " << v << " to " << t << ".";
    else {
        vector<int> path;
        for (int cur=t; cur!=-1; cur=p[cur])
            path.push_back (cur);
        reverse (path.begin(), path.end());

        cout << "Path from " << v << " to " << t << ": ";
        for (size_t i=0; i<path.size(); ++i)
            cout << path[i] << ' ';
    }
}
```

Тут ми спочатку проходимся по предкам, починаючи з вершини $t$, і зберігаємо весь пройденный шлях в списку $\rm path$. В цим списку виходить найкоротший шлях від $v$ до $t$, але в зворотньому порядку, тому ми викликаємо $\rm reverse$ від нього і потім виводимо.

## Доведення алгоритму

По-перше, зразу зауважимо, що для недостижимых з $v$ вершин алгоритм відпрацює правильно: для них мітка $d[]$ так і залишиться рівній нескінченності (т.до. алгоритм Форда-Беллмана знайде які-то шляхи до всіх досяжних з $s$ вершин, а релаксація у всіх інших вершинах не відбудеться ні разу).

Доведемо тепер випливає **твердження**: після виконання $i$ фаз алгоритм Форда-Беллмана правильно знаходить всі найкоротші шляхи, довжина яких (по числу ребер) не перевершує $i$.

Іншими словами, для будь-який вершини $a$ позначимо через $k$ число ребер в найкоротшому шляхи до її (якщо таких шляхів декілька, можна взяти будь-який). Значить це твердження говорить про тому, що після $k$ фаз цей найкоротший шлях буде знайдений гарантовано. 

**Доведення**. Розглянемо довільну вершину $a$, до якій існує шлях з стартової вершини $v$, і розглянемо найкоротший шлях до її: $(p_0=v, p_1, \ldots, p_k=a)$. Перед першо] фазою найкоротший шлях до вершини $p_0=v$ знайдений правильно. У час першо] фази ребро $(p_0,p_1)$ було переглянуто алгоритмом Форда-Беллмана, отже, відстань до вершини $p_1$ було правильно пораховано після першо] фази. Повторюючи ці затвердження $k$ раз, отримуємо, що після $k$-й фази відстань до вершини $p_k=a$ пораховано правильно, що і потрібно довести.

Останнє, що треба замітити - це то, що будь-який найкоротший шлях не можливо мати більш $n-1$ ребра. Отже, алгоритму достатньо провести тільки $n-1$ фазу. Після цього ні одна релаксація гарантовано не можливо завершиться улучшением відстані до якийсь вершини.

## Випадок негативного циклу

Вище ми всюди считали, що негативного циклу в графі ні (уточним, нас цікавить негативний цикл, досяжний з стартової вершини $v$, а недостижимые цикли нічого в вищеописаному алгоритмі не змінюють). При його наявності виникають додаткові складності, пов'язані з тим, що відстані до всіх вершин на цим циклі, а також відстані до досяжних з цього циклу вершин не визначені - вони повинні бути рівні мінус нескінченності.

Неважко зрозуміти, що алгоритм Форда-Беллмана зможе **нескінченно робити релаксації** серед всіх вершин цього циклу і вершин, досяжних з нього. Отже, якщо не ограничивать число фаз числом $n-1$, то алгоритм буде працювати нескінченно, постійно улучшая відстані до цих вершин.

Звідси ми отримуємо **критерій наявності достижимого циклу негативного ваги**: якщо після $n-1$ фази ми виконаємо ще одну фазу, і на ній відбудеться хоча б одна релаксація, то граф містить цикл негативного ваги, досяжний з $v$; в іншому випадку, такого циклу ні.

Більш того, якщо такий цикл обнаружился, то алгоритм Форда-Беллмана можна модифікувати таким чином, аби він виводив сам цей цикл в вигляді послідовності вершин, що входять в нього. Для цього достатньо запам'ятати номер вершини $x$, в якій произошла релаксація на $n$-ой фазі. Ця вершина буде або лежати на циклі негативного ваги, або вона досяжна з нього. Щоб получити вершину, яка гарантовано лежить на циклі, достатньо, наприклад, $n$ раз пройти по предкам, починаючи від вершини $x$. Получив номер $y$ вершини, лежащей на циклі, треба пройтися від цій вершини по предкам, поки ми не повернемося в цю ж вершину $y$ (а це обов'язково відбудеться, тому що релаксації в циклі негативного ваги відбуваються по кругу).

Реалізація:

<!--- TODO: specify code snippet id -->
``` cpp
void solve() {
    vector<int> d (n, INF);
    d[v] = 0;
    vector<int> p (n, -1);
    int x;
    for (int i=0; i<n; ++i) {
        x = -1;
        for (int j=0; j<m; ++j)
            if (d[e[j].a] < INF)
                if (d[e[j].b] > d[e[j].a] + e[j].cost) {
                    d[e[j].b] = max (-INF, d[e[j].a] + e[j].cost);
                    p[e[j].b] = e[j].a;
                    x = e[j].b;
                }
    }

    if (x == -1)
        cout << "No negative cycle from " << v;
    else {
        int y = x;
        for (int i=0; i<n; ++i)
            y = p[y];

        vector<int> path;
        for (int cur=y; ; cur=p[cur]) {
            path.push_back (cur);
            if (cur == y && path.size() > 1)  break;
        }
        reverse (path.begin(), path.end());
        
        cout << "Negative cycle: ";
        for (size_t i=0; i<path.size(); ++i)
            cout << path[i] << ' ';
    }
}
```

Оскільки при наявності негативного циклу за $n$ ітерацій алгоритму відстані могли уйти далеко в мінус (по всій видимості, до негативних чисел порядку $-2^n$), в коді приняты додаткові меры проти такого цілочисельного переповнення:

<!--- TODO: specify code snippet id -->
``` cpp
d[e[j].b] = max (-INF, d[e[j].a] + e[j].cost);
```

В наведеної вище реалізації шукається негативний цикл, досяжний з деякої стартової вершини $v$; однак алгоритм можна модифікувати, аби він искал просто **будь-який негативний цикл** в графі. Для цього треба покласти всі відстані $d[i]$ рівними нулю, а не нескінченності - так, як ніби б ми шукаємо найкоротший шлях изо всіх вершин одночасно; на коректність обнаружения негативного циклу це не повлияет.

Дополнительно на тему цій задачі - див. окрему статтю [**"Пошук негативного циклу в графі"**](negative_cycle).

## Задачі в online judges

Список задач, які можна розв'язати з допомогою алгоритму Форда-Беллмана:

* [E-OLIMP #1453 **"Форд-Беллман"** [складність: низька]](http://www.e-olimp.com.ua/problems/1453)

* [UVA #423 **"MPI Maelstrom"** [складність: низька]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=364)

* [UVA #534 **"Frogger"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=7&page=show_problem&problem=475)

* [UVA #10099 **"The Tourist Guide"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=12&page=show_problem&problem=1040)

* [UVA #515 **"King"** [складність: середня]](http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=456)

Див. також список задач в статті [**"Пошук негативного циклу"**](negative_cycle).
