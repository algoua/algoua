# Декартово дерево (treap, дераміда)

Декартово дерево - це структура данних, объединяющая в собі бінарне дерево пошуку і бинарную купу (звідси і друге її назва: treap (tree+heap) і дераміда (дерево+пирамида).

Більш строго, це структура данних, яка зберігає пари (X,Y) в вигляді бінарного дерева таким чином, що вона є бінарним деревом пошуку по x і бінарної пирамидой по y. Предполагая, що всі X і всі Y є різними, отримуємо, що якщо деякий елемент дерева містить (X<sub>0</sub>,Y<sub>0</sub>), то у всіх елементів в лівому піддереві X < X<sub>0</sub>, у всіх елементів в правом піддереві X > X<sub>0</sub>, а також і в лівому, і в правом піддереві маємо: Y &lt Y<sub>0</sub>.

Дерамиды були предложены Сиделем (Siedel) і Арагон (Aragon) в 1989 р.

## Преимущества такий организации данних

В тому застосуванні, яке ми розглядаємо (ми будемо розглядати дерамиды, оскільки декартове дерево - це фактично більш загальна структура данних), X'ы є ключами (і одночасно значеннями, хранящимися в структурі данних), а Y'і - називаються **приоритетами**. Якщо б пріоритетів не було, то було б звичайне бінарне дерево пошуку по X, і заданому набору X'ов могло б відповідати багато дерев, деякі з яких є вырожденными (наприклад, в вигляді ланцюжка), а тому надзвичайно медленными (основные операції выполнялись б за O (N)).

В то ж час, **пріоритети** дозволяють **однозначно** вказати дерево, яке буде построено (звісно, не зависящее від порядку додавання елементів) (це доводиться відповідної теоремою). Тепер очевидно, що якщо **вибирати пріоритети випадково**, то цим ми доб'ємося побудови **невырожденных** дерев в середньому випадку, що обеспечит асимптотику O (log N) в середньому. Звідси і зрозуміло ще одне назва цій структури данних - **рандомизированное бінарне дерево пошуку**.

## Операції

Отже, treap предоставляет наступні операції:

* **Insert (X, Y)** - за O (log N) в середньому
Выполняет додавання в дерево нового елементу.
Возможен різновид, при якому значення пріоритету Y не передається функції, а вибирається випадково (правда, потрібно врахувати, що воно не має збігатися ні з яким іншим Y в дереві).
* **Search (X)** - за O (log N) в середньому
Ищет елемент з зазначеним значенням ключа X. Реализуется абсолютно так ж, як і для звичайного бінарного дерева пошуку.
* **Erase (X)** - за O (log N) в середньому
Ищет елемент і удаляет його з дерева.
* **Build (X<sub>1</sub>, ..., X<sub>N</sub>)** - за O (N)
Строит дерево з списку значень. Цю операцію можна реалізувати за лінійне час (в припущенні, що значення X<sub>1</sub>, ..., X<sub>N</sub> відсортовані), але тут ця реалізація розглядатися не буде.
Тут буде використовуватися тільки простейшая реалізація - в вигляді послідовних викликів Insert, тобто за O (N log N).
* **Union (T<sub>1</sub>, T<sub>2</sub>)** - за O (M log (N/M)) в середньому
Объединяет два дерева, в припущенні, що всі елементи різні (втім, цю операцію можна реалізувати з тією ж асимптотикою, якщо при об'єднанні потрібно видаляти повторювані елементи).
* **Intersect (T<sub>1</sub>, T<sub>2</sub>)** - за O (M log (N/M)) в середньому
Находит перетин двох дерев (тобто їх загальні елементи). Тут реалізація цій операції не буде розглядатися.

Крім того, за рахунок того, що декартове дерево є і бінарним деревом пошуку по своїм значенням, до нього застосовні такі операції, як знаходження K-го по величині елементу, і, навпаки, визначення номера елементу.

## Опис реалізації

З точки зору реалізації, кожний елемент містить в собі X, Y і вказівники на лівого L і правого R сина.

Для реалізації операцій знадобиться реалізувати дві допоміжні операції: Split і Merge.

**Split (T, X)** - розділяє дерево T на два дерева L і R (які є возвращаемым значенням) таким чином, що L містить всі елементи, менші по ключу X, а R містить всі елементи, великі X. Ця операція виконується за O (log N). Реалізація її досить проста - очевидна рекурсія.

**Merge (T<sub>1</sub>, T<sub>2</sub>)** - об'єднує два піддерева T<sub>1</sub> і T<sub>2</sub>, і повертає це нове дерево. Ця операція також реалізується за O (log N). Вона працює в припущенні, що T<sub>1</sub> і T<sub>2</sub> мають відповідним порядком (всі значення X в першому менше значень X у іншому). Таким чином, нам потрібно об'єднати їх так, аби не нарушить порядок по приоритетам Y. Для цього просто вибираємо в якості кореня то дерево, у якого Y в корені більше, і рекурсивно викликаємо собі від іншого дерева і відповідного сина выбранного дерева.

Тепер очевидна реалізація **Insert (X, Y)**. Спочатку спускаємося по дереву (як в звичайному бінарному дереві пошуку по X), але зупиняємося на першому елементі, в якому значення пріоритету виявилося менше Y. Ми знайшли позицію, куди будемо вставлять наш елемент. Тепер викликаємо Split (X) від знайденого елементу (від елементу разом зі всім його під деревом), і возвращаемые ею L і R записываем в якості лівого і правого сина додається елементу.

Також понятна і реалізація **Erase (X)**. Спускаемся по дереву (як в звичайному бінарному дереві пошуку по X), ища видаляється елемент. Найдя елемент, ми просто викликаємо Merge від його лівого і правого синів, і возвращаемое ею значення ставимо на місце удаляемого елементу.

Операцию **Build** реалізуємо за O (N log N) просто з допомогою послідовних викликів Insert.

Нарешті, операція **Union (T<sub>1</sub>, T<sub>2</sub>)**. Теоретически її асимптотика O (M log (N/M)), однак на практиці вона працює дуже добре, ймовірно, з вельми малої прихованої константою. Нехай, не втрачаючи спільності, T<sub>1</sub>->Y > T<sub>2</sub>->Y, тобто корінь T<sub>1</sub> буде коренем результату. Щоб получити результат, нам потрібно об'єднати дерева T<sub>1</sub>->L, T<sub>1</sub>->R і T<sub>2</sub> в два таких дерева, аби їх можна було зробити синами T<sub>1</sub>. Для цього вызовем Split (T<sub>2</sub>, T<sub>1</sub>->X), тим самим ми разобъём T<sub>2</sub> на дві половинки L і R, які потім рекурсивно об'єднаємо з синами T<sub>1</sub>: Union (T<sub>1</sub>->L, L) і Union (T<sub>1</sub>->R, R), тим самим ми побудуємо ліве і праве піддерева результату.

## Реалізація

Реалізуємо всі описані вище операції. Тут для зручності введены інші позначення - приоритет обозначается prior, значення - key.

<!--- TODO: specify code snippet id -->
``` cpp
struct item {
    int key, prior;
    item * l, * r;
    item() { }
    item (int key, int prior) : key(key), prior(prior), l(NULL), r(NULL) { }
};
typedef item * pitem;

void split (pitem t, int key, pitem & l, pitem & r) {
    if (!t)
        l = r = NULL;
    else if (key < t->key)
        split (t->l, key, l, t->l),  r = t;
    else
        split (t->r, key, t->r, r),  l = t;
}

void insert (pitem & t, pitem it) {
    if (!t)
        t = it;
    else if (it->prior > t->prior)
        split (t, it->key, it->l, it->r),  t = it;
    else
        insert (it->key < t->key ? t->l : t->r, it);
}

void merge (pitem & t, pitem l, pitem r) {
    if (!l || !r)
        t = l ? l : r;
    else if (l->prior > r->prior)
        merge (l->r, l->r, r),  t = l;
    else
        merge (r->l, l, r->l),  t = r;
}

void erase (pitem & t, int key) {
    if (t->key == key)
        merge (t, t->l, t->r);
    else
        erase (key < t->key ? t->l : t->r, key);
}

pitem unite (pitem l, pitem r) {
    if (!l || !r)  return l ? l : r;
    if (l->prior < r->prior)  swap (l, r);
    pitem lt, rt;
    split (r, l->key, lt, rt);
    l->l = unite (l->l, lt);
    l->r = unite (l->r, rt);
    return l;
}
```

## Підтримка розмірів поддеревьев

Щоб розширити функциональность декартового дерева, дуже часто необхідно для кожної вершини зберігати кількість вершин в її піддереві - некое поле int cnt в структурі item. Наприклад, з його допомогою легко буде знайти за O (log N) K-ый по величині елемент дерева, або, навпаки, за ту ж асимптотику дізнатися номер елементу в відсортованому списку (реалізація цих операцій нічим не буде відрізнятися від їх реалізації для звичайних бінарних дерев пошуку).

При зміні дерева (додаванні або видаленні елементу і т.д). повинні відповідним чином змінюватися і cnt деяких вершин. Реалізуємо дві функції - функція cnt() буде повертати поточний значення cnt або 0, якщо вершина не існує, а функція upd_cnt() буде оновлювати значення cnt для зазначеної вершини, при умови, що для її синів l і r ці cnt вже правильно обновлены. Значить, зрозуміло, достатньо додати виклики функції upd_cnt() в кінець кожної з функцій insert, erase, split, merge, аби постійно підтримувати корректные значення cnt.

<!--- TODO: specify code snippet id -->
``` cpp
int cnt (pitem t) {
    return t ? t->cnt : 0;
}

void upd_cnt (pitem t) {
    if (t)
        t->cnt = 1 + cnt(t->l) + cnt (t->r);
}
```

## Побудова декартового дерева за O (N) в офлайн

TODO

## Неявные декартовы дерева

Неявное декартове дерево - це проста модифікація звичайного декартового дерева, яка, тим не менш, виявляється дуже мощной структурою данних. Фактично, неявное декартове дерево можна сприймати як масив, над яким можна реалізувати наступні операції (всі за O (log N) в режимі онлайн):

* Вставка елементу в масив в будь-яку позицію
* Видалення довільного елементу
* Сума, мінімум/максимум на довільному відрізку, і т.д.
* Додаток, покраска на відрізку
* Переворот (перестановка елементів в зворотньому порядку) на відрізку

Ключова ідея полягає в тому, що в якості ключей key випливає використовувати **індекси** елементів в масиві. Однак явно зберігати ці значення key ми не будемо (інакше, наприклад, при вставке елементу довелося б змінювати key в O (N) вершинах дерева).

Зауважимо, що фактично в даному випадку ключ для якийсь вершини - це кількість вершин, менших її. Слід замітити, що вершини, менші даній, знаходяться не тільки в її лівому піддереві, але і, можливо, в лівих поддеревьях її предків. Більш строго, **неявний ключ** для деякої вершини t рівний кількості вершин cnt(t->l) в лівому піддереві цій вершини плюс аналогічні величини cnt(p->l)+1 для кожного предка p цій вершини, при умови, що t знаходиться в правом піддереві для p.

Ясно, як тепер швидко обчислювати для поточній вершини її неявний ключ. Оскільки у всіх операциях ми приходимо в яку-або вершину, спускаясь по дереву, ми можемо просто накапливать цю суму, передавая її функції. Якщо ми йдемо в ліве піддерево - накапливаемая сума не змінюється, а якщо йдемо в праве - збільшується на cnt(t->l)+1.

Наведемо нові реалізації функцій split і merge:

<!--- TODO: specify code snippet id -->
``` cpp
void merge (pitem & t, pitem l, pitem r) {
    if (!l || !r)
        t = l ? l : r;
    else if (l->prior > r->prior)
        merge (l->r, l->r, r),  t = l;
    else
        merge (r->l, l, r->l),  t = r;
    upd_cnt (t);
}

void split (pitem t, pitem & l, pitem & r, int key, int add = 0) {
    if (!t)
        return void( l = r = 0 );
    int cur_key = add + cnt(t->l); // обчислюємо неявний ключ
    if (key <= cur_key)
        split (t->l, l, t->l, key, add),  r = t;
    else
        split (t->r, t->r, r, key, add + 1 + cnt(t->l)),  l = t;
    upd_cnt (t);
}
```
Тепер перейдемо до реалізації різних додаткових операцій на неявных декартовых деревьях:

* **Вставка** елементу.
Нехай нам треба вставити елемент в позицію pos. Розіб'Ємо декартове дерево на дві половинки: відповідну масиву [0..pos-1] і масиву [pos..sz]; для цього достатньо викликати split (t, t1, t2, pos). Після цього ми можемо об'єднати дерево t1 з нової вершиною; для цього достатньо викликати merge (t1, t1, new_item) (неважко переконатися в тому, що всі предусловия для merge виконані). Нарешті, об'єднаємо два дерева t1 і t2 назад в дерево t - викликом merge (t, t1, t2).
* **Видалення** елементу.
Тут усе ще простіше: достатньо знайти видаляється елемент, а потім виконати merge для його синів l і r, і поставити результат про'єднання на місце вершини t. Фактично, видалення з неявного декартового дерева не відрізняється від видалення з звичайного декартового дерева.
* **Сума/мінімум** і т.п. на відрізку.
По-перше, для кожної вершини створимо дополнительное поле f в структурі item, в якому буде зберігатися значення целевой функції для піддерева цій вершини. Таке поле легко підтримувати, для цього треба вступити аналогічно поддержке розмірів cnt (створити функцію, вычисляющую значення цього поля, користуючись його значеннями для синів, і вставити виклики цій функції в наприкінці всіх функцій, меняющих дерево).
По-друге, нам треба навчитися відповідати на запит на довільному відрізку [A;B]. Навчимося выделять з дерева його частина, відповідну відрізку [A;B]. Неважко зрозуміти, що для цього достатньо спочатку викликати split (t, t1, t2, A), а потім split (t2, t2, t3, B-A+1). В результаті дерево t2 і буде складатися з всіх елементів в відрізку [A;B], і тільки них. Отже, відповідь на запит буде перебувати в поле f вершини t2. Після відповіді на запит дерево треба відновити викликами merge (t, t1, t2) і merge (t, t, t3).
* **Додаток/покраска** на відрізку.
Тут ми чинимо аналогічно попередньому пункту, але замість поля f будемо зберігати поле add, яке і буде містити прибавляемую величину (або величину, в яку красят усе піддерево цій вершини). Перед виконанням будь-який операції цю величину add треба "протолкнуть" - тобто відповідним чином змінити t-l->add і t->r->add, а у собі значення add снять. Тим самим ми доб'ємося того, що ні при яких изменениях дерева інформація не буде потеряна.
* **Переворот** на відрізку.
Цей пункт майже аналогичен попередньому - потрібно ввести поле bool rev, яке ставити в true, коли потрібно провести переворот в піддереві поточній вершини. "Проталкивание" поля rev полягає в тому, що ми обмінюємо місцями сини поточній вершини, і ставимо цей прапор для них.

**Реалізація**. Наведемо для прикладу повну реалізацію неявного декартового дерева з переворотом на відрізку. Тут для кожної вершини також зберігається поле value - власне значення елементу, стоящего в масиві на поточній позиції. Приведена також реалізація функції output(), яка виводить масив, відповідний поточному станом неявного декартового дерева.

<!--- TODO: specify code snippet id -->
``` cpp
typedef struct item * pitem;
struct item {
    int prior, value, cnt;
    bool rev;
    pitem l, r;
};

int cnt (pitem it) {
    return it ? it->cnt : 0;
}

void upd_cnt (pitem it) {
    if (it)
        it->cnt = cnt(it->l) + cnt(it->r) + 1;
}

void push (pitem it) {
    if (it && it->rev) {
        it->rev = false;
        swap (it->l, it->r);
        if (it->l)  it->l->rev ^= true;
        if (it->r)  it->r->rev ^= true;
    }
}

void merge (pitem & t, pitem l, pitem r) {
    push (l);
    push (r);
    if (!l || !r)
        t = l ? l : r;
    else if (l->prior > r->prior)
        merge (l->r, l->r, r),  t = l;
    else
        merge (r->l, l, r->l),  t = r;
    upd_cnt (t);
}

void split (pitem t, pitem & l, pitem & r, int key, int add = 0) {
    if (!t)
        return void( l = r = 0 );
    push (t);
    int cur_key = add + cnt(t->l);
    if (key <= cur_key)
        split (t->l, l, t->l, key, add),  r = t;
    else
        split (t->r, t->r, r, key, add + 1 + cnt(t->l)),  l = t;
    upd_cnt (t);
}

void reverse (pitem t, int l, int r) {
    pitem t1, t2, t3;
    split (t, t1, t2, l);
    split (t2, t2, t3, r-l+1);
    t2->rev ^= true;
    merge (t, t1, t2);
    merge (t, t, t3);
}

void output (pitem t) {
    if (!t)  return;
    push (t);
    output (t->l);
    printf ("%d ", t->value);
    output (t->r);
}
```
