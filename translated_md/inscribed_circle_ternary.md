# Знаходження вписаною кола в опуклому багатокутнику з допомогою тернарного пошуку

Дан опуклий багатокутник з N вершинами. Потрібно знайти координати центру і радіус найбільшою вписаною кола.

Тут описується простий метод розв'язку цій задачі з допомогою двох тернарних пошуків, працюючий за **O (N log<sup>2</sup> C)**, де C - коефіцієнт, определяемый величиною координат і необхідної точністю (див. нижче).

## Алгоритм

Визначимо функцію **Radius (X, Y)**, возвращающую радіус вписаною в даний багатокутник кола з центром в точці (X;Y). Передбачається, що точки X і Y лежати всередині (або на кордоні) багатокутника. Очевидно, цю функцію легко реалізувати з асимптотикою **O (N)** - просто проходимо по всім сторонам багатокутника, припустимо для кожної відстань до центру (причому відстань можна брати як від прямої до точки, не обов'язково розглядати як відрізок), і повертаємо мінімум з знайдених відстаней - очевидно, він і буде найбільшим радіусом.

Отже, нам потрібно максимізувати цю функцію. Зауважимо, що, оскільки багатокутник опуклий, то ця функція буде пригодна для **тернарного пошуку** по обом аргументам: при фіксованому X<sub>0</sub> (звісно, такому, що пряма X=X<sub>0</sub> перетинає багатокутник) функція Radius(X<sub>0</sub>, Y) як функція одного аргументу Y буде спочатку возрастать, потім убывать (знову ж, ми розглядаємо тільки такі Y, що точка (X<sub>0</sub>, Y) належить багатокутнику). Більш того, функція max (по Y) { Radius (X, Y) } як функція одного аргументу X буде спочатку возрастать, потім убывать. Ці властивості ясны з геометричних міркувань.

Таким чином, нам потрібно зробити два тернарних пошуку: по X і всередині нього по Y, максимизируя значення функції Radius. Єдиний особливий момент - потрібно правильно вибирати межі тернарних пошуків, оскільки обчислення функції Radius за пределами багатокутника буде некорректным. Для пошуку по X ніяких складнощів ні, просто вибираємо абсциссу самою лівої і самою правою точки. Для пошуку по Y знаходимо ті відрізки багатокутника, в які потрапляє поточний X, і знаходимо ординаты точок цих відрізків при абсцисі X (вертикальні відрізки не розглядаємо).

Залишилося оцінити **асимптотику**. Нехай максимальне значення, яке можуть приймати координати - це C<sub>1</sub>, а необхідна точність - порядку 10<sup>-C<sub>2</sub></sup>, і нехай C = C<sub>1</sub> + C<sub>2</sub>. Значить кількість кроків, які повинен буде совершить кожний тернарний пошук, є величина O (log C), і підсумкова асимптотика виходить: O (N log<sup>2</sup> C).

## Реалізація

Константа steps визначає кількість кроків обох тернарних пошуків.

В реалізації варто відзначити, що для кожної сторони зразу предпосчитываются коефіцієнти в рівнянні прямої, і зразу ж нормализуются (діляться на sqrt(A<sup>2</sup>+B<sup>2</sup>)), аби уникнути зайвих операцій всередині тернарного пошуку.

<!--- TODO: specify code snippet id -->
``` cpp
const double EPS = 1E-9;
int steps = 60;

struct pt {
    double x, y;
};

struct line {
    double a, b, c;
};

double dist (double x, double y, line & l) {
    return abs (x * l.a + y * l.b + l.c);
}

double radius (double x, double y, vector<line> & l) {
    int n = (int) l.size();
    double res = INF;
    for (int i=0; i<n; ++i)
        res = min (res, dist (x, y, l[i]));
    return res;
}

double y_radius (double x, vector<pt> & a, vector<line> & l) {
    int n = (int) a.size();
    double ly = INF,  ry = -INF;
    for (int i=0; i<n; ++i) {
        int x1 = a[i].x,  x2 = a[(i+1)%n].x,  y1 = a[i].y,  y2 = a[(i+1)%n].y;
        if (x1 == x2)  continue;
        if (x1 > x2)  swap (x1, x2),  swap (y1, y2);
        if (x1 <= x+EPS && x-EPS <= x2) {
            double y = y1 + (x - x1) * (y2 - y1) / (x2 - x1);
            ly = min (ly, y);
            ry = max (ry, y);
        }
    }
    for (int sy=0; sy<steps; ++sy) {
        double diff = (ry - ly) / 3;
        double y1 = ly + diff,  y2 = ry - diff;
        double f1 = radius (x, y1, l),  f2 = radius (x, y2, l);
        if (f1 < f2)
            ly = y1;
        else
            ry = y2;
    }
    return radius (x, ly, l);
}

int main() {

    int n;
    vector<pt> a (n);
    ... читання a ...

    vector<line> l (n);
    for (int i=0; i<n; ++i) {
        l[i].a = a[i].y - a[(i+1)%n].y;
        l[i].b = a[(i+1)%n].x - a[i].x;
        double sq = sqrt (l[i].a*l[i].a + l[i].b*l[i].b);
        l[i].a /= sq,  l[i].b /= sq;
        l[i].c = - (l[i].a * a[i].x + l[i].b * a[i].y);
    }

    double lx = INF,  rx = -INF;
    for (int i=0; i<n; ++i) {
        lx = min (lx, a[i].x);
        rx = max (rx, a[i].x);
    }

    for (int sx=0; sx<stepsx; ++sx) {
        double diff = (rx - lx) / 3;
        double x1 = lx + diff,  x2 = rx - diff;
        double f1 = y_radius (x1, a, l),  f2 = y_radius (x2, a, l);
        if (f1 < f2)
            lx = x1;
        else
            rx = x2;
    }

    double ans = y_radius (lx, a, l);
    printf ("%.7lf", ans);

}
```
