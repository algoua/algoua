# Зворотня задача SSSP (inverse-SSSP - зворотна задача найкоротших шляхів з однієї вершини)

Є зважений неорієнтований мультиграф G з N вершин і M ребер. Дан масив P[1..N] і вказана деяка начальная вершина S. Потрібно змінити ваги ребер так, аби для всіх I P[I] було рівне довжині найкоротшого шляхи з S в I, причому сума всіх змін (сума модулів змін ваг ребер) була б найменшою. Якщо цього зробити неможливо, то алгоритм повинен видати "No solution". Делать вага ребра негативним заборонено.

## Опис розв'язку

Ми вирішимо цю задачу за лінійне час, просто перебрав всі ребра (тобто за один прохід).

Нехай на поточному кроці ми розглядаємо ребро з вершини A в вершину B довжиною R. Ми припускаємо, що для вершини A вже всі умови виконані (тобто відстань від S до A дійсно рівне P[A]), і будемо перевіряти виконання умов для вершини B. Маємо декілька варіантів ситуації:

* 1. **P[A] + R < P[B]**
Це означає, що ми знайшли шлях, більш короткий, ніж він повинен бути. Оскільки P[A] і P[B] ми змінювати не можемо, то ми зобов'язані удлинить поточний ребро (незалежно від інших ребер), а саме виконати:
R += P[B] - P[A] - R.
Крім того, це означає, що ми знайшли вже шлях в вершину B з S, довжина якого рівна требуемому значенням P[B], тому на подальших кроках нам не доведеться вкорочувати які-або ребра (див. різновид 2).
* 2. **P[A] + R >= P[B]**
Це означає, що ми знайшли шлях, більш довгий, ніж необхідний. Оскільки таких шляхів можливо бути декілька, ми повинні вибрати серед всіх таких шляхів (ребер) то, яке зажадає найменшого зміни. Повторимся, що якщо ми удлиняли якесь ребро, ведущее в вершину B (різновид 1), то цим ми фактично побудували найкоротший шлях в вершину B, а тому вкорочувати никакое ребро вже не треба буде. Таким чином, для кожної вершини ми повинні зберігати ребро, яке собираемся вкорочувати, тобто ребро з найменшим вагою зміни.

Таким чином, просто перебрав всі ребра, і рассмотрев для кожного ребра ситуацию (за O(1)), ми вирішимо зворотню задачу SSSP за лінійне час.

Якщо в якийсь момент ми намагаємося змінити вже изменённое ребро, то, очевидно, цього робити не можна, і випливає видати "No solution". Крім того, у деяких вершин можливо бути так і не досягнута необхідна оцінка найкоротшого шляхи, тоді відповідь теж буде "No solution". У всіх інших випадках (крім, звісно, явно некорректных значень в масиві P, тобто P[S] != 0 або негативні значення) відповідь буде існувати.

## Реалізація

Програма виводить "No solution", якщо розв'язку ні, інакше виводить в першо] стрічки мінімальну суму змін ваг ребер, а в подальших M рядках - нові ваги ребер.

<!--- TODO: specify code snippet id -->
``` cpp
const int INF = 1000*1000*1000;
int n, m;
vector<int> p (n);

bool ok = true;
vector<int> cost (m), cost_ch (m), decrease (n, INF), decrease_id (n, -1);
decrease[0] = 0;
for (int i=0; i<m; ++i) {
    int a, b, c; // поточний ребро (a,b) з ціною c
    cost[i] = c;

    for (int j=0; j<=1; ++j) {
        int diff = p[b] - p[a] - c;
        if (diff > 0) {
            ok &= cost_ch[i] == 0 || cost_ch[i] == diff;
            cost_ch[i] = diff;
            decrease[b] = 0;
        }
        else
            if (-diff <= c && -diff < decrease[b]) {
                decrease[b] = -diff;
                decrease_id[b] = i;
            }
        swap (a, b);
    }
}

for (int i=0; i<n; ++i) {
    ok &= decrease[i] != INF;
    int r_id = decrease_id[i];
    if (r_id != -1) {
        ok &= cost_ch[r_id] == 0 || cost_ch[r_id] == -decrease[i];
        cost_ch[r_id] = -decrease[i];
    }
}

if (!ok)
    cout << "No solution";
else {
    long long sum = 0;
    for (int i=0; i<m; ++i)  sum += abs (cost_ch[i]);
    cout << sum << \'\n\';
    for (int i=0; i<m; ++i)
        printf ("%d ", cost[i] + cost_ch[i]);
}
```
