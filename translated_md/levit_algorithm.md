# Алгоритм Левіта знаходження найкоротших шляхів від заданої вершини до всіх інших вершин

Нехай дано граф з N вершинами і M ребрами, для кожного з яких вказано його вага L<sub>i</sub>. Також дана стартова вершина V<sub>0</sub>. Потрібно знайти найкоротші шляхи від вершини V<sub>0</sub> до всіх інших вершин.

Алгоритм Левіта вирішує цю задачу вельми ефективно (по приводу асимптотики і швидкості роботи див. нижче).

## Опис

Нехай масив D[1..N] буде містити поточні найкоротші довжини шляхів, тобто D<sub>i</sub> - це поточна довжина найкоротшого шляхи від вершини V<sub>0</sub> до вершини i. Cпершу масив D заполнен значеннями "нескінченність", крім D<sub>V<sub>0</sub></sub> = 0. За закінченні роботи алгоритму цей масив буде містити окончательные найкоротші відстані.

Нехай масив P[1..N] містить поточних предків, тобто P<sub>i</sub> - це вершина, предшествующая вершині i в найкоротшому шляхи від вершини V<sub>0</sub> до i. Так ж як і масив D, масив P змінюється поступово по ходу алгоритму і до кінця його приймає окончательные значення.

&nbsp;

Тепер власне сам алгоритм Левіта. На кожному кроці підтримується три множини вершин:

* M<sub>0</sub> - вершини, відстань до яких вже обчислено (але, можливо, не остаточно);
* M<sub>1</sub> - вершини, відстань до яких обчислюється;
* M<sub>2</sub> - вершини, відстань до яких ще не обчислено.

Вершини в множині M<sub>1</sub> зберігаються в вигляді двунаправленной черги (deque).

&nbsp;

Cпершу всі вершини помещаются в множину M<sub>2</sub>, крім вершини V<sub>0</sub>, яка поміщається в множину M<sub>1</sub>.

На кожному кроці алгоритму ми беремо вершину з множини M<sub>1</sub> (дістаємо верхний елемент з черги). Нехай V - це обрана вершина. Переводим цю вершину у множину M<sub>0</sub>. Потім просматриваем всі ребра, выходящие з цій вершини. Нехай T - це другий кінець поточного ребра (тобто не рівний V), а L - це довжина поточного ребра.

* Якщо T належить M<sub>2</sub>, то T переносим у множину M<sub>1</sub> в кінець черги. D<sub>T</sub> вважаємо рівним D<sub>V</sub> + L.
* Якщо T належить M<sub>1</sub>, то намагаємося покращити значення D<sub>T</sub>: D<sub>T</sub> = min (D<sub>T</sub>, D<sub>V</sub> + L). Сама вершина T ніяк не передвигается в черги.
* Якщо T належить M<sub>0</sub>, і якщо D<sub>T</sub> можна покращити (D<sub>T</sub> > D<sub>V</sub> + L), то улучшаем D<sub>T</sub>, а вершину T повертаємо в множину M<sub>1</sub>, поміщаючи її в початок черги.

Зрозуміло, при кожному обновлении масиву D випливає оновлювати і значення в масиві P.

## Подробности реалізації

Створимо масив ID[1..N], в якому для кожної вершини будемо зберігати, якого безлічі вона належить: 0 - якщо M<sub>2</sub> (тобто відстань рівне нескінченності), 1 - якщо M<sub>1</sub> (тобто вершина знаходиться в черги), і 2 - якщо M<sub>0</sub> (деякий шлях вже був знайдений, відстань менше нескінченності).

Черга обробки можна реалізувати стандартної структурою данних deque. Однак є більш ефективний спосіб. По-перше, очевидно, в черги в будь-який момент часу буде зберігатися максимум N елементів. Але, у-вторых, ми можемо додавати елементи і в початок, і в кінець черги. Отже, ми можемо организовать чергу на масиві розміру N, однак потрібно зациклить його. тобто. робимо масив Q[1..N], вказівники (int) на перший елемент QH і на елемент після останнього QT. Черга порожня, коли QH == QT. Додавання в кінець - просто запис в Q[QT] і збільшення QT на 1; якщо QT після цього вышел за межі черги (QT == N), то робимо QT = 0. Додавання в початок черги - зменшуємо QH на 1, якщо вона вышла за межі черги (QH == -1), то робимо QH = N-1.

Сам алгоритм реалізуємо в точності по опису вище.

## Асимптотика

Мне не відома більш-менш хороша асимптотическая оцінка цього алгоритму. Я встречал тільки оцінку O (N M) у похожего алгоритму.

Однак на практиці алгоритму зарекомендовал собі дуже добре: час його роботи я оцениваю як **O (M log N)**, хоча, повторюсь, це виключно **экспериментальная** оцінка.

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
typedef pair<int,int> rib;
typedef vector < vector<rib> > graph;

const int inf = 1000*1000*1000;

int main()
{
    int n, v1, v2;
    graph g (n);

    ... читання графа ...

    vector<int> d (n, inf);
    d[v1] = 0;
    vector<int> id (n);
    deque<int> q;
    q.push_back (v1);
    vector<int> p (n, -1);

    while (!q.empty())
    {
        int v = q.front(),  q.pop_front();
        id[v] = 1;
        for (size_t i=0; i<g[v].size(); ++i)
        {
            int to = g[v][i].first, len = g[v][i].second;
            if (d[to] > d[v] + len)
            {
                d[to] = d[v] + len;
                if (id[to] == 0)
                    q.push_back (to);
                else if (id[to] == 1)
                    q.push_front (to);
                p[to] = v;
                id[to] = 1;
            }
        }
    }

    ... висновок результату ...

}
```
