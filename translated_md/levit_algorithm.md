# Алгоритм Левіта знаходження найкоротших шляхів від заданої вершини до всіх інших вершин

Нехай дано граф з N вершинами і M ребрами, для кожного з яких вказано його вага L<sub>i</sub>. Також дана стартова вершина V<sub>0</sub>. Потрібно знайти найкоротші шляхи від вершини V<sub>0</sub> до всіх інших вершин.

Алгоритм Левіта вирішує цю задачу вельми ефективно (по приводу асимптотики і швидкості роботи див. нижче).

## Опис

Нехай масив D[1..N] буде містити поточні найкоротші довжини шляхів, тобто D<sub>i</sub> - це поточна довжина найкоротшого шляхи від вершини V<sub>0</sub> до вершини i. Cпершу масив D заполнен значеннями "нескінченність", крім D<sub>V<sub>0</sub></sub> = 0. За закінченні роботи алгоритму цей масив буде містити окончательные найкоротші відстані.

Нехай масив P[1..N] містить поточних предків, тобто P<sub>i</sub> - це вершина, предшествующая вершині i в найкоротшому шляхи від вершини V<sub>0</sub> до i. Так ж як і масив D, масив P змінюється поступово по ходу алгоритму і до кінця його приймає окончательные значення.

&nbsp;

Тепер власне сам алгоритм Левіта. На кожному кроці підтримується три множини вершин:

* M<sub>0</sub> - вершини, відстань до яких вже обчислено (але, можливо, не остаточно);
* M<sub>1</sub> - вершини, відстань до яких обчислюється;
* M<sub>2</sub> - вершини, відстань до яких ще не обчислено.

Вершини в множині M<sub>1</sub> зберігаються в вигляді двунаправленной черги (deque).

&nbsp;

Cпершу всі вершини помещаются в множину M<sub>2</sub>, крім вершини V<sub>0</sub>, яка поміщається в множину M<sub>1</sub>.

На кожному кроці алгоритму ми беремо вершину з множини M<sub>1</sub> (дістаємо верхний елемент з черги). Нехай V - це обрана вершина. Переводим цю вершину у множину M<sub>0</sub>. Потім просматриваем всі ребра, выходящие з цій вершини. Нехай T - це другий кінець поточного ребра (тобто не рівний V), а L - це довжина поточного ребра.

* Якщо T належить M<sub>2</sub>, то T переносим у множину M<sub>1</sub> в кінець черги. D<sub>T</sub> вважаємо рівним D<sub>V</sub> + L.
* Якщо T належить M<sub>1</sub>, то намагаємося покращити значення D<sub>T</sub>: D<sub>T</sub> = min (D<sub>T</sub>, D<sub>V</sub> + L). Сама вершина T ніяк не передвигается в черги.
* Якщо T належить M<sub>0</sub>, і якщо D<sub>T</sub> можна покращити (D<sub>T</sub> > D<sub>V</sub> + L), то улучшаем D<sub>T</sub>, а вершину T повертаємо в множину M<sub>1</sub>, поміщаючи її в початок черги.

Зрозуміло, при кожному обновлении масиву D випливає оновлювати і значення в масиві P.

## Подробности реалізації

Створимо масив ID[1..N], в якому для кожної вершини будемо зберігати, якого безлічі вона належить: 0 - якщо M<sub>2</sub> (тобто відстань рівне нескінченності), 1 - якщо M<sub>1</sub> (тобто вершина знаходиться в черги), і 2 - якщо M<sub>0</sub> (деякий шлях вже був знайдений, відстань менше нескінченності).

Черга обробки можна реалізувати стандартної структурою данних deque. Однак є більш ефективний спосіб. По-перше, очевидно, в черги в будь-який момент часу буде зберігатися максимум N елементів. Але, у-вторых, ми можемо додавати елементи і в початок, і в кінець черги. Отже, ми можемо организовать чергу на масиві розміру N, однак потрібно зациклить його. тобто. робимо масив Q[1..N], вказівники (int) на перший елемент QH і на елемент після останнього QT. Черга порожня, коли QH == QT. Додавання в кінець - просто запис в Q[QT] і збільшення QT на 1; якщо QT після цього вышел за межі черги (QT == N), то робимо QT = 0. Додавання в початок черги - зменшуємо QH на 1, якщо вона вышла за межі черги (QH == -1), то робимо QH = N-1.

Сам алгоритм реалізуємо в точності по опису вище.

## Асимптотика

Мне не відома більш-менш хороша асимптотическая оцінка цього алгоритму. Я встречал тільки оцінку O (N M) у похожего алгоритму.

Однак на практиці алгоритму зарекомендовал собі дуже добре: час його роботи я оцениваю як **O (M log N)**, хоча, повторюсь, це виключно **экспериментальная** оцінка.

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
typedef pair<int, int> rib;
typedef vector<vector<rib>> graph;

const int inf = 1000 * 1000 * 1000;

int main() {
    int n, v1, v2;
    graph g(n);

    ... читання графа...

        vector<int>
            d(n, inf);
    d[v1] = 0;
    vector<int> id(n);
    deque<int> q;
    q.push_back(v1);
    vector<int> p(n, -1);

    while (!q.empty()) {
        int v = q.front(), q.pop_front();
        id[v] = 1;
        for (size_t i = 0; i < g[v].size(); ++i) {
            int to = g[v][i].first, len = g[v][i].second;
            if (d[to] > d[v] + len) {
                d[to] = d[v] + len;
                if (id[to] == 0)
                    q.push_back(to);
                else if (id[to] == 1)
                    q.push_front(to);
                p[to] = v;
                id[to] = 1;
            }
        }
    }

    ... висновок результату...
}
```
