# Потік мінімальної вартості, циркуляція мінімальної вартості. Алгоритм видалення циклів негативного ваги

## Постановка задач

Нехай $G$ - мережа (network), то є орієнтований граф, в якому выбраны вершини-джерело $s$ і стік $t$. Безліч вершин позначимо через $V$, множину ребер - через $E$. Кожному ребру $(i,j) \in E$ сопоставлены його пропускна здатність $u_{ij} \ge 0$ і вартість одиниці потоку $c_{ij}$. Якщо якогось ребра $(i,j)$ в графі ні, то передбачається, що $u_{ij} = c_{ij} = 0$.

**Потоком** (flow) в мережі $G$ називається така действительнозначная функція $f$, сопоставляющая кожної пари вершин $(i,j)$ потік $f_{ij}$ між ними, і удовлетворяющая трём умовами:

* Ограничение пропускною здатності (виконується для будь-яких $i, j \in V$):

$$
f_{ij} \le u_{ij}
$$

* Антисимметричность (виконується для будь-яких $i, j \in V$):

$$
f_{ij} = - f_{ji}
$$

* Збереження потоку (виконується для будь-яких $i \in V$, крім $i=s$, $i=t$):

$$
\sum_{j \in V} f_{ij} = 0
$$

Величиной потоку називається величина

$$
|f| = \sum_{i \in V} f_{si}
$$

Стоимостью потоку називається величина

$$
z(f) = \sum_{i,j \in V} c_{ij} f_{ij}
$$

Задача знаходження **потоку мінімальної вартості** полягає в тому, що по заданої величині потоку $|f|$ потрібно знайти потік, обладающий мінімальної вартістю $z(f)$. Варто звернути увага на то, що вартості $c_{ij}$, приписанные ребрам, отвечают за вартість одиниці потоку уздовж цього ребра ; іноді зустрічається задача, коли ребрам сопоставляются вартості протекания потоку уздовж цього ребра (тобто якщо протікає потік будь-який величини, то взимается ця вартість, незалежно від величини потоку) - ця задача не має нічого загального з розглянутої тут і, більш того, є NP-повної.

Задача знаходження **максимального потоку мінімальної вартості** полягає в тому, аби знайти потік найбільшою величини, а серед всіх таких - з мінімальної вартістю. В приватному випадку, коли ваги всіх ребер однакові, ця задача стає эквивалентной звичайної задачі про максимальному потоці.

Задача знаходження **циркуляції мінімальної вартості** полягає в тому, аби знайти потік нульовий величини з мінімальної вартістю. Якщо всі вартості невід'ємні, то, зрозуміло, відповіддю буде нульовий потік $f_{ij}=0$; якщо ж є ребра негативного ваги (а, точніше, цикли негативного ваги), то навіть при нульовому потоці можливо знайти потік негативною вартості. Завдання знаходження циркуляції мінімальної вартості можна, звісно, поставити і на мережі без джерела і стоку, оскільки ніякий смысловой нагрузки вони не несут (втім, в такий граф можна додати джерело і стік в вигляді изолированных вершин і получити звичайну по формулюванні задачу). Іноді ставиться задача знаходження циркуляції максимальної вартості - зрозуміло, достатньо змінити вартості ребер на протилежні і отримаємо задачу знаходження циркуляції вже мінімальної вартості.

Усе ці задачі, звісно, можна перенести і на неориентированные графи. Втім, перейти від неориентированного графа до орієнтованому легко: кожне неорієнтоване ребро $(i,j)$ з пропускною здатністю $u_{ij}$ і вартістю $c_{ij}$ випливає замінити двома ориентированными ребрами $(i,j)$ і $(j,i)$ з однаковими пропускними здібностями і стоимостями.

## Залишкова мережа

Концепция **залишкової мережі** $G^f$ заснована на наступного простий ідеї. Нехай є деякий потік $f$; уздовж кожного ребра $(i,j) \in E$ протікає деякий потік $f_{ij} \le u_{ij}$. Значить уздовж цього ребра можна (теоретично) пустити ще $u_{ij} - f_{ij}$ одиниць потоку; цю величину і назвемо **залишкової пропускною здатністю**:

$$
r_{ij}^f = u_{ij} - f_{ij}
$$

Стоимость цих додаткових одиниць потоку буде такий ж:

$$
c_{ij}^f = c_{ij}
$$

Однак крім цього, **прямого** ребра $(i,j)$, в залишкової мережі $G^f$ з'являється і **зворотнє ребро** $(j,i)$. Интуитивный сенс цього ребра в тому, що ми можемо в будущем отменить частина потоку, протекавшего по ребру $(i,j)$. Відповідно, пропускание потоку уздовж цього зворотнього ребра $(j,i)$ фактично, і формально, означає зменшення потоку уздовж ребра $(i,j)$. Зворотне ребро має пропускну здатність, рівну нулю (аби, наприклад, при $f_{ij}=0$ і по зворотному ребру неможливо було б пропустити потік; при позитивної величині $f_{ij}>0$ для зворотнього ребра по властивості антисимметричности стане $f_{ji}<0$, що менше $c_{ji}^f = 0$, тобто можна буде пропускать якийсь потік уздовж зворотнього ребра), залишкову пропускну здатність - рівну потоку уздовж прямого ребра, а вартість - протилежну (адже після отмены частини потоку ми повинні відповідно зменшити і вартість):

$$
u_{ji}^f = 0
$$

$$
r_{ji}^f = f_{ij}
$$

$$
c_{ji}^f = -c_{ij}
$$

Таким чином, кожному орієнтованому ребру в $G$ відповідає два орієнтованих ребра в залишкової мережі $G^f$, і у кожного ребра залишкової мережі з'являється дополнительная характеристика - залишкова пропускна здатність. Втім, неважко замітити, що вираження для залишкової пропускною здатності $r_{ij}^f$ по суті однакові як для прямого, так і для зворотнього ребра, тобто ми можемо записати для будь-якого ребра $(i,j)$ залишкової мережі:

$$
r_{ij}^f = u_{ij}^f - f_{ij}^f
$$

До Речі, при реалізації це властивість дозваляє не зберігати остаточные пропускні здатності, а просто обчислювати їх при необхідності для ребра.

Слід відзначити, що з залишкової мережі видаляються всі ребра, мають нульову залишкову пропускну здатність. Залишкова мережа $G^f$ повинна містити **тільки ребра з позитивної залишкової пропускною здатністю $r_{ij}^f$**.

Тут варто звернути увага на такий важный момент: якщо в мережі $G$ були одночасно обидва ребра $(i,j)$ і $(j,i)$, то в залишкової мережі у кожного з них з'явиться по зворотному ребру, і в підсумку появятся **кратні ребра**. Наприклад, така ситуація часто виникає, коли мережа будується по неориентированному графу (і, виходить, кожне неорієнтоване ребро в підсумку приведе до появлению чотирьох ребер в залишкової мережі). Цю особливість потрібно завжди пам'ятати, вона призводить до небольшому усложнению програмування, хоча в загалом нічого не змінює. Крім того, позначення ребра $(i,j)$ в такому випадку стає неоднозначным, тому нижче ми всюди будемо вважати, що такий ситуації в мережі ні (виключно в цілях простоти і коректності описаний; на правильність ідей це ніяк не впливає).

## Критерій оптимальності по наличию циклів негативного ваги

**Теорема.** Некоторый потік $f$ є оптимальним (тобто має найменшу вартість серед всіх потоків такий ж величини) тоді і тільки тоді, коли залишкова мережа $G^f$ не містить циклів негативного ваги.

**Доведення: необхідність**. Нехай потік $f$ є оптимальним. Припустимо, що залишкова мережа $G^f$ містить цикл негативного ваги. Візьмемо цей цикл негативного ваги і виберемо мінімум $k$ серед залишкових пропускних здібностей ребер цього циклу ($k$ буде більше нуля). Але тоді можна збільшити потік уздовж кожного ребра циклу на величину $k$, при цим ніякі властивості потоку не порушаться, величина потоку не зміниться, однак вартість потоку зменшиться (зменшиться на вартість циклу, умноженную на $k$). Таким чином, якщо є цикл негативного ваги, то $f$ не можливо бути оптимальним, що і треба було довести.

**Доведення: достаточность**. Для цього спочатку доведемо допоміжні факти.

**Лема 1** (про декомпозиції потоку): будь-який потік $f$ можна уявити в вигляді сукупності шляхів з джерела в стік і циклів, всі - мають положительный потік. Доведемо цю лему конструктивно: покажемо, як розбити потік на совокупность шляхів і циклів. Якщо потік має ненулевую величину, то, очевидно, з джерела $s$ виходить хоча б одне ребро з позитивним потоком; пройдемо по цьому ребру, окажемся в якийсь вершині $v_1$. Якщо ця вершина $v_1 = t$, то зупиняємося - знайшли шлях з $s$ в $t$. Інакше, по властивості збереження потоку, з $v_1$ має виходити хоча б одне ребро з позитивним потоком; пройдемо по нього в якусь вершину $v_2$. Повторюючи цей процес, ми або прийдемо в стік $t$, або ж прийдемо в якусь вершину у другий раз. В першому випадку ми виявимо шлях з $s$ в $t$, у іншому - цикл. Найденный шлях/цикл буде мати положительный потік $k$ (мінімум з потоків ребер цього шляхи/циклу). Значить зменшимо потік уздовж кожного ребра цього шляхи/циклу на величину $k$, в результаті отримаємо знову потік, до якому знову застосуємо цей процес. Рано або пізно потік уздовж всіх ребер стане нульовим, і ми найдемо його декомпозицію на шляхи і цикли.

**Лема 2** (про різниці потоків): для будь-яких двох потоків $f$ і $g$ однієї величини ($|f| = |g|$) потік $g$ можна уявити як потік $f$ плюс декілька циклів в залишкової мережі $G^f$. Дійсно, розглянемо різницю цих потоків $g-f$ (віднімання потоків - це почленное віднімання, тобто віднімання потоків уздовж кожного ребра). Неважко переконатися, що в результаті вийде деякий потік нульовий величини, тобто циркуляція. Зробимо декомпозицію цій циркуляції згідно попередньою лемме. Очевидно, це декомпозиція не можливо містити шляхів (т.до. наявність $s$-$t$-шляхи з позитивним потоком означає, що і величина потоку в мережі позитивна). Таким чином, різницю потоків $g$ і $f$ можна уявити в вигляді суми циклів в мережі $G$. Більш того, це будуть і цикли в залишкової мережі $G^f$, т.до. $g_{ij} - f_{ij} \le u_{ij} - f_{ij} = r_{ij}^f$, що і треба було довести.

Тепер, вооружившись цими леммами, ми легко можемо **довести достаточность**. Отже, розглянемо довільний потік $f$, в залишкової мережі якого ні циклів негативною вартості. Розглянемо також потік тією ж величини, але мінімальної вартості $f^*$; доведемо, що $f$ і $f^*$ мають однакову вартість. Згідно з лемою 2, потік $f^*$ можна уявити в вигляді суми потоку $f$ і декількох циклів. Але раз вартості всіх циклів невід'ємні, то і вартість потоку $f^*$ не можливо бути менше вартості потоку $f$: $z(f^*) \ge z(f)$. З іншої сторони, т.до. потік $f^*$ є оптимальним, то його вартість не можливо бути вище вартості потоку $f$. Таким чином, $z(f) = z(f^*)$, що і треба було довести.

## Алгоритм видалення циклів негативного ваги

Только що доказанная теорема дає нам простий **алгоритм**, дозволяє знайти потік мінімальної вартості: якщо у нас є якийсь потік $f$, то побудувати для нього залишкову мережа, перевірити, є або в ній цикл негативного ваги. Якщо такого циклу ні, то потік $f$ є оптимальним (має найменшу вартість серед всіх потоків такий ж величини). Якщо ж був знайдений цикл негативною вартості, то порахувати потік $k$, який можна пропустити додатково через цей цикл (це $k$ буде рівне мінімуму з залишкових пропускних здібностей ребер циклу). Увеличив потік на $k$ уздовж кожного ребра циклу, ми, очевидно, не порушимо властивості потоку, не змінимо величину потоку, але зменшимо вартість цього потоку, отримавши новий потік $f^\prime$, для якого треба повторити весь процес.

Таким чином, аби запустити процес поліпшення вартості потоку, нам попередньо потрібно знайти **довільний потік потрібної величини** (яким-нибудь стандартним алгоритмом знаходження максимального потоку, див., наприклад, [алгоритм Едмондса-Карпа](edmonds_karp)). В зокрема, якщо потрібно знайти циркуляцию найменшою вартості, то почати можна просто з нульового потоку.

Оцінимо **асимптотику** алгоритму. Пошук циклу негативною вартості в графі з $n$ вершинами і $m$ ребрами виготовляється за $O(nm)$ (див. [відповідну статтю](negative_cycle)). Якщо ми позначимо через $C$ найбільше з вартостей ребер, через $U$ - найбільшу з пропускних здібностей, то максимальне значення вартості потоку не перевершує $mCU$. Якщо всі вартості і пропускні здатності - цілі числа, то кожна ітерація алгоритму уменьшает вартість потоку як мінімум на одиницю; отже, всього алгоритм зробить $O(mCU)$ ітерацій, а підсумкова асимптотика складе:

$$
O(nm^2CU)
$$

Ця асимптотика - не строго полиномиальна (strong polynomial), оскільки залежить від величин пропускних здібностей і вартостей.

Втім, якщо шукати не довільний негативний цикл, а використовувати якийсь більш чёткий підхід, то асимптотика можливо значно зменшитися. Наприклад, якщо кожний раз шукати цикл з мінімальної середньою вартістю (що також можна виробляти за $O(nm)$), то час роботи всього алгоритму можна оцінити строго полиномиальной асимптотикою $O(n^2 m^3 \log n)$.

## Реалізація

Спочатку введемо структури данних і функції для зберігання графа. Кожне ребро зберігається в окремої структурі $\rm edge$, всі ребра лежати в загалом списку $\rm edges$, а для кожної вершини $i$ в векторі ${\rm g}[i]$ зберігаються номера ребер, виходять з її. Така организация дозваляє легко знаходити номер зворотнього ребра по номеру прямого ребра - вони виявляються в списку $\rm edges$ сусідніми, і номер одного можна получити по номеру іншого операцією "^1" (вона инвертирует молодший біт). Додавання орієнтованого ребра в граф осуществляет функція $\rm add\_edge$, яка додає зразу пряме і зворотнє ребра.

<!--- TODO: specify code snippet id -->
``` cpp
const int MAXN = 100 * 2;
int n;
struct edge {
    int v, to, u, f, c;
};
vector<edge> edges;
vector<int> g[MAXN];

void add_edge(int v, int to, int cap, int cost) {
    edge e1 = {v, to, cap, 0, cost};
    edge e2 = {to, v, 0, 0, -cost};
    g[v].push_back((int)edges.size());
    edges.push_back(e1);
    g[to].push_back((int)edges.size());
    edges.push_back(e2);
}
```

В основний програмі після читання графа йде нескінченний цикл, всередині якого виконується алгоритм Форда-Беллмана, і якщо він обнаруживает цикл негативною вартості, то уздовж цього циклу збільшується потік. Оскільки залишкова мережа можливо представляти собою несвязный граф, то алгоритм Форда-Беллмана запускується з кожної не достигнутой ще вершини. В цілях оптимізації алгоритм використовує чергу (поточна чергу $\rm q$ і нова чергу $\rm nq$), аби не перебирати на кожної стадії всі ребра. Вдоль виявленого циклу кожний раз проталкивается рівне одиниця потоку, хоча, зрозуміло, в цілях оптимізації величину потоку можна визначати як мінімум залишкових пропускних здібностей.

<!--- TODO: specify code snippet id -->
``` cpp
const int INF = 1000000000;
for (;;) {
    bool found = false;

    vector<int> d(n, INF);
    vector<int> par(n, -1);
    for (int i = 0; i < n; ++i)
        if (d[i] == INF) {
            d[i] = 0;
            vector<int> q, nq;
            q.push_back(i);
            for (int it = 0; it < n && q.size(); ++it) {
                nq.clear();
                sort(q.begin(), q.end());
                q.erase(unique(q.begin(), q.end()), q.end());
                for (size_t j = 0; j < q.size(); ++j) {
                    int v = q[j];
                    for (size_t k = 0; k < g[v].size(); ++k) {
                        int id = g[v][k];
                        if (edges[id].f < edges[id].u)
                            if (d[v] + edges[id].c < d[edges[id].to]) {
                                d[edges[id].to] = d[v] + edges[id].c;
                                par[edges[id].to] = v;
                                nq.push_back(edges[id].to);
                            }
                    }
                }
                swap(q, nq);
            }
            if (q.size()) {
                int leaf = q[0];
                vector<int> path;
                for (int v = leaf; v != -1; v = par[v])
                    if (find(path.begin(), path.end(), v) == path.end())
                        path.push_back(v);
                    else {
                        path.erase(path.begin(), find(path.begin(), path.end(), v));
                        break;
                    }
                for (size_t j = 0; j < path.size(); ++j) {
                    int to = path[j], v = path[(j + 1) % path.size()];
                    for (size_t k = 0; k < g[v].size(); ++k)
                        if (edges[g[v][k]].to == to) {
                            int id = g[v][k];
                            edges[id].f += 1;
                            edges[id ^ 1].f -= 1;
                        }
                }
                found = true;
            }
        }

    if (!found)
        break;
}
```

## Література

* \book{Томас Кормен, Чарльз Лейзерсон, Рональд Рівест, Кліффорд Штайн}{Алгоритми: Побудова і аналіз}{2005}{cormen.djvu}
* \book{Ravindra Ahuja, Thomas Magnanti, James Orlin}{Network flows}{1993}{ahuja_flows.djvu}
* \book{Andrew Goldberg, Robert Tarjan}{Finding Minimum-Cost Circulations by Cancelling Negative Cycles}{1989}
