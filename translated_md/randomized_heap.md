# Рандомізованих купа

Рандомізованих купа (randomized heap) - це купа, яка за рахунок застосування генератора випадкових чисел дозваляє виконувати всі необхідні операції за логарифмічна ожидаемое час.

**Кучей** називається бінарне дерево, для будь-який вершини якого справедливо, що значення в цій вершині менше або рівне значень у всіх її потомках (це купа для мінімуму; звісно, симетрично можна визначити купу для максимуму). Таким чином, в корені купи завжди знаходиться мінімум.

Стандартный набір операцій, определяемый для куп, наступного:

* Додавання елементу
* Знаходження мінімуму
* Витяг мінімуму (видалення його з дерева і возврат його значення)
* Слияние двох куп (повертається купа, що містить елементи обох куп; дубликаты не видаляються)
* Видалення довільного елементу (при відомої позиції в дереві)

Рандомізованих купа дозваляє виконувати всі ці операції за ожидаемое час $O(\log n)$ при дуже простий реалізації.

## Структура данних

Відразу опишемо структуру данних, описывающую бинарную купу:
<!--- TODO: specify code snippet id -->
``` cpp
struct tree {
    T value;
    tree * l, * r;
};
```
В вершині дерева зберігається значення $\rm value$ деякого типу $\rm T$, для якого визначений оператор порівняння ($\rm operator\ <$). Крім того, зберігаються вказівники на лівого і правого синів (які рівні 0, якщо відповідний син відсутній).

## Выполнение операцій

Неважко зрозуміти, що всі операції над купою зводяться до однієї операції: **злиття** двох куп в одну. Дійсно, додавання елементу в купу равносильно злиття цій купи з купою, що складається з єдиного додається елементу. Знаходження мінімуму взагалі не вимагає ніяких дій - мінімумом просто є корінь купи. Витяг мінімуму еквівалентно тому, що купа замінюється результатом злиття лівого і правого піддерева кореня. Нарешті, видалення довільного елементу аналогічно удалению мінімуму: усе піддерево з коренем в цій вершині замінюється результатом злиття двох поддеревьев-синів цій вершини.

Отже, нам фактично треба реалізувати тільки операцію злиття двох куп, всі інші операції тривіально зводяться до цій операції.

Нехай дані дві купи $T_1$ і $T_2$, потрібно повернути їх об'єднання. Зрозуміло, що в корені кожної з цих куп знаходяться їх мінімуми, тому в корені результуючій купи буде перебувати мінімум з цих двох значень. Отже, ми порівнюємо, в корені який з куп знаходиться менше значення, його поміщаємо в корінь результату, а тепер ми повинні об'єднати синів обраної вершини з оставшейся купою. Якщо ми по якого-то признаку виберемо одного з двох синів, то тоді нам треба буде просто об'єднати піддерево в корені з цим сином з купою. Таким чином, ми знову прийшли до операції злиття. Рано або пізно цей процес зупиниться (на це знадобиться, зрозуміло, не більш ніж сума высот куп).

Таким чином, аби досягти логарифмічною асимптотики в середньому, нам треба вказати спосіб вибору одного з двох синів з тим, аби в середньому довжина проходимого шляхи получалась б порядку логарифма від кількості елементів в купі. Неважко догадаться, що виробляти цей вибір ми будемо **випадково**, таким чином, реалізація операції злиття виходить такий:

<!--- TODO: specify code snippet id -->
``` cpp
tree * merge (tree * t1, tree * t2) {
    if (!t1 || !t2)
        return t1 ? t1 : t2;
    if (t2->value < t1->value)
        swap (t1, t2);
    if (rand() & 1)
        swap (t1->l, t1->r);
    t1->l = merge (t1->l, t2);
    return t1;
}
```

Тут спочатку перевіряється, якщо хоча б одна з куп порожня, то ніяких дій по злиття виробляти не треба. Інакше, ми робимо, аби купа $\rm t1$ була купою з меншим значенням в корені (для чого обмінюємо $\rm t1$ і $\rm t2$, якщо треба). Нарешті, ми припустимо, що одному купу $\rm t2$ будемо сливать з лівим сином кореня купи $\rm t1$, тому ми случайным чином обмінюємо лівого і правого синів, а потім виконуємо злиття лівого сина і другий купи.

## Асимптотика

Введемо випадкову величину $h(T)$, позначає **довжину случайного шляхи** від кореня до листа (довжина в числі ребер). Зрозуміло, що алгоритм $\rm merge$ виконується за $O(h(T1)+h(T2))$ операцій. Тому для исследования асимптотики алгоритму треба исследовать випадкову величину $h(T)$.

### Математическое ожидание

Стверджується, що математическое ожидание $h(T)$ оцінюється зверху логарифмом від числа $n$ вершин в цій купі:

$$
Eh(T) \le \log(n+1)
$$

Доказывается це легко по індукції. Нехай $L$ і $R$ - відповідно ліве і праве піддерева кореня купи $T$, а $n_L$ і $n_R$ - кількості вершин в них (зрозуміло, що $n = n_L+n_R+1$).

Значить справедливо:

$$
Eh(T) = 1 + \frac{1}{2}(Eh(L) + Eh(R)) \le 1 + \frac{1}{2}(\log(n_L+1) + \log(n_R+1)) =
$$

$$
= 1 + \log \sqrt{ (n_L+1)(n_R+1) } = \log 2 \sqrt{ (n_L+1)(n_R+1) } \le
$$

$$
\le \log \frac{ 2 ((n_L+1) + (n_R+1)) }{ 2 } = \log (n_L + n_R + 2) = \log(n+1)
$$

що і потрібно довести.

### Превышение ожидаемой оцінки

Доведемо, що ймовірність превышения отриманої вище оцінки мала:

$$
P\{ h(T) > (c+1) \log n \} < \frac{1}{n^c}
$$

для будь-який позитивної константи $c$.

Позначимо через $P$ множину шляхів від кореня купи до листя, довжина яких перевершує $(c+1) \log n$. Зауважимо, що для будь-якого шляхи $p$ довжини $|p|$ ймовірність того, в якості случайного шляхи буде обраний саме він, рівна $2^{-|p|}$. Значить отримуємо:

$$
P\{ h(T) > (c+1) \log n \} = \sum_{p \in P} 2^{-|p|} < \sum_{p \in P} 2^{-(c+1) \log n} = |P| n^{-(c+1)} \le n^{-c}
$$

що і потрібно довести.

### Асимптотика алгоритму

Таким чином, алгоритм $\rm merge$, а, значить, і всі інші выраженные через нього операції, виконується за $O(\log n)$ в середньому.

Більш того, для будь-який позитивної константи $\epsilon$ знайдеться така положительная константа $c$, що ймовірність того, що операція зажадає більше ніж $c \log n$ операцій, менше $n^{-\epsilon}$ (це в деякому сенсі описывает худшее поведение алгоритму).
