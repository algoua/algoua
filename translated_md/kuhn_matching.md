# Алгоритм Куна знаходження найбільшого паросполука в дводольному графі

Дан дводольний граф $G$, що містить $n$ вершин і $m$ ребер. Потрібно знайти найбільше паросполука, тобто вибрати як можна більше ребер, аби ні одне выбранное ребро не имело загальної вершини ні з яким іншим выбранным ребром.

## Опис алгоритму

### Необходимые визначення

**Паросочетанием** $M$ називається набір попарно несмежных ребер графа (іншими словами, будь-який вершині графа має бути инцидентно не більш одного ребра з множини $M$). Мощностью паросполука назвемо кількість ребер в ньому. Наибольшим (або максимальним) паросполукою назвемо паросполука, потужність якого максимальна серед всіх можливих паросочетание в даному графі. Усе ті вершини, у яких є суміжне ребро з паросполука (тобто які мають ступінь рівне один в подграфе, образованном $M$), назвемо насыщенными цим паросполукою.

**Цепью** довжини $k$ назвемо деякий простий шлях (тобто не що містить повторюваних вершин або ребер), що містить $k$ ребер.

**Чередующейся ланцюгом** (в дводольному графі, щодо деякого паросполука) назвемо ланцюг, в якій ребра поочередно належать/не належать паросполуці.

**Увеличивающей ланцюгом** (в дводольному графі, щодо деякого паросполука) назвемо чередующуюся ланцюг, у якій начальная і конечная вершини не належать паросполуці.

### Теорема Бержа

**Формулювання**. Паросочетание є максимальним тоді і тільки тоді, коли не існує збільшують щодо нього ланцюгів.

**Доведення необхідності**. Покажемо, що якщо паросполука $M$ максимально, то не існує збільшоючим щодо нього ланцюги. Доведення це буде конструктивним: ми покажемо, як збільшити з допомогою цій збільшоючим ланцюги $P$ потужність паросполука $M$ на одиницю.

Для цього виконаємо так зване чергування паросполука уздовж ланцюги $P$. Ми пам'ятаємо, що по визначенню перший ребро ланцюги $P$ не належить паросполуці, друге - належить, третій - знову не належить, четвёртое - належить, і т.д. Давайте поменяем стан всіх ребер уздовж ланцюги $P$: ті ребра, які не входили в паросполука (перший, третій і т.д. до останнього) включимо в паросполука, а ребра, які раніше входили в паросполука (друге, четвёртое і т.д. до предпоследнего) - видалимо з нього.

Зрозуміло, що потужність паросполука при цим увеличилась на одиницю (тому що було добавлено на одне ребро більше, ніж удалено). Залишилося перевірити, що ми побудували коректне паросполука, тобто що ніяка вершина графа не має зразу двох суміжних ребер з цього паросполука. Для всіх вершин чередующей ланцюги $P$, крім першо] і останньої, це випливає з самого алгоритму чергування: спочатку ми у кожної такий вершини видалили суміжне ребро, потім додали. Для першо] і останньої вершини ланцюги $P$ також нічого не могло нарушиться, оскільки до чергування вони повинні були бути ненасиченими. Нарешті, для всіх інших вершин, - не що входять в ланцюг $P$, - очевидно, нічого не поменялось. Таким чином, ми насправді побудували паросполука, і на одиницю більшої потужності, ніж старе, що і завершує доведення необхідності.

**Доведення достатності**. Доведемо, що якщо щодо деякого паросполука $M$ ні збільшують шляхів, то воно - максимально.

Доведення проведемо від противного. Нехай є паросполука $M^\prime$, имеющее бОльшую потужність, ніж $M$. Розглянемо симметрическую різницю $Q$ цих двох паросочетание, тобто оставим всі ребра, що входять в $M$ або в $M^\prime$, але не в обидва одночасно.

Зрозуміло, що множину ребер $Q$ - вже наверняка не паросполука. Розглянемо, який вид це множину ребер має; для зручності будемо розглядати його як граф. В цим графі кожна вершина, очевидно, має ступінь не вище 2 (тому що кожна вершина можливо мати максимум два суміжних ребра - з одного паросполука і з іншого). Легко зрозуміти, що тоді цей граф складається тільки з циклів або шляхів, причому ні ті, ні інші не перетинаються один з другом.

Тепер зауважимо, що і шляхи в цим графі $Q$ можуть бути не будь-якими, а тільки парної довжини. Насправді, в будь-якому шляхи в графі $Q$ ребра чередуются: після ребра з $M$ йде ребро з $M^\prime$, і навпаки. Тепер, якщо ми розглянемо якийсь шлях непарної довжини в графі $Q$, то вийде, що в вихідному графі $G$ це буде збільшоючим ланцюгом або для паросполука $M$, або для $M^\prime$. Але цього бути не могло, тому що в випадку паросполука $M$ це суперечить з умовою, а в випадку $M^\prime$ - з його максимальностью (адже ми вже довели необхідність теореми, з якій випливає, що при существовании збільшоючим ланцюги паросполука не можливо бути максимальним).

Доведемо тепер аналогичное твердження і для циклів: всі цикли в графі $Q$ можуть мати тільки парну довжину. Це довести зовсім просто: зрозуміло, що в циклі ребра також повинні чередоваться (належати по черги то $M$, то $M^\prime$), але це умова не можливо выполниться в циклі непарної довжини - в ньому обов'язково знайдуться два сусідніх ребра з одного паросполука, що суперечить визначенню паросполука.

Таким чином, всі шляхи і цикли графа $Q = M \oplus M^\prime$ мають парну довжину. Отже, граф $Q$ містить рівне кількість ребер з $M$ і з $M^\prime$. Але, враховуючи, що в $Q$ містяться всі ребра $M$ і $M^\prime$, за винятком їх загальних ребер, то звідси випливає, що потужність $M$ і $M^\prime$ збігаються. Ми прийшли до протиріччя: по припущенням паросполука $M$ було не максимальним, значить, теорема доведена.

### Алгоритм Куна

Алгоритм Куна - безпосереднє застосування теореми Бержа. Його можна коротко описати так: спочатку візьмемо порожнє паросполука, а потім - поки в графі вдається знайти збільшує ланцюг, - будемо виконувати чергування паросполука уздовж цій ланцюги, і повторювати процес пошуку збільшоючим ланцюги. Як тільки таку ланцюг знайти не вдалося - процес зупиняємо, - поточний паросполука і є максимальне.

Залишилося детализировать спосіб знаходження збільшують ланцюгів. **Алгоритм Куна** - просто шукає будь-яку з таких ланцюгів з допомогою **[обходу в глибину](dfs)** або **[в ширину](bfs)**. Алгоритм Куна переглядає всі вершини графа по черги, запуская з кожної обхід, пытающийся знайти збільшує ланцюг, начинающуюся в цій вершині.

Удобнее описувати цей алгоритм, вважаючи, що граф вже разбит на дві частки (хоча насправді алгоритм можна реалізувати і так, аби йому не давался на вхід граф, явно разбитый на дві частки).

Алгоритм переглядає всі вершини $v$ першо] частки графа: $v = 1 \ldots n_1$. Якщо поточна вершина $v$ вже насичена поточним паросполукою (тобто вже вибрано якесь суміжне їй ребро), то цю вершину пропускаємо. Інакше - алгоритм намагається наситити цю вершину, для чого запускується пошук збільшоючим ланцюги, що починається з цій вершини.

Пошук збільшоючим ланцюги здійснюється з допомогою специального обходу в глибину або ширину (зазвичай в цілях простоти реалізації використовують саме обхід в глибину). Cпершу обхід в глибину варто в поточній ненасиченої вершині $v$ першо] частки. Просматриваем всі ребра з цій вершини, нехай поточний ребро - це ребро $(v,to)$. Якщо вершина $to$ ще не насичена паросполукою, то, значить, ми змогли знайти збільшує ланцюг: вона складається з єдиного ребра $(v,to)$; в такому випадку просто включаем це ребро в паросполука і прекращаем пошук збільшоючим ланцюги з вершини $v$. Інакше, - якщо $to$ вже насичена яким-то ребром $(p,to)$, то попытаемся пройти уздовж цього ребра: тим самим ми попробуем знайти збільшує ланцюг, що проходить через ребра $(v,to)$, $(to,p)$. Для цього просто перейдемо в нашому обході в вершину $p$ - тепер ми вже пробуем знайти збільшує ланцюг з цій вершини.

Можна зрозуміти, що в результаті цей обхід, запущенный з вершини $v$, або знайде збільшує ланцюг, і тим самим насытит вершину $v$, або ж такий збільшоючим ланцюги не знайде (і, отже, ця вершина $v$ вже не зможе стать насыщенной).

Після того, як всі вершини $v = 1 \ldots n_1$ будуть просмотрены, поточний паросполука буде максимальним.

### Час роботи

Отже, алгоритм Куна можна уявити як серію з $n$ запусків обходу в глибину/ширину на усьому графі. Отже, всього цей алгоритм исполняется за час $O(n m)$, що в гіршому випадку є $O(n^3)$.

Однак цю оцінку можна трохи **покращити**. Виявляється, для алгоритму Куна важливо то, яка частка обрана за першу, а яка - за одному. Насправді, в описаної вище реалізації запуски обходу в глибину/ширину відбуваються тільки з вершин першо] частки, тому весь алгоритм исполняется за час $O(n_1 m)$, де $n_1$ - кількість вершин першо] частки. В гіршому випадку це становить $O(n_1^2 n_2)$ (де $n_2$ - кількість вершин другий частки). Звідси видно, що выгоднее, коли перша частка містить менше кількість вершин, нежели друга. На дуже несбалансированных графах (коли $n_1$ і $n_2$ сильно відрізняються) це выливается в значительную різницю часів роботи.

## Реалізація

Наведемо тут реалізацію вищеописаного алгоритму, основанную на обході в глибину, і принимающей дводольний граф в вигляді явно разбитого на дві частки графа. Ця реалізація вельми лаконична, і, можливо, її варто запам'ятати саме в такому вигляді.

Тут $n$ - кількість вершин в першо] частці, $k$ - у другий частці, $g[v]$ - список ребер з вершини $v$ першо] частки (тобто список номерів вершин, в які ведуть ці ребра з $v$). Вершини в обох частках занумерованы незалежно, тобто перша частка - з номерами $1 \ldots n$, друга - з номерами $1 \ldots k$.

Далі йдуть два допоміжних масиву: $\rm mt$ і $\rm used$. Перший - $\rm mt$ - містить в собі інформацію про поточному паросполуці. Для зручності програмування, інформація ця міститься тільки для вершин другий частки: $mt[i]$ - це номер вершини першо] частки, связанной ребром з вершиною $i$ другий частки (або $-1$, якщо ніякого ребра паросполука з $i$ не виходить). Другий масив - $\rm used$ - звичайний масив "посещённостей" вершин в обході в глибину (він потрібен, просто аби обхід в глибину не заходил в одну вершину двічі).

Функція $\rm try\_kuhn$ - і є обхід в глибину. Вона повертає $\rm true$, якщо їй вдалося знайти збільшує ланцюг з вершини $v$, при цим вважається, що ця функція вже произвела чергування паросполука уздовж найденной ланцюги.

Усередині функції проглядаються всі ребра, вихідні з вершини $v$ першо] частки, і потім перевіряється: якщо це ребро веде в ненасыщенную вершину $to$, або якщо ця вершина $to$ насичена, але вдається знайти збільшує ланцюг рекурсивным запуском з $\rm mt[to]$, то ми говорим, що ми знайшли збільшує ланцюг, і перед возвратом з функції з результатом $\rm true$ виробляємо чергування в поточному ребрі: перенаправляємо ребро, суміжне з $to$, в вершину $v$.

В основний програмі спочатку указывается, що поточний паросполука - порожнє (список $\rm mt$ заповнюється числами $-1$). Потім перебирається вершина $v$ першо] частки, і з її запускується обхід в глибину $\rm try\_kuhn$, попередньо обнулив масив $\rm used$.

Варто замітити, що розмір паросполука легко получити як число викликів $\rm try\_kuhn$ в основний програмі, вернувших результат $\rm true$. Саме шукане максимальне паросполука міститься в масиві $\rm mt$.

<!--- TODO: specify code snippet id -->
``` cpp
int n, k;
vector < vector<int> > g;
vector<int> mt;
vector<char> used;

bool try_kuhn (int v) {
    if (used[v])  return false;
    used[v] = true;
    for (size_t i=0; i<g[v].size(); ++i) {
        int to = g[v][i];
        if (mt[to] == -1 || try_kuhn (mt[to])) {
            mt[to] = v;
            return true;
        }
    }
    return false;
}

int main() {
    ... читання графа ...

    mt.assign (k, -1);
    for (int v=0; v<n; ++v) {
        used.assign (n, false);
        try_kuhn (v);
    }

    for (int i=0; i<k; ++i)
        if (mt[i] != -1)
            printf ("%d %d\n", mt[i]+1, i+1);
}
```

Ще раз повторимо, що алгоритм Куна легко реалізувати і так, аби він працював на графах, про які відомо, що вони двудольные, але явне їх розбиття на дві частки не знайдено. В цим випадку доведеться отказаться від удобного разбиения на дві частки, і всю інформацію зберігати для всіх вершин графа. Для цього масив списків $g$ тепер задається не тільки для вершин першо] частки, а для всіх вершин графа (зрозуміло, тепер вершини обох часткою занумерованы в загальної нумерації - від $1$ до $n$). Массивы $\rm mt$ і $\rm used$ тепер також визначені для вершин обох часткою, і, відповідно, їх потрібно підтримувати в цим стані.

## Покращена реалізація

Модифицируем алгоритм наступним чином. До основного циклу алгоритму найдемо яким-нибудь простим алгоритмом **довільне паросполука** (простим **эвристическим алгоритмом**), і лише потім будемо виконувати цикл з викликами функції kuhn(), який буде улучшать це паросполука. В результаті алгоритм буде працювати помітно швидше на випадкових графах - тому що в більшості графів можна легко набрать паросполука достатньо великого ваги з допомогою евристики, а потім покращити знайдене паросполука до максимального вже звичайним алгоритмом Куна. Тим самим ми сэкономим на запусках обходу в глибину з тих вершин, які ми вже включили з допомогою евристики в поточний паросполука.

**Наприклад**, можна просто перебрати всі вершини першо] частки, і для кожної з них знайти довільне ребро, яке можна додати в паросполука, і додати його. Даже така проста евристика здатна прискорити алгоритм Куна в декілька раз.

Слід звернути увага на то, що основний цикл доведеться трохи модифікувати. Оскільки при виклику функції $\rm try\_kuhn$ в основному циклі передбачається, що поточна вершина ще не входити в паросполука, то потрібно додати відповідну перевірку.

В реалізації зміниться тільки код в функції main():

<!--- TODO: specify code snippet id -->
``` cpp
int main() {
    ... читання графа ...

    mt.assign (k, -1);
    vector<char> used1 (n);
    for (int i=0; i<n; ++i)
        for (size_t j=0; j<g[i].size(); ++j)
            if (mt[g[i][j]] == -1) {
                mt[g[i][j]] = i;
                used1[i] = true;
                break;
            }
    for (int i=0; i<n; ++i) {
        if (used1[i])  continue;
        used.assign (n, false);
        try_kuhn (i);
    }

    for (int i=0; i<k; ++i)
        if (mt[i] != -1)
            printf ("%d %d\n", mt[i]+1, i+1);
}
```

**Інший хорошей евристикою** є наступна. На кожному кроці буде шукати вершину найменшою степені (але не изолированную), з її вибирати будь-яке ребро і додавати його в паросполука, потім видаляючи обидві ці вершини зі усіма инцидентными їм ребрами з графа. Така жадность працює дуже добре на випадкових графах, навіть в більшості випадків будує максимальне паросполука (хоча і проти її є тест, на якому вона знайде паросполука значно меншої величини, ніж максимальне).
