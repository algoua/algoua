# Дерево відрізків

Дерево відрізків - це структура данних, яка дозваляє ефективно (тобто за асимптотику $O(\log n)$) реалізувати операції наступного увазі: знаходження суми/мінімуму елементів масиву в заданому відрізку ($a[l \ldots r]$, де $l$ і $r$ надходять на вхід алгоритму), при цим додатково можливо зміна елементів масиву: як зміна значення одного елементу, так і зміна елементів на цілому підвідрізку масиву (тобто дозволяється присвоїти всім елементам $a[l \ldots r]$ яке-або значення, або додати до всім елементам масиву яке-або число).

Взагалі, дерево відрізків - дуже гибкая структура, і число задач, решаемых їй, теоретично неограниченно. Крім приведённых вище видів операцій з деревами відрізків, також можливі і набагато більш складні операції (див. раздел "Усложнённые версії дерева відрізків"). В зокрема, дерево відрізків легко узагальнюється на великі розмірності: наприклад, для розв'язку задачі про пошуку суми/мінімуму в деякому подпрямоугольнике даній матриці (правда, вже тільки за час $O(\log^2 n)$).

Важной особенностью дерев відрізків є то, що вони потребляют лінійний об'єм пам'яті: стандартному дереву відрізків потрібно порядку $4n$ елементів пам'яті для роботи над масивом розміру $n$.

## Опис дерева відрізків в базовом варіанті

Для початку розглянемо найпростіший випадок дерева відрізків - дерево відрізків для сум. Якщо ставити задачу формально, то у нас є масив $a[0..n-1]$, і наше дерево відрізків має вміти знаходити суму елементів з $l$-го по $r$-ый (це запит суми), а також обробляти зміна значення одного зазначеного елементу масиву, тобто фактично реагувати на привласнення $a[i]=x$ (це запит модифікації). Ще раз повторимося, дерево відрізків має обробляти обидва цих запиту за час $O(\log n)$.

### Структура дерева відрізків

Отже, що ж представляє з собі дерево відрізків?

Подсчитаем і запам'ятаємо де-нибудь суму елементів всього масиву, тобто відрузку $a[0 \ldots n-1]$. Також порахуємо суму на двох половинках цього масиву: $a[0 \ldots n/2]$ і $a[n/2+1 \ldots n-1]$. Каждую з цих двох половинок в свою чергу розіб'ємо навпіл, порахуємо і збережемо суму на них, потім знову розіб'ємо навпіл, і так далі, поки поточний відрізок не досягне довжини $1$. Іншими словами, ми стартуємо з відрузку $[0;n-1]$ і кожний раз делим поточний відрізок надвое (якщо він ще не став відрізком одиничної довжини), вызывая потім цю ж процедуру від обох половинок; для кожного такого відрузку ми зберігаємо суму чисел на ньому.

Можна говорити, що ці відрізки, на яких ми считали суму, утворюють дерево: корінь цього дерева - відрізок $[0 \ldots n-1]$, а кожна вершина має рівне двох синів (крім вершин-листя, у яких відрізок має довжину $1$). Звідси і відбувається назва - "дерево відрізків" (хоча при реалізації зазвичай ніякого дерева явно не будується, але про цим нижче в розділі реалізації).

Отже, ми описали структуру дерева відрізків. Відразу зауважимо, що воно має **лінійний розмір**, а саме, містить менш $2n$ вершин. Понять це можна наступним чином: перший рівень дерева відрізків містить одну вершину (відрізок $[0 \ldots n-1]$), другий рівень - в гіршому випадку дві вершини, на третьому рівні в гіршому випадку буде чотири вершини, і так далі, поки кількість вершин не досягне $n$. Таким чином, кількість вершин в гіршому випадку оцінюється сумою $n + n/2 + n/4 + n/8 + \ldots + 1 < 2n$.

Варто відзначити, що при $n$, отличных від степеней двійки, не всі уровни дерева відрізків будуть повністю заполнены. Наприклад, при $n=3$ лівий син кореня є відрізок $[0 \ldots 1]$, має двох нащадків, в то час як правий син кореня - відрізок $[2 \ldots 2]$, є листком. Никаких особливих складнощів при реалізації це не становить, але тим не менш це треба мати в увазі.

**Высота** дерева відрізків є величина $O(\log n)$ - наприклад, тому що довжина відрузку в корені дерева рівна $n$, а при переході на один рівень вниз довжина відрізків зменшується приблизно вдвічі.

### Побудова

Процес побудови дерева відрізків по заданому масиву $a$ можна робити ефективно наступним чином, знизу вгору: спочатку запишемо значення елементів $a[i]$ в відповідні листя дерева, потім на основі них порахуємо значення для вершин попереднього рівня як суму значень в двох листьях, потім аналогічним чином порахуємо значення для ще одного рівня, і т.д. Удобно описувати цю операцію рекурсивно: ми запускаємо процедуру побудови від кореня дерева відрізків, а сама процедура побудови, якщо її вызвали не від листа, викликає собі від кожного з двох синів і суммирует обчислені значення, а якщо її вызвали від листа - то просто записывает в собі значення цього елементу масиву.

Асимптотика побудови дерева відрізків складе, таким чином, $O(n)$.

### Запит суми

Розглянемо тепер запит суми. На вхід надходять два числа $l$ і $r$, і ми повинні за час $O(\log n)$ порахувати суму чисел на відрізку $a[l \ldots r]$.

Для цього ми будемо спускатися по построенному дереву відрізків, використовуючи для підрахунку відповіді посчитанные раніше суми на кожної вершині дерева. Cпершу ми встаём в корінь дерева відрізків. Подивимося, в які з двох його синів потрапляє відрізок запиту $[l \ldots r]$ (нагадаємо, що сини кореня дерева відрізків - це відрізки $[0 \ldots n/2]$ і $[n/2+1 \ldots n-1]$). Возможны два варіанти: що відрізок $[l \ldots r]$ потрапляє тільки в одного сина кореня, і що, навпаки, відрізок пересекается з обоими синами.

Перший випадок простий: просто перейдемо в того сина, в якому лежить наш відрізок-запит, і застосуємо описаний тут алгоритм до поточній вершині.

У іншому ж випадку нам не залишається інших варіантів, крім як перейти спочатку в лівого сина і порахувати відповідь на запит в ньому, а потім - перейти в правого сина, порахувати в ньому відповідь і додати до нашому відповіді. Іншими словами, якщо лівий син представлял відрізок $[l_1 \ldots r_1]$, а правий - відрізок $[l_2 \ldots r_2]$ (зауважимо, що $l_2 = r_1 + 1$), то ми перейдемо в лівого сина з запитом $[l \ldots r_1]$, а в правого - з запитом $[l_2 \ldots r]$.

Отже, обробка запиту суми представляє собою **рекурсивну функцію**, яка всякий раз викликає собі або від лівого сина, або від правого (не изменяя межі запиту в обох випадках), або від обох зразу (при цим деля наш запит на два відповідних подзапроса). Однак рекурсивні виклики будемо робити не завжди: якщо поточний запит совпал з кордонами відрузку в поточній вершині дерева відрізків, то в якості відповіді будемо повертати предвычисленное значення суми на цим відрізку, записанное в дереві відрізків.

Іншими словами, обчислення запиту представляє собою спуск по дереву відрізків, який распространяется по всім нужным ветвям дерева, і для швидкої роботи использующий вже посчитанные суми по кожному відрізку в дереві відрізків.

Чому ж **асимптотика** цього алгоритму буде $O(\log n)$? Для цього подивимося на кожному рівні дерева відрізків, скільки максимум відрізків могла посетить наша рекурсивна функція при обробці какого-або запиту. Стверджується, що таких відрізків не могло бути більш чотирьох; тоді, враховуючи оцінку $O(\log n)$ для висоти дерева, ми і отримуємо нужную асимптотику часу роботи алгоритму.

Покажемо, що ця оцінка про чотирьох відрізках вірна. Насправді, на нульовому рівні дерева запитом затрагивается єдина вершина - корінь дерева. Далі на першому рівні рекурсивний виклик в гіршому випадку розбивається на два рекурсивних виклику, але важливо тут то, що запити в цих двох викликах будуть соседствовать, тобто число $l^{\prime\prime}$ запиту у іншому рекурсивном виклику буде на одиницю більше числа $r^\prime$ запиту в першому рекурсивном виклику. Звідси випливає, що на наступному рівні кожний з цих двох викликів міг породить ще по два рекурсивних виклику, але в такому випадку половина цих запитів відпрацює нерекурсивно, взявши потрібне значення з вершини дерева відрізків. Таким чином, всякий раз у нас буде не більш двох реально працюючих ветвей рекурсії (можна сказати, що одна ветвь приближается до лівої кордоні запиту, а друга ветвь - до правою), а всього число затронутых відрізків не могло превысить висоти дерева відрізків, умноженной на чотири, тобто воно є число $O(\log n)$.

В завершення можна привести і таке понимание роботи запиту суми: вхідний відрізок $[l \ldots r]$ розбивається на декілька підвідрізків, відповідь на кожному з яких вже подсчитан і сохранён в дереві. Якщо робити це розбиття правильным чином, то завдяки структурі дерева відрізків число необхідних підвідрізків завжди буде $O(\log n)$, що і дає эффективность роботи дерева відрізків.

### Запит поновлення

Нагадаємо, що запит поновлення получает на вхід індекс $i$ і значення $x$, і перестраивает дерево відрізків таким чином, аби воно соответствовало новому значенням $a[i]=x$. Цей запит повинен також виконуватися за час $O(\log n)$.

Це більш простий запит по порівняно з запитом підрахунку суми. Справа в тому, що елемент $a[i]$ участвует тільки в щодо небольшом числі вершин дерева відрізків: а саме, в $O(\log n)$ вершинах - по однієї з кожного рівня.

Значить зрозуміло, що запит поновлення можна реалізувати як рекурсивну функцію: їй передається поточна вершина дерева відрізків, і ця функція виконує рекурсивний виклик від одного з двох своїх синів (від того, який містить позицію $i$ в своєму відрізку), а після цього - пересчитывает значення суми в поточній вершині точно таким ж чином, як ми це делали при побудові дерева відрізків (тобто як сума значень по обом синам поточній вершини).

### Реалізація

Основной реализационный момент - це то, як **зберігати** дерево відрізків в пам'яті. В цілях простоти ми не будемо зберігати дерево в явному вигляді, а скористаємось таким трюком: скажімо, що корінь дерева має номер $1$, його сини - номера $2$ і $3$, їх сини - номера з $4$ по $7$, і так далі. Легко зрозуміти коректність наступного формули: якщо вершина має номер $i$, то нехай її лівий син - це вершина з номером $2i$, а правий - з номером $2i+1$.

Такий прийом значно упрощает програмування дерева відрізків, - тепер нам не потрібно зберігати в пам'яті структуру дерева відрізків, а тільки лише завести який-або масив для сум на кожному відрізку дерева відрізків.

Варто тільки відзначити, що розмір цього масиву при такий нумерації треба ставити не $2n$, а $4n$. Справа в тому, що така нумерация не идеально працює в випадку, коли $n$ не є степенем двійки - тоді з'являються пропущенные номера, яким не відповідають ніякі вершини дерева (фактично, нумерация веде собі подобно тому, як якщо б $n$ округлили б вгору до найближчій степені двійки). Це не создаёт ніяких складнощів при реалізації, однак призводить до тому, що розмір масиву треба збільшувати до $4n$.

Отже, дерево відрізків ми **зберігаємо** просто в вигляді масиву $t[]$, розміру вчетверо більше розміру $n$ вхідних данних:

<!--- TODO: specify code snippet id -->
``` cpp
int n, t[4*MAXN];
```

Процедура **побудови дерева відрізків** по заданому масиву $a[]$ виглядає наступним чином: це рекурсивна функція, їй передається сам масив $a[]$, номер $v$ поточній вершини дерева, і межі $tl$ і $tr$ відрузку, відповідного поточній вершині дерева. З основний програми викликати цю функцію випливає з параметрами $v=1$, $tl=0$, $tr=n-1$.

<!--- TODO: specify code snippet id -->
``` cpp
void build (int a[], int v, int tl, int tr) {
    if (tl == tr)
        t[v] = a[tl];
    else {
        int tm = (tl + tr) / 2;
        build (a, v*2, tl, tm);
        build (a, v*2+1, tm+1, tr);
        t[v] = t[v*2] + t[v*2+1];
    }
}
```

Далі, функція для **запиту суми** представляє з собі також рекурсивну функцію, якій таким ж чином передається інформація про поточній вершині дерева (тобто числа $v$, $tl$, $tr$, яким в основний програмі випливає передавати значення $1$, $0$, $n-1$ відповідно), а крім цього - також межі $l$ і $r$ поточного запиту. В цілях спрощення коду ця фукнция завжди робить по два рекурсивних виклику, навіть якщо насправді потрібен один - просто лишнему рекурсивному вызову передастся запит, у якого $l > r$, що легко отсекается додаткової перевіркою в самому початку функції.

<!--- TODO: specify code snippet id -->
``` cpp
int sum (int v, int tl, int tr, int l, int r) {
    if (l > r)
        return 0;
    if (l == tl && r == tr)
        return t[v];
    int tm = (tl + tr) / 2;
    return sum (v*2, tl, tm, l, min(r,tm))
        + sum (v*2+1, tm+1, tr, max(l,tm+1), r);
}
```

Нарешті, **запит модифікації**. Ему точно так ж передається інформація про поточній вершині дерева відрізків, а додатково указывается індекс меняющегося елементу, а також його нове значення.

<!--- TODO: specify code snippet id -->
``` cpp
void update (int v, int tl, int tr, int pos, int new_val) {
    if (tl == tr)
        t[v] = new_val;
    else {
        int tm = (tl + tr) / 2;
        if (pos <= tm)
            update (v*2, tl, tm, pos, new_val);
        else
            update (v*2+1, tm+1, tr, pos, new_val);
        t[v] = t[v*2] + t[v*2+1];
    }
}
```

Варто відзначити, що функцію $\rm update$ легко зробити нерекурсивною, оскільки рекурсія в ній хвостовая, тобто разветвлений ніколи не відбувається: один виклик можливо породить тільки один рекурсивний виклик. При нерекурсивною реалізації швидкість роботи можливо вырасти в декілька раз.

З інших **оптимизаций** варто упомянуть, що множення і ділення на два варто замінити бітовими операціями - це також трохи покращує продуктивність дерева відрізків.

## Усложнённые версії дерева відрізків

Дерево відрізків - дуже гибкая структура, і дозваляє робити обобщения у багатьох різних напрямках. Спробуємо нижче классифицировать їх.

### Більш складні функції і запити

Улучшения дерева відрізків в цим напрямку можуть бути як досить очевидными (як в випадку мінімуму/максимуму замість суми), так і вельми і вельми нетривиальными.

#### Пошук мінімуму/максимуму

Трохи змінимо умова задачі, описаної вище: замість запиту суми будемо виробляти тепер запит мінімуму/максимуму на відрізку.

Значить дерево відрізків для такий задачі практично нічим не відрізняється від дерева відрізків, описаного вище. Просто треба змінити спосіб обчислення $t[v]$ в функціях $\rm build$ і $\rm update$, а також обчислення возвращаемого відповіді в функції $\rm sum$ (замінити підсумовування на мінімум/максимум).

#### Пошук мінімуму/максимуму і кількості раз, яке він зустрічається

Задача аналогічна попередньою, тільки тепер крім максимуму потрібно також повертати кількість його входжень. Ця задача встаёт естественным чином, наприклад, при рішенні з допомогою дерева відрізків такий задачі: знайти кількість наидлиннейших зростаючих підпослідовностей в заданому масиві.

Для розв'язку цій задачі в кожної вершині дерева відрізків будемо зберігати пару чисел: крім максимуму кількість його входжень на відповідному відрізку. Значить при побудові дерева ми повинні просто по двом таким парам, полученным від синів поточній вершини, получать пару для поточній вершини.

Объединение двох таких пар в одну варто виділити в окрему функцію, оскільки цю операцію треба буде виробляти і в запиті модифікації, і в запиті пошуку максимуму.

<!--- TODO: specify code snippet id -->
``` cpp
pair<int,int> t[4*MAXN];

pair<int,int> combine (pair<int,int> a, pair<int,int> b) {
    if (a.first > b.first)
        return a;
    if (b.first > a.first)
        return b;
    return make_pair (a.first, a.second + b.second);
}

void build (int a[], int v, int tl, int tr) {
    if (tl == tr)
        t[v] = make_pair (a[tl], 1);
    else {
        int tm = (tl + tr) / 2;
        build (a, v*2, tl, tm);
        build (a, v*2+1, tm+1, tr);
        t[v] = combine (t[v*2], t[v*2+1]);
    }
}

pair<int,int> get_max (int v, int tl, int tr, int l, int r) {
    if (l > r)
        return make_pair (-INF, 0);
    if (l == tl && r == tr)
        return t[v];
    int tm = (tl + tr) / 2;
    return combine (
        get_max (v*2, tl, tm, l, min(r,tm)),
        get_max (v*2+1, tm+1, tr, max(l,tm+1), r)
    );
}

void update (int v, int tl, int tr, int pos, int new_val) {
    if (tl == tr)
        t[v] = make_pair (new_val, 1);
    else {
        int tm = (tl + tr) / 2;
        if (pos <= tm)
            update (v*2, tl, tm, pos, new_val);
        else
            update (v*2+1, tm+1, tr, pos, new_val);
        t[v] = combine (t[v*2], t[v*2+1]);
    }
}
```

#### Пошук найбільшого загального подільника / найменшого загального кратного

тобто. ми хочемо навчитися шукати НСД/НСК всіх чисел в заданому відрізку масиву.

Це досить интересное узагальнення дерева відрізків виходить абсолютно таким ж шляхом, як і дерева відрізків для суми/мінімуму/максимуму: достатньо просто зберігати в кожної вершині дерева НСД/НСК всіх чисел в відповідному відрізку масиву.

#### Підрахунок кількості нулів, пошук $k$-го нуля

В цій задачі ми хочемо навчитися відповідати на запит кількості нулів в заданому відрізку масиву, а також на запит знаходження $k$-го нульового елементу.

Знову трохи змінимо дані, хранящиеся в дереві відрізків: будемо зберігати тепер в масиві $t[]$ кількість нулів, зустрічаються в відповідних відрізках масиву. Зрозуміло, як підтримувати і використовувати ці дані в функціях $\rm build$, $\rm sum$, $\rm update$, - тим самим ми вирішили задачу про кількості нулів в заданому відрізку масиву.

Тепер навчимося розв'язувати задачу про пошуку позиції $k$-го входження нуля в масиві. Для цього будемо спускатися по дереву відрізків, починаючи з кореня, і переходячи кожний раз в лівого або правого сина в залежності від того, в якому з відрізків знаходиться шуканий $k$-ый нуль. Насправді, аби зрозуміти, в какого сина нам треба переходити, достатньо подивитися на значення, записанное в лівому сина: якщо воно більше або рівне $k$, то переходити треба в лівого сина (тому що в його відрізку є як мінімум $k$ нулів), а інакше - переходити в правого сина.

При реалізації можна отсечь випадок, коли $k$-го нуля не існує, ще при в ході в функцію, вернув в якості відповіді, наприклад, $-1$.

<!--- TODO: specify code snippet id -->
``` cpp
int find_kth (int v, int tl, int tr, int k) {
    if (k > t[v])
        return -1;
    if (tl == tr)
        return tl;
    int tm = (tl + tr) / 2;
    if (t[v*2] >= k)
        return find_kth (v*2, tl, tm, k);
    else
        return find_kth (v*2+1, tm+1, tr, k - t[v*2]);
}
```

#### Пошук префікса масиву з заданої сумою

Задача така: потрібно по даному значенням $x$ швидко знайти таке $i$, що сума перших $i$ елементів масиву $a[]$ більше або рівна $x$ (вважаючи, що масив $a[]$ містить тільки невід'ємні числа).

Цю задачу можна розв'язувати бінарним пошуком, вычисляя кожний раз всередині нього суму на тому або іншому префиксе масиву, але це приведе до розв'язку за час $O(\log^2 n)$.

Замість цього можна скористатися тією ж самою ідеєю, що і в попередньому пункті, і шукати шукану позицію одним спуском по дереву: переходячи кожний раз в лівого або правого сина в залежності від величини суми в лівому сина. Значить відповідь на запит пошуку буде представляти собою один такий спуск по дереву, а, отже, буде виконуватися за $O(\log n)$.

#### Пошук підвідрізку з максимальної сумою

За-прежнему на вхід даётся масив $a[0 \ldots n-1]$, і надходять запити $(l,r)$, які означают: знайти такий підвідрізок $a[l^\prime \ldots r^\prime]$, що $l \le l^\prime$, $r^\prime \le r$, і сума цього відрузку $a[l^\prime \ldots r^\prime]$ максимальна. Запросы модифікації окремих елементів масиву допускаються. Елементи масиву можуть бути негативними (і, наприклад, якщо всі числа отрицательны, то оптимальним подотрезком буде порожній - на ньому сума рівна нулю).

Це вельми нетривиальное узагальнення дерева відрізків виходить наступним чином. Будемо зберігати в кожної вершині дерева відрізків чотири величини: суму на цим відрізку, максимальну суму серед всіх префіксів цього відрузку, максимальну суму серед всіх суфіксів, а також максимальну суму підвідрізку на ньому. Іншими словами, для кожного відрузку дерева відрізків відповідь на ньому вже предпосчитан, а також додатково відповідь посчитан серед всіх відрізків, упирающихся в ліву кордон відрузку, а також серед всіх відрізків, упирающихся в праву кордон.

Як ж побудувати дерево відрізків з такими даними? Знову підійдемо до цьому з рекурсивної точки зору: нехай для поточній вершини всі чотири значення в лівому сина і в правом сина вже підраховані, порахуємо їх тепер для самою вершини. Зауважимо, що відповідь в самою вершині рівний:

* або відповіді в лівому сина, що означає, що кращий підвідрізок в поточній вершині цілком поміщається в відрізок лівого сина,
* або відповіді в правом сина, що означає, що кращий підвідрізок в поточній вершині цілком поміщається в відрізок правого сина,
* або сумі максимального суфікса в лівому сина і максимального префікса в правом сина, що означає, що кращий підвідрізок лежить своїм початком в лівому сина, а кінцем - в правом.

Значить, відповідь в поточній вершині рівний максимуму з цих трьох величин. Пересчитывать ж максимальну суму на префиксах і суффиксах ще простіше. Наведемо реалізацію функції $\rm combine$, якій будуть передаваться дві структури $\rm data$, містять в собі дані про лівому і правом синах, і яка повертає дані в поточній вершині.

<!--- TODO: specify code snippet id -->
``` cpp
struct data {
    int sum, pref, suff, ans;
};

data combine (data l, data r) {
    data res;
    res.sum = l.sum + r.sum;
    res.pref = max (l.pref, l.sum + r.pref);
    res.suff = max (r.suff, r.sum + l.suff);
    res.ans = max (max (l.ans, r.ans), l.suff + r.pref);
    return res;
}
```

Таким чином, ми навчилися будувати дерево відрізків. Звідси легко получити і реалізацію запиту модифікації: як і в самому простому дереві відрізків, ми виконуємо перерахунок значень у всіх изменившихся вершинах дерева відрізків, для чого використовуємо усе ту ж функцію $\rm combine$. Для обчислення значень дерева в листьях також допоміжну функцію $\rm make\_data$, яка повертає структуру $\rm data$, обчислену по одному числу $\rm val$.

<!--- TODO: specify code snippet id -->
``` cpp
data make_data (int val) {
    data res;
    res.sum = val;
    res.pref = res.suff = res.ans = max (0, val);
    return res;
}

void build (int a[], int v, int tl, int tr) {
    if (tl == tr)
        t[v] = make_data (a[tl]);
    else {
        int tm = (tl + tr) / 2;
        build (a, v*2, tl, tm);
        build (a, v*2+1, tm+1, tr);
        t[v] = combine (t[v*2], t[v*2+1]);
    }
}

void update (int v, int tl, int tr, int pos, int new_val) {
    if (tl == tr)
        t[v] = make_data (new_val);
    else {
        int tm = (tl + tr) / 2;
        if (pos <= tm)
            update (v*2, tl, tm, pos, new_val);
        else
            update (v*2+1, tm+1, tr, pos, new_val);
        t[v] = combine (t[v*2], t[v*2+1]);
    }
}
```

Залишилося разобраться з відповіддю на запит. Для цього ми так ж, як і раніше, спускаємося по дереву, разбивая тим самим відрізок запиту $[l \ldots r]$ на декілька підвідрізків, співпадаючих з відрізками дерева відрізків, і объединяем відповіді в них в единый відповідь на всю задачу. Значить зрозуміло, що робота нічим не відрізняється від роботи звичайного дерева відрізків, тільки треба замість простого підсумовування/мінімуму/максимуму значень використовувати функцію $\rm combine$. Наведена нижче реалізація трохи відрізняється від реалізації запиту $\rm sum$: вона не допускає випадків, коли ліва межа $l$ запиту перевищує праву кордон $r$ (інакше возникнут неприятные випадки - яку структуру $\rm data$ возврашать, коли відрізок запиту порожній?.)..

<!--- TODO: specify code snippet id -->
``` cpp
data query (int v, int tl, int tr, int l, int r) {
    if (l == tl && tr == r)
        return t[v];
    int tm = (tl + tr) / 2;
    if (r <= tm)
        return query (v*2, tl, tm, l, r);
    if (l > tm)
        return query (v*2+1, tm+1, tr, l, r);
    return combine (
        query (v*2, tl, tm, l, tm),
        query (v*2+1, tm+1, tr, tm+1, r)
    );
}
```

### Збереження всього підмасиву в кожної вершині дерева відрізків

Це окремий подраздел, стоящий особняком від інших, оскільки в кожної вершині дерева відрізків ми будемо зберігати не якусь стислу інформацію про цим підвідрізку (суму, мінімум, максимум і т.п)., а **всі** елементи масиву, що лежать в цим підвідрізку. Таким чином, корінь дерева відрізків буде зберігати всі елементи масиву, лівий син кореня - першу половину масиву, правий син кореня - одному половину, і так далі.

Самий простий різновид застосування цій техніки - коли в кожної вершині дерева відрізків зберігається відсортований список всіх чисел, зустрічаються в відповідному відрізку. В більш складних вариантах зберігаються не списки, а які-або структури данних, построенные над цими списками ($\rm set$, $\rm map$ і т.д).. Але всі ці методи об'єднує то, що в кожної вершині дерева відрізків зберігається якась структура данних, має в пам'яті розмір порядку довжини відповідного відрузку.

Перший естественный питання, встающий при розгляді дерев відрізків цього класу - це **об'єм використаної пам'яті**. Стверджується, що якщо в кожної вершині дерева відрізків зберігається список всіх зустрічаються на цим відрізку чисел, або будь-яка інша структура данних розміру того ж порядку, то в сумі усе дерево відрізків буде займати $O(n \log n)$ осередків пам'яті. Чому це так? Потому що кожне число $a[i]$ потрапляє в $O(\log n)$ відрізків дерева відрізків (хоча б тому, що висота дерева відрізків є $O(\log n)$).

Отже, незважаючи на кажущуюся расточительность такого дерева відрізків, він споживає пам'яті не сильно більше звичайного дерева відрізків.

Нижче описано декілька типичных застосувань такий структури данних. Варто зразу відзначити явну аналогію дерев відрізків цього типу з **двумерными структурами данних** (власне, в якому-то сенсі це і є двумерная структура данних, але з досить ограниченными возможностями).

#### Пошук найменшого числа, більше або рівного заданого, в зазначеному відрізку. Запросов модифікації ні

Потрібно відповідати на запити наступного увазі: $(l,r,x)$, що означає знайти мінімальне число в відрізку $a[l \ldots r]$, яке більше або рівне $x$.

**Побудуємо** дерево відрізків, в якому в кожної вершині будемо зберігати відсортований список всіх чисел, зустрічаються на відповідному відрізку. Наприклад, корінь буде містити масив $a[]$ в відсортованому вигляді. Як побудувати таке дерево відрізків максимально ефективно? Для цього підійдемо до задачі, як зазвичай, з точки зору рекурсії: нехай для лівого і правого синів поточній вершини ці списки вже построены, і нам потрібно побудувати цей список для поточній вершини. При такий постановці вопроса стає майже очевидно, що це можна зробити за лінійне час: нам просто треба об'єднати два відсортованих списку в один, що робиться одним проходом по ним з двома указателями. Пользователям C++ ще простіше, тому що цей алгоритм злиття вже включён в стандартну библиотеку STL:

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> t[4*MAXN];

void build (int a[], int v, int tl, int tr) {
    if (tl == tr)
        t[v] = vector<int> (1, a[tl]);
    else {
        int tm = (tl + tr) / 2;
        build (a, v*2, tl, tm);
        build (a, v*2+1, tm+1, tr);
        merge (t[v*2].begin(), t[v*2].end(), t[v*2+1].begin(), t[v*2+1].end(),
            back_inserter (t[v]));
    }
}
```

Ми вже знаємо, що построенное таким чином дерево відрізків буде займати $O(n \log n)$ пам'яті. А завдяки такий реалізації час його побудови також є величина $O(n \log n)$ - адже кожний список будується за лінійне щодо його розміру час. (До Речі кажучи, тут прослеживается очевидна аналогия з алгоритмом **сортування слиянием**: тільки тут ми зберігаємо інформацію зі всіх этапов роботи алгоритму, а не тільки підсумок).

Тепер розглянемо **відповідь на запит**. Будемо спускатися по дереву, як це робить стандартний відповідь на запит в дереві відрізків, разбивая наш відрізок $a[l \ldots r]$ на декілька підвідрізків (порядку $O(\log n)$ штук). Зрозуміло, що відповідь на всю задачу рівний мінімуму серед відповідей на кожному з цих підвідрізків. Поймём тепер, як відповідати на запит на одному такому підвідрізку, совпадающем з деякої вершиною дерева.

Отже, ми прийшли в якусь вершину дерева відрізків і хочемо порахувати відповідь на ній, тобто знайти мінімальне число, більше або рівне даного $x$. Для цього нам всього лише треба виконати **бінарний пошук** по списку, посчитанному в цій вершині дерева, і повернути перший число з цього списку, більше або рівне $x$.

Таким чином, відповідь на запит в одному підвідрізку відбувається за $O(\log n)$, а весь запит обробляється за час $O(\log^2 n)$.

<!--- TODO: specify code snippet id -->
``` cpp
int query (int v, int tl, int tr, int l, int r, int x) {
    if (l > r)
        return INF;
    if (l == tl && tr == r) {
        vector<int>::iterator pos = lower_bound (t[v].begin(), t[v].end(), x);
        if (pos != t[v].end())
            return *pos;
        return INF;
    }
    int tm = (tl + tr) / 2;
    return min (
        query (v*2, tl, tm, l, min(r,tm), x),
        query (v*2+1, tm+1, tr, max(l,tm+1), r, x)
    );
}
```

Константа $\rm INF$ рівна деякого большому числу, свідомо большему, ніж будь-яке число в масиві. Вона несёт сенс "відповіді в заданому відрізку не існує".

#### Пошук найменшого числа, більше або рівного заданого, в зазначеному відрізку. Допускаются запити модифікації

Задача аналогічна попередньою, тільки тепер дозволені запити модифікації: обробити привласнення $a[i] = y$.

Розв'язок також аналогічно розв'язку попередньою задачі, тільки замість простих списків в кожної вершині дерева відрізків ми будемо зберігати сбалансированный список, який дозваляє швидко шукати необхідну число, видаляти його, а також вставлять нове число. Враховуючи, що взагалі кажучи число у вхідному масиві можуть повторяться, оптимальним вибором є структура данних STL $\rm multiset$.

**Побудова** такого дерева відрізків відбувається приблизно так ж, як і в попередньою задачі, тільки тепер треба об'єднувати не отсортированные списки, а $\rm multiset$, що приведе до тому, що асимптотика побудови ухудшится до $n \log^2 n$ (хоча, мабуть, красно-чёрные дерева дозволяють виконати злиття двох дерев за лінійне час, однак библиотека STL цього не гарантирует).

Відповідь на **запит пошуку** взагалі практично еквівалентний приведённому вище коду, тільки тепер $\rm lower\_bound$ треба викликати від $t[v]$.

Нарешті, **запит модифікації**. Для його обробки ми повинні спуститься по дереву, внеся зміни у всі $O(\log n)$ списків, містять затрагиваемый елемент. Ми просто видаляємо старе значення цього елементу (не забыв, що нам не треба вилучити разом з ним всі повтори цього числа) і вставляємо його нове значення.

<!--- TODO: specify code snippet id -->
``` cpp
void update (int v, int tl, int tr, int pos, int new_val) {
    t[v].erase (t[v].find (a[pos]));
    t[v].insert (new_val);
    if (tl != tr) {
        int tm = (tl + tr) / 2;
        if (pos <= tm)
            update (v*2, tl, tm, pos, new_val);
        else
            update (v*2+1, tm+1, tr, pos, new_val);
    }
    else
        a[pos] = new_val;
}
```

Обработка цього запиту відбувається також за час $O(\log^2 n)$.

#### Пошук найменшого числа, більше або рівного заданого, в зазначеному відрізку. Ускорение з допомогою техніки "часткового каскадування"

Улучшим час відповіді на запит пошуку до часу $O(\log n)$ з допомогою застосування техніки **"часткового каскадування"** ("fractional cascading").

Частичное каскадирование - це простий прийом, який дозваляє покращити час роботи декількох бінарних пошуків, ведущихся по одному і тому ж значенням. Насправді, відповідь на запит пошуку полягає в тому, що ми розбиваємо нашу задачу на декілька подзадач, кожна з яких потім вирішується бінарним пошуком по числу $x$. Частичное каскадирование дозваляє замінити всі ці двоичные поиски на один.

Простейшим і самим наглядным прикладом часткового каскадування є **наступна задача**: є декілька відсортованих списків чисел, і ми повинні в кожному списку знайти перший число, більше або рівне заданого.

Якщо б ми вирішували задачу "в лоб", то змушені були б запустити бінарний пошук по кожному з цих списків, що, якщо цих списків багато, стає вельми существенным фактором: якщо всього списків $k$, то асимптотика вийде $O(k \log(n/k))$, де $n$ - сумарний розмір всіх списків (асимптотика така, тому що худший випадок - коли всі списки приблизно рівні один одному по довжині, тобто рівні $n/k$).

Замість цього, ми могли б об'єднати всі ці списки в один відсортований список, в якому для кожного числа $n_i$ будемо зберігати список позицій: позицію в першому списку першого числа, більше або рівного $n_i$, аналогичную позицію у іншому списку, і так далі. Іншими словами, для кожного встречающегося числа ми зберігаємо разом з цим числом результати двоичных пошуків по нього в кожному з списків. В такому випадку асимптотика відповіді на запит виходить $O(\log n + k)$, що істотно краще, однак ми змушені расплачиваться великим потреблением пам'яті: а саме, нам потрібно $O(nk)$ осередків пам'яті.

Техника часткового каскадування йде далі в рішенні цій задачі і добивается споживання пам'яті $O(n)$ при тому ж самому часу відповіді на запит $O(\log n + k)$. (Для цього ми зберігаємо не один великий список довжини $n$, а знову возвращаемся до $k$ списками, але разом з кожним списком зберігаємо кожний другий елемент з наступного списку; нам знову доведеться разом з кожним числом записувати його позицію в обох списках (поточному і наступному), однак це дозволить як і раніше ефективно відповідати на запит: ми робимо двійковий пошук по першого списку, а потім йдемо по цим списками по порядку, переходячи кожний раз в наступного список з допомогою предпосчитанных покажчиків, і роблячи один крок вліво, враховуючи тим самим, що половина чисел наступного списку учтена не була).

Але нам в нашому приложении до дереву відрізків **не потрібна** повна мощь цій техніки. Справа в тому, що список в поточній вершині містить всі числа, які можуть зустрічатися в лівому і правом синах. Тому, аби уникнути бінарного пошуку по списку сина, нам достатньо для кожного списку в дереві відрізків порахувати для кожного числа його позиції в списках лівого і правого синів (точніше, позиції першого числа, меншого або рівного поточному).

Таким чином, замість звичайного списку всіх чисел ми зберігаємо список трійок: саме число, позиція в списку лівого сина, позиція в списку правого сина. Це дозволить нам за $O(1)$ визначати позицію в списку лівого або правого сина, замість того аби робити двійковий список по нього.

Простіше всього цю технику застосовувати до задачі, коли запити модифікації відсутні, - тоді ці позиції являють собою просто числа, а підраховувати їх при побудові дерева дуже легко всередині алгоритму злиття двох відсортованих послідовностей.

В випадку, коли дозволені запити модифікації, усе декілька усложняется: ці позиції тепер треба зберігати в вигляді итераторов всередині $\rm multiset$, а при запиті поновлення - правильно зменшувати/збільшувати для тих елементів, для яких це потрібно.

Так або інакше, задача вже зводиться до чисто реализационным тонкостям, а основна ідея - заміна $O(\log n)$ бінарних пошуків одним бінарним пошуком по списку в корені дерева - описана повністю.

#### Інші можливі напрямку

Зауважимо, що ця техника подразумевает під собою цілий клас можливих додатків - усе визначається структурою данних, обраної для зберігання в кожної вершині дерева. Вище були розглянуті приложения з використанням $\rm vector$ і $\rm multiset$, в то час як взагалі використовуватися можливо будь-яка інша компактная структура данних: інше дерево відрізків (про цим трохи сказано нижче в розділі про многомерных деревьях відрізків), [дерево Фенвіка](fenwick_tree), [декартове дерево](treap) і т.д.

### Обновление на відрізку

Вище рассматривались тільки задачі, коли запит модифікації затрагивает єдиний елемент масиву. Насправді, дерево відрізків дозваляє робити запити, які застосовуються до цілим відрізках поспіль идущих елементів, причому виконувати ці запити за то ж час $O(\log n)$.

#### Додаток на відрізку

Почнемо розгляд дерев відрізків такого рода з самого простого випадку: запит модифікації представляє собою додаток до всім числах на деякому підвідрізку $a[l \ldots r]$ деякого числа $x$. Запит читання - як і раніше зчитування значення деякого числа $a[i]$.

Щоб робити запит додавання ефективно, будемо зберігати в кожної вершині дерева відрізків, скільки треба додати до всім числах цього відрузку цілком. Наприклад, якщо приходить запит "додати до всьому масиву $a[0 \ldots n-1]$ число 2", то ми поставимо в корені дерева число $2$. Тим самим ми зможемо обробляти запит додавання на будь-якому підвідрізку ефективно, замість того аби змінювати всі $O(n)$ значень.

Якщо тепер приходить запит читання значення того або іншого числа, то нам достатньо спуститься по дереву, просуммировав всі встреченные по шляхи значення, записані в вершинах дерева.

<!--- TODO: specify code snippet id -->
``` cpp
void build (int a[], int v, int tl, int tr) {
    if (tl == tr)
        t[v] = a[tl];
    else {
        int tm = (tl + tr) / 2;
        build (a, v*2, tl, tm);
        build (a, v*2+1, tm+1, tr);
    }
}

void update (int v, int tl, int tr, int l, int r, int add) {
    if (l > r)
        return;
    if (l == tl && tr == r)
        t[v] += add;
    else {
        int tm = (tl + tr) / 2;
        update (v*2, tl, tm, l, min(r,tm), add);
        update (v*2+1, tm+1, tr, max(l,tm+1), r, add);
    }
}

int get (int v, int tl, int tr, int pos) {
    if (tl == tr)
        return t[v];
    int tm = (tl + tr) / 2;
    if (pos <= tm)
        return t[v] + get (v*2, tl, tm, pos);
    else
        return t[v] + get (v*2+1, tm+1, tr, pos);
}
```

#### Присвоение на відрізку

Нехай тепер запит модифікації представляє собою привласнення всім елементам деякого відрузку $a[l \ldots r]$ деякого значення $p$. В якості іншого запиту будемо розглядати зчитування значення масиву $a[i]$.

Щоб робити модифікацію на цілому відрізку, доведеться в кожної вершині дерева відрізків зберігати, пофарбований або цей відрізок цілком в яке-або число або ні (і якщо пофарбований, то зберігати саме це число). Це дозволить нам робити **"запаздывающее" оновлення** дерева відрізків: при запиті модифікації ми, замість того аби змінювати значення у множині вершин дерева відрізків, поменяем тільки деякі з них, оставив флаги "пофарбований" для інших відрізків, що означає, що весь цей відрізок разом зі своїми подотрезками повинен бути пофарбований в цей колір.

Отже, після виконання запиту модифікації дерево відрізків стає, взагалі кажучи, неактуальным - в ньому залишилися недовыполненными деякі модифікації.

Наприклад, якщо прийшов запит модифікації "присвоїти всьому масиву $a[0 \ldots n-1]$ якесь число", то в дереві відрізків ми зробимо єдине зміна - пометим корінь дерева, що він пофарбований цілком в це число. Остальные ж вершини дерева залишаться неизменёнными, хоча насправді усе дерево має бути пофарбовано в одне і то ж число.

Припустимо тепер, що в тому ж дереві відрізків прийшов другий запит модифікації - пофарбувати першу половину масиву $a[0 \ldots n/2]$ в яке-або інше число. Щоб обробити такий запит, ми повинні пофарбувати цілком лівого сина кореня в цей новий колір, однак перед тим як зробити це, ми повинні разобраться з коренем дерева. Тонкость тут в тому, що в дереві має сохраниться, що права половина пофарбована в старий колір, а в даний момент в дереві ніякий інформації для правою половини не сохранено.

Выход такий: провести **проштовхування** інформації з кореня, тобто якщо корінь дерева був пофарбований в яке-або число, то пофарбувати в це число його правого і лівого сина, а з кореня цю отметку убрать. Після цього ми можемо спокойно красить лівого сина кореня, не втрачаючи ніякий потрібної інформації.

Обобщая, отримуємо: при будь-яких запросах з таким деревом (запит модифікації або читання) у час спуска по дереву ми завжди повинні робити проштовхування інформації з поточній вершини в обох її синів. Можна розуміти це так, що при спуске по дереву ми застосовуємо запаздывающие модифікації, але рівне настільки, наскільки це необхідно (аби не ухудшить асимптотику з $O(\log n)$).

При реалізації це означає, що нам треба зробити функцію $\rm push$, якій буде передаваться вершина дерева відрізків, і вона буде виробляти проштовхування інформації з цій вершини в обох її синів. Вызывать цю функцію випливає в самому початку функцій обробки запитів (але не викликати її з листя, адже з листа проталкивать інформацію не треба, да і некуда).

<!--- TODO: specify code snippet id -->
``` cpp
void push (int v) {
    if (t[v] != -1) {
        t[v*2] = t[v*2+1] = t[v];
        t[v] = -1;
    }
}

void update (int v, int tl, int tr, int l, int r, int color) {
    if (l > r)
        return;
    if (l == tl && tr == r)
        t[v] = color;
    else {
        push (v);
        int tm = (tl + tr) / 2;
        update (v*2, tl, tm, l, min(r,tm), color);
        update (v*2+1, tm+1, tr, max(l,tm+1), r, color);
    }
}

int get (int v, int tl, int tr, int pos) {
    if (tl == tr)
        return t[v];
    push (v);
    int tm = (tl + tr) / 2;
    if (pos <= tm)
        return get (v*2, tl, tm, pos);
    else
        return get (v*2+1, tm+1, tr, pos);
}
```

Функцию $\rm get$ можна було б реалізувати і по-іншому: не робити в ній запаздывающих обновлений, а зразу повертати відповідь, як тільки вона потрапляє в вершину дерева відрізків, цілком покрашенную в той або інший колір.

#### Додаток на відрізку, запит максимуму

Нехай тепер запитом модифікації знову буде запит додавання до всім числах деякого підвідрізку одного і того ж числа, а запитом читання буде знаходження максимуму в деякому підвідрізку.

Значить в кожної вершині дерева відрізків треба буде додатково зберігати максимум на усьому цим підвідрізку. Але тонкість тут полягає в тому, як треба перераховувати ці значення.

Наприклад, нехай произошёл запит "додати до всій першо] половині, тобто $a[0 \ldots n/2]$, число 2". Значить в дереві це отразится записью числа $2$ в лівого сина кореня. Як тепер порахувати нове значення максимуму в лівому сина і в корені? Тут стає важливо не запутаться - який максимум зберігається в вершині дерева: максимум без обліку додавання на всій цій вершині, або ж з урахуванням його. Выбрать можна будь-який з цих подходов, але головне - послідовно використовувати його всюди. Наприклад, при першому підході максимум в корені буде виходити як максимум з двох чисел: максимум в лівому сина плюс додаток в лівому сина, і максимум в правом сина плюс додаток в ньому. При іншому ж підході максимум в корені буде виходити як додаток в корені плюс максимум з максимумов в лівому і правом синах.

#### Інші напрямку

Тут були розглянуті тільки базовые застосування дерев відрізків в завданнях з модификациями на відрізку. Остальные задачі виходять на основі тих ж самих ідей, що описані тут.

Важно тільки бути дуже акуратним при роботі з отложенными модификациями: випливає пам'ятати, що навіть якщо в поточній вершині ми вже "протолкнули" отложенную модифікацію, то в лівому і правом синах, швидше всього, цього ще не сделали. Тому часто необходимым є викликати $\rm push$ також від лівого і правого синів поточній вершини, або ж акуратно враховувати отложенные модифікації в них.

### Узагальнення на великі розмірності

Дерево відрізків узагальнюється цілком естественным чином на двумерный і взагалі багатовимірний випадок. Якщо в одномерном випадку ми разбивали індекси масиву на відрізки, то в двовимірному випадку тепер будемо спочатку розбивати усе по першим індексам, а для кожного відрузку по першим індексам - будувати звичайне дерево відрізків по іншим індексам. Таким чином, основна ідея розв'язку - це вкладывание дерев відрізків по іншим індексам всередину дерева відрізків по першим індексам.

Поясним цю ідею на прикладі конкретної задачі.

#### Двумерное дерево відрізків в простейшем варіанті

Дана прямокутна матриця $a[0 \ldots n-1, 0 \ldots m-1]$, і надходять запити пошуку суми (або мінімуму/максимуму) на деяких подпрямоугольниках $a[x_1 \ldots x_2, y_1 \ldots y_2]$, а також запити модифікації окремих елементів матриці (тобто запити увазі $a[x][y] = p$).

Отже, будемо будувати двовимірне дерево відрізків: спочатку дерево відрізків по першо] координаті ($x$), потім - по другий ($y$).

Щоб **процес побудови** був більш зрозумілий, можна на час забути, що исходный масив був двумерным, і залишити тільки першу координату. Будемо будувати звичайне одномерное дерево відрізків, работая тільки з першо] координатою. Але в якості значення кожного відрузку ми будемо записувати не якесь число, як в одномерном випадку, а ціле дерево відрізків: тобто в цей момент ми вспоминаем, що у нас є ще і друга координата; але т.до. в цей момент вже зафіксовано, що перша координата є деякий відрізок $[l \ldots r]$, то ми фактично працюємо з такий полосой $a[l \ldots r, 0 \ldots m-1]$, і для її будуємо дерево відрізків.

Наведемо реалізацію операції побудови двовимірного дерева. Вона фактично представляє собою два окремих блоку: побудова дерева відрізків по координаті $x$ ($\rm build\_x$) і по координаті $y$ ($\rm build\_y$). Якщо перша функція майже нічим не відрізняється від звичайного одновимірного дерева, то друга вынуждена разбираться окремо з двома случаями: коли поточний відрізок по першо] координаті ($[tlx \ldots trx]$) має единичную довжину, і коли - довжину, велику одиниці. В першому випадку ми просто беремо потрібне значення з матриці $a[][]$, а у іншому - объединяем значення двох дерев відрізків з лівого сина і правого сина по координаті $x$.

<!--- TODO: specify code snippet id -->
``` cpp
void build_y (int vx, int lx, int rx, int vy, int ly, int ry) {
    if (ly == ry)
        if (lx == rx)
            t[vx][vy] = a[lx][ly];
        else
            t[vx][vy] = t[vx*2][vy] + t[vx*2+1][vy];
    else {
        int my = (ly + ry) / 2;
        build_y (vx, lx, rx, vy*2, ly, my);
        build_y (vx, lx, rx, vy*2+1, my+1, ry);
        t[vx][vy] = t[vx][vy*2] + t[vx][vy*2+1];
    }
}

void build_x (int vx, int lx, int rx) {
    if (lx != rx) {
        int mx = (lx + rx) / 2;
        build_x (vx*2, lx, mx);
        build_x (vx*2+1, mx+1, rx);
    }
    build_y (vx, lx, rx, 1, 0, m-1);
}
```

Таке дерево відрізків занимает як і раніше лінійний об'єм пам'яті, але вже з більшої константою: $16 n m$ осередків пам'яті. Зрозуміло, що будується воно описаної вище процедурою $\rm build\_x$ теж за лінійне час.

Перейдем тепер до **обробці запитів**. Отвечать на двумерный запит будемо по тому ж самому принципом: спочатку розбивати запит по першо] координаті, а потім, коли ми дійшли до якийсь вершини дерева відрізків по першо] координаті - викликати запит від відповідного дерева відрізків по другий координаті.

<!--- TODO: specify code snippet id -->
``` cpp
int sum_y (int vx, int vy, int tly, int try_, int ly, int ry) {
    if (ly > ry)
        return 0;
    if (ly == tly && try_ == ry)
        return t[vx][vy];
    int tmy = (tly + try_) / 2;
    return sum_y (vx, vy*2, tly, tmy, ly, min(ry,tmy))
        + sum_y (vx, vy*2+1, tmy+1, try_, max(ly,tmy+1), ry);
}

int sum_x (int vx, int tlx, int trx, int lx, int rx, int ly, int ry) {
    if (lx > rx)
        return 0;
    if (lx == tlx && trx == rx)
        return sum_y (vx, 1, 0, m-1, ly, ry);
    int tmx = (tlx + trx) / 2;
    return sum_x (vx*2, tlx, tmx, lx, min(rx,tmx), ly, ry)
        + sum_x (vx*2+1, tmx+1, trx, max(lx,tmx+1), rx, ly, ry);
}
```

Ця функція працює за час $O(\log n \log m)$, оскільки вона спочатку спускается по дереву по першо] координаті, а для кожної пройденной вершини цього дерева - робить запит у звичайного дерева відрізків по другий координаті.

Нарешті, розглянемо **запит модифікації**. Ми хочемо навчитися модифікувати дерево відрізків в відповідно з зміною значення какого-або елементу $a[x][y] = p$. Зрозуміло, що зміни произойдут тільки в тих вершинах першого дерева відрізків, які накрывают координату $x$ (а таких буде $O(\log n)$), а для дерев відрізків, відповідних їм - зміни будуть тільки в тих вершинах, які накрывают координату $y$ (і таких буде $O(\log m)$). Тому реалізація запиту модифікації не буде сильно відрізнятися від одновимірного випадку, тільки тепер ми спочатку спускаємося по першо] координаті, а потім - по другий.

<!--- TODO: specify code snippet id -->
``` cpp
void update_y (int vx, int lx, int rx, int vy, int ly, int ry, int x, int y, int new_val) {
    if (ly == ry) {
        if (lx == rx)
            t[vx][vy] = new_val;
        else
            t[vx][vy] = t[vx*2][vy] + t[vx*2+1][vy];
    }
    else {
        int my = (ly + ry) / 2;
        if (y <= my)
            update_y (vx, lx, rx, vy*2, ly, my, x, y, new_val);
        else
            update_y (vx, lx, rx, vy*2+1, my+1, ry, x, y, new_val);
        t[vx][vy] = t[vx][vy*2] + t[vx][vy*2+1];
    }
}

void update_x (int vx, int lx, int rx, int x, int y, int new_val) {
    if (lx != rx) {
        int mx = (lx + rx) / 2;
        if (x <= mx)
            update_x (vx*2, lx, mx, x, y, new_val);
        else
            update_x (vx*2+1, mx+1, rx, x, y, new_val);
    }
    update_y (vx, lx, rx, 1, 0, m-1, x, y, new_val);
}
```

#### Стиснення двовимірного дерева відрізків

Нехай задача наступна: є $n$ точок на площині, заданих своїми координатами $(x_i,y_i)$, і надходять запити увазі "порахувати кількість точок, лежачих в прямокутнику $((x_1,y_1),(x_2,y_2))$". Зрозуміло, що в випадку такий задачі стає невиправдано расточительным будувати двовимірне дерево відрізків з $O(n^2)$ елементами. Большая частина цій пам'яті буде потрачена впустую, оскільки кожна окремо взята точка можливо потрапити тільки в $O(\log n)$ відрізків дерева відрізків по першо] координаті, а, значить, сумарний "полезный" розмір всіх дерев відрізків по другий координаті є величина $O(n \log n)$.

Значить вчинимо наступним чином: в кожної вершині дерева відрізків по першо] координаті будемо зберігати дерево відрізків, построенное тільки по тим іншим координатам, які зустрічаються в поточному відрізку перших координат. Іншими словами, при побудові дерева відрізків всередині якийсь вершини з номером $vx$ і кордонами $tlx, trx$ ми будемо розглядати тільки ті точки, які попадают в цей відрізок $x \in [tlx; trx]$, і будувати дерево відрізків тільки над ними.

Тим самим ми доб'ємося того, що кожне дерево відрізків по другий координаті буде займати рівне стільки пам'яті, скільки і має. В результаті сумарний **об'єм пам'яті** зменшиться до $O(n \log n)$. **Отвечать на запит** ми будемо як і раніше за $O(\log^2 n)$, просто тепер при виклику запиту від дерева відрізків по другий координаті ми повинні будемо зробити бінарний пошук по другий координаті, але асимптотику це не ухудшит.

Але расплатой стане невозможность робити довільний **запит модифікації**: насправді, якщо з'явиться нова точка, то це приведе до тому, що ми повинні будемо в якому-або дереві відрізків по другий координаті додати новий елемент в середину, що ефективно зробити неможливо.

В завершення відзначимо, що стислий описаним чином двовимірне дерево відрізків стає практично **еквівалентним** описаної вище модифікації одновимірного дерева відрізків (див. "Збереження всього підмасиву в кожної вершині дерева відрізків"). В зокрема, виходить, що описываемое тут двовимірне дерево відрізків - це просто приватний випадок збереження підмасиву в кожної вершині дерева, де подмассив сам зберігається в вигляді дерева відрізків. Звідси випливає, що якщо доводиться отказываться від двовимірного дерева відрізків по причини невозможности виконання того або іншого запиту, то має сенс спробувати замінити вложенное дерево відрізків на яку-або більш мощную структуру данних, наприклад, [декартове дерево](treap).

### Дерево відрізків з сохранением истории його значень (поліпшення до persistent-структури данних)

Persistent-структурою данних називається така структура данних, яка при кожної модифікації запоминает своє попереднє стан. Це дозваляє при необхідності обратиться до будь-який интересующей нас версії цій структури данних і виконати запит на ній.

Дерево відрізків є однієї з тих структур данних, яка можливо бути превращена в persistent-структуру данних (звісно, ми розглядаємо эффективную persistent-структуру, а не таку, яка копирует всю собі цілком перед кожним обновлением).

Насправді, будь-який запит зміни в дереві відрізків призводить до изменению данних в $O(\log n)$ вершинах, причому уздовж шляхи, начинающегося з кореня. Значить, якщо ми будемо зберігати дерево відрізків на указателях (тобто вказівники на лівого і правого синів зробити указателями, хранящимися в вершині), то при запиті поновлення ми повинні просто замість зміни наявних вершин створити нові вершини, посилання з яких направлять на старі вершини. Тим самим, при запиті поновлення буде создано $O(\log n)$ нових вершин, в тому числі буде создан новий корінь дерева відрізків, а вся предыдующая версія дерева, подвешенная за старий корінь, залишиться без змін.

Наведемо приклад реалізації для простейшего дерева відрізків: коли є тільки запит підрахунку суми на підвідрізку і запит модифікації єдиного числа.

<!--- TODO: specify code snippet id -->
``` cpp
struct vertex {
    vertex * l, * r;
    int sum;

    vertex (int val)
        : l(NULL), r(NULL), sum(val)
    { }

    vertex (vertex * l, vertex * r)
        : l(l), r(r), sum(0)
    {
        if (l)  sum += l->sum;
        if (r)  sum += r->sum;
    }
};

vertex * build (int a[], int tl, int tr) {
    if (tl == tr)
        return new vertex (a[tl]);
    int tm = (tl + tr) / 2;
    return new vertex (
        build (a, tl, tm),
        build (a, tm+1, tr)
    );
}

int get_sum (vertex * t, int tl, int tr, int l, int r) {
    if (l > r)
        return 0;
    if (l == tl && tr == r)
        return t->sum;
    int tm = (tl + tr) / 2;
    return get_sum (t->l, tl, tm, l, min(r,tm))
        + get_sum (t->r, tm+1, tr, max(l,tm+1), r);
}

vertex * update (vertex * t, int tl, int tr, int pos, int new_val) {
    if (tl == tr)
        return new vertex (new_val);
    int tm = (tl + tr) / 2;
    if (pos <= tm)
        return new vertex (
                update (t->l, tl, tm, pos, new_val),
                t->r
            );
    else
        return new vertex (
                t->l,
                update (t->r, tm+1, tr, pos, new_val)
            );
}
```

З допомогою цього подхода можна перетворити в persistent-структуру данних практично будь-яке дерево відрізків.
