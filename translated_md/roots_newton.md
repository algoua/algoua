# Метод Ньютона (дотичних) для пошуку коренів

Це итерационный метод, изобретённый **Исааком Ньютоном** (Isaak Newton) близько 1664 р. Втім, іноді цей метод називають методом Ньютона-Рафсона (Raphson), оскільки Рафсон винайшов той ж самий алгоритм на декілька років пізніше Ньютона, однак його стаття була опубликована набагато раніше.

Задача полягає в наступному. Дано рівняння:

$$
f(x) = 0.
$$

Потрібно розв'язати це рівняння, точніше, знайти один з його коренів (передбачається, що корінь існує). Передбачається, що $f(x)$ непрерывна і дифференцируема на відрізку $[a;b]$.

## Алгоритм

Входным параметром алгоритму, крім функції $f(x)$, є також **початкова наближення** - деякий $x_0$, від якого алгоритм починає йти.

Нехай вже обчислено $x_i$, вычислим $x_{i+1}$ наступним чином. Проведемо касательную до графику функції $f(x)$ в точці $x = x_i$, і найдемо точку перетину цій касательной з осью абсцисс. $x_{i+1}$ покладемо рівним найденной точці, і повторимо весь процес з початку.

Неважко получити наступну формулу:

$$
x_{i+1} = x_i - \frac{ f(x_i) }{ f^\prime(x_i) }.
$$

Інтуїтивно ясно, що якщо функція $f(x)$ достатньо "хороша" (гладкая), а $x_i$ знаходиться достатньо близко від кореня, то $x_{i+1}$ буде перебувати ще ближче до искомому корені.

Скорость збіжності є **квадратичной**, що, условно кажучи, означає, що число точных розрядів в приближенном значенні $x_i$ удваивается з кожної ітерацією.

## Застосування для обчислення квадратного кореня

Розглянемо метод Ньютона на прикладі обчислення квадратного кореня.

Якщо підставити $f(x) = \sqrt{x}$, то після спрощення вираження отримуємо:

$$
x_{i+1} = \frac{ x_i + \frac{n}{x_i} }{ 2 }.
$$

Перший типичный різновид задачі - коли дано дробове число $n$, і потрібно подсчитать його корінь з деякої точністю $\rm EPS$:

<!--- TODO: specify code snippet id -->
``` cpp
double n;
cin >> n;
const double EPS = 1E-15;
double x = 1;
for (;;) {
    double nx = (x + n / x) / 2;
    if (abs (x - nx) < EPS)  break;
    x = nx;
}
printf ("%.15lf", x);
```

Інший распространённый різновид задачі - коли потрібно порахувати целочисленный корінь (для даного $n$ знайти найбільше $x$ таке, що $x^2 \le n$). Тут доводиться трохи змінювати умова останова алгоритму, оскільки можливо случиться, що $x$ начнёт "скакать" возле відповіді. Тому ми додаємо умова, що якщо значення $x$ на попередньому кроці уменьшилось, а на поточному кроці намагається збільшитися, то алгоритм треба зупинити.

<!--- TODO: specify code snippet id -->
``` cpp
int n;
cin >> n;
int x = 1;
bool decreased = false;
for (;;) {
    int nx = (x + n / x) >> 1;
    if (x == nx || nx > x && decreased)  break;
    decreased = nx < x;
    x = nx;
}
cout << x;
```

Нарешті, наведемо ще третий різновид - для випадку довгою арифметики. Оскільки число $n$ можливо бути достатньо великим, то має сенс звернути увага на початкова наближення. Очевидно, що ніж воно ближче до корені, тим швидше буде досягнутий результат. Досить простим і ефективним буде брати в якості початкового наближення число $2^{{\rm bits}/2}$, де $\rm bits$ - кількість бітів в числі $n$. Ось код на мові Java, демонстрирующий цей різновид:

<!--- TODO: specify code snippet id -->
``` cpp
BigInteger n; // вхідні дані

BigInteger a = BigInteger.ONE.shiftLeft (n.bitLength() / 2);
boolean p_dec = false;
for (;;) {
    BigInteger b = n.divide(a).add(a).shiftRight(1);
    if (a.compareTo(b) == 0 || a.compareTo(b) < 0 && p_dec)  break;
    p_dec = a.compareTo(b) > 0;
    a = b;
}
```

Наприклад, цей різновид коду виконується для числа $10^{1000}$ за $60$ миллисекунд, а якщо убрать улучшенный вибір початкового наближення (просто начинать з $1$), то буде виконуватися приблизно $120$ миллисекунд.
