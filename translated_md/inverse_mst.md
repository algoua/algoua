# Зворотня задача MST (inverse-MST - зворотна задача мінімального острови) за O (N M<sup>2</sup>)

Дан зважений неорієнтований граф G з N вершинами і M ребрами (без петель і кратних ребер). Відомо, що граф зв'язний. Також вказано деякий каркас T цього графа (тобто вибрано N-1 ребро, які утворюють дерево з N вершинами). Потрібно змінити ваги ребер таким чином, аби зазначений каркас T являлся мінімальним каркасом цього графа (точніше кажучи, одним з мінімальних кістяків), причому зробити це так, аби сумарне зміна всіх ваг було найменшим.

## Розв'язок

**Сведём** задачу inverse-MST до задачі min-cost-flow, точніше, **до задачі, двоїстої min-cost-flow** (в сенсі двойственности задач лінійного програмування); потім вирішимо останню задачу.

Отже, нехай дано граф G з N вершинами, M ребрами. Вес кожного ребра позначимо через C<sub>i</sub>. Припустимо, не втрачаючи спільності, що ребра з номерами з 1 по N-1 є ребрами T.

### 1. Необходимое і достатню умова MST

Нехай дано деякий каркас S (не обов'язково мінімальний).

Введемо спочатку одне позначення. Розглянемо деякий ребро j, не принадлежащее S. Очевидно, в графі S є єдиний шлях, з'єднує кінці цього ребра, тобто єдиний шлях, з'єднує кінці ребра j і состоящий тільки з ребер, що належать S. **Позначимо через P[j]** множину ребер, утворюють цей шлях для j-го ребра.

Для того, аби деякий каркас S являлся мінімальним, **необхідно і достатньо**, аби:

$$
C<sub>i</sub> <= C<sub>j</sub> для всіх j &notin; S і кожного i &isin; P[j]
$$

Можна замітити, що, оскільки **в нашій задачі** каркасу T належать ребра 1..N-1, то ми можемо записати це умова таким чином:

$$
C<sub>i</sub> <= C<sub>j</sub> для всіх j = N..M і кожного i &isin; P[j]
(причому всі i лежати в діапазоні 1..N-1)
$$

### 2. Граф шляхів

Понятие графа шляхів безпосередньо пов'язане з попередньою теоремою.

Нехай дано деякий каркас S (не обов'язково мінімальний).

Значить **графом шляхів H** для графа G буде наступного граф:

* Він містить M вершин, кожна вершина в H взаємно однозначно відповідає деякого ребру в G.
* Граф H дводольний. В першо] його частці знаходяться вершини i, які відповідають ребрам в G, принадлежащим каркасу S. Відповідно, у другий частці знаходяться вершини j, які відповідають ребрам, не принадлежащим S.
* Ребро проводиться з вершини i в вершину j тоді і тільки тоді, коли i належить P[j].
Іншими словами, для кожної вершини j з другий частки в її входять ребра з всіх вершин першо] частки, відповідних безлічі ребер P[j].

В випадку **нашій задачі** ми можемо трохи спростити опис графа шляхів:

$$
ребро (i,j) існує в H, якщо i &isin; P[j],  j = N..M, i = 1..N-1
$$

### 3. Математическая формулювання задачі

Чисто формально **задача inverse-MST** записується таким чином:

$$
знайти масив A[1..M] такий, що
C<sub>i</sub> + A<sub>i</sub> <= C<sub>j</sub> + A<sub>j</sub> для всіх j = N..M і кожного i &isin; P[j] (i в 1..N-1),
і мінімізувати суму |A<sub>1</sub>| + |A<sub>2</sub>| + ... + |A<sub>m</sub>|
$$

тут під шуканим масивом A ми подразумеваем ті значення, які потрібно додати до весам ребер (тобто, вирішивши задачу inverse-MST, ми замінюємо вага C<sub>i</sub> кожного ребра i на величину C<sub>i</sub> + A<sub>i</sub>).

Очевидно, що ні сенсу збільшувати вага ребер, що належать T, тобто

<pre>A<sub>i</sub> <= 0,  i = 1..N-1</pre>
і ні сенсу вкорочувати ребра, не належать T:

$$
A<sub>i</sub> >= 0,  i = N..M
$$

(оскільки в іншому випадку ми тільки ухудшим відповідь)

Значить ми можемо трохи **спростити** постановку задачі, убрав з суми модулі:

$$
знайти масив A[1..M] такий, що
C<sub>i</sub> + A<sub>i</sub> <= C<sub>j</sub> + A<sub>j</sub> для всіх j = N..M і кожного i &isin; P[j] (i в 1..N-1),
A<sub>i</sub> <= 0,  i = 1..N-1,
A<sub>i</sub> >= 0,  i = N..M,
і мінімізувати суму A<sub>n</sub> + ... + A<sub>m</sub> - (A<sub>1</sub> + ... + A<sub>n-1</sub>)
$$

Нарешті, просто змінимо "минимизацию" на "максимизацию", а в самою сумі змінимо всі знаки на протилежні:

$$
знайти масив A[1..M] такий, що
C<sub>i</sub> + A<sub>i</sub> <= C<sub>j</sub> + A<sub>j</sub> для всіх j = N..M і кожного i &isin; P[j] (i в 1..N-1),
A<sub>i</sub> <= 0,  i = 1..N-1,
A<sub>i</sub> >= 0,  i = N..M,
і максимізувати суму A<sub>1</sub> + ... + A<sub>n-1</sub> - (A<sub>n</sub> + ... + A<sub>m</sub>)
$$

### 4. Сведение задачі inverse-MST до задачі, двоїстої задачі про призначеннях

Формулювання задачі inverse-MST, яку ми тільки що дали, є формулюванням задачі **лінійного програмування** з невідомими A<sub>1</sub>..A<sub>m</sub>.

Застосуємо классический прийом - розглянемо **двоїсту** їй задачу.

За визначенню, аби получити двоїсту задачу, потрібно кожному нерівності сопоставить двоїсту змінну X<sub>ij</sub>, поміняти ролями целевую функцію (яку потрібно було мінімізувати) і коефіцієнти в правих частях нерівностей, поміняти знаки "&lt=" на ">=" і навпаки, поміняти максимизацию на минимизацию.

Отже, **двойственная до inverse-MST** задача:

$$
знайти всі X<sub>ij</sub> для кожного (i,j) &isin; H, такі що:
всі X<sub>ij</sub> >= 0,
для кожного i=1..N-1 &sum; X<sub>ij</sub> по всім j: (i,j) &isin; H &lt= 1,
для кожного j=N..M &sum; X<sub>ij</sub> по всім i: (i,j) &isin; H &lt= 1,
і мінімізувати &sum; X<sub>ij</sub> (C<sub>j</sub> - C<sub>i</sub>) для всіх (i,j) &isin; H
$$

Последняя задача є **завданням про призначеннях**: нам потрібно в графі шляхів H вибрати декілька ребер так, аби ні одне ребро не пересекалось з іншим в вершині, а сума ваг ребер (вага ребра (i,j) визначимо як C<sub>j</sub> - C<sub>i</sub>) повинна бути найменшою.

Таким чином, **двойственная задача inverse-MST эквивалентна задачі про призначеннях**. Якщо ми навчимося розв'язувати двоїсту задачу про призначеннях, то ми автоматично вирішимо задачу inverse-MST.

### 5. Розв'язок двоїстої задачі про призначеннях

Спочатку уделим трохи уваги тому частному нагоди задачі про призначеннях, який ми отримали. По-перше, це несбалансированная задача про призначеннях, оскільки в однієї частці знаходиться N-1 вершин, а в іншої - M вершин, тобто в загалом випадку кількість вершин у другий частці більше на цілий порядок. Для розв'язку такий двоїстої задачі про призначеннях є специализированный алгоритм, який решит її за O (N<sup>3</sup>), але тут цей алгоритм розглядатися не буде. По-друге, таку задачу про призначеннях можна назвать завданням про призначеннях з взвешенными вершинами: ваги ребер покладемо рівними 0, вага кожної вершини з першо] частки покладемо рівним -C<sub>i</sub>, з другий частки - рівним C<sub>j</sub>, і розв'язок отриманої задачі буде тим ж самим.

Ми будемо розв'язувати задачу двоїсту задачу про призначеннях з допомогою **модифікованого алгоритму min-cost-flow**, який буде знаходити потік мінімальної вартості і одночасно розв'язок двоїстої задачі.

**Свести** задачу про призначеннях до задачі min-cost-flow дуже легко, але для полноты картины ми опишемо цей процес.

Додамо в граф джерело s і стік t. З s до кожної вершині першо] частки проведемо ребро з пропускною здатністю = 1 і вартістю = 0. З кожної вершини другий частки проведемо ребро до t з пропускною здатністю = 1 і вартістю = 0. Пропускные здатності всіх ребер між першо] і другий долями також покладемо рівними 1.

Нарешті, аби модифікований алгоритм min-cost-flow (описаний нижче) працював, потрібно **додати ребро з s в t** з пропускною здатністю = N+1 і вартістю = 0.

### 6. Модифицированный алгоритм min-cost-flow для розв'язку задачі про призначеннях

Тут ми розглянемо **алгоритм послідовних найкоротших шляхів з потенциалами**, який нагадує звичайний алгоритм min-cost-flow, але використовує також поняття **потенціалів**, які до кінця роботи алгоритму будуть містити **розв'язок двоїстої задачі**.

Введемо позначення. Для кожного ребра (i,j) позначимо через U<sub>ij</sub> його пропускну здатність, через C<sub>ij</sub> - його вартість, через F<sub>ij</sub> - потік уздовж цього ребра.

Також введемо поняття потенціалів. Кожна вершина володіє своїм потенціалом PI<sub>i</sub>. Залишкова вартість ребра CPI<sub>ij</sub> визначається як:

$$
CPI<sub>ij</sub> = C<sub>ij</sub> - PI<sub>i</sub> + PI<sub>j</sub>
$$

В будь-який момент роботи алгоритму **потенциалы такі**, що виконуються умови:

$$
якщо F<sub>ij</sub> = 0, то CPI<sub>ij</sub> >= 0
якщо F<sub>ij</sub> = U<sub>ij</sub>, то CPI<sub>ij</sub> <= 0
інакше CPI<sub>ij</sub> = 0
$$

Алгоритм починає з нульового потоку, і нам потрібно знайти деякі початкові значення потенціалів, які б удовлетворяли зазначеним умовами. Неважко перевірити, що такий спосіб є одним з можливих рішень:

$$
PI<sub>j</sub> = 0   для j = N..M
PI<sub>i</sub> = min C<sub>ij</sub>, де (i,j) &isin; H
PI<sub>s</sub> = min PI<sub>i</sub>, де i = 1..N-1
PI<sub>t</sub> = 0
$$

Власне сам алгоритм min-cost-flow складається з декількох ітерацій. **На кожної ітерації** ми знаходимо найкоротший шлях з s в t в залишкової мережі, причому в якості ваг ребер використовуємо остаточные вартості CPI. Потім ми збільшуємо потік уздовж знайденого шляхи на одиницю, і оновлюємо потенциалы наступним чином:

$$
PI<sub>i</sub> -= D<sub>i</sub>
$$

де D<sub>i</sub> - знайдене найкоротший відстань від s до i (повторимося, в залишкової мережі з вагами ребер CPI).

Рано або пізно ми найдемо той шлях з s в t, який складається з єдиного ребра (s,t). Значить після цій ітерації нам випливає **завершити** роботу алгоритму: дійсно, якщо ми не остановим алгоритм, то далі вже будуть перебувати шляхи з неотрицательной вартістю, і додавати їх в відповідь не треба.

До кінця роботи алгоритму ми отримаємо розв'язок задачі про призначеннях (в вигляді потоку F<sub>ij</sub>) і розв'язок двоїстої задачі про призначеннях (в масиві PI<sub>i</sub>).

(з PI<sub>i</sub> треба буде провести небольшую модифікацію: від всіх значень PI<sub>i</sub> відняти PI<sub>s</sub>, оскільки його значення мають сенс тільки при PI<sub>s</sub> = 0)

### 6. Итог

Отже, ми вирішили двоїсту задачу про призначеннях, а, отже, і задачу inverse-MST.

Оцінимо **асимптотику** отриманого алгоритму.

Спочатку ми повинні будемо побудувати граф шляхів. Для цього просто для кожного ребра j &notin; T обходом в ширину по каркасу T найдемо шлях P[j]. Значить граф шляхів ми побудуємо за O (M) * O (N) = O (N M).

Потім ми найдемо початкові значення потенціалів за O (N) * O (M) = O (N M).

Потім ми будемо виконувати ітерації min-cost-flow, всього ітерацій буде не більш N (оскільки з джерела виходить N ребер, кожне з пропускною здатністю = 1), на кожної ітерації ми шукаємо в графі шляхів найкоротші шляхи від джерела до всіх інших вершин. Оскільки вершин в графі шляхів рівне M+2, а число ребер - O (N M), то, якщо реалізувати пошук найкоротших шляхів найпростішим варіантом алгоритму Дейкстри, кожна ітерація min-cost-flow буде виконувати за O (M<sup>2</sup>), а весь алгоритм min-cost-flow виконається за O (N M<sup>2</sup>).

Підсумкова асимптотика алгоритму рівна **O (N M<sup>2</sup>)**.

## Реалізація

Реалізуємо весь вищеописаний алгоритм. Єдине зміна - замість [алгоритму Дейкстри](dijkstra) застосовується [алгоритм Левіта](levit_algorithm), який на багатьох тестах повинен працювати декілька швидше.

<!--- TODO: specify code snippet id -->
``` cpp
const int INF = 1000*1000*1000;

struct rib {
    int v, c, id;
};

struct rib2 {
    int a, b, c;
};

int main() {

    int n, m;
    cin >> n >> m;
    vector < vector<rib> > g (n); // граф в формате списків суміжності
    vector<rib2> ribs (m); // всі ребра в одному списку
    ... читання графа ...

    int nn = m+2,  s = nn-2,  t = nn-1;
    vector < vector<int> > f (nn, vector<int> (nn));
    vector < vector<int> > u (nn, vector<int> (nn));
    vector < vector<int> > c (nn, vector<int> (nn));
    for (int i=n-1; i<m; ++i) {
        vector<int> q (n);
        int h=0, t=0;
        rib2 & cur = ribs[i];
        q[t++] = cur.a;
        vector<int> rib_id (n, -1);
        rib_id[cur.a] = -2;
        while (h < t) {
            int v = q[h++];
            for (size_t j=0; j<g[v].size(); ++j)
                if (g[v][j].id >= n-1)
                    break;
                else if (rib_id [ g[v][j].v ] == -1) {
                    rib_id [ g[v][j].v ] = g[v][j].id;
                    q[t++] = g[v][j].v;
                }
        }
        for (int v=cur.b, pv; v!=cur.a; v=pv) {
            int r = rib_id[v];
            pv = v != ribs[r].a ? ribs[r].a : ribs[r].b;
            u[r][i] = n;
            c[r][i] = ribs[i].c - ribs[r].c;
            c[i][r] = -c[r][i];
        }
    }
    u[s][t] = n+1;
    for (int i=0; i<n-1; ++i)
        u[s][i] = 1;
    for (int i=n-1; i<m; ++i)
        u[i][t] = 1;

    vector<int> pi (nn);
    pi[s] = INF;
    for (int i=0; i<n-1; ++i) {
        pi[i] = INF;
        for (int j=n-1; j<m; ++j)
            if (u[i][j])
                pi[i] = min (pi[i], ribs[j].c-ribs[i].c);
        pi[s] = min (pi[s], pi[i]);
    }

    for (;;) {
        vector<int> id (nn);
        deque<int> q;
        q.push_back (s);
        vector<int> d (nn, INF);
        d[s] = 0;
        vector<int> p (nn, -1);
        while (!q.empty()) {
            int v = q.front();  q.pop_front();
            id[v] = 2;
            for (int i=0; i<nn; ++i)
                if (f[v][i] < u[v][i]) {
                    int new_d = d[v] + c[v][i] - pi[v] + pi[i];
                    if (new_d < d[i]) {
                        d[i] = new_d;
                        if (id[i] == 0)
                            q.push_back (i);
                        else if (id[i] == 2)
                            q.push_front (i);
                        id[i] = 1;
                        p[i] = v;
                    }
                }
        }
        for (int i=0; i<nn; ++i)
            pi[i] -= d[i];
        for (int v=t; v!=s; v=p[v]) {
            int pv = p[v];
            ++f[pv][v],  --f[v][pv];
        }
        if (p[t] == s)  break;
    }

    for (int i=0; i<m; ++i)
        pi[i] -= pi[s];
    for (int i=0; i<n-1; ++i)
        if (f[s][i])
            ribs[i].c += pi[i];
    for (int i=n-1; i<m; ++i)
        if (f[i][t])
            ribs[i].c += pi[i];

    ... висновок графа ...
    
}
```
