# Пошук підвідрізку масиву з максимальної/мінімальної сумою

Тут ми розглянемо задачу про пошуку підвідрізку масиву з максимальної сумою ("maximum subarray problem" на англійською), а також деякі її вариации (в тому числі алгоритм розв'язку варіанти цій задачі в режимі онлайн - описаний автором алгоритму - KADR (Ярослав Твердохлеб)).

## Постановка задачі

Дан масив чисел $a[1 \ldots n]$. Потрібно знайти такий його підвідрізок $a[l \ldots r]$, що сума на ньому **максимальна**:

$$
\max_{ 1 \le l \le r \le n } \sum_{i=l}^{r} a[i].
$$

Наприклад, якщо б всі числа масиву $a[]$ були б неотрицательными, то в якості відповіді можна було б взяти весь масив. Розв'язок нетривиально, коли масив можливо містити як позитивні, так і негативні числа.

Зрозуміло, що задача про пошуку **мінімального** підвідрізку - по суті та ж сама, достатньо лише змінити знаки всіх чисел на протилежні.

## Алгоритм 1

Тут ми розглянемо практично очевидний алгоритм. (Далі ми розглянемо іншої алгоритм, який трохи складніше придумати, однак його реалізація виходить ще коротше).

### Опис алгоритму

Алгоритм вельми простий.

Введемо для зручності **позначення**: $s[i] = \sum_{j=1}^{i} a[j]$. тобто. масив $s[i]$ - це масив часткових сум масиву $a[]$. Також покладемо значення $s[0] = 0$.

Будемо тепер **перебирати** індекс $r = 1 \ldots n$, і навчимося для кожного поточного значення $r$ швидко знаходити оптимальне $l$, при якому досягається максимальна сума на підвідрізку $[l; r]$.

Формально це означає, що нам треба для поточного $r$ знайти таке $l$ (не превосходящее $r$), аби величина $s[r] - s[l-1]$ була максимальної. Після тривіального перетворення ми отримуємо, що нам треба знайти в масиві $s[]$ мінімум на відрізку $[0;r-1]$.

Звідси ми зразу отримуємо алгоритм розв'язку: ми просто будемо зберігати, де в масиві $s[]$ знаходиться поточний мінімум. Використовуючи цей мінімум, ми за $O(1)$ знаходимо поточний оптимальний індекс $l$, а при переході від поточного індексу $r$ до наступного ми просто оновлюємо цей мінімум.

Очевидно, цей алгоритм працює за $O(n)$ і асимптотично оптимальний.

### Реалізація

Для реалізації нам навіть не знадобиться явно зберігати масив часткових сум $s[]$ - від нього нам буде требоваться тільки поточний елемент.

Реалізація наводиться в 0-индексированных массивах, а не в 1-нумерації, як було описано вище.

Наведемо спочатку розв'язок, яке знаходить просто чисельний відповідь, не знаходячи індекси шуканого відрузку:

<!--- TODO: specify code snippet id -->
``` cpp
int ans = a[0], sum = 0, min_sum = 0;
for (int r = 0; r < n; ++r) {
    sum += a[r];
    ans = max(ans, sum - min_sum);
    min_sum = min(min_sum, sum);
}
```

Тепер наведемо повний різновид розв'язку, який паралельно з числовым розв'язком знаходить межі шуканого відрузку:

<!--- TODO: specify code snippet id -->
``` cpp
int ans = a[0], ans_l = 0, ans_r = 0, sum = 0, min_sum = 0, min_pos = -1;
for (int r = 0; r < n; ++r) {
    sum += a[r];

    int cur = sum - min_sum;
    if (cur > ans) {
        ans = cur;
        ans_l = min_pos + 1;
        ans_r = r;
    }

    if (sum < min_sum) {
        min_sum = sum;
        min_pos = r;
    }
}
```

## Алгоритм 2

Тут ми розглянемо іншої алгоритм. Його трохи складніше зрозуміти, але зате він більш элегантен, ніж наведений вище, і реалізується трохи-чуть коротше. Цей алгоритм був запропонований Джеем Каданом (Jay Kadane) в 1984 р.

### Опис алгоритму

Сам **алгоритм** виглядає наступним чином. Будемо йти по масиву і накапливать в деякої змінній $s$ поточну частичную суму. Якщо в якийсь момент $s$ виявиться негативною, то ми просто дамо $s=0$. Стверджується, що максимум з всіх значень змінній $s$, случившихся за час роботи, і буде відповіддю на задачу.

**Доведемо** цей алгоритм.

Насправді, розглянемо перший момент часу, коли сума $s$ стала негативною. Це означає, що, стартовав з нульовий частичной суми, ми в підсумку прийшли до негативною частичной сумі - значить, і весь цей префікс масиву, рівне як і будь-який його суфікс мають отрицательную суму. Отже, від всього цього префікса масиву в надалі не можливо бути ніякий пользы: він можливо дати тільки отрицательную прибавку до відповіді.

Однак цього недостатньо для доведення алгоритму. В алгоритмі ми, фактично, ограничиваемся в пошуку відповіді тільки такими відрізками, які починаються безпосередньо після мест, коли случалось $s<0$.

Але, насправді, розглянемо довільний відрізок $[l;r]$, причому $l$ не знаходиться в такий "критической" позиції (тобто $l > p+1$, де $p$ - остання така позиція, в якій $s<0$). Оскільки остання критическая позиція знаходиться строго раніше, ніж в $l-1$, то виходить, що сума $a[p+1 \ldots l-1]$ неотрицательна. Це означає, що, сдвинув $l$ в позицію $p+1$, ми збільшимо відповідь або, в крайнем випадку, не змінимо його.

Так або інакше, але виходить, що дійсно при пошуку відповіді можна обмежитися тільки відрізками, начинающимися зразу після позицій, в яких оказывалось $s<0$. Це доводить правильність алгоритму.

### Реалізація

Як і в алгоритмі 1, наведемо спочатку упрощённую реалізацію, яка шукає тільки числовий відповідь, не знаходячи границ шуканого відрузку:

<!--- TODO: specify code snippet id -->
``` cpp
int ans = a[0], sum = 0;
for (int r = 0; r < n; ++r) {
    sum += a[r];
    ans = max(ans, sum);
    sum = max(sum, 0);
}
```

Полный різновид розв'язку, з поддержанием індексів-границ шуканого відрузку:

<!--- TODO: specify code snippet id -->
``` cpp
int ans = a[0], ans_l = 0, ans_r = 0, sum = 0, minus_pos = -1;
for (int r = 0; r < n; ++r) {
    sum += a[r];

    if (sum > ans) {
        ans = sum;
        ans_l = minus_pos + 1;
        ans_r = r;
    }

    if (sum < 0) {
        sum = 0;
        minus_pos = r;
    }
}
```

## Смежные задачі

### Пошук максимального/мінімального підвідрізку з обмеженнями

Якщо в умови задачі на шуканий відрізок $[l;r]$ накладываются додаткові обмеження (наприклад, що довжина $r-l+1$ відрузку повинна перебувати в заданих пределах), то описаний алгоритм швидше всього легко узагальнюється на ці випадки - так або інакше, задача буде як і раніше полягати в пошуку мінімуму в масиві $s[]$ при заданих додаткових обмеженнях.

### Двовимірний випадок задачі: пошук максимальної/мінімальної підматриці

Описанная в даній статті задача природно узагальнюється на великі розмірності. Наприклад, в двовимірному випадку вона перетворюється в пошук такий підматриці $[l_1 \ldots r_1; l_2 \ldots r_2]$ заданої матриці, яка має максимальну суму чисел в ній.

З описаного вище розв'язку для одновимірного випадку **легко получити** розв'язок за $O(n^3)$: переберемо $l_1$ і $r_1$, і порахуємо масив сум з $l_1$ по $r_1$ в кожної рядка матриці; ми прийшли до одномерной задачі пошуку індексів $l_2$ і $r_2$ в цим масиві, яку вже можна розв'язувати за лінійне час.

**Більш быстрые** алгоритми розв'язку цій задачі хоча і відомі, однак вони не сильно швидше $O(n^3)$, і при цим вельми складні (настільки складні, що по прихованої константі багато з них уступают тривиальному алгоритму при всіх розумних обмеженнях). За всій видимості, кращий з відомих алгоритмів працює за $O \left( n^3 \frac{ \log^3 \log n }{ \log^2 n} \right)$ (T. Chan 2007 "More algorithms for all-pairs shortest paths in weighted graphs").

Цей алгоритм Chan, а також багато інші результати в даній області насправді описывают **швидке множення** матриць (де під множенням матриць мається на увазі модифицированное множення: замість складання використовується мінімум, а замість множення - складання). Справа в тому, що задача про пошуку підматриці з найбільшою сумою зводиться до задачі про пошуку найкоротших шляхів між усіма парами вершин, а ця задача, в свою чергу - зводиться до такому множенню матриць.

### Пошук підвідрізку з максимальної/мінімальної середньою сумою

Ця задача полягає в тому, що треба знайти такий відрізок $[l;r]$, аби середнє значення на ньому було максимальним:

$$
\max_{l \le r} \frac{ 1 }{ r-l+1 } \sum_{i=l}^{r} a[i].
$$

Конечно, якщо на шуканий відрізок $[l;r]$ по умові не накладено інших умов, то розв'язком завжди буде бути відрізок довжини $1$ в точці-максимуме масиву. Задача має сенс, тільки якщо є **додаткові обмеження** (наприклад, довжина шуканого відрузку обмежена знизу).

В такому випадку застосуємо **стандартний прийом** при роботі з завданнями про середньому значенні: будемо подбирать шукану максимальну среднюю величину **двоичным пошуком**.

Для цього нам треба навчитися розв'язувати таку подзадачу: дано число $x$, і треба перевірити, є або підвідрізок масиву $a[]$ (звісно, задовольняє всім додатковим обмеженням задачі), на якому середнє значення більше $x$.

Щоб розв'язати цю подзадачу, отнимем $x$ від кожного елементу масиву $a[]$. Значить наша подзадача фактично перетворюється в таку: є або ні в даному масиві підвідрізок позитивної суми. А цю задачу ми вже вміємо розв'язувати.

Таким чином, ми отримали розв'язок за асимпотику $O(T(n) \log W)$, де $W$ - необхідна точність, $T(n)$ - час розв'язку подзадачи для масиву довжини $n$ (яке можливо варьироваться в залежності від конкретних накладываемых додаткових обмежень).

### Розв'язок задачі в режимі онлайн

Умова задачі таке: дано масив з $n$ чисел, а також дано число $L$. Надходять запити увазі $(l,r)$, і в відповідь на запит потрібно знайти підвідрізок відрузку $[l;r]$ довжини не менш $L$ з максимально можливим середнім арифметическим.

Алгоритм розв'язку цій задачі достатньо сложен. Автор даного алгоритму - KADR (Ярослав Твердохлеб) - [описал даний алгоритм в своєму сообщении на форуме](http://e-maxx.ru/forum/viewtopic.php?id=410).
