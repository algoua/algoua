# Пошук точок зчеплення

Нехай дано зв'язний неорієнтований граф. **Точкой зчеплення** (або точкою артикуляции, англ. "cut vertex" або "articulation point") називається така вершина, видалення якій робить граф незв'язним.

Опишемо алгоритм, заснований на пошуку в глибину, працюючий за $O(n+m)$, де $n$ - кількість вершин, $m$ - ребер.

## Алгоритм

Запустимо обхід в глибину з довільної вершини графа ; позначимо її через $\rm root$. Зауважимо наступного **факт** (який не складно довести):

* Нехай ми знаходимося в обході в глибину, просматривая зараз всі ребра з вершини $v \ne {\rm root}$. Значить, якщо поточний ребро $(v,to)$ таке, що з вершини $to$ і з будь-якого її нащадка в дереві обходу в глибину ні зворотнього ребра в какого-або предка вершини $v$, то вершина $v$ є точкою зчеплення. В іншому випадку, тобто якщо обхід в глибину просмотрел всі ребра з вершини $v$, і не нашёл удовлетворяющего вищеописаним умовами ребра, то вершина $v$ не є точкою зчеплення. (Насправді, ми цим умовою перевіряємо, ні або іншого шляхи з $v$ в $to$)

* Розглянемо тепер залишився випадок: $v = {\rm root}$. Значить ця вершина є точкою зчеплення тоді і тільки тоді, коли ця вершина має більш одного сина в дереві обходу в глибину. (Насправді, це означає, що, пройшовши з $\rm root$ по безпідставного ребру, ми не змогли обійти весь граф, звідки зразу випливає, що $\rm root$ - точка зчеплення).

(Ср. формулировку цього критерію з формулюванням критерію для [алгоритму пошуку мостів](bridge_searching)).

Тепер залишилося навчитися перевіряти цей факт для кожної вершини ефективно. Для цього скористаємось "временами входу в вершину", вычисляемыми [алгоритмом пошуку в глибину](dfs).

Отже, нехай $tin[v]$ - це час заходу пошуку в глибину в вершину $v$. Тепер введемо масив $fup[v]$, який і дозволить нам відповідати на вищеописані запити. Час $fup[v]$ рівне мінімуму з часу заходу в саму вершину $tin[v]$, часів заходу в кожну вершину $p$, що є кінцем деякого зворотнього ребра $(v,p)$, а також з всіх значень $fup[to]$ для кожної вершини $to$, є безпосереднім сином $v$ в дереві пошуку:

$$
fup[v] = \min \cases{
tin[v], & \cr
tin[p], & {\rm for all} (v,p){\rm\ - back edge } \cr
fup[to], & {\rm for all} (v,to){\rm\ - tree edge } \cr
}
$$

(тут "back edge" - зворотнє ребро, "tree edge" - ребро дерева)

Значить, з вершини $v$ або її нащадка є зворотнє ребро в її предка тоді і тільки тоді, коли знайдеться такий син $to$, що $fup[to] < tin[v]$.

Таким чином, якщо для поточного ребра $(v,to)$ (належить дереву пошуку) виконується $fup[to] \ge tin[v]$, то вершина $v$ є точкою зчеплення. Для початкової вершини $v = {\rm root}$ критерій іншої: для цій вершини треба порахувати число непосредственных синів в дереві обходу в глибину.

## Реалізація

Якщо говорити про самою реалізації, то тут нам потрібно вміти розрізняти три випадку: коли ми йдемо по ребру дерева пошуку в глибину, коли йдемо по зворотному ребру, і коли намагаємося піти по ребру дерева в зворотню сторону. Це, відповідно, випадки $used[to]=false$, $used[to]=true ~ \&\& ~ to \ne parent$, і $to=parent$. Таким чином, нам треба передавати в функцію пошуку в глибину вершину-предка поточній вершини.

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> g[MAXN];
bool used[MAXN];
int timer, tin[MAXN], fup[MAXN];

void dfs(int v, int p = -1) {
    used[v] = true;
    tin[v] = fup[v] = timer++;
    int children = 0;
    for (size_t i = 0; i < g[v].size(); ++i) {
        int to = g[v][i];
        if (to == p)
            continue;
        if (used[to])
            fup[v] = min(fup[v], tin[to]);
        else {
            dfs(to, v);
            fup[v] = min(fup[v], fup[to]);
            if (fup[to] >= tin[v] && p != -1)
                IS_CUTPOINT(v);
            ++children;
        }
    }
    if (p == -1 && children > 1)
        IS_CUTPOINT(v);
}

int main() {
    int n;
    ... читання n і g...

        timer = 0;
    for (int i = 0; i < n; ++i)
        used[i] = false;
    dfs(0);
}
```

Тут константі $\rm MAXN$ має бути задано значення, рівне максимально можливого числу вершин у вхідному графі.

Функція ${\rm IS\_CUTPOINT}(v)$ в коді - це якась функція, яка буде реагувати на то, що вершина $v$ є точкою зчеплення, наприклад, виводити цю вершини на екран (треба враховувати, що для однієї і тією ж вершини ця функція можливо бути вызвана декілька раз).

## Задачі в online judges

Список задач, в яких потрібно шукати точки зчеплення:

* [UVA #10199 **"Tourist Guide"** [складність: низька]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=13&page=show_problem&problem=1140)

* [UVA #315 **"Network"** [складність: низька]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=5&page=show_problem&problem=251)
