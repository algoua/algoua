# Задача про призначеннях. Розв'язок з допомогою min-cost-flow

Задача має дві эквивалентные постановки:

* Дана квадратна матриця A[1..N,1..N]. Потрібно вибрати в ній N елементів так, аби в кожної стрічки і стовпці був обраний рівне один елемент, а сума значень цих елементів була найменшою.
* Є N заказов і N станков. Про кожний заказ відома вартість його изготовления на кожному верстаті. На кожному верстаті можна виконувати тільки один заказ. Потрібно розподілити всі заказы по станкам так, аби мінімізувати сумарну вартість.

Тут ми розглянемо розв'язок задачі на основі алгоритму [знаходження потоку мінімальної вартості (min-cost-flow)](min_cost_flow), вирішивши задачу про призначеннях за **O (N<sup>5</sup>)**.

## Опис

**Побудуємо** двудольную мережа: є джерело S, стік T, в першо] частці знаходяться N вершин (відповідні рядках матриці або заказам), у другий - теж N вершин (відповідні стовпчиках матриці або станкам). Между кожної вершиною i першо] частки і кожної вершиною j другий частки проведемо ребро з пропускною здатністю 1 і вартістю A<sub>ij</sub>. Від джерела S проведемо ребра до всім вершин i першо] частки з пропускною здатністю 1 і вартістю 0. Від кожної вершини другий частки j до стоку T проведемо ребро з пропускною здатністю 1 і вартістю 0.

Знайдемо в отриманої мережі максимальний потік мінімальної вартості. Очевидно, величина потоку буде рівна N. Далі, очевидно, що для кожної вершини i з першо] частки знайдеться рівне одна вершина j з другий частки, така, що потік F<sub>ij</sub> = 1. Нарешті, очевидно, це взаємно однозначное відповідність між вершинами першо] частки і вершинами другий частки є розв'язком задачі (оскільки знайдений потік має мінімальну вартість, то сума вартостей обраних ребер буде найменшою з можливих, що і є критерієм оптимальності).

Асимптотика цього розв'язку задачі про призначеннях залежить від того, яким алгоритмом виготовляється пошук максимального потоку мінімальної вартості. Асимптотика складе **O (N<sup>3</sup>)** при використанні алгоритму Дейкстри або O (N<sup>4</sup>) при використанні алгоритму Форда-Беллмана.

## Реалізація

Наведена тут реалізація длинноватая, можливо, її можна значно скоротити.

<!--- TODO: specify code snippet id -->
``` cpp
typedef vector<int> vint;
typedef vector<vint> vvint;

const int INF = 1000*1000*1000;

int main()
{
    int n;
    vvint a (n, vint (n));
    ... читання a ...

    int m = n * 2 + 2;
    vvint f (m, vint (m));
    int s = m-2, t = m-1;
    int cost = 0;
    for (;;)
    {
        vector<int> dist (m, INF);
        vector<int> p (m);
        vector<int> type (m, 2);
        deque<int> q;
        dist[s] = 0;
        p[s] = -1;
        type[s] = 1;
        q.push_back (s);
        for (; !q.empty(); )
        {
            int v = q.front(); q.pop_front();
            type[v] = 0;
            if (v == s)
            {
                for (int i=0; i<n; ++i)
                    if (f[s][i] == 0)
                    {
                        dist[i] = 0;
                        p[i] = s;
                        type[i] = 1;
                        q.push_back (i);
                    }
            }
            else
            {
                if (v < n)
                {
                    for (int j=n; j<n+n; ++j)
                        if (f[v][j] < 1 && dist[j] > dist[v] + a[v][j-n])
                        {
                            dist[j] = dist[v] + a[v][j-n];
                            p[j] = v;
                            if (type[j] == 0)
                                q.push_front (j);
                            else if (type[j] == 2)
                                q.push_back (j);
                            type[j] = 1;
                        }
                }
                else
                {
                    for (int j=0; j<n; ++j)
                        if (f[v][j] < 0 && dist[j] > dist[v] - a[j][v-n])
                        {
                            dist[j] = dist[v] - a[j][v-n];
                            p[j] = v;
                            if (type[j] == 0)
                                q.push_front (j);
                            else if (type[j] == 2)
                                q.push_back (j);
                            type[j] = 1;
                        }
                }
            }
        }

        int curcost = INF;
        for (int i=n; i<n+n; ++i)
            if (f[i][t] == 0 && dist[i] < curcost)
            {
                curcost = dist[i];
                p[t] = i;
            }
        if (curcost == INF) break;
        cost += curcost;
        for (int cur=t; cur!=-1; cur=p[cur])
        {
            int prev = p[cur];
            if (prev!=-1)
                f[cur][prev] = - (f[prev][cur] = 1);
        }

    }

    printf ("%d\n", cost);
    for (int i=0; i<n; ++i)
        for (int j=0; j<n; ++j)
            if (f[i][j+n] == 1)
                printf ("%d ", j+1);

}
```
