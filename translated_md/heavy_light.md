# Heavy-light декомпозиція

**Heavy-light декомпозиція** - це достатньо загальний прийом, який дозваляє ефективно розв'язувати багато задачі, сводящиеся до **запитам на дереві**.

Найпростіший **приклад** задач такого увазі - це наступна задача. Дано дерево, кожної вершині якого приписано якесь число. Надходять запити увазі $(a,b)$, де $a$ і $b$ - номера вершин дерева, і потрібно дізнатися максимальне число на шляхи між вершинами $a$ і $b$.

## Опис алгоритму

Отже, нехай дано дерево $G$ з $n$ вершинами, подвешенное за деякий корінь.

Суть цій декомпозиції в тому, аби **розбити дерево на декілька шляхів** таким чином, аби для будь-який вершини $v$ виходило, що якщо ми будемо подниматься від $v$ до корені, то по шляхи сменим не більш $\log n$ шляхів. Крім того, всі шляхи повинні не перетинатися один з другом по ребрам.

Зрозуміло, що якщо ми навчимося шукати таку декомпозицію для будь-якого дерева, це дозволить звести будь-який запит увазі "дізнатися що-то на шляхи з $a$ в $b$" до кільком запитам увазі "дізнатися що-то на відрізку $[l;r]$ $k$-го шляхи".

### Побудова heavy-light декомпозиції

Порахуємо для кожної вершини $v$ розмір її піддерева $s(v)$ (тобто це кількість вершин в піддереві вершини $v$, включаючи саму вершину).

Далі, розглянемо всі ребра, провідні до синам який-або вершини $v$. Назвемо ребро $(v,c)$ **тяжёлым**, якщо воно веде в вершину $c$ таку, що:

$$
s(c) \ge \frac{ s(v) }{ 2 } \Leftrightarrow {\rm edge} ~ (v,c) ~ {\rm is ~ heavy}.
$$

Усе інші ребра назвемо **лёгкими**. Очевидно, що з однієї вершини $v$ вниз можливо исходить максимум одне тяжёлое ребро (т.до. в іншому випадку у вершини $v$ було б два сина розміру $s(v)/2$, що з урахуванням самою вершини $v$ дає розмір $2 \cdot s(v) / 2 + 1 > s(v)$, тобто прийшли до протиріччя).

Тепер побудуємо саму **декомпозицію** дерева на непересекающиеся шляхи. Розглянемо всі вершини, з яких не виходить вниз ні одного тяжёлого ребра, і будемо йти від кожної з них вгору, поки не дійдемо до кореня дерева або не пройдемо легке ребро. В результаті ми отримаємо декілька шляхів - покажемо, що це і є шукані шляхи heavy-light декомпозиції.

### Доведення коректності алгоритму

По-перше, зауважимо, що отримані алгоритмом шляхи будуть **непересічними**. Насправді, якщо б два якихось шляхи имели б загальне ребро, це б означало, що з якийсь вершини исходит вниз два тяжёлых ребра, чого бути не можливо.

По-друге, покажемо, що спускаясь від кореня дерева до довільної вершини, ми **сменим по шляхи не більш $\log n$ шляхів**. Насправді, прохід вниз по лёгкому ребру уменьшает розмір поточного піддерева більш ніж вдвічі:

$$
s(c) < \frac{ s(v) }{ 2 } \Leftrightarrow {\rm edge} ~ (v,c) ~ {\rm is ~ light}.
$$

Таким чином, ми не могли пройти більш $\log n$ лёгких ребер. Однак переходити з одного шляхи на іншої ми можемо тільки через легке ребро (т.до. кожний шлях, крім закінчуються в корені, містить легке ребро в наприкінці; а потрапити зразу посередині шляхи ми не можемо).

Отже, по шляхи від кореня до будь-який вершини ми не можемо сменить більш $\log n$ шляхів, що і потрібно довести.

## Застосування при рішенні задач

При рішенні задач іноді буває зручніше розглядати heavy-light як набір **вершинно-що не перетинаються** шляхів (а не рёберо-що не перетинаються). Для цього достатньо з кожного шляхи виключити останнє ребро, якщо воно є лёгким ребром - тоді ніякі властивості не порушаться, але тепер кожна вершина буде належати рівне одному шляхи.

Нижче ми розглянемо декілька типичных задач, які можна розв'язувати з допомогою heavy-light декомпозиції.

Отдельно варто звернути увага на задачу **сума чисел на шляхи**, оскільки це приклад задачі, яка можливо бути вирішена і більш простими техниками.

### Максимальное число на шляхи між двома вершинами

Дано дерево, кожної вершині якого приписано якесь число. Надходять запити увазі $(a,b)$, де $a$ і $b$ - номера вершин дерева, і потрібно дізнатися максимальне число на шляхи між вершинами $a$ і $b$.

Побудуємо заздалегідь heavy-light декомпозицію. Над кожним получившимся шляхом побудуємо [дерево відрізків для максимуму](segment_tree), що дозволить шукати вершину з максимальним приписанным числом в зазначеному сегменте зазначеного шляхи за $O(\log n)$. Хоча число шляхів в heavy-light декомпозиції можливо достигать $n-1$, сумарний розмір всіх шляхів є величина $O(n)$, тому і сумарний розмір дерев відрізків також буде лінійним.

Тепер, для того аби відповідати на поступивший запит $(a,b)$ найдемо найменшого загального предка $l$ цих вершин (наприклад, [методом двійкового підйому](lca_simpler)). Тепер задача звелася до двом запитам: $(a,l)$ і $(b,l)$, на кожний з яких ми можемо відповісти таким чином: найдемо, в якому шляхи лежить нижня вершина, зробимо запит до цьому шляхи, перейдемо в вершину-кінець цього шляхи, знову визначимо, в якому ми шляхи виявилися і зробимо запит до нього, і так далі, поки не дійдемо до шляхи, содержащего $l$.

Аккуратно випливає бути зі випадком, коли, наприклад, $a$ і $l$ виявилися в одному шляхи - тоді запит максимуму до цьому шляхи треба робити не на суфікс, а на внутреннем підвідрізку.

Таким чином, в процесі відповіді на один подзапрос ми пройдемо по $O(\log n)$ шляхах, в кожному з них зробивши запит максимуму на суфікс або на префиксе/підвідрізку (запит на префиксе/підвідрізку міг бути тільки один раз).

Так ми отримали розв'язок за $O(\log^2 n)$ на один запит.

Якщо ще додатково предпосчітать на кожному шляхи максимуми на всіх суффиксах, то вийде розв'язок за $O(n \log n)$ - т.до. запит максимуму не на суфікс случается тільки один раз, коли ми доходим до вершини $l$.

### Сума чисел на шляхи між двома вершинами

Дано дерево, кожної вершині якого приписано якесь число. Надходять запити увазі $(a,b)$, де $a$ і $b$ - номера вершин дерева, і потрібно дізнатися суму чисел на шляхи між вершинами $a$ і $b$. Возможен різновид цій задачі, коли додатково бувають запити зміни числа, приписанного тією або інший вершині.

Хоча цю задачу можна розв'язувати з допомогою heavy-light декомпозиції, построив над кожним шляхом дерево відрізків для суми (або просто предпосчитав частичные суми, якщо в задачі відсутні запити зміни), ця задача можливо бути вирішена **більш простими техниками**.

Якщо запити модифікації відсутні, то дізнаватися суму на шляхи між двома вершинами можна паралельно з пошуком LCA двох вершин в [алгоритмі двійкового підйому](lca_simpler) - для цього достатньо у час препроцесингу для LCA підраховувати не тільки $2^k$-ых предків кожної вершини, але і суму чисел на шляхи до цього предка.

Є і принципово іншої підхід до цій задачі - розглянути ейлерів обхід дерева, і побудувати дерево відрізків над ним. Цей алгоритм розглядається в [статті з розв'язком похожей задачі](tree_painting). (А якщо запити модифікації відсутні - то достатньо обійтися предпосчётом часткових сум, без дерева відрізків).

Обидва цих способу дають щодо прості розв'язку з асимптотикою $O(\log n)$ на один запит.

### Перекраска ребер шляхи між двома вершинами

Дано дерево, кожне ребро спершу пофарбовано в белый колір. Надходять запити увазі $(a,b,c)$, де $a$ і $b$ - номера вершин, $c$ - колір, що означає, що всі ребра на шляхи з $a$ в $b$ треба перекрасить в колір $c$. Потрібно після всіх перекрашиваний сообщить, скільки в підсумку вийшло ребер кожного кольори.

Розв'язок - просто зробити [дерево відрізків з покраской на відрізку](segment_tree) над набором шляхів heavy-light декомпозиції.

Кожен запит перекраски на шляхи $(a,b)$ перетвориться в два подзапроса $(a,l)$ і $(b,l)$, де $l$ - найменший загальний предок вершин $a$ і $b$ (знайдений, наприклад, [алгоритмом двійкового підйому](lca_simpler)), а кожний з цих подзапросов - в $O(\log n)$ запитів до деревам відрізків над шляхами.

Разом виходить розв'язок з асимптотикою $O(\log^2 n)$ на один запит.

## Задачі в online judges

Список задач, які можна розв'язати, використовуючи heavy-light декомпозицію:

* [TIMUS #1553 **"Caves and Tunnels"** [складність: середня]](http://acm.timus.ru/problem.aspx?space=1&num=1553)

* [IPSC 2009 L **"Let there be rainbows!"** [складність: середня]](http://ipsc.ksp.sk/contests/ipsc2009/real/problems/l.php)

* [SPOJ #2798 **"Query on a tree again!"** [складність: середня]](http://www.spoj.pl/problems/QTREE3/)

* [Codeforces Beta Round #88 E **"Дерево або не дерево"** [складність: висока] ](http://codeforces.ru/contest/117/problem/E)
