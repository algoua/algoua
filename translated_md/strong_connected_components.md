# Пошук компонент сильної зв'язності, побудова конденсації графа

## Определения, постановка задачі

Дан орієнтований граф $G$, множину вершин якого $V$ і множину ребер - $E$. Петли і кратні ребра допускаються. Позначимо через $n$ кількість вершин графа, через $m$ - кількість ребер.

**Компонентой сильної зв'язності** (strongly connected component) називається таке (максимальне по включению) підмножина вершин $C$, що будь-які дві вершини цього підмножини досяжні один з одного, тобто для $\forall u,v \in C$:

$$
u \mapsto v, v \mapsto u
$$

де символом $\mapsto$ тут і далі ми будемо позначати достижимость, тобто існування шляхи з першо] вершини у одному.

Зрозуміло, що компоненти сильної зв'язності для даного графа не перетинаються, тобто фактично це розбиття всіх вершин графа. Звідси логично визначення **конденсації** $G^{\rm SCC}$ як графа, получаемого з даного графа сжатием кожної компоненти сильної зв'язності в одну вершину. Каждой вершині графа конденсації відповідає компонента сильної зв'язності графа $G$, а ориентированное ребро між двома вершинами $C_i$ і $C_j$ графа конденсації проводиться, якщо знайдеться пара вершин $u \in C_i, v \in C_j$, між якими існувало ребро в вихідному графі, тобто $(u,v) \in E$.

Важнейшим властивістю графа конденсації є то, що він **аціклічен**. Дійсно, припустимо, що $C \mapsto C^\prime$, доведемо, що $C^\prime \not\mapsto C$. З визначення конденсації отримуємо, що знайдуться дві вершини $u \in C$ і $v \in C^\prime$, що $u \mapsto v$. Доводити будемо від противного, тобто припустимо, що $C^\prime \mapsto C$, тоді знайдуться дві вершини $u^\prime \in C$ і $v^\prime \in C^\prime$, що $v^\prime \mapsto u^\prime$. Але т.до. $u$ і $u^\prime$ знаходяться в однієї компоненті сильної зв'язності, то між ними є шлях; аналогічно для $v$ і $v^\prime$. В результаті, об'єднуючи шляхи, отримуємо, що $v \mapsto u$, і одночасно $u \mapsto v$. Отже, $u$ і $v$ повинні належати однієї компоненті сильної зв'язності, тобто отримали протиріччя, що і потрібно довести.

Описаний нижче алгоритм выделяет в даному графі всі компоненти сильної зв'язності. Побудувати по ним граф конденсації не складе праці.

## Алгоритм

Описаний тут алгоритм був запропонований незалежно Косараю (Kosaraju) і Шариром (Sharir) в 1979 р. Це дуже простий в реалізації алгоритм, заснований на двох сериях [пошуків в глибину](dfs), і тому працюючий за час $O(n+m)$.

**На першому кроці** алгоритму виконується серия обходів в глибину, посещающая весь граф. Для цього ми проходимся по всім вершин графа і з кожної ще не посещённой вершини викликаємо обхід в глибину. При цим для кожної вершини $v$ запам'ятаємо **час виходу** ${\rm tout}[v]$. Ці часи виходу играют ключевую роль в алгоритмі, і ця роль выражена в наведеної нижче теоремі.

Спочатку введемо позначення: час виходу ${\rm tout}[C]$ з компоненти $C$ сильної зв'язності визначимо як максимум з значень ${\rm tout}[v]$ для всіх $v \in C$. Крім того, в доведенні теореми будуть упоминаться і часи входу в кожну вершину ${\rm tin}[v]$, і аналогічно визначимо часи входу ${\rm tin}[C]$ для кожної компоненти сильної зв'язності як мінімум з величин ${\rm tin}[v]$ для всіх $v \in C$.

**Теорема**. Нехай $C$ і $C^\prime$ - дві різні компоненти сильної зв'язності, і нехай в графі конденсації між ними є ребро $(C,C^\prime)$. Значить ${\rm tout}[C] > {\rm tout}[C^\prime]$.

При доведенні виникає два принципово різних випадку в залежності від того, в яку з компонент першо] зайдёт обхід в глибину, тобто в залежності від співвідношення між ${\rm tin}[C]$ і ${\rm tin}[C^\prime]$:

* Первой була досягнута компонента $C$. Це означає, що в якийсь момент часу обхід в глибину заходить в деяку вершину $v$ компоненти $C$, при цим всі інші вершини компонент $C$ і $C^\prime$ ще не відвідані. Але, т.до. по умові в графі конденсацій є ребро $(C,C^\prime)$, то з вершини $v$ буде досяжна не тільки вся компонента $C$, але і вся компонента $C^\prime$. Це означає, що при запуску з вершини $v$ обхід в глибину пройдёт по всім вершин компонент $C$ і $C^\prime$, а, значить, вони стануть потомками по відношенню до $v$ в дереві обходу в глибину, тобто для будь-який вершини $u \in C \cup C^\prime, u \ne v$ буде виконано ${\rm tout}[v] > {\rm tout}[u]$, що і треба було довести.
* Первой була досягнута компонента $C^\prime$. Знову ж, в якийсь момент часу обхід в глибину заходить в деяку вершину $v \in C^\prime$, причому всі інші вершини компонент $C$ і $C^\prime$ не відвідані. Оскільки по умові в графі конденсацій існувало ребро $(C,C^\prime)$, то, вследствие ацикличности графа конденсацій, не існує зворотнього шляхи $C^\prime \not\mapsto C$, тобто обхід в глибину з вершини $v$ не досягне вершин $C$. Це означає, що вони будуть відвідані обходом в глибину пізніше, звідки і випливає ${\rm tout}[C] > {\rm tout}[C^\prime]$, що і треба було довести.

Доказанная теорема є **основой алгоритму** пошуку компонент сильної зв'язності. З її випливає, що будь-яке ребро $(C,C^\prime)$ в графі конденсацій йде з компоненти з більшої величиною ${\rm tout}$ в компоненту з меншої величиною.

Якщо ми відсортуємо всі вершини $v \in V$ в порядку зменшення часу виходу ${\rm tout}[v]$, то першо] виявиться деяка вершина $u$, принадлежащая "корневой" компоненті сильної зв'язності, тобто в яку не входити ні одне ребро в графі конденсацій. Тепер нам хотелось б запустити такий обхід з цій вершини $u$, який б посетил тільки цю компоненту сильної зв'язності і не зашёл ні в яку іншу; научившись це робити, ми зможемо поступово виділити всі компоненти сильної зв'язності: видаливши з графа вершини першо] выделенной компоненти, ми знову найдемо серед залишилися вершину з найбільшою величиною ${\rm tout}$, знову запустимо з її цей обхід, і т.д.

Щоб навчитися робити такий обхід, розглянемо **транспонований граф** $G^T$, тобто граф, отриманий з $G$ зміною напрямку кожного ребра на протилежне. Неважко зрозуміти, що в цим графі будуть ті ж компоненти сильної зв'язності, що і в вихідному графі. Більш того, граф конденсації $(G^T)^{\rm SCC}$ для нього буде рівний транспонированному графу конденсації вихідного графа $G^{\rm SCC}$. Це означає, що тепер з розглянутої нами "корневой" компоненти вже не будуть виходити ребра в інші компоненти.

Таким чином, аби обійти всю "корневую" компоненту сильної зв'язності, що містить деяку вершину $v$, достатньо запустити обхід з вершини $v$ в графі $G^T$. Цей обхід посетит всі вершини цій компоненти сильної зв'язності і тільки їх. Як вже говорилося, далі ми можемо подумки вилучити ці вершини з графа, знаходити чергову вершину з максимальним значенням ${\rm tout}[v]$ і запускати обхід на транспонированном графі з її, і т.д.

Отже, ми побудували наступного **алгоритм** выделения компонент сильної зв'язності:

1 крок. Запустить серію обходів в глибину графа $G$, яка повертає вершини в порядку збільшення часу виходу ${\rm tout}$, тобто деякий список $\rm order$.

2 крок. Побудувати транспонований граф $G^T$. Запустить серію обходів в глибину/ширину цього графа в порядку, определяемом списком $\rm order$ (а саме, в зворотньому порядку, тобто в порядку зменшення часу виходу). Кожне множину вершин, достигнутое в результаті чергового запуску обходу, і буде черговий компонентой сильної зв'язності.

**Асимптотика** алгоритму, очевидно, рівна $O(n+m)$, оскільки він представляє собою всього лише два обходу в глибину/ширину.

Нарешті, уместно відзначити зв'язок з понятием **[топологічної сортування](topological_sort)**. По-перше, крок 1 алгоритму представляє собою не що інше, як топологічну сортування графа $G$ (фактично саме це і означає сортування вершин по часу виходу). По-друге, сама схема алгоритму така, що і компоненти сильної зв'язності він генерує в порядку зменшення їх часів виходу, таким чином, він генерує компоненти - вершини графа конденсації в порядку топологічної сортування.

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
vector < vector<int> > g, gr;
vector<char> used;
vector<int> order, component;

void dfs1 (int v) {
    used[v] = true;
    for (size_t i=0; i<g[v].size(); ++i)
        if (!used[ g[v][i] ])
            dfs1 (g[v][i]);
    order.push_back (v);
}

void dfs2 (int v) {
    used[v] = true;
    component.push_back (v);
    for (size_t i=0; i<gr[v].size(); ++i)
        if (!used[ gr[v][i] ])
            dfs2 (gr[v][i]);
}

int main() {
    int n;
    ... читання n ...
    for (;;) {
        int a, b;
        ... читання чергового ребра (a,b) ...
        g[a].push_back (b);
        gr[b].push_back (a);
    }

    used.assign (n, false);
    for (int i=0; i<n; ++i)
        if (!used[i])
            dfs1 (i);
    used.assign (n, false);
    for (int i=0; i<n; ++i) {
        int v = order[n-1-i];
        if (!used[v]) {
            dfs2 (v);
            ... висновок черговий component ...
            component.clear();
        }
    }
}
```

Тут в $\rm g$ зберігається сам граф, а $\rm gr$ - транспонований граф. Функція $\rm dfs1$ виконує обхід в глибину на графі $G$, функція $\rm dfs2$ - на транспонированном $G^T$. Функція $\rm dfs1$ заполняет список $\rm order$ вершинами в порядку збільшення часу виходу (фактично, робить топологічну сортування). Функція $\rm dfs2$ зберігає всі достигнутые вершини в списку $\rm component$, який після кожного запуску буде містити чергову компоненту сильної зв'язності.

## Література

* \book{Томас Кормен, Чарльз Лейзерсон, Рональд Рівест, Кліффорд Штайн}{Алгоритми: Побудова і аналіз}{2005}{cormen.djvu}
* \book{M. Sharir}{A strong-connectivity algorithm and its applications in data-flow
analysis}{1979}
