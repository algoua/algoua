# Знаходження всіх підпаліндромів

## Постановка задачі

Дано рядок $s$ довжини $n$. Потрібно знайти всі такі пари $(i,j)$, де $i<j$, що підрядок $s[i \ldots j]$ є палиндромом (тобто читается одинаково ліворуч направо і справа наліво).

### Уточнение постановки

Зрозуміло, що в гіршому випадку таких підрядків-паліндромів можливо бути $O(n^2)$, і на перший погляд здається, що алгоритму з лінійної асимптотикою існувати не можливо.

Однак інформацію про знайдених палиндромах можна повертати більш **компактно**: для кожної позиції $i=0 \ldots n-1$ найдемо значення $d_1[i]$ і $d_2[i]$, обозначающие кількість паліндромів відповідно непарної і парної довжини з центром в позиції $i$.

Наприклад, в рядка $s = abababc$ є три паліндрома непарної довжини з центром в символі $s[3]=b$, тобто значення $d_1[3]=3$:

$$
a\ \overbrace{b\ a\ \underbrace{b}_{s_3}\ a\ b}^{d_1[3]=3}\ c
$$

А в рядка $s = cbaabd$ є два паліндрома парної довжини з центром в символі $s[3]=a$, тобто значення $d_2[3]=2$:

$$
c\ \overbrace{b\ a\ \underbrace{a}_{s_3}\ b}^{d_2[3]=2}\ d
$$

тобто. ідея - в тому, що якщо є подпалиндром довжини $l$ з центром в якийсь позиції $i$, то є також подпалиндромы довжини $l-2$, $l-4$, і т.д. з центрами в $i$. Тому двох таких масивів $d_1[i]$ і $d_2[i]$ достатньо для зберігання інформації про всіх подпалиндромах цій рядка.

Досить неожиданным фактом є то, що існує досить простий алгоритм, який обчислює ці "масиви палиндромностей" $d_1[]$ і $d_2[]$ за лінійне час. Цей алгоритм і описується в даній статті.

## Розв'язок

Взагалі кажучи, дана задача має декілька відомих рішень: з допомогою [техніки хешування](string_hashes) її можна розв'язати за $O(n \log n)$, а з допомогою [суфіксних дерев](ukkonen) і [швидкого алгоритму LCA](lca_linear) цю задачу можна розв'язати за $O(n)$.

Однак описаний в даній статті метод значно простіше, і володіє меньшими скрытыми константами в асимптотиці часу і пам'яті. Цей алгоритм був відкритий **Гленном Манакером (Glenn Manacher)** в 1975 р.

### Тривіальний алгоритм

Щоб уникнути неоднозначностей при надалі описі условимся, що ж таке є "тривіальний алгоритм".

Це алгоритм, який для пошуку відповіді в позиції $i$ раз за разом пробует збільшити відповідь на одиницю, кожний раз порівнюючи пару відповідних символів.

Такий алгоритм занадто медленен, весь відповідь він можливо порахувати лише за час $O(n^2)$.

Наведемо для наочності його реалізацію:

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> d1(n), d2(n);
for (int i = 0; i < n; ++i) {
    d1[i] = 1;
    while (i - d1[i] >= 0 && i + d1[i] < n && s[i - d1[i]] == s[i + d1[i]])
        ++d1[i];

    d2[i] = 0;
    while (i - d2[i] - 1 >= 0 && i + d2[i] < n && s[i - d2[i] - 1] == s[i + d2[i]])
        ++d2[i];
}
```

### Алгоритм Манакера

Навчимося спочатку знаходити всі подпалиндромы непарної довжини, тобто обчислювати масив $d_1[]$; розв'язок для паліндромів парної довжини (тобто знаходження масиву $d_2[]$) вийде невеликий модификацией цього.

Для швидкого обчислення будемо підтримувати **межі $(l,r)$** самого правого з виявлених подпаліндрома (тобто подпаліндрома з найбільшим значенням $r$). Cпершу можна покласти $l=0, r=-1$.

Отже, нехай ми хочемо обчислити значення $d_1[i]$ для чергового $i$, при цим всі попередні значення $d_1[]$ вже підраховані.

* Якщо $i$ не знаходиться в пределах поточного подпаліндрома, тобто $i > r$, то просто виконаємо тривіальний алгоритм.

тобто. будемо послідовно збільшувати значення $d_1[i]$, і перевіряти кожний раз - правда або поточний підрядок $[i-d_1[i]; i+d_1[i]]$ є палиндромом. Коли ми найдемо перший расхождение, або коли ми дійдемо до границ рядка $s$ - зупиняємося: ми остаточно порахували значення $d_1[i]$. Після цього ми повинні не забути оновити значення $(l,r)$.

* Розглянемо тепер випадок, коли $i \le r$.

Попробуем извлечь частина інформації з вже подсчитанных значень $d_1[]$. А саме, отразим позицію $i$ всередині подпаліндрома $(l,r)$, тобто отримаємо позицію $j = l + (r - i)$, і розглянемо значення $d_1[j]$. Оскільки $j$ - позиція, симетрична позиції $i$, то **майже завжди** ми можемо просто присвоїти $d_1[i] = d_1[j]$. Ілюстрація цього отражения (паліндром навколо $j$ фактично "копируется" в паліндром навколо $i$):

$$
\ldots \overbrace{s_l\ \ldots\ \underbrace{s_{j-d_1[j]+1}\ \ldots\ s_j\ \ldots\ s_{j+d_1[j]-1}}_{\rm palindrome}\ \ldots\ \underbrace{s_{i-d_1[j]+1}\ \ldots\ s_i\ \ldots\ s_{i+d_1[j]-1}}_{\rm palindrome}\ \ldots\ s_r\ \ldots}^{\rm palindrome}
$$

Однак тут є **тонкість**, яку треба обробити правильно: коли "внутрішній паліндром" досягає межі зовнішнього або вилазить за її, тобто $j-d_1[j]+1 \le l$ (або, що то ж саме, $i+d_1[j]-1 \ge r$). Оскільки за кордонами зовнішнього паліндрома ніякий симетрії не гарантируется, то просто присвоїти $d_1[i] = d_1[j]$ буде вже некоректно: у нас недостатньо сведений, аби стверджувати, що в позиції $i$ подпалиндром має таку ж довжину.

Насправді, аби правильно обробляти такі ситуації, треба "обрезать" довжину подпаліндрома, тобто присвоїти $d_1[i] = r - i$. Після цього випливає пустити тривіальний алгоритм, який буде намагатися збільшити значення $d_1[i]$, поки це можливо.

Ілюстрація цього випадку (на ній паліндром з центром в $j$ изображён вже "обрезанным" до такий довжини, що він впритык поміщається у зовнішній паліндром):

$$
\ldots \overbrace{\underbrace{s_l\ \ldots\ s_j\ \ldots\ s_{j+(j-l)}}_{\rm palindrome}\ \ldots\ \underbrace{s_{i-(r-i)}\ \ldots\ s_i\ \ldots\ s_r}_{\rm palindrome}}^{\rm palindrome}\ \underbrace{\ldots\ldots\ldots\ldots}_{\rm try\ moving\ here}
$$

(На цій иллюстрации показано, що, хоча паліндром з центром в позиції $j$ міг бути і більш длинным, выходящим за межі зовнішнього паліндрома, - але в позиції $i$ ми можемо використовувати тільки ту його частина, яка цілком поміщається у зовнішній паліндром. Але відповідь для позиції $i$ можливо бути більше, ніж ця частина, тому далі ми повинні запустити тривіальний пошук, який буде намагатися розсунути його за межі зовнішнього паліндрома, тобто в область "try moving here").

В завершення опису алгоритму сталось тільки напомнить, що треба не забувати оновлювати значення $(l,r)$ після обчислення чергового значення $d_1[i]$.

Також повторимося, що вище ми описали міркування для обчислення масиву непарних паліндромів $d_1[]$; для масиву парних паліндромів $d_2[]$ всі міркування аналогичны.

### Оцінка асимптотики алгоритму Манакера

На перший погляд не очевидно, що даний алгоритм має лінійну асимптотику: при обчисленні відповіді для певної позиції в ньому нерідко запускується тривіальний алгоритм пошуку паліндромів.

Однак більш внимательный аналіз показує, що алгоритм усе ж лине. (Варто сослаться на відомий [алгоритм побудови Z-функції рядка](z_function), який внутренне сильно нагадує даний алгоритм, і працює також за лінійне час).

Насправді, легко проследить по алгоритму, що кожна ітерація, производимая тривіальним пошуком, призводить до збільшення на один межі $r$. При цим зменшень $r$ по ходу алгоритму відбуватися не можливо. Отже, тривіальний алгоритм в сумі зробить лише $O(n)$ дій.

Враховуючи, що, крім тривіальних пошуків, всі інші частини алгоритму Манакера очевидно працюють за лінійне час, ми і отримуємо підсумкову асимптотику: $O(n)$.

### Реалізація алгоритму Манакера

Для випадку підпаліндромів непарної довжини, тобто для обчислення масиву $d_1[]$, отримуємо такий код:

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> d1(n);
int l = 0, r = -1;
for (int i = 0; i < n; ++i) {
    int k = i > r ? 1 : min(d1[l + r - i], r - i + 1);
    while (i + k < n && i - k >= 0 && s[i + k] == s[i - k])
        ++k;
    d1[i] = k;
    if (i + k - 1 > r)
        l = i - k + 1, r = i + k - 1;
}
```

Для підпаліндромів парної довжини, тобто для обчислення масиву $d_2[]$, лише трохи змінюються арифметические вираження:

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> d2(n);
l = 0, r = -1;
for (int i = 0; i < n; ++i) {
    int k = i > r ? 0 : min(d2[l + r - i + 1], r - i + 1);
    while (i + k < n && i - k - 1 >= 0 && s[i + k] == s[i - k - 1])
        ++k;
    d2[i] = k;
    if (i + k - 1 > r)
        l = i - k, r = i + k - 1;
}
```

## Задачі в online judges

Список задач, які можна здати з використанням цього алгоритму:

* [UVA #11475 **"Extend to Palindrome"** [складність: низька]](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2470)
