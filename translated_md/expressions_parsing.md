# Розбір виразів. Зворотня польська нотація

Дано рядок, представляющая собою математическое вираз, содержащее числа, змінні, різні операції. Потрібно обчислити його значення за $O(n)$, де $n$ - довжина рядка.

Тут описаний алгоритм, який переводит це вираз в так звану **зворотню польскую нотацию** (явним або неявным чином), і вже в ній обчислює вираз.

## Зворотня польська нотація

Зворотня польська нотація - це форма записи математических виразів, в якій оператори розташовані після своїх операндов.

Наприклад, випливає вираз:

$$
a + b * c * d + (e - f) * (g * h + i)
$$

в зворотного польської нотації записується наступним чином:

$$
a b c * d * + e f - g h * i + * +
$$

Зворотня польська нотація була разработана австралийским философом і специалистом в області теорії вычислительных машин Чарльзом Хэмблином в середине 1950-х на основі польської нотації, яка була предложена в 1920 р. польским математиком Яном Лукасевичем.

Удобство зворотного польської нотації полягає в тому, що вираження, представленные в такий формі, дуже **легко обчислювати**, причому за лінійне час. Заведемо стек, спершу він порожній. Будемо рухатися ліворуч направо по выражению в зворотного польської нотації; якщо поточний елемент - число або змінна, то кладемо на вершину стека її значення; якщо ж поточний елемент - операція, то дістаємо з стека два верхних елементу (або один, якщо операція унарная), застосовуємо до ним операцію, і результат кладемо назад в стек. В наприкінці кінців в стеці залишиться рівне один елемент - значення вираження.

Очевидно, цей простий алгоритм виконується за $O(n)$, тобто порядку довжини вираження.

## Розбір найпростіших виразів

Поки Що ми розглядаємо тільки найпростіший випадок: всі операції **бинарны** (тобто від двох аргументів), і всі **левоассоциативны** (тобто при рівності пріоритетів виконуються ліворуч направо). Скобки дозволені.

Заведемо два стека: один для чисел, іншої для операцій і дужок (тобто стек символів). Cпершу обидва стека пусты. Для іншого стека будемо підтримувати предусловие, що всі операції впорядковані в ньому по строгому зменшенням пріоритету, якщо рухатися від вершини стека. Якщо в стеці є открывающие дужки, то впорядкований кожний блок операцій, находящийся між дужками, а весь стек в такому випадку не обов'язково впорядкований.

Будемо йти по рядка ліворуч направо. Якщо поточний елемент - цифра або змінна, то покладемо в стек значення цього числа/змінній. Якщо поточний елемент - відкриває дужка, то покладемо її в стек. Якщо поточний елемент - закриває дужка, то будемо виштовхувати з стека і виконувати всі операції до тих пір, поки ми не виберемо відкриває дужку (тобто, інакше кажучи, встречая закриває дужку, ми виконуємо всі операції, що знаходяться всередині цій дужки). Нарешті, якщо поточний елемент - операція, то, поки на вершині стека знаходиться операція з таким ж або великим пріоритетом, будемо виштовхувати і виконувати її.

Після того, як ми опрацюємо всю рядок, в стеці операцій ще можуть остаться деякі операції, які ще не були обчислені, і потрібно виконати їх всі (тобто діємо аналогічно нагоди, коли зустрічаємо закриває дужку).

Ось реалізація даного методу на прикладі звичайних операцій $+-*/\%$:

<!--- TODO: specify code snippet id -->
``` cpp
bool delim(char c) { return c == ' '; }

bool is_op(char c) { return c == '+' || c == '-' || c == '*' || c == '/' || c == '%'; }

int priority(char op) { return op == '+' || op == '-' ? 1 : op == '*' || op == '/' || op == '%' ? 2 : -1; }

void process_op(vector<int> &st, char op) {
    int r = st.back();
    st.pop_back();
    int l = st.back();
    st.pop_back();
    switch (op) {
    case '+':
        st.push_back(l + r);
        break;
    case '-':
        st.push_back(l - r);
        break;
    case '*':
        st.push_back(l * r);
        break;
    case '/':
        st.push_back(l / r);
        break;
    case '%':
        st.push_back(l % r);
        break;
    }
}

int calc(string &s) {
    vector<int> st;
    vector<char> op;
    for (size_t i = 0; i < s.length(); ++i)
        if (!delim(s[i]))
            if (s[i] == '(')
                op.push_back('(');
            else if (s[i] == ')') {
                while (op.back() != '(')
                    process_op(st, op.back()), op.pop_back();
                op.pop_back();
            } else if (is_op(s[i])) {
                char curop = s[i];
                while (!op.empty() && priority(op.back()) >= priority(s[i]))
                    process_op(st, op.back()), op.pop_back();
                op.push_back(curop);
            } else {
                string operand;
                while (i < s.length() && isalnum(s[i])))
                    operand += s[i++];
                --i;
                if (isdigit(operand[0]))
                    st.push_back(atoi(operand.c_str()));
                else
                    st.push_back(get_variable_val(operand));
            }
    while (!op.empty())
        process_op(st, op.back()), op.pop_back();
    return st.back();
}
```

Таким чином, ми навчилися обчислювати значення вираження за $O(n)$, і при цим ми неявно скористалися зворотного польської нотацией: ми расположили операції в такому порядку, коли до моменту обчислення черговий операції обидва її операнда вже обчислені. Слегка модифицировав вищеописаний алгоритм, можна получити вираз в зворотного польської нотаци і в явному вигляді.

## Унарные операції

Тепер припустимо, що вираз містить унарні операції (тобто від одного аргументу). Наприклад, особливо часто зустрічаються унарный плюс і мінус.

Одне з відмінностей цього випадку полягає в необхідності визначення того, є або поточна операція унарною або бінарної.

Можна замітити, що перед унарною операцією завжди варто або інша операція, або відкриває дужка, або взагалі нічого (якщо вона варто в самому початку рядка). Перед бінарної операцією, напротив, завжди варто або операнд (число/змінна), або закриває дужка. Таким чином, достатньо завести який-нибудь прапор для указания того, можливо або наступна операція бути унарною або ні.

Ще чисто реализационная тонкість - як розрізняти унарні і бинарные операції при добуванні з стека і обчисленні. Тут можна, наприклад, для унарних операцій замість символу $s[i]$ класти в стек $-s[i]$.

Приоритет для унарних операцій потрібно вибирати таким, аби він був більше пріоритетів всіх бінарних операцій.

Крім того, треба замітити, що унарні операції фактично є правоассоциативными - якщо поспіль йдуть декілька унарних операцій, то вони повинні обрабатываться справа наліво (для опису цього випадку див. нижче; наведений тут код вже враховує правоассоциативность).

Реалізація для бінарних операцій $+-*/$ і унарних операцій $+-$:

<!--- TODO: specify code snippet id -->
``` cpp
bool delim(char c) { return c == ' '; }

bool is_op(char c) { return c == '+' || c == '-' || c == '*' || c == '/' || c == '%'; }

int priority(char op) {
    if (op < 0)
        return 4; // op == -'+' || op == -'-'
    return op == '+' || op == '-' ? 1 : op == '*' || op == '/' || op == '%' ? 2 : -1;
}

void process_op(vector<int> &st, char op) {
    if (op < 0) {
        int l = st.back();
        st.pop_back();
        switch (-op) {
        case '+':
            st.push_back(l);
            break;
        case '-':
            st.push_back(-l);
            break;
        }
    } else {
        int r = st.back();
        st.pop_back();
        int l = st.back();
        st.pop_back();
        switch (op) {
        case '+':
            st.push_back(l + r);
            break;
        case '-':
            st.push_back(l - r);
            break;
        case '*':
            st.push_back(l * r);
            break;
        case '/':
            st.push_back(l / r);
            break;
        case '%':
            st.push_back(l % r);
            break;
        }
    }
}

int calc(string &s) {
    bool may_unary = true;
    vector<int> st;
    vector<char> op;
    for (size_t i = 0; i < s.length(); ++i)
        if (!delim(s[i]))
            if (s[i] == '(') {
                op.push_back('(');
                may_unary = true;
            } else if (s[i] == ')') {
                while (op.back() != '(')
                    process_op(st, op.back()), op.pop_back();
                op.pop_back();
                may_unary = false;
            } else if (is_op(s[i])) {
                char curop = s[i];
                if (may_unary && isunary(curop))
                    curop = -curop;
                while (!op.empty() && (curop >= 0 && priority(op.back()) >= priority(curop) || curop < 0 && priority(op.back()) > priority(curop)))
                    process_op(st, op.back()), op.pop_back();
                op.push_back(curop);
                may_unary = true;
            } else {
                string operand;
                while (i < s.length() && isalnum(s[i])))
                    operand += s[i++];
                --i;
                if (isdigit(operand[0]))
                    st.push_back(atoi(operand.c_str()));
                else
                    st.push_back(get_variable_val(operand));
                may_unary = false;
            }
    while (!op.empty())
        process_op(st, op.back()), op.pop_back();
    return st.back();
}
```

Варто замітити, що в найпростіших випадках, наприклад, коли з унарних операцій дозволені тільки $+$ і $-$, правоассоциативность не играет ніякий роли, тому в таких ситуациях ніяких усложнений в схему можна не вводить. тобто. цикл:

<!--- TODO: specify code snippet id -->
``` cpp
while (!op.empty() && (curop >= 0 && priority(op.back()) >= priority(curop) || curop < 0 && priority(op.back()) > priority(curop)))
    process_op(st, op.back()), op.pop_back();
```

Можна замінити на:

<!--- TODO: specify code snippet id -->
``` cpp
while (!op.empty() && priority(op.back()) >= priority(curop))
    process_op(st, op.back()), op.pop_back();
```

## Правоассоциативность

Правоассоциативность оператора означає, що при рівності пріоритетів оператори обчислюються справа наліво (соотвественно, левоассоциативность - коли ліворуч направо).

Як вже було отмечено вище, унарні оператори зазвичай є правоассоциативными. Інший приклад - зазвичай операція піднесення в ступінь вважається правоассоциативной (дійсно, a^b^c зазвичай воспринимается як a^(b^c), а не (a^b)^c).

Які отличия потрібно внести в алгоритм, аби правильно обробляти правоассоциативность? Насправді, зміни потрібні самі минимальные. Єдине відміну буде проявляться тільки при рівності пріоритетів, і полягає воно в тому, що операції з рівним пріоритетом, що знаходяться на вершині стека, не повинні виконувати раніше поточній операції.

Таким чином, единственные отличия потрібно внести в функцію calc:

<!--- TODO: specify code snippet id -->
``` cpp
int calc(string &s) { ... while (!op.empty() && (left_assoc(curop) && priority(op.back()) >= priority(curop) || !left_assoc(curop) && priority(op.back()) > priority(curop)))... }
```
