# Решето Ератосфена

Решето Ератосфена - це алгоритм, дозволяє знайти всі прості числа в відрізку $[1; n]$ за $O(n \log \log n)$ операцій.

Ідея проста - запишемо ряд чисел $1 \ldots n$, і будемо вычеркивать спочатку всі числа, делящиеся на $2$, крім самого числа $2$, потім деляющиеся на $3$, крім самого числа $3$, потім на $5$, потім на $7$, $11$, і всі інші прості до $n$.

## Реалізація

Відразу наведемо реалізацію алгоритму:

<!--- TODO: specify code snippet id -->
``` cpp
int n;
vector<char> prime (n+1, true);
prime[0] = prime[1] = false;
for (int i=2; i<=n; ++i)
    if (prime[i])
        if (i * 1ll * i <= n)
            for (int j=i*i; j<=n; j+=i)
                prime[j] = false;
```

Цей код спочатку позначає всі числа, крім нуля і одиниці, як прості, а потім починає процес отсеивания составных чисел. Для цього ми перебираємо в циклі всі числа від $2$ до $n$, і, якщо поточний число $i$ просте, то помічаємо всі числа, кратні йому, як складові.

При цим ми починаємо йти від $i^2$, оскільки всі менші числа, кратні $i$, обов'язково мають простий дільник менше $i$, а значить, всі вони вже були отсеяны раніше. (Але оскільки $i^2$ легко можливо переполнить тип $int$, в коді перед іншим вложенным циклом робиться дополнительная перевірка з використанням типу $long~long$).

При такий реалізації алгоритм споживає $O(n)$ пам'яті (що очевидно) і виконує $O(n \log \log n)$ дій (це доводиться в наступному розділі).

## Асимптотика

Доведемо, що асимптотика алгоритму рівна $O(n \log \log n)$.

Отже, для кожного простого $p \le n$ буде виконуватися внутрішній цикл, який зробить $\frac{n}{p}$ дій. Отже, нам потрібно оцінити наступну величину:

$$
\sum_{ \scriptstyle p \le n, \atop\scriptstyle p~is~prime } \frac{n}{p} = n \cdot \sum_{ \scriptstyle p \le n, \atop\scriptstyle p~is~prime } \frac{1}{p}.
$$

Згадаймо тут два відомих факту: що число простих, менше або рівних $n$, приблизно рівне $\frac{n}{\ln n}$, і що $k$-е просте число приблизно рівне $k \ln k$ (це випливає з першого затвердження). Значить суму можна записати таким чином:

$$
\sum_{ \scriptstyle p \le n, \atop\scriptstyle p~is~prime } \frac{1}{p} \approx \frac{1}{2} + \sum_{k=2}^{\frac{n}{\ln n}} \frac{1}{k \ln k}.
$$

Тут ми выделили перший просте з суми, оскільки при $k = 1$ згідно приближению $k \ln k$ вийде $0$, що приведе до делению на нуль.

Тепер оцінимо таку суму з допомогою интеграла від тією ж функції по $k$ від $2$ до $\frac{n}{\ln n}$ (ми можемо виробляти таке наближення, оскільки, фактично, сума відноситься до интегралу як його наближення по формулою прямоугольников):

$$
\sum_{k=2}^{\frac{n}{\ln n}} \frac{1}{k \ln k} \approx \int\limits_2^{\frac{n}{\ln n}} \frac{1}{k \ln k}\ dk.
$$

Первообразная для подынтегральной функції є $\ln \ln k$. Выполняя подстановку і убирая члены меншого порядку, отримуємо:

$$
\int\limits_2^{\frac{n}{\ln n}} \frac{1}{k \ln k}\ dk = \ln \ln \frac{n}{\ln n} - \ln \ln 2 = \ln (\ln n - \ln \ln n) - \ln \ln 2 \approx \ln \ln n.
$$

Тепер, возвращаясь до первоначальной сумі, отримуємо її приближённую оцінку:

$$
\sum_{ \scriptstyle p \le n, \atop\scriptstyle p~is~prime } \frac{n}{p} \approx n \ln \ln n + o(n),
$$

що і потрібно довести.

Більш строгое доведення (і дающее більш точную оцінку з точністю до константных множителей) можна знайти в книзі Hardy і Wright "An Introduction to the Theory of Numbers" (стр. 349).

## Различные оптимізації решета Ератосфена

Самий великий недолік алгоритму - то, що він "гуляет" по пам'яті, постійно выходя за межі кэш-пам'яті, з-за чого константа, прихована в  $O(n \log \log n)$, порівняно велика.

Крім того, для достатньо великих $n$ узким местом стає об'єм використаної пам'яті.

Нижче розглянуті методи, дозволяють як зменшити число выполняемых операцій, так і значно скоротити потребление пам'яті.

### Просеивание простими до кореня

Самий очевидний момент - що для того, аби знайти всі прості до $n$, достатньо виконати просіювання тільки простими, не переважаючими кореня з $n$.

Таким чином, зміниться зовнішній цикл алгоритму:

<!--- TODO: specify code snippet id -->
``` cpp
for (int i=2; i*i<=n; ++i)
```

На асимптотику така оптимізація не впливає (дійсно, повторив приведённое вище доведення, ми отримаємо оцінку $n \ln \ln \sqrt{n} + o(n)$, що, по свойствам логарифма, асимптотично є то ж саме), хоча число операцій помітно зменшиться.

### Решето тільки по непарним числах

Оскільки всі парні числа, крім $2$, - складові, то можна взагалі не обробляти ніяк парні числа, а оперировать тільки непарними числами.

По-перше, це дозволить вдвічі скоротити об'єм необхідної пам'яті. По-друге, це уменьшит число делаемых алгоритмом операцій приблизно вдвічі.

### Уменьшение объёма використаної пам'яті

Зауважимо, що алгоритм Ератосфена фактично оперирует з $n$ бітами пам'яті. Отже, можна істотно сэкономить потребление пам'яті, храня не $n$ байт - змінних булевского типу, а $n$ біт, тобто $n/8$ байт пам'яті.

Однак такий підхід - **"бітове стиснення"** - істотно усложнит оперирование цими бітами. Будь-яке читання або запис біта будуть представляти з собі декілька арифметических операцій, що в підсумку приведе до замедлению алгоритму.

Таким чином, цей підхід оправдан, тільки якщо $n$ настільки велике, що $n$ байт пам'яті виділити вже не можна. Сэкономив пам'ять (в $8$ раз), ми заплатим за це существенным замедлением алгоритму.

В завершення варто відзначити, що в мові C++ вже реалізовані контейнеры, автоматично осуществляющие бітове стиснення: vector<bool> і bitset<>. Втім, якщо швидкість роботи дуже важна, то краще реалізувати бітове стиснення вручну, з допомогою бітових операцій - на сегодняшний день компілятори усе ж не в стані генерировать достатньо швидкий код.

### Блочное решето

З оптимізації "просіювання простими до кореня" випливає, що ні необхідності зберігати усе час весь масив $prime[1 \ldots n]$. Для виконання просеивания достатньо зберігати тільки прості до кореня з $n$, тобто $prime[1 \ldots \sqrt{n}]$, а остальную частина масиву $prime$ будувати поблочно, храня в поточний момент часу тільки один блок.

Нехай $s$ - константа, определяющая розмір блоку, тоді всього буде $\left\lceil \frac{n}{s} \right\rceil$ блоків, $k$-ый блок ($k = 0 \ldots \left\lfloor \frac{n}{s} \right\rfloor$) містить числа в відрізку $[ks; ks+s-1]$. Будемо обробляти блоки по черги, тобто для кожного $k$-го блоку будемо перебирати всі прості (від $1$ до $\sqrt{n}$) і виконувати ними просіювання тільки всередині поточного блоку. Аккуратно варто обробляти перший блок - у-перших, прості з $[1; \sqrt{n}]$ не повинні вилучити самі собі, а у-вторых, числа $0$ і $1$ повинні особливо помечаться як не прості. При обробці останнього блоку також випливає не забувати про тому, що останнє потрібне число $n$ не обов'язково знаходиться в наприкінці блоку.

Наведемо реалізацію блочного решета. Програма зчитує число $n$ і знаходить кількість простих від $1$ до $n$:

<!--- TODO: specify code snippet id -->
``` cpp
const int SQRT_MAXN = 100000; // корінь з максимального значення N
const int S = 10000;
bool nprime[SQRT_MAXN], bl[S];
int primes[SQRT_MAXN], cnt;

int main() {

    int n;
    cin >> n;
    int nsqrt = (int) sqrt (n + .0);
    for (int i=2; i<=nsqrt; ++i)
        if (!nprime[i]) {
            primes[cnt++] = i;
            if (i * 1ll * i <= nsqrt)
                for (int j=i*i; j<=nsqrt; j+=i)
                    nprime[j] = true;
        }

    int result = 0;
    for (int k=0, maxk=n/S; k<=maxk; ++k) {
        memset (bl, 0, sizeof bl);
        int start = k * S;
        for (int i=0; i<cnt; ++i) {
            int start_idx = (start + primes[i] - 1) / primes[i];
            int j = max(start_idx,2) * primes[i] - start;
            for (; j<S; j+=primes[i])
                bl[j] = true;
        }
        if (k == 0)
            bl[0] = bl[1] = true;
        for (int i=0; i<S && start+i<=n; ++i)
            if (!bl[i])
                ++result;
    }
    cout << result;

}
```

Асимптотика блочного решета така ж, як і звичайного решета Ератосфена (якщо, звісно, розмір $s$ блоків не буде зовсім маленьким), зате об'єм используемой пам'яті скоротиться до $O(\sqrt{n} + s)$ і зменшиться "блуждание" по пам'яті. Але, з іншої сторони, для кожного блоку для кожного простого з $[1; \sqrt{n}]$ буде виконуватися поділ, що буде сильно сказываться при менших размерах блоку. Отже, при виборі константи $s$ необхідно соблюсти баланс.

Як показывают эксперименты, наилучшая швидкість роботи досягається, коли $s$ має значення приблизно від $10^4$ до $10^5$.

### Улучшение до лінійного часу роботи

Алгоритм Ератосфена можна преобразовать в іншої алгоритм, який вже буде працювати за лінійне час - див. статтю ["Решето Ератосфена з лінійним часом роботи"](prime_sieve_linear). (Втім, цей алгоритм має і недостатки).
