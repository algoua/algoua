# Біноміальні коефіцієнти

Биномиальным коефіцієнтом $C_n^k$ називається кількість способів вибрати набір $k$ предметов з $n$ різних предметов без обліку порядку расположения цих елементів (тобто кількість неупорядоченных наборов).

Також биномиальные коефіцієнти - це коффициенты в разложении $(a+b)^n$ (т.н. біном Ньютона):

$$
(a+b)^n = C_n^0 a^n + C_n^1 a^{n-1} b + C_n^2 a^{n-2} b^2 + \ldots + C_n^k a^{n-k} b^k + \ldots + C_n^n b^n
$$

Вважається, що цю формулу, як і трикутник, дозволяє ефективно знаходити коефіцієнти, відкрив Блез Паскаль (Blaise Pascal), живший в 17 в. Тим не менш, вона була відома ще китайскому математику Яну Хуэю (Yang Hui), жившему в 13 в. Возможно, її відкрив персидский учёный Омар Хайям (Omar Khayyam). Більш того, индийский математик Пингала (Pingala), живший ще в 3 в. до н.е., отримав близкие результати. Заслуга ж Ньютона полягає в тому, що він обобщил цю формулу для степеней, не являющихся натуральными.

## Обчислення

**Аналитическая формула** для обчислення:

$$
C_n^k = \frac{n!}{k! (n-k)!}
$$

Цю формулу легко вивести з задачі про неупорядоченной выборке (кількість способів неупорядоченно вибрати $k$ елементів з $n$ елементів). Спочатку порахуємо кількість упорядкованих выборок. Выбрать перший елемент є $n$ способів, другий - $n-1$, третий - $n-2$, і так далі. В результаті для числа упорядкованих выборок отримуємо формулу: $ n (n-1) (n-2) \ldots (n-k+1) = \frac{n!}{(n-k)!} $. До неупорядоченным выборкам легко перейти, якщо замітити, що кожної неупорядоченной выборке відповідає рівне $k!$ упорядкованих (т.до. це кількість всіляких перестановок $k$ елементів). В результаті, деля $\frac{n!}{(n-k)!}$ на $k!$, ми і отримуємо шукану формулу.

**Рекуррентная формула** (з якій связан знаменитый "трикутник Паскаля"):

$$
C_n^k = C_{n-1}^{k-1} + C_{n-1}^k
$$

Її легко вивести через предыдущую формулу.

Варто замітити особливо, при $n<k$ значення $C_n^k$ завжди покладається рівним нулю.

## Властивості

Біноміальні коефіцієнти мають безліччю різних властивостей, наведемо найбільш прості з них:

* Правило симетрії:

$$
C_n^k = C_n^{n-k}
$$

* Внесение-вынесение:

$$
C_n^k = \frac{n}{k} C_{n-1}^{k-1}
$$

* Підсумовування по $k$:

$$
\sum_{k=0}^n C_n^k = 2^n
$$

* Підсумовування по $n$:

$$
\sum_{m=0}^n C_m^k = C_{n+1}^{k+1}
$$

* Підсумовування по $n$ і $k$:

$$
\sum_{k=0}^{m} C_{n+k}^k = C_{n+m+1}^m
$$

* Підсумовування квадратів:

$$
(C_n^0)^2 + (C_n^1)^2 + \ldots + (C_n^n)^2 = C_{2n}^n
$$

* Взвешенное підсумовування:

$$
1 C_n^1 + 2 C_n^2 + \ldots + n C_n^n = n 2^{n-1}
$$

* Cвязь з [числами Фібоначчі](fibonacci_numbers):

$$
C_n^0 + C_{n-1}^1 + \ldots + C_{n-k}^k + \ldots + C_0^n = F_{n+1}
$$

## Вычисления в програмі

### Непосредственные обчислення по аналитической формулою

Вычисления по першо], непосредственной формулою, дуже легко программировать, однак цей спосіб подвержен переполнениям навіть при порівняно невеликих значениях $n$ і $k$ (навіть якщо відповідь цілком поміщається в який-нибудь тип данних, обчислення промежуточных факториалов можливо привести до переполнению). Тому дуже часто цей спосіб можна застосовувати тільки разом з [[Довга арифметика|Длинной арифметикой]]:

<!--- TODO: specify code snippet id -->
``` cpp

int C (int n, int k) {
    int res = 1;
    for (int i=n-k+1; i<=n; ++i)
        res *= i;
    for (int i=2; i<=k; ++i)
        res /= i;
}
```

### Покращена реалізація

Можна замітити, що в наведеної вище реалізації в числителе і знаменателе варто однакове кількість сомножителей ($k$), кожний з яких не менше одиниці. Тому можна замінити нашу дріб на добуток $k$ дробів, кожна з яких є вещественнозначной. Однак, можна замітити, що після домножения поточного відповіді на кожну чергову дріб усе рівне буде виходити ціле число (це, наприклад, випливає з властивості "внесения-вынесения"). Таким чином, отримуємо таку реалізацію:

<!--- TODO: specify code snippet id -->
``` cpp

int C (int n, int k) {
    double res = 1;
    for (int i=1; i<=k; ++i)
        res = res * (n-k+i) / i;
    return (int) (res + 0.01);
}
```

Тут ми акуратно наводимо дробове число до цілому, враховуючи, що з-за накапливающихся похибок воно можливо виявитися трохи менше истинного значення (наприклад, $2.99999$ замість трьох).

### Треугольник Паскаля

З використанням ж рекуррентного співвідношення можна побудувати таблицю биномиальных коефіцієнтів (фактично, трикутник Паскаля), і з її брати результат. Перевага цього методу в тому, що проміжні результати ніколи не перевершують відповіді, і для обчислення кожного нового елементу таблиці треба всього лише одне складання. Недоліком є медленная робота для великих N і K, якщо насправді таблица не потрібна, а потрібно єдине значення (тому що для обчислення $C_n^k$ знадобиться будувати таблицю для всіх $C_i^j,\ \ 1 \le i \le n,\ \ 1 \le j \le n$, або хоча б до $1 \le j \le \min(i,2k)$).

<!--- TODO: specify code snippet id -->
``` cpp

const int maxn = ...;
int C[maxn+1][maxn+1];
for (int n=0; n<=maxn; ++n) {
    C[n][0] = C[n][n] = 1;
    for (int k=1; k<n; ++k)
        C[n][k] = C[n-1][k-1] + C[n-1][k];
}
```

Якщо вся таблица значень не потрібна, то, як неважко замітити, достатньо зберігати від її тільки дві стрічки (поточну - $n$-ую стрічку і предыдущую - $n-1$-ую).

### Обчислення за O(1)

Нарешті, в деяких ситуациях виявляється вигідно предпосчітать заздалегідь значення всіх факториалов, з тим, аби згодом вважати будь-який необходимый биномиальный коефіцієнт, производя лише два ділення. Це можливо бути вигідно при використанні [Длинной арифметики](big_integer), коли пам'ять не дозваляє предпосчітать весь трикутник Паскаля, або ж коли потрібно виробляти расчёты по деякого простому модулю (якщо модуль не простий, то виникають складності при делении числителя дроби на знаменник; їх можна преодолеть, якщо факторизовать модуль і зберігати всі числа в вигляді векторів з степеней цих простих; см [раздел "Довга арифметика в факторизованном вигляді"](big_integer)).
