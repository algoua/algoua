# Знаходження найкоротших шляхів від заданої вершини до всіх інших вершин алгоритмом Дейкстри

## Постановка задачі

Дан орієнтований або неорієнтований зважений граф з $n$ вершинами і $m$ ребрами. Веса всіх ребер невід'ємні. Указана деяка стартова вершина $s$. Потрібно знайти довжини найкоротших шляхів з вершини $s$ у всі інші вершини, а також предоставить спосіб виведення самих найкоротших шляхів.

Ця задача називається "завданням про найкоротших шляхах з єдиним источником" (single-source shortest paths problem).

## Алгоритм

Тут описується алгоритм, який запропонував голландский исследователь **Дейкстра** (Dijkstra) в 1959 р.

Заведемо масив $d[]$, в якому для кожної вершини $v$ будемо зберігати поточну довжину $d[v]$ найкоротшого шляхи з $s$ в $v$. Cпершу $d[s]=0$, а для всіх інших вершин ця довжина рівна нескінченності (при реалізації на комп'ютері зазвичай в якості нескінченності выбирают просто достатньо велике число, свідомо більше возможной довжини шляхи):

$$
d[v] = \infty, v \ne s
$$

Крім того, для кожної вершини $v$ будемо зберігати, позначена вона ще або ні, тобто заведемо булевий масив $u[]$. Cпершу всі вершини не позначені, тобто

$$
u[v] = {\rm false}
$$

Сам алгоритм Дейкстри складається з $n$ **ітерацій**. На черговий ітерації вибирається вершина $v$ з найменшою величиною $d[v]$ серед ще не помічених, тобто:

$$
d[v] = \min_{p:\ u[p]={\rm false}} d[p]
$$

(Зрозуміло, що на першо] ітерації обрана буде стартова вершина $s$).

Выбранная таким чином вершина $v$ отмечается поміченої. Далі, на поточній ітерації, з вершини $v$ виробляються **релаксації**: проглядаються всі ребра $(v,to)$, вихідні з вершини $v$, і для кожної такий вершини $to$ алгоритм намагається покращити значення $d[to]$. Нехай довжина поточного ребра рівна $\rm len$, тоді в вигляді коду релаксація виглядає як:

$$
d[to] = \min (d[to], d[v] + {\rm len})
$$

На цим поточна ітерація закінчується, алгоритм переходити до наступного ітерації (знову вибирається вершина з найменшою величиною $d$, з її виробляються релаксації, і т.д).. При цим в наприкінці кінців, після $n$ ітерацій, всі вершини графа стануть помеченными, і алгоритм свою роботу завершує. Стверджується, що знайдені значення $d[v]$ і є шукані довжини найкоротших шляхів з $s$ в $v$.

Варто замітити, що, якщо не всі вершини графа досяжні з вершини $s$, то значення $d[v]$ для них так і залишаться бесконечными. Зрозуміло, що декілька останніх ітерацій алгоритму будуть як раз вибирати ці вершини, але ніякий корисної роботи виробляти ці ітерації не будуть (оскільки нескінченне відстань не зможе прорелаксировать інші, навіть теж нескінченні відстані). Тому алгоритм можна зразу зупиняти, як тільки в якості обраної вершини береться вершина з бесконечным відстанню.

**Відновлення шляхів**. Зрозуміло, зазвичай потрібно знати не тільки довжини найкоротших шляхів, але і получити самі шляхи. Покажемо, як зберегти інформацію, достаточную для последующего відновлення найкоротшого шляхи з $s$ до будь-який вершини. Для цього достатньо так называемого **масиву предків**: масиву $p[]$, в якому для кожної вершини $v \ne s$ зберігається номер вершини $p[v]$, є предпоследней в найкоротшому шляхи до вершини $v$. Тут використовується той факт, що якщо ми візьмемо найкоротший шлях до якийсь вершини $v$, а потім видалимо з цього шляхи останню вершину, то вийде шлях, закінчується деякої вершиною $p[v]$, і цей шлях буде найкоротшим для вершини $p[v]$. Отже, якщо ми будемо володіти цим масивом предків, то найкоротший шлях можна буде відновити по нього, просто кожний раз беручи предка від поточній вершини, поки ми не прийдемо в стартову вершину $s$ - так ми отримаємо шуканий найкоротший шлях, але записанный в зворотньому порядку. Отже, найкоротший шлях $P$ до вершини $v$ рівний:

$$
P = (s, \ldots, p[p[p[v]]], p[p[v]], p[v], v)
$$

Залишилося зрозуміти, як будувати цей масив предків. Однак це робиться дуже просто: при кожної успешной релаксації, тобто коли з обраної вершини $v$ відбувається поліпшення відстані до деякої вершини $to$, ми записываем, що предком вершини $to$ є вершина $v$:

$$
p[to] = v
$$

## Доведення

**Основное твердження**, на якому заснована коректність алгоритму Дейкстри, випливає. Стверджується, що після того як яка-або вершина $v$ стає поміченої, поточний відстань до її $d[v]$ вже є найкоротшим, і, відповідно, більше змінюватися не буде.

**Доведення** будемо виробляти по індукції. Для першо] ітерації справедливость його очевидна - для вершини $s$ маємо $d[s]=0$, що і є довжиною найкоротшого шляхи до її. Нехай тепер це твердження виконано для всіх попередніх ітерацій, тобто всіх вже помічених вершин; доведемо, що воно не нарушается після виконання поточній ітерації. Нехай $v$ - вершина, обрана на поточній ітерації, тобто вершина, яку алгоритм собирается пометить. Доведемо, що $d[v]$ дійсно рівне довжині найкоротшого шляхи до її (позначимо цю довжину через $l[v]$).

Розглянемо найкоротший шлях $P$ до вершини $v$. Зрозуміло, цей шлях можна розбити на два шляхи: $P_1$, состоящий тільки з помічених вершин (як мінімум стартова вершина $s$ буде в цим шляхи), і остальная частина шляхи $P_2$ (вона теж можливо включать помеченные вершини, але починається обов'язково з непомеченной). Позначимо через $p$ першу вершину шляхи $P_2$, а через $q$ - останню вершини шляхи $P_1$.

Доведемо спочатку наше твердження для вершини $p$, тобто доведемо рівність $d[p] = l[p]$. Однак це практично очевидно: адже на однієї з попередніх ітерацій ми выбирали вершину $q$ і выполняли релаксацію з її. Оскільки (в силу самого вибору вершини $p$) найкоротший шлях до $p$ рівний кратчайшему шляхи до $q$ плюс ребро $(p,q)$, то при виконанні релаксації з $q$ величина $d[p]$ дійсно установится в необхідну значення.

Вследствие неотрицательности вартостей ребер довжина найкоротшого шляхи $l[p]$ (а вона по тільки що доказанному рівна $d[p]$) не перевершує довжини $l[v]$ найкоротшого шляхи до вершини $v$. Враховуючи, що $l[v] \le d[v]$ (адже алгоритм Дейкстри не міг знайти більш короткого шляхи, ніж це взагалі можливо), в підсумку отримуємо співвідношення:

$$
d[p] = l[p] \le l[v] \le d[v]
$$

З іншої сторони, оскільки і $p$, і $v$ - вершини непомеченные, то так як на поточній ітерації була обрана саме вершина $v$, а не вершина $p$, то отримуємо інше нерівність:

$$
d[p] \ge d[v]
$$

З цих двох нерівностей заключаем рівність $d[p] = d[v]$, а тоді з знайдених до цього соотношений отримуємо і:

$$
d[v] = l[v]
$$

що і потрібно довести.

## Реалізація

Отже, алгоритм Дейкстри представляє собою $n$ ітерацій, на кожної з яких вибирається непомеченная вершина з найменшою величиною $d[v]$, ця вершина позначається, і потім проглядаються всі ребра, вихідні з даній вершини, і уздовж кожного ребра робиться спроба покращити значення $d[]$ на другом наприкінці ребра.

Час роботи алгоритму складається з:

* $n$ раз пошук вершини з найменшою величиною $d[v]$ серед всіх непомеченных вершин, тобто серед $O(n)$ вершин
* $m$ раз виготовляється спроба релаксаций

При найпростішої реалізації цих операцій на пошук вершини буде затрачиваться $O(n)$ операцій, а на одну релаксацію - $O(1)$ операцій, і підсумкова **асимптотика** алгоритму становить:

$$
O(n^2+m)
$$

**Реалізація**:

<!--- TODO: specify code snippet id -->
``` cpp
const int INF = 1000000000;

int main() {
    int n;
    ... читання n ...
    vector < vector < pair<int,int> > > g (n);
    ... читання графа ...
    int s = ...; // стартова вершина

    vector<int> d (n, INF),  p (n);
    d[s] = 0;
    vector<char> u (n);
    for (int i=0; i<n; ++i) {
        int v = -1;
        for (int j=0; j<n; ++j)
            if (!u[j] && (v == -1 || d[j] < d[v]))
                v = j;
        if (d[v] == INF)
            break;
        u[v] = true;

        for (size_t j=0; j<g[v].size(); ++j) {
            int to = g[v][j].first,
                len = g[v][j].second;
            if (d[v] + len < d[to]) {
                d[to] = d[v] + len;
                p[to] = v;
            }
        }
    }
}
```

Тут граф $g$ зберігається в вигляді списків суміжності: для кожної вершини $v$ список $g[v]$ містить список ребер, вихідних з цій вершини, тобто список пар $\rm pair<int,int>$, де перший елемент пари - вершина, в яку веде ребро, а другий елемент - вага ребра.

Після читання заводятся масиви відстаней $d[]$, міток $u[]$ і предків $p[]$. Потім виконуються $n$ ітерацій. На кожної ітерації спочатку знаходиться вершина $v$, має найменше відстань $d[]$ серед непомеченных вершин. Якщо відстань до обраної вершини $v$ виявляється рівним нескінченності, то алгоритм зупиняється. Інакше вершина позначається як помеченная, і проглядаються всі ребра, вихідні з даній вершини, і уздовж кожного ребра виконуються релаксації. Якщо релаксація успешна (тобто відстань $d[to]$ змінюється), то перераховується відстань $d[to]$ і зберігається предок $p[]$.

Після виконання всіх ітерацій в масиві $d[]$ виявляються довжини найкоротших шляхів до всіх вершин, а в масиві $p[]$ - предки всіх вершин (крім стартової $s$). Восстановить шлях до будь-який вершини $t$ можна наступним чином:
<!--- TODO: specify code snippet id -->
``` cpp
vector<int> path;
for (int v=t; v!=s; v=p[v])
    path.push_back (v);
path.push_back (s);
reverse (path.begin(), path.end());
```

## Література

* \book{Томас Кормен, Чарльз Лейзерсон, Рональд Рівест, Кліффорд Штайн}{Алгоритми: Побудова і аналіз}{2005}{cormen.djvu}
* \book{Edsger Dijkstra}{A note on two problems in connexion with graphs}{1959}
