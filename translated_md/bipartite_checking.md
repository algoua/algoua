# Перевірка графа на дводольні і розбиття на дві частки

Нехай дано неорієнтований граф. Потрібно перевірити, є або він дводольним, тобто можна або розділити його вершини на дві частки так, аби не було ребер, з'єднують дві вершини однієї частки. Якщо граф є дводольним, то вивести самі частки.

Вирішимо цю задачу з допомогою [пошуку в ширину](bfs) за O (M).

## Признак дводольні

Теорема. Граф є дводольним тоді і тільки тоді, коли всі його прості цикли мають парну довжину.

Втім, з практической точки зору шукати всі прості цикли неудобно. Намного простіше перевіряти граф на дводольні наступним алгоритмом:

## Алгоритм

Зробимо серію пошуків в ширину. тобто. будемо запускати пошук в ширину з кожної непосещённой вершини. Ту вершину, з якій ми починаємо йти, ми поміщаємо в першу долю. В процесі пошуку в ширину, якщо ми йдемо в якусь нову вершину, то ми поміщаємо її в долю, отличную від частки поточній вершину. Якщо ж ми намагаємося пройти по ребру в вершину, яка вже переглянуло, то ми перевіряємо, аби ця вершина і поточна вершина знаходилися в різних частках. В іншому випадку граф дводольним не є.

За закінченні роботи алгоритму ми або виявимо, що граф не двудолен, або найдемо розбиття вершин графа на дві частки.

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
int n;
vector < vector<int> > g;
... читання графа ...

vector<char> part (n, -1);
bool ok = true;
vector<int> q (n);
for (int st=0; st<n; ++st)
    if (part[st] == -1) {
        int h=0, t=0;
        q[t++] = st;
        part[st] = 0;
        while (h<t) {
            int v = q[h++];
            for (size_t i=0; i<g[v].size(); ++i) {
                int to = g[v][i];
                if (part[to] == -1)
                    part[to] = !part[v],  q[t++] = to;
                else
                    ok &= part[to] != part[v];
            }
        }
    }

puts (ok ? "YES" : "NO");
```
