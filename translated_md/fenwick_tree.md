# Дерево Фенвіка

**Дерево Фенвіка** - це структура данних, дерево на масиві, обладающее следующими свойствами:

1) дозваляє обчислювати значення деякої обратимой операції G на будь-якому відрізку [L; R] за час **O (log N)**;

2) дозваляє змінювати значення будь-якого елементу за **O (log N)**;

3) вимагає **O (N) пам'яті**, а точніше, рівне стільки ж, скільки і масив з N елементів;

4) легко узагальнюється на випадок многомерных масивів.

Найбільш распространённое застосування дерева Фенвіка - для обчислення суми на відрізку, тобто функція G (X1, ..., Xk) = X1 + ... + Xk.

Дерево Фенвіка було вперше описано в статті "A new data structure for cumulative frequency tables" (Peter M. Fenwick, 1994).

## Опис

Для простоти опису ми припускаємо, що операція G, по якій ми будуємо дерево, - це **сума**.

Нехай дано масив A[0..N-1]. Дерево Фенвіка - масив **T**[0..N-1], в кожному елементі якого зберігається сума деяких елементів масиву A:

$$
**T<sub>i</sub> = сума A<sub>j</sub>** для всіх **F(i) <= j <= i**,
$$

де F(i) - деяка функція, яку ми визначимо декілька пізніше.

Тепер ми вже можемо написати **псевдокод** для функції обчислення суми на відрізку [0; R] і для функції зміни осередки:

<!--- TODO: specify code snippet id -->
``` cpp
int sum (int r)
{
    int result = 0;
    while (r >= 0) {
        result += t[r];
        r = f(r) - 1;
    }
    return result;
}

void inc (int i, int delta)
{
    для всіх j, для яких F(j) <= i <= j
    {
        t[j] += delta;
    }
}
```
Функція sum працює наступним чином. Замість того аби йти по всім елементам масиву A, вона рухається по масиву T, роблячи "прыжки" через відрізки там, де це можливо. Спочатку вона додає до відповіді значення суми на відрізку [F(R); R], потім бере суму на відрізку [F(F(R)-1); F(R)-1], і так далі, поки не дійде до нуля.

Функція inc рухається в зворотню сторону - в сторону збільшення індексів, обновляя значення суми T<sub>j</sub> тільки для тих позицій, для яких це потрібно, тобто для всіх j, для яких F(j) <= i <= j.

Очевидно, що від вибору функції F буде залежати швидкість виконання обох операцій. Сейчас ми розглянемо функцію, яка дозволить досягти логарифмічною производительности в обох випадках.

**Визначимо значення F(X)** наступним чином. Розглянемо двоичную запис цього числа і подивимося на його молодший біт. Якщо він рівний нулю, то F(X) = X. Інакше двоичное уявлення числа X закінчується на групу з однієї або декількох одиниць. Заменим всі одиниці з цій групи на нулі, і дамо отримане число значенням функції F(X).

Этому досить сложному опису відповідає дуже проста формула:

$$
**F(X) = X & (X+1)**,
$$

де & - це операція побітового логического "І".

Неважко переконатися, що ця формула відповідає словесному опису функції, даному вище.

&nbsp;

Нам залишилося тільки навчитися швидко знаходити такі числа j, для яких F(j) <= i <= j.

Однак неважко переконатися в тому, що всі такі числа j виходять з i последовательными заменами самого правого (самого младшего) нуля в двоичном поданні. Наприклад, для i = 10 ми отримаємо, що j = 11, 15, 31, 63 і т.д.

Як ні странно, такий операції (заміна самого младшего нуля на одиницю) також відповідає дуже проста формула:

$$
**H(X) = X | (X+1)**,
$$

де | - це операція побітового логического "ИЛИ".

## Реалізація дерева Фенвіка для суми для одновимірного випадку

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> t;
int n;

void init (int nn)
{
    n = nn;
    t.assign (n, 0);
}

int sum (int r)
{
    int result = 0;
    for (; r >= 0; r = (r & (r+1)) - 1)
        result += t[r];
    return result;
}

void inc (int i, int delta)
{
    for (; i < n; i = (i | (i+1)))
        t[i] += delta;
}

int sum (int l, int r)
{
    return sum (r) - sum (l-1);
}

void init (vector<int> a)
{
    init ((int) a.size());
    for (unsigned i = 0; i < a.size(); i++)
        inc (i, a[i]);
}
```

## Реалізація дерева Фенвіка для мінімуму для одновимірного випадку

Слід зразу замітити, що, оскільки дерево Фенвіка дозваляє знайти значення функції в довільному відрізку [0;R], то ми ніяк не зможемо знайти мінімум на відрізку [L;R], де L > 0. Далі, всі зміни значень повинні відбуватися тільки в сторону зменшення (знову ж, оскільки ніяк не вийде звернути функцію min). Це значительные обмеження.

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> t;
int n;

const int INF = 1000*1000*1000;

void init (int nn)
{
    n = nn;
    t.assign (n, INF);
}

int getmin (int r)
{
    int result = INF;
    for (; r >= 0; r = (r & (r+1)) - 1)
        result = min (result, t[r]);
    return result;
}

void update (int i, int new_val)
{
    for (; i < n; i = (i | (i+1)))
        t[i] = min (t[i], new_val);
}

void init (vector<int> a)
{
    init ((int) a.size());
    for (unsigned i = 0; i < a.size(); i++)
        update (i, a[i]);
}
```

## Реалізація дерева Фенвіка для суми для двовимірного випадку

Як вже отмечалось, дерево Фенвіка легко узагальнюється на багатовимірний випадок.

<!--- TODO: specify code snippet id -->
``` cpp
vector <vector <int> > t;
int n, m;

int sum (int x, int y)
{
    int result = 0;
    for (int i = x; i >= 0; i = (i & (i+1)) - 1)
        for (int j = y; j >= 0; j = (j & (j+1)) - 1)
            result += t[i][j];
    return result;
}

void inc (int x, int y, int delta)
{
    for (int i = x; i < n; i = (i | (i+1)))
        for (int j = y; j < m; j = (j | (j+1)))
            t[i][j] += delta;
}
```
