# Алгоритм Дініца

## Постановка задачі

Нехай дана мережа, тобто орієнтований граф $G$, в якому кожному ребру $(u,v)$ приписана пропускна здатність $c_{uv}$, а також виділені дві вершини - джерело $s$ і стік $t$.

Потрібно знайти в цій мережі потік $f_{uv}$ з джерела $s$ в стік $t$ максимальної величини.

## Трохи истории

Цей алгоритм був опубліковано советским (израильским) вченим Ефимом **Диницем** (Yefim Dinic, іноді пишеться як "Dinitz") в 1970 р., тобто навіть на два року раніше опубликования алгоритму Едмондса-Карпа (втім, обидва алгоритму були незалежно открыты в 1968 г)..

Крім того, випливає відзначити, що деякі спрощення алгоритму були произведены Шимоном Ивеном (Shimon **Even**) і його учеником Алоном Итаи (Alon **Itai**) в 1979 р. Саме завдяки їм алгоритм отримав свій современный облик: вони применили до ідеї Дініца концепцию блокирующих потоків Александра Карзанова (Alexander Karzanov, 1974 г)., а також переформулировали алгоритм до тією комбінації обходу в ширину і в глибину, в якій зараз цей алгоритм і излагается всюди.

Развитие ідей по відношенню до потоковым алгоритмам вкрай цікаво розглядати, враховуючи **"железный занавес"** тих років, разделявший СССР і Запад. Видно, як іноді схожі ідеї появлялись майже одночасно (як в випадку алгоритму Дініца і алгоритму Едмондса-Карпа), правда, маючи при цим разную эффективность (алгоритм Дініца на один порядок швидше); іноді ж, навпаки, появление ідеї по одну сторону "занавеса" опережало аналогічний хід по іншу сторону більш ніж на десятилетие (як алгоритм Карзанова проштовхування в 1974 р. і алгоритм Гольдберга (Goldberg) проштовхування в 1985 г)..

## Необходимые визначення

Введемо три необхідних визначення (кожне з них є независимым від інших), які потім будуть використовуватися в алгоритмі Дініца.

**Остаточной сетью $G^R$** по відношенню до мережі $G$ і деякого потоку $f$ в ній називається мережа, в якій кожному ребру $(u,v) \in G$ з пропускною здатністю $c_{uv}$ і потоком $f_{uv}$ відповідають два ребра:

* $(u,v)$ з пропускною здатністю $c_{uv}^R = c_{uv} - f_{uv}$

* $(v,u)$ з пропускною здатністю $c_{vu}^R = f_{uv}$

Варто відзначити, що при такому определении в залишкової мережі можуть з'являтися кратні ребра: якщо в вихідної мережі було як ребро $(u,v)$, так і $(v,u)$.

Остаточное ребро можна інтуїтивно розуміти як меру того, наскільки ще можна збільшити потік уздовж якогось ребра. Насправді, якщо по ребру $(u,v)$ з пропускною здатністю $c_{uv}$ протікає потік $f_{uv}$, то потенциально по нього можна пропустити ще $c_{uv}-f_{uv}$ одиниць потоку, а в зворотню сторону можна пропустити до $f_{uv}$ одиниць потоку, що буде означати отмену потоку в первоначальном напрямку.

**Блокирующим потоком** в даній мережі називається такий потік, що будь-який шлях з джерела $s$ в стік $t$ містить насыщенное цим потоком ребро. Іншими словами, в даній мережі не знайдеться такого шляхи з джерела в стік, уздовж якого можна беспрепятственно збільшити потік.

Блокирующий потік не обов'язково максимален. Теорема Форда-Фалкерсона говорить про тому, що потік буде максимальним тоді і тільки тоді, коли в залишкової мережі не знайдеться $s-t$ шляхи; в блокирующем ж потоці нічого не затверджується про существовании шляхи по ребрам, появляющимся в залишкової мережі.

**Слоистая мережа** для даній мережі будується наступним чином. Спочатку визначаються довжини найкоротших шляхів з джерела $s$ до всіх інших вершин; назвемо уровнем ${\rm level}[v]$ вершини її відстань від джерела. Значить в шарувату мережа включают всі ті ребра $(u,v)$ вихідної мережі, які ведуть з одного рівня на який-або іншої, більш поздний, рівень, тобто ${\rm level}[u] + 1 = {\rm level}[v]$ (чому в цим випадку разница відстаней не можливо перевершувати одиниці, випливає з властивості найкоротших відстаней). Таким чином, видаляються всі ребра, расположенные цілком всередині уровней, а також ребра, провідні назад, до попереднім уровням.

Очевидно, шарувата мережа ациклічності. Крім того, будь-який $s-t$ шлях в шаруватої мережі є найкоротшим шляхом в вихідної мережі.

Побудувати шарувату мережа по даній мережі дуже легко: для цього треба запустити обхід в ширину по ребрам цій мережі, вважаючи тим самим для кожної вершини величину ${\rm level}[]$, і потім внести в шарувату мережа всі подходящие ребра.

Зауваження. Термин "шарувата мережа" в русскоязычной літературі не употребляется; зазвичай ця конструкція називається просто "вспомогательным графом". Втім, на англійською мові зазвичай використовується термин "layered network".

## Алгоритм

### Схема алгоритму

Алгоритм представляє собою декілька **фаз**. На кожної фазі спочатку будується залишкова мережа, потім по відношенню до ній будується шарувата мережа (обходом в ширину), а в ній шукається довільний блокуючий потік. Найденный блокуючий потік прибавляется до поточному потоку, і на цим чергова ітерація закінчується.

Цей алгоритм схож з алгоритмом Едмондса-Карпа, але основное відміну можна розуміти так: на кожної ітерації потік збільшується не уздовж одного найкоротшого $s-t$ шляхи, а уздовж цілого набору таких шляхів (адже саме такими шляхами і є шляхи в блокирующем потоці шаруватої мережі).

### Корректность алгоритму

Покажемо, що якщо алгоритм завершується, то на виході у нього виходить потік саме максимальної величини.

Насправді, припустимо, що в якийсь момент в шаруватої мережі, побудованої для залишкової мережі, не вдалося знайти блокуючий потік. Це означає, що стік $t$ взагалі не достижим в шаруватої мережі з джерела $s$. Але оскільки шарувата мережа містить в собі всі найкоротші шляхи з джерела в залишкової мережі, це в свою чергу означає, що в залишкової мережі ні шляхи з джерела в стік. Отже, застосовуючи теорему Форда-Фалкерсона, отримуємо, що поточний потік насправді максимален.

### Оцінка числа фаз

Покажемо, що алгоритм Дініца завжди виконує **менш $n$ фаз**. Для цього доведемо дві леми:

**Лема 1**. Кратчайшее відстань від джерела до кожної вершини не зменшується з виконанням кожної ітерації, тобто

$$
{\rm level}_{i+1}[v] \ge {\rm level}_i[v]
$$

де нижній індекс позначає номер фази, перед якій взяты значення цих змінних.

**Доведення**. Зафіксуємо довільну фазу $i$ і довільну вершину $v$ і розглянемо будь-який найкоротший $s-v$ шлях $P$ в мережі $G^R_{i+1}$ (нагадаємо, так ми обозначаем залишкову мережа, взятую перед виконанням $i+1$-ої фази). Очевидно, довжина шляхи $P$ рівна ${\rm level}_{i+1}[v]$.

Зауважимо, що в залишкову мережа $G^R_{i+1}$ можуть входити тільки ребра з $G^R$, а також ребра, зворотні ребрам з $G^R$ (це випливає з визначення залишкової мережі). Розглянемо два випадку:

* Шлях $P$ містить тільки ребра з $G^R$. Значить, зрозуміло, довжина шляхи $P$ більше або рівна ${\rm level}_i[v]$ (тому що ${\rm level}_i[v]$ по визначенню - довжина найкоротшого шляхи), що і означає виконання нерівності.
* Шлях $P$ містить як мінімум одне ребро, не содержащееся в $G^R$ (але зворотнє якого-то ребру з $G^R$). Розглянемо перший таке ребро; нехай це буде ребро $(u,w)$.

$$
s \Longrightarrow u \rightarrow w \Longrightarrow v
$$

Ми можемо застосувати нашу лему до вершині $u$, тому що вона подпадает під перший випадок; итак, ми отримуємо нерівність ${\rm level}_{i+1}[u] \ge {\rm level}_i[u]$.

Тепер зауважимо, що оскільки ребро $(u,w)$ з'явилося в залишкової мережі тільки після виконання $i$-ой фази, то звідси випливає, що уздовж ребра $(w,u)$ був додатково пропущен якийсь потік; отже, ребро $(w,u)$ принадлежало шаруватої мережі перед $i$-ой фазою, а тому ${\rm level}_i[u] = {\rm level}_i[w] + 1$. Учтём, що по властивості найкоротших шляхів ${\rm level}_{i+1}[w] = {\rm level}_{i+1}[u] + 1$, і об'єднуючи це рівність з двома попередніми неравенствами, отримуємо:

$$
{\rm level}_{i+1}[w] \ge {\rm level}_i[w] + 2.
$$

Тепер ми можемо застосовувати ті ж самі міркування до всьому оставшемуся шляхи до $v$ (тобто що кожне инвертированное ребро додає до $\rm level$ як мінімум два), і в підсумку отримаємо необхідну нерівність.

**Лема 2**. Расстояние між витоком і стоком строго збільшується після кожної фази алгоритму, тобто:

$$
{\rm level}^\prime[t] > {\rm level}[t],
$$

де штрихом помечено значення, отримане на наступного фазі алгоритму.

**Доведення**: від противного. Припустимо, що після виконання поточній фази виявилося, що $ {\rm level}^\prime[t] = {\rm level}[t] $. Розглянемо найкоротший шлях з джерела в стік; по припущенням, його довжина повинна сохраниться неизменной. Однак залишкова мережа на наступного фазі містить тільки ребра залишкової мережі перед виконанням поточній фази, або зворотні до ним. Таким чином, прийшли до протиріччя: знайшовся $s-t$ шлях, який не містить насичених ребер, і має ту ж довжину, що і найкоротший шлях. Цей шлях повинен був бути "заблокирован" блокирующим потоком, чого не відбулося, в чому і полягає протиріччя, що і потрібно довести.

Цю лему інтуїтивно можна розуміти наступним чином: на $i$-ой фазі алгоритм Дініца выявляет і насичує всі $s-t$ шляхи довжини $i$.

Оскільки довжина найкоротшого шляхи з $s$ в $t$ не можливо перевершувати $n-1$, то, отже, алгоритм Дініца здійснює **не більш $n-1$ фази**.

### Пошук блокуючого потоку

Щоб завершити побудова алгоритму Дініца, треба описати алгоритм знаходження блокуючого потоку в шаруватої мережі - ключевое місце алгоритму.

Ми розглянемо три можливих варіанти реалізації пошуку блокуючого потоку:

* Шукати $s-t$ шляхи по одному, поки такі шляхи знаходяться. Шлях можна знайти за $O(m)$ обходом в глибину, а всього таких шляхів буде $O(m)$ (оскільки кожний шлях насичує як мінімум одне ребро). Підсумкова асимптотика пошуку одного блокуючого потоку складе $O(m^2)$.

* Аналогічно попередньою ідеї, однак видаляти в процесі обходу в глибину з графа всі "зайві" ребра, тобто ребра, уздовж яких не вийде дійти до стоку.

Це дуже легко реалізувати: достатньо видаляти ребро після того, як ми просмотрели його в обході в глибину (крім того випадку, коли ми пройшли уздовж ребра і знайшли шлях до стоку). З точки зору реалізації, треба просто підтримувати в списку суміжності кожної вершини вказівник на перший неудалённое ребро, і збільшувати цей вказати в циклі всередині обходу в глибину.

Оцінимо асимптотику цього розв'язку. Кожен обхід в глибину завершується або насыщением як мінімум одного ребра (якщо цей обхід достиг стоку), або продвижением вперед як мінімум одного покажчика (в іншому випадку). Можна зрозуміти, що один запуск обходу в глибину з основний програми працює за $O(k + n)$, де $k$ - число продвижений покажчиків. Враховуючи, що всього запусків обходу в глибину в рамках пошуку одного блокуючого потоку буде $O(p)$, де $p$ - число ребер, насичених цим блокирующим потоком, то весь алгоритм пошуку блокуючого потоку відпрацює за $O(p k + p n)$, що, враховуючи, що всі вказівники в сумі пройшли відстань $O(m)$, дає асимптотику $O(m + pn)$. В гіршому випадку, коли блокуючий потік насичує всі ребра, асимптотика виходить $O(n m)$; ця асимптотика і буде використовуватися далі.

Можна сказати, що цей спосіб знаходження блокуючого потоку надзвичайно эффективен в тому сенсі, що на пошук одного збільшує шляхи він тратит $O(n)$ операцій в середньому. Саме в цим і кроется різницю на цілий порядок эффективностей алгоритму Дініца і Едмондса-Карпа (який шукає один збільшує шлях за $O(m)$).

Цей спосіб розв'язку є як і раніше простим для реалізації, але достатньо ефективним, і тому найбільш часто застосовується на практиці.

* Можна застосувати специальные структури данних - динамические дерева Слетора (Sleator) і Тар'яна (Tarjan)). Значить кожний блокуючий потік можна знайти за час $O(m \log n)$.

### Асимптотика

Таким чином, весь алгоритм Дініца виконується за $O(n^2 m)$, якщо блокуючий потік шукати описаним вище способом за $O(n m)$. Реалізація з використанням динамических дерев Слетора і Тар'яна буде працювати за час $O(n m \log n)$.

#### Единичные мережі

Единичной сетью ("unit network") називається така мережа, в якій пропускні здатності всіх существующих ребер рівні одиниці, і у будь-який вершини, крім джерела і стоку, або входящее, або исходящее ребро єдино.

Цей випадок є достатньо важливим, оскільки в задачі пошуку **максимального паросполука** построенная мережа є саме одиничної.

**Доведемо**, що на одиничних мережах алгоритм Дініца навіть в простий реалізації (яка на довільних графах отрабатывает за $O(n^2 m)$) працює за час $O(m \sqrt{n})$, достигая на задачі пошуку найбільшого паросполука один з кращих відомих алгоритмів - алгоритм Хопкрофта-Карпа.

По-перше, відзначимо, що наведений вище алгоритм пошуку блокуючого потоку, який на довільних мережах працює за час $O(n m)$, в мережах з единичными пропускними здібностями буде працювати за $O(m)$: в силу того, що кожне ребро не буде переглянуто більш одного рази.

По-друге, оцінимо загальне кількість фаз, яке могло статися в випадку одиничних сетей.

Нехай вже було произведено $\sqrt{n}$ фаз алгоритму Дініца; тоді всі збільшують шляхи довжини не більш $\sqrt{n}$ вже обнаружены. Нехай $f$ - поточний знайдений потік, а $f^*$ - шуканий максимальний потік; розглянемо їх різницю: $f^* - f$. Вона представляє з собі потік в залишкової мережі $G^R$. Цей потік має величину $|f^*| - |f|$, і уздовж кожного ребра рівний нулю або одиниці. Його можна декомпозировать на набір з $|f^*| - |f|$ шляхів з $s$ в $t$ і, можливо, циклів. Оскільки мережа единична, то всі ці шляхи не можуть мати загальних вершин, тому, враховуючи вышесказанное, сумарне кількість вершин в них $cnt$ можна оцінити як:

$$
cnt \ge (|f^*| - |f|) \cdot \sqrt{n}.
$$

З іншої сторони, враховуючи, що $cnt \le n$, ми отримуємо звідси:

$$
|f^*| - |f| \le \sqrt{n},
$$

що означає, що ще через $\sqrt{n}$ фаз алгоритму Дініца гарантовано знайдеться максимальний потік.

Отже, загальне число фаз алгоритму Дініца, выполняемое на одиничних мережах, можна оцінити як $2 \sqrt{n}$, що і потрібно довести.

## Реалізація

Наведемо дві реалізації алгоритму за $O(n^2 m)$, работающие на мережах, заданих матрицами суміжності і списками суміжності відповідно.

### Реалізація над графами в вигляді матриць суміжності

<!--- TODO: specify code snippet id -->
``` cpp
const int MAXN = ...;       // кількість вершин
const int INF = 1000000000; // константа-нескінченність

int n, c[MAXN][MAXN], f[MAXN][MAXN], s, t, d[MAXN], ptr[MAXN], q[MAXN];

bool bfs() {
    int qh = 0, qt = 0;
    q[qt++] = s;
    memset(d, -1, n * sizeof d[0]);
    d[s] = 0;
    while (qh < qt) {
        int v = q[qh++];
        for (int to = 0; to < n; ++to)
            if (d[to] == -1 && f[v][to] < c[v][to]) {
                q[qt++] = to;
                d[to] = d[v] + 1;
            }
    }
    return d[t] != -1;
}

int dfs(int v, int flow) {
    if (!flow)
        return 0;
    if (v == t)
        return flow;
    for (int &to = ptr[v]; to < n; ++to) {
        if (d[to] != d[v] + 1)
            continue;
        int pushed = dfs(to, min(flow, c[v][to] - f[v][to]));
        if (pushed) {
            f[v][to] += pushed;
            f[to][v] -= pushed;
            return pushed;
        }
    }
    return 0;
}

int dinic() {
    int flow = 0;
    for (;;) {
        if (!bfs())
            break;
        memset(ptr, 0, n * sizeof ptr[0]);
        while (int pushed = dfs(s, INF))
            flow += pushed;
    }
    return flow;
}
```

Сеть повинна бути попередньо зчитана: повинні бути задані змінні $n$, $s$, $t$, а також зчитана матриця пропускних здібностей $c[][]$. Основна функція розв'язку - $\rm dinic()$, яка повертає величину знайденого максимального потоку.

### Реалізація над графами в вигляді списків суміжності

<!--- TODO: specify code snippet id -->
``` cpp
const int MAXN = ...;       // кількість вершин
const int INF = 1000000000; // константа-нескінченність

struct edge {
    int a, b, cap, flow;
};

int n, s, t, d[MAXN], ptr[MAXN], q[MAXN];
vector<edge> e;
vector<int> g[MAXN];

void add_edge(int a, int b, int cap) {
    edge e1 = {a, b, cap, 0};
    edge e2 = {b, a, 0, 0};
    g[a].push_back((int)e.size());
    e.push_back(e1);
    g[b].push_back((int)e.size());
    e.push_back(e2);
}

bool bfs() {
    int qh = 0, qt = 0;
    q[qt++] = s;
    memset(d, -1, n * sizeof d[0]);
    d[s] = 0;
    while (qh < qt && d[t] == -1) {
        int v = q[qh++];
        for (size_t i = 0; i < g[v].size(); ++i) {
            int id = g[v][i], to = e[id].b;
            if (d[to] == -1 && e[id].flow < e[id].cap) {
                q[qt++] = to;
                d[to] = d[v] + 1;
            }
        }
    }
    return d[t] != -1;
}

int dfs(int v, int flow) {
    if (!flow)
        return 0;
    if (v == t)
        return flow;
    for (; ptr[v] < (int)g[v].size(); ++ptr[v]) {
        int id = g[v][ptr[v]], to = e[id].b;
        if (d[to] != d[v] + 1)
            continue;
        int pushed = dfs(to, min(flow, e[id].cap - e[id].flow));
        if (pushed) {
            e[id].flow += pushed;
            e[id ^ 1].flow -= pushed;
            return pushed;
        }
    }
    return 0;
}

int dinic() {
    int flow = 0;
    for (;;) {
        if (!bfs())
            break;
        memset(ptr, 0, n * sizeof ptr[0]);
        while (int pushed = dfs(s, INF))
            flow += pushed;
    }
    return flow;
}
```

Сеть повинна бути попередньо зчитана: повинні бути задані змінні $n$, $s$, $t$, а також добавлены всі ребра (орієнтовані) з допомогою викликів функції $\rm add\_edge$. Основна функція розв'язку - $\rm dinic()$, яка повертає величину знайденого максимального потоку.
