# Знаходження найбільшою нульовий підматриці

Дана матриця $a$ розміром $n \times m$. Потрібно знайти в ній таку підматрицю, состоящую тільки з нулів, і серед всіх таких - имеющую найбільшу площа (подматріца - це прямокутна область матриці).

Тривіальний алгоритм, - перебирающий шукану підматрицю, - навіть при самою хорошей реалізації буде працювати $O(n^2 m^2)$. Нижче описується алгоритм, працюючий за $O(n m)$, тобто за лінійне щодо розмірів матриці час.

## Алгоритм

Для устранения неоднозначностей зразу зауважимо, що $n$ рівне числу стрічок матриці $a$, відповідно, $m$ - це число стовпців. Елементи матриці будемо нумерувати в $0$-індексації, тобто в обозначении $a[i][j]$ індекси $i$ і $j$ пробігають диапазоны $i = 0 \ldots n-1$, $j = 0 \ldots m-1$.

### Шаг 1: Вспомогательная динаміка

Спочатку порахуємо наступну допоміжну динаміку: $d[i][j]$ - ближайшая зверху одиниця для елементу $a[i][j]$. Формально кажучи, $d[i][j]$ рівне найбільшому номеру стрічки (серед стрічок діапазоні від $-1$ до $i$), в якій в $j$-ом стовпці варто одиниця. В зокрема, якщо такий стрічки ні, то $d[i][j]$ покладається рівним $-1$ (це можна розуміти як то, що вся матриця як ніби обмежена снаружи единицами).

Цю динаміку легко вважати рухаючись по матриці зверху вниз: нехай ми варто в $i$-ой стрічки, і відомо значення динаміки для попередньою стрічки. Значить достатньо скопировать ці значення в динаміку для поточній стрічки, изменив тільки ті елементи, в яких в матриці стоять одиниці. Зрозуміло, що тоді навіть не потрібно зберігати всю прямоугольную матрицю динаміки, а достатньо тільки одного масиву розміру $m$:

<!--- TODO: specify code snippet id -->
``` cpp
vector<int> d (m, -1);
for (int i=0; i<n; ++i) {
    for (int j=0; j<m; ++j)
        if (a[i][j] == 1)
            d[j] = i;

    // вирахували d для i-ой стрічки, можемо тут використовувати ці значення
}
```

### Шаг 2: Розв'язок задачі

Уже зараз ми можемо розв'язати задачу за $O(n m^2)$ - просто перебирати в поточній стрічки номер лівого і правого стовпців шуканої підматриці, і з допомогою динаміки $d[][]$ обчислювати за $O(1)$ верхню кордон нульовий підматриці. Однак можна піти далі і значно покращити асимптотику розв'язку.

Ясно, що шукана нулевая подматріца обмежена зі всіх чотирьох сторін якимись единичками (або кордонами поля), - які і мешают їй збільшитися в размерах і покращити відповідь. Тому, затверджується, ми не пропустимо відповідь, якщо будемо діяти наступним чином: спочатку переберемо номер $i$ нижней стрічки нульовий підматриці, потім переберемо, в якому стовпці $j$ ми будемо упирать вгору нульову підматрицю. Користуючись значенням $d[i][j]$, ми зразу отримуємо номер верхней стрічки нульовий підматриці. Залишилося тепер визначити оптимальные ліву і праву межі нульовий підматриці, - тобто максимально розсунути цю підматрицю вліво і вправо від $j$-го стовпчика.

Що значить розсунути максимально вліво? Це значить знайти такий індекс $k_1$, для якого буде $d[i][k_1] > d[i][j]$, і при цим $k_1$ - найближчий такий ліворуч для індексу $j$. Зрозуміло, що тоді $k_1+1$ дає номер лівого стовпчика шуканої нульовий підматриці. Якщо такого індексу взагалі ні, то покласти $k_1=-1$ (це означає, що ми змогли розширити поточну нульову підматрицю вліво до упора - до межі всій матриці $a$).

Симметрично можна визначити індекс $k_2$ для правою межі: це найближчий справа від $j$ індекс такий, що $d[i][k_2] > d[i][j]$ (або $m$, якщо такого індексу ні).

Отже, індекси $k_1$ і $k_2$, якщо ми навчимося ефективно їх шукати, дадуть нам всю необхідну інформацію про поточній нульовий подматрице. В зокрема, її площа буде рівна $(i - d[i][j]) \cdot (k_2 - k_1 - 1)$.

Як ж шукати ці індекси $k_1$ і $k_2$ ефективно при фиксированных $i$ і $j$? Нас удовлетворит тільки асимптотика $O(1)$, хоча б в середньому.

Добиться такий асимптотики можна з допомогою стека (stack) наступним чином. Навчимося спочатку шукати індекс $k_1$, і зберігати його значення для кожного індексу $j$ всередині поточній стрічки $i$ в динаміці $d_1[i][j]$. Для цього будемо переглядати всі стовпці $j$ ліворуч направо, і заведемо такий стек, в якому завжди будуть лежати тільки ті стовпці, в яких значення динаміки $d[][]$ строго більше $d[i][j]$. Зрозуміло, що при переході від стовпчика $j$ до наступного колонки $j+1$ потрібно оновити содержимое цього стека. Стверджується, що потрібно спочатку покласти в стек стовпець $j$ (оскільки для нього стек "хороший"), а потім, поки на вершині стека лежить неподходящий елемент (тобто у якого значення $d \le d[i][j+1]$), - доставать цей елемент. Легко зрозуміти, що видаляти з стека достатньо тільки з його вершини, і ні з яких інших його мест (тому що стек буде містити зростаючу по $d$ послідовність стовпців).

Значення $d_1[i][j]$ для кожного $j$ буде рівне значенням, лежащему в цей момент на вершині стека.

Ясно, що оскільки добавлений в стек на кожної строчке $i$ відбувається рівне $m$ штук, то і удалений також не могло бути більше, тому в сумі асимптотика буде лінійної.

Динаміка $d_2[i][j]$ для знаходження індексів $k_2$ вважається аналогічно, тільки треба переглядати стовпці справа наліво.

Також випливає відзначити, що цей алгоритм споживає $O(m)$ пам'яті (не вважаючи вхідні дані - матрицю $a[][]$).

## Реалізація

Ця реалізація вищеописаного алгоритму зчитує розміри матриці, потім саму матрицю (як послідовність чисел, разделённых пробелами або переводами стрічок), і потім виводить відповідь - розмір найбільшою нульовий підматриці.

Легко покращити цю реалізацію, аби вона також выводила саму нульову підматрицю: для цього треба при кожному зміні $\rm ans$ запам'ятовувати також номера стрічок і стовпців підматриці (ними будуть відповідно $d[j]+1$, $i$, $d1[j]+1$, $d2[j]-1$).

<!--- TODO: specify code snippet id -->
``` cpp
int n, m;
cin >> n >> m;
vector < vector<int> > a (n, vector<int> (m));
for (int i=0; i<n; ++i)
    for (int j=0; j<m; ++j)
        cin >> a[i][j];

int ans = 0;
vector<int> d (m, -1), d1 (m), d2 (m);
stack<int> st;
for (int i=0; i<n; ++i) {
    for (int j=0; j<m; ++j)
        if (a[i][j] == 1)
            d[j] = i;
    while (!st.empty()) st.pop();
    for (int j=0; j<m; ++j) {
        while (!st.empty() && d[st.top()] <= d[j])  st.pop();
        d1[j] = st.empty() ? -1 : st.top();
        st.push (j);
    }
    while (!st.empty()) st.pop();
    for (int j=m-1; j>=0; --j) {
        while (!st.empty() && d[st.top()] <= d[j])  st.pop();
        d2[j] = st.empty() ? m : st.top();
        st.push (j);
    }
    for (int j=0; j<m; ++j)
        ans = max (ans, (i - d[j]) * (d2[j] - d1[j] - 1));
}

cout << ans;
```
