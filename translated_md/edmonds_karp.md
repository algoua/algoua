# Максимальний потік методом Едмондса-Карпа за O (N M<sup>2</sup>)

<p style="color:red">Внимание: дана стаття устарела і містить помилки і не рекомендуется до чтению. Через деякий час стаття буде повністю переписана.

Нехай дано граф G, в якому виділені дві вершини: джерело S і стік T, а у кожного ребра визначена пропускна здатність C<sub>u,v</sub>. Потік F можна уявити як потік вещества, яке могло б пройти по мережі від джерела до стоку, якщо розглядати граф як мережа труб з деякими пропускними здібностями. тобто. потік - функція F<sub>u, v</sub>, певна на множині ребер графа.

&nbsp;

Задача полягає в знаходженні максимального потоку. Тут буде розглянуто метод Едмондса-Карпа, працюючий за O (N M<sup>2</sup>), або (інша оцінка) O (F M), де F - величина шуканого потоку. Алгоритм був запропонований в 1972 році.

## Алгоритм

**Остаточной пропускною здатністю** називається пропускна здатність ребра за вычетом поточного потоку уздовж цього ребра. При цим треба пам'ятати, що якщо деякий потік протікає по орієнтованому ребру, то виникає так зване зворотнє ребро (направленное в зворотню сторону), яке буде мати нульову пропускну здатність, і по якому буде протекать той ж по величині потік, але зі знаком мінус. Якщо ж ребро було неориентированным, то воно як б розпадається на два орієнтованих ребра з однаковою пропускною здатністю, і кожне з цих ребер є зворотним для іншого (якщо по одному протікає потік F, то по іншому протікає -F).

Загальна схема **алгоритму Едмондса-Карпа** така. Спочатку вважаємо потік рівним нулю. Потім шукаємо доповнює шлях, тобто простий шлях з S в T по тим ребрам, у яких залишкова пропускна здатність строго позитивна. Якщо доповнює шлях був знайдений, то виготовляється збільшення поточного потоку уздовж цього шляхи. Якщо ж шляхи не було знайдено, то поточний потік є максимальним. Для пошуку дополняющего шляхи можливо використовуватися як [Обход в ширину](bfs), так і [Обход в глибину](dfs).

Розглянемо більш точно процедуру збільшення потоку. Нехай ми знайшли деякий доповнює шлях, тоді нехай C - найменша з залишкових пропускних здібностей ребер цього шляхи. Процедура збільшення потоку полягає в наступному: для кожного ребра (u, v) дополняющего шляхи виконаємо: F<sub>u, v</sub> += C, а F<sub>v, u</sub> = - F<sub>u, v</sub> (або, що то ж саме, F<sub>v, u</sub> -= C).

Величиной потоку буде сума всіх невід'ємних величин F<sub>S, v</sub>, де v - будь-яка вершина, соединённая з витоком.

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
const int inf = 1000*1000*1000;

typedef vector<int> graf_line;
typedef vector<graf_line> graf;

typedef vector<int> vint;
typedef vector<vint> vvint;

int main()
{
    int n;
    cin >> n;
    vvint c (n, vint(n));
    for (int i=0; i<n; i++)
        for (int j=0; j<n; j++)
            cin >> c[i][j];
    // джерело - вершина 0, стік - вершина n-1

    vvint f (n, vint(n));
    for (;;)
    {
        
        vint from (n, -1);
        vint q (n);
        int h=0, t=0;
        q[t++] = 0;
        from[0] = 0;
        for (int cur; h<t;)
        {
            cur = q[h++];
            for (int v=0; v<n; v++)
                if (from[v] == -1 &&
                    c[cur][v]-f[cur][v] > 0)
                {
                    q[t++] = v;
                    from[v] = cur;
                }
        }

        if (from[n-1] == -1)
            break;
        int cf = inf;
        for (int cur=n-1; cur!=0; )
        {
            int prev = from[cur];
            cf = min (cf, c[prev][cur]-f[prev][cur]);
            cur = prev;
        }

        for (int cur=n-1; cur!=0; )
        {
            int prev = from[cur];
            f[prev][cur] += cf;
            f[cur][prev] -= cf;
            cur = prev;
        }

    }

    int flow = 0;
    for (int i=0; i<n; i++)
        if (c[0][i])
            flow += f[0][i];

    cout << flow;

}
```
