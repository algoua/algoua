# Максимальний потік методом Едмондса-Карпа за O (N M<sup>2</sup>)

<p style="color:red">Внимание: дана стаття устарела і містить помилки і не рекомендуется до чтению. Через деякий час стаття буде повністю переписана.

Нехай дано граф G, в якому виділені дві вершини: джерело S і стік T, а у кожного ребра визначена пропускна здатність C<sub>u,v</sub>. Потік F можна уявити як потік вещества, яке могло б пройти по мережі від джерела до стоку, якщо розглядати граф як мережа труб з деякими пропускними здібностями. тобто. потік - функція F<sub>u, v</sub>, певна на множині ребер графа.

&nbsp;

Задача полягає в знаходженні максимального потоку. Тут буде розглянуто метод Едмондса-Карпа, працюючий за O (N M<sup>2</sup>), або (інша оцінка) O (F M), де F - величина шуканого потоку. Алгоритм був запропонований в 1972 році.

## Алгоритм

**Остаточной пропускною здатністю** називається пропускна здатність ребра за вычетом поточного потоку уздовж цього ребра. При цим треба пам'ятати, що якщо деякий потік протікає по орієнтованому ребру, то виникає так зване зворотнє ребро (направленное в зворотню сторону), яке буде мати нульову пропускну здатність, і по якому буде протекать той ж по величині потік, але зі знаком мінус. Якщо ж ребро було неориентированным, то воно як б розпадається на два орієнтованих ребра з однаковою пропускною здатністю, і кожне з цих ребер є зворотним для іншого (якщо по одному протікає потік F, то по іншому протікає -F).

Загальна схема **алгоритму Едмондса-Карпа** така. Спочатку вважаємо потік рівним нулю. Потім шукаємо доповнює шлях, тобто простий шлях з S в T по тим ребрам, у яких залишкова пропускна здатність строго позитивна. Якщо доповнює шлях був знайдений, то виготовляється збільшення поточного потоку уздовж цього шляхи. Якщо ж шляхи не було знайдено, то поточний потік є максимальним. Для пошуку дополняющего шляхи можливо використовуватися як [Обход в ширину](bfs), так і [Обход в глибину](dfs).

Розглянемо більш точно процедуру збільшення потоку. Нехай ми знайшли деякий доповнює шлях, тоді нехай C - найменша з залишкових пропускних здібностей ребер цього шляхи. Процедура збільшення потоку полягає в наступному: для кожного ребра (u, v) дополняющего шляхи виконаємо: F<sub>u, v</sub> += C, а F<sub>v, u</sub> = - F<sub>u, v</sub> (або, що то ж саме, F<sub>v, u</sub> -= C).

Величиной потоку буде сума всіх невід'ємних величин F<sub>S, v</sub>, де v - будь-яка вершина, соединённая з витоком.

## Реалізація

<!--- TODO: specify code snippet id -->
``` cpp
const int inf = 1000 * 1000 * 1000;

typedef vector<int> graf_line;
typedef vector<graf_line> graf;

typedef vector<int> vint;
typedef vector<vint> vvint;

int main() {
    int n;
    cin >> n;
    vvint c(n, vint(n));
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            cin >> c[i][j];
    // джерело - вершина 0, стік - вершина n-1

    vvint f(n, vint(n));
    for (;;) {
        vint from(n, -1);
        vint q(n);
        int h = 0, t = 0;
        q[t++] = 0;
        from[0] = 0;
        for (int cur; h < t;) {
            cur = q[h++];
            for (int v = 0; v < n; v++)
                if (from[v] == -1 && c[cur][v] - f[cur][v] > 0) {
                    q[t++] = v;
                    from[v] = cur;
                }
        }

        if (from[n - 1] == -1)
            break;
        int cf = inf;
        for (int cur = n - 1; cur != 0;) {
            int prev = from[cur];
            cf = min(cf, c[prev][cur] - f[prev][cur]);
            cur = prev;
        }

        for (int cur = n - 1; cur != 0;) {
            int prev = from[cur];
            f[prev][cur] += cf;
            f[cur][prev] -= cf;
            cur = prev;
        }
    }

    int flow = 0;
    for (int i = 0; i < n; i++)
        if (c[0][i])
            flow += f[0][i];

    cout << flow;
}
```
