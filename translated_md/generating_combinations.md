# Генерация сполучень з N елементів

## Сочетания з N елементів по K в лексикографічному порядку

Постановка задачі. Дано натуральні числа N і K. Розглянемо множину чисел від 1 до N. Потрібно вивести всі різні його підмножини потужності K, причому в лексикографічному порядку.

Алгоритм вельми простий. Першим сочетанием, очевидно, буде сочетание (1,2,...,K). Навчимося для поточного поєднання знаходити лексикографічно випливає. Для цього в поточному сочетании найдемо самий правий елемент, не достигший ще свого найбільшого значення; тоді збільшимо його на одиницю, а всім последующим елементам дамо наименьшие значення.

<!--- TODO: specify code snippet id -->
``` cpp
bool next_combination (vector<int> & a, int n) {
    int k = (int)a.size();
    for (int i=k-1; i>=0; --i)
        if (a[i] < n-k+i+1) {
            ++a[i];
            for (int j=i+1; j<k; ++j)
                a[j] = a[j-1]+1;
            return true;
        }
    return false;
}
```
З точки зору производительности, цей алгоритм лине (в середньому), якщо K не близко до N (тобто якщо не виконується, що K = N - o(N)). Для цього достатньо довести, що порівняння "a[i] < n-k+i+1" виконуються в сумі C<sub>n+1</sub><sup>k</sup> раз, тобто в (N+1) / (N-K+1) раз більше, ніж всього є сполучень з N елементів по K.

## Сочетания з N елементів по K з изменениями рівне одного елементу

Потрібно выписать всі поєднання з N елементів по K, але в такому порядку, що будь-які два сусідніх поєднання будуть відрізнятися рівне одним елементом.

Інтуїтивно можна зразу замітити, що ця задача схожа на задачу генерации всіх підмножин даного множини в такому порядку, коли два сусідніх підмножини відрізняються рівне одним елементом. Ця задача безпосередньо вирішується з допомогою [Кода Грея](gray_code): якщо ми кожному подмножеству поставимо в відповідність битовую маску, то, генерируя з допомогою кодів Грея ці битовые маски, ми і отримаємо відповідь.

Может здатися удивительным, але задача генерации сполучень також безпосередньо вирішується з допомогою **коду Грея**. А саме, сгенерируем коди Грея для чисел від 0 до 2<sup>N</sup>-1, і оставим тільки ті коди, які містять рівне K одиниць. Удивительный факт полягає в тому, що в отриманої послідовності будь-які дві сусідні маски (а також перша і остання маски) будуть відрізнятися рівне двома бітами, що нам як раз і потрібно.

**Доведемо** це.

Для доведення згадаємо факт, що послідовність G(N) кодів Грея можна получити наступним чином:

$$
G(N) = 0G(N-1) &cup; 1G(N-1)<sup>R</sup>
$$

тобто беремо послідовність кодів Грея для N-1, дописываем в початок кожної маски 0, додаємо до відповіді; потім знову беремо послідовність кодів Грея для N-1, інвертуємо її, дописываем в початок кожної маски 1 і додаємо до відповіді.

Тепер ми можемо провести доведення.

Спочатку доведемо, що перша і остання маски будуть відрізнятися рівне в двох битах. Для цього достатньо замітити, що перша маска буде мати вид N-K нулів і K одиниць, а остання маска буде мати вид: одиниця, потім N-K-1 нулів, потім K-1 одиниця. Довести це легко по індукції по N, користуючись наведеної вище формулою для послідовності кодів Грея.

Тепер доведемо, що будь-які два сусідніх коду будуть відрізнятися рівне в двох битах. Для цього знову обратимся до формулою для послідовності кодів Грея. Нехай всередині кожної з половинок (образованных з G(N-1)) твердження вірно, доведемо, що воно вірно для всій послідовності. Для цього достатньо довести, що воно вірно в місці "склеивания" двох половинок G(N-1), а це легко показати, грунтуючись на тому, що ми знаємо перший і останній елементи цих половинок.

Наведемо тепер наивную реалізацію, работающую за 2<sup>N</sup>:

<!--- TODO: specify code snippet id -->
``` cpp
int gray_code (int n) {
    return n ^ (n >> 1);
}

int count_bits (int n) {
    int res = 0;
    for (; n; n>>=1)
        res += n & 1;
    return res;
}

void all_combinations (int n, int k) {
    for (int i=0; i<(1<<n); ++i) {
        int cur = gray_code (i);
        if (count_bits (cur) == k) {
            for (int j=0; j<n; ++j)
                if (cur & (1<<j))
                    printf ("%d ", j+1);
            puts ("");
        }
    }
}
```
Варто замітити, що возможна і в деякому сенсі більш эффективная реалізація, яка буде будувати всілякі поєднання на ходу, і тим самим працювати за O (C<sub>n</sub><sup>k</sup> n). З іншої сторони, ця реалізація представляє собою рекурсивну функцію, і тому для невеликих n, ймовірно, вона має велику приховану константу, ніж попереднє розв'язок.

Власне сама реалізація - це безпосереднє следование формулою:

$$
G(N,K) = 0G(N-1,K) &cup; 1G(N-1,K-1)<sup>R</sup>
$$

Ця формула легко виходить з наведеної вище формули для послідовності Грея - ми просто вибираємо підпослідовність з відповідних нам елементів.

<!--- TODO: specify code snippet id -->
``` cpp
bool ans[MAXN];

void gen (int n, int k, int l, int r, bool rev, int old_n) {
    if (k > n || k < 0)  return;
    if (!n) {
        for (int i=0; i<old_n; ++i)
            printf ("%d", (int)ans[i]);
        puts ("");
        return;
    }
    ans[rev?r:l] = false;
    gen (n-1, k, !rev?l+1:l, !rev?r:r-1, rev, old_n);
    ans[rev?r:l] = true;
    gen (n-1, k-1, !rev?l+1:l, !rev?r:r-1, !rev, old_n);
}

void all_combinations (int n, int k) {
    gen (n, k, 0, n-1, false, n);
}
```
