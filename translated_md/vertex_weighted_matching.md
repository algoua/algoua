# Знаходження найбільшого по вазі вершинно-взвешенного паросполука

Дан дводольний граф G. Для кожної вершини першо] частки вказано її вага. Потрібно знайти паросполука найбільшого ваги, тобто з найбільшою сумою ваг насичених вершин.

Нижче ми опишемо і доведемо алгоритм, заснований на [алгоритмі Куна](kuhn_matching), який буде знаходити оптимальне розв'язок.

## Алгоритм

Сам алгоритм надзвичайно простий. **Відсортуємо** вершини першо] частки в порядку зменшення (точніше кажучи, невозрастания) ваг, і застосуємо до полученному графу **[алгоритм Куна](kuhn_matching)**.

Стверджується, що отримане при цим максимальне (з точки зору кількості ребер) паросполука буде і оптимальним з точки зору суми ваг насичених вершин (незважаючи на то, що після сортування ми фактично більше не використовуємо ці ваги).

Таким чином, реалізація буде приблизно такий:

<!--- TODO: specify code snippet id -->
``` cpp
int n;
vector < vector<int> > g (n);
vector<char> used (n);
vector<int> order (n); // список вершин, відсортований по вазі
... читання ...

for (int i=0; i<n; ++i) {
    int v = order[i];
    used.assign (n, false);
    try_kuhn (v);
}
```
Функція try_kuhn() береться безо всяких змін з алгоритму Куна.

## Доведення

Нагадаємо основные положения **теорії матроїдів**.

Матроид M - це упорядоченная пара (S,I), де S - деякий множину, I - непустое сімейство підмножин множини S, які задовольняють наступним умовами:

<ol>
* Безліч S кінцеве.
* Семейство I є наследственным, тобто якщо якесь множину належить I, то всі його підмножини також належать I.
* Структура M володіє властивістю замены, тобто якщо A&isin;I, і B&isin;I, і |A|<|B|, то знайдеться такий елемент x&isin;A-B, що A&cup;x&isin;I.
</ol>
Елементи семейства I називаються незалежними подмножествами.

Матроид називається взвешенным, якщо для кожного елементу x&isin;S визначений деякий вага. Весом підмножини називається сума ваг його елементів.

Нарешті, важнейшая теорема в теорії взвешенных матроїдів: аби получити оптимальний відповідь, тобто независимое підмножина з найбільшим вагою, потрібно діяти жадібно: починаючи з порожнього підмножини, будемо додавати (якщо, звісно, поточний елемент можна додати без нарушения независимости) всі елементи по одному в порядку зменшення (точніше, невозрастания) їх ваг:

<!--- TODO: specify code snippet id -->
``` cpp
відсортувати множину S по невозрастанию ваги;
ans = [];
foreach (x in S)
    if (ans &cup; x &isin; I)
        ans = ans &cup; x;
```
Стверджується, що по закінченні цього процесу ми отримаємо підмножина з найбільшим вагою.

Тепер **доведемо**, що **наша задача -** не що інше, як зважений **матроид**.

Нехай S - множину всіх вершин першо] частки. Щоб звести нашу задачу в дводольному графі до матроиду щодо вершин першо] частки, поставимо в відповідність кожному паросполуці таке підмножина S, яке рівне безлічі насичених вершин першо] частки. Можна також визначити і зворотнє відповідність (з множини насичених вершин - в паросполука), яке, хоча і не буде однозначным, однак цілком нас буде устраивать.

Значить визначимо сімейство I як сімейство таких підмножин множини S, для яких знайдеться хоча б одне відповідне паросполука.

Далі, для кожного елементу S, тобто для кожної вершини першо] частки, по умові визначений деякий вага. Причому вага підмножини, як нам і потрібно в рамках теорії матроїдів, визначається як сума ваг елементів в ньому.

Значить задача про знаходженні паросполука найбільшого ваги тепер переформулируется як задача знаходження независимого підмножини найбільшого ваги.

Залишилося перевірити, що виконані 3 вищеописаних умови, наложенных на матроид. По-перше, очевидно, що S є конечным. По-друге, очевидно, що видалення ребра з паросполука еквівалентно удалению вершини з множини насичених вершин, а тому властивість наследственности виконується. По-третє, як випливає з коректності алгоритму Куна, якщо поточний паросполука не максимально, то завжди знайдеться така вершина, яку можна буде наситити, не видаляючи з множини насичених вершин інші вершини.

Отже, ми показали, що наша задача є взвешенным матроидом щодо множини насичених вершин першо] частки, а тому до ній застосуємо жадібний алгоритм.

Залишилося показати, що **алгоритм Куна є цим жадібним алгоритмом**.

Однак це досить очевидний факт. Алгоритм Куна на кожному кроці намагається наситити поточну вершину - або просто проводя ребро в ненасыщенную вершину другий частки, або знаходячи удлиняющую ланцюг і чередуя паросполука уздовж її. І в тому, і в другом випадку ніякі вже насыщенные вершини не перестають бути ненасиченими, а ненасыщенные на попередніх кроках вершини першо] частки не насыщаются і на цим кроці. Таким чином, алгоритм Куна є жадібним алгоритмом, строящим оптимальне независимое підмножини матроида, що і завершує наше доведення.
