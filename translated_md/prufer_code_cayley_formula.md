# Код Прюфера. Формула Келі. Кількість способів зробити граф зв'язним

В даній статті ми розглянемо так званий **код Прюфера**, який представляє з собі спосіб однозначного кодирования помеченного дерева з допомогою послідовності чисел.

З допомогою кодів Прюфера демонструється доведення **формули Келі** (задающей кількість остовних дерев в повному графі), а також розв'язок задачі про кількості способів додати в завдань граф ребра, аби перетворити його в зв'язний.

**Зауваження**. Ми не будемо розглядати дерева, состоящие з єдиною вершини, - це особливий випадок, на якому багато затвердження вироджуються.

## Код Прюфера

Код Прюфера - це спосіб взаємно однозначного кодирования помічених дерев з $n$ вершинами з допомогою послідовності $n-2$ цілих чисел в відрізку $[1;n]$. Іншими словами, код Прюфера - це **биекция** між усіма остовными деревами повного графа і числовыми последовательностями.

Хоча використовувати код Прюфера для зберігання і оперирования з деревами недоцільно з-за специфичности уявлення, коди Прюфера находят застосування в рішенні комбінаторних задач.

Автор - Хейнц Прюфер (Heinz Prüfer) - запропонував цей код в 1918 р. як доведення формули Келі (див. нижче).

### Побудова коду Прюфера для даного дерева

Код Прюфера будується наступним чином. Будемо $n-2$ рази проделывать процедуру: вибираємо лист дерева з найменшим номером, видаляємо його з дерева, і додаємо до коду Прюфера номер вершини, яка була связана з цим листком. В наприкінці кінців в дереві залишиться тільки $2$ вершини, і алгоритм на цим завершується (номер цих вершин явним чином в коді не записываются).

Таким чином, код Прюфера для заданого дерева - це послідовність з $n-2$ чисел, де кожне число - номер вершини, связанной з найменшим на той момент листком - тобто це число в відрізку $[1;n]$.

Алгоритм обчислення коду Прюфера легко реалізувати з асимптотикою $O(n \log n)$, просто підтримуючи структуру данних для вилучення мінімуму (наприклад, $\rm set<>$ або $\rm priority\_queue<>$ в мові C++), що містить в собі список всіх поточних листя:

<!--- TODO: specify code snippet id -->
``` cpp
const int MAXN = ...;
int n;
vector<int> g[MAXN];
int degree[MAXN];
bool killed[MAXN];

vector<int> prufer_code() {
    set<int> leaves;
    for (int i = 0; i < n; ++i) {
        degree[i] = (int)g[i].size();
        if (degree[i] == 1)
            leaves.insert(i);
        killed[i] = false;
    }

    vector<int> result(n - 2);
    for (int iter = 0; iter < n - 2; ++iter) {
        int leaf = *leaves.begin();
        leaves.erase(leaves.begin());
        killed[leaf] = true;

        int v;
        for (size_t i = 0; i < g[leaf].size(); ++i)
            if (!killed[g[leaf][i]])
                v = g[leaf][i];

        result[iter] = v;
        if (--degree[v] == 1)
            leaves.insert(v);
    }
    return result;
}
```

Втім, побудова коду Прюфера можна реалізувати і за лінійне час, що описується в наступному розділі.

### Побудова коду Прюфера для даного дерева за лінійне час

Наведемо тут простий алгоритм, має асимптотику $O(n)$.

Суть алгоритму полягає в хранении **движущегося покажчика** $ptr$, який завжди буде продвигаться тільки в сторону збільшення номерів вершин.

На перший погляд, таке неможливо, адже в процесі побудови коду Прюфера номера листя можуть як збільшуватися, так і **зменшуватися**. Однак легко замітити, що зменшення відбуваються тільки в единственном випадку: коду при видаленні поточного листа його предок має менший номер (цей предок стане мінімальним листком і удалится з дерева на наступному ж кроці коду Прюфера). Таким чином, випадки зменшення можна обробити за час $O(1)$, і нічого не заважає побудови алгоритму з **лінійної асимптотикою**:

<!--- TODO: specify code snippet id -->
``` cpp
const int MAXN = ...;
int n;
vector<int> g[MAXN];
int parent[MAXN], degree[MAXN];

void dfs(int v) {
    for (size_t i = 0; i < g[v].size(); ++i) {
        int to = g[v][i];
        if (to != parent[v]) {
            parent[to] = v;
            dfs(to);
        }
    }
}

vector<int> prufer_code() {
    parent[n - 1] = -1;
    dfs(n - 1);

    int ptr = -1;
    for (int i = 0; i < n; ++i) {
        degree[i] = (int)g[i].size();
        if (degree[i] == 1 && ptr == -1)
            ptr = i;
    }

    vector<int> result;
    int leaf = ptr;
    for (int iter = 0; iter < n - 2; ++iter) {
        int next = parent[leaf];
        result.push_back(next);
        --degree[next];
        if (degree[next] == 1 && next < ptr)
            leaf = next;
        else {
            ++ptr;
            while (ptr < n && degree[ptr] != 1)
                ++ptr;
            leaf = ptr;
        }
    }
    return result;
}
```

Прокоментуємо цей код. Основна функція тут - $\rm prufer\_code()$, яка повертає код Прюфера для дерева, заданого в глобальних змінних $n$ (кількість вершин) і $g$ (списки суміжності, задающие граф). На Початку ми знаходимо для кожної вершини її предка ${\rm parent}[i]$ - тобто того предка, якого ця вершина буде мати в момент видалення з дерева (усе це ми можемо знайти заздалегідь, користуючись тим, що максимальна вершина $n-1$ ніколи не удалится з дерева). Також ми знаходимо для кожної вершини її ступінь ${\rm degree}[i]$. Переменная $\rm ptr$ - це движущийся вказівник ("кандидат" на мінімальний лист), який змінюється завжди тільки в сторону збільшення. Переменная $\rm leaf$ - це поточний лист з мінімальним номером. Таким чином, кожна ітерація коду Прюфера полягає в додаванні $\rm leaf$ в відповідь, а також перевірці, не виявилося або $\rm parent[leaf]$ менше поточного кандидата $\rm ptr$: якщо виявилося менше, то ми просто присвоюємо $\rm leaf = parent[leaf]$, а в іншому випадку - двигаем вказівник $\rm ptr$ до наступного листа.

Як легко видно по коду, асимптотика алгоритму дійсно становить $O(n)$: вказівник $\rm ptr$ претерпит лише $O(n)$ змін, а всі інші частини алгоритму очевидно працюють за лінійне час.

### Деякі властивості кодів Прюфера

* За закінченні побудови коду Прюфера в дереві залишаться неудалёнными дві вершини.

Одной з них точно буде вершина з максимальним номером - $n-1$, а ось про іншу вершину нічого определённого сказати не можна.

* Кожна вершина зустрічається в коді Прюфера певне число раз, рівне її степені мінус один.

Це легко зрозуміти, якщо замітити, що вершина видаляється з дерева в момент, коли її ступінь рівна одиниці - тобто до цьому моменту всі смежные з ній ребра, крім одного, були удалены. (Для двох залишилися після побудови коду вершин це твердження теж вірно).

### Відновлення дерева по його коду Прюфера

Для відновлення дерева достатньо замітити з попереднього пункту, що степені всіх вершин в искомом дереві ми вже знаємо (і можемо порахувати і зберегти в деякому масиві $degree[]$). Отже, ми можемо знайти всі листя, і, відповідно, номер найменшого листа - який був удалён на першому кроці. Цей лист був соединён з вершиною, номер якій записан в першо] осередку коду Прюфера.

Таким чином, ми знайшли перший ребро, удалённое кодом Прюфера. Додамо це ребро в відповідь, потім зменшимо степені $degree[]$ у обох кінців ребра.

Будемо повторювати цю операцію, поки не просмотрим весь код Прюфера: шукати мінімальну вершину з $degree = 1$, з'єднувати її з черговий вершиною коду Прюфера, зменшувати $degree[]$ у обох кінців.

В наприкінці кінців у нас залишиться тільки дві вершини з $degree = 1$ - це ті вершини, який алгоритм Прюфера оставил неудалёнными. Соединим їх ребром.

Алгоритм завершён, шукане дерево построено.

**Реалізувати** цей алгоритм легко за час $O(n \log n)$: підтримуючи в структурі данних для вилучення мінімуму (наприклад, $\rm set<>$ або $\rm priority\_queue<>$ в C++) номера всіх вершин, мають $degree=1$, і извлекая з нього кожний раз мінімум.

Наведемо відповідну реалізацію (де функція $prufer\_decode()$ повертає список з ребер шуканого дерева):

<!--- TODO: specify code snippet id -->
``` cpp
vector<pair<int, int>> prufer_decode(const vector<int> &prufer_code) {
    int n = (int)prufer_code.size() + 2;
    vector<int> degree(n, 1);
    for (int i = 0; i < n - 2; ++i)
        ++degree[prufer_code[i]];

    set<int> leaves;
    for (int i = 0; i < n; ++i)
        if (degree[i] == 1)
            leaves.insert(i);

    vector<pair<int, int>> result;
    for (int i = 0; i < n - 2; ++i) {
        int leaf = *leaves.begin();
        leaves.erase(leaves.begin());

        int v = prufer_code[i];
        result.push_back(make_pair(leaf, v));
        if (--degree[v] == 1)
            leaves.insert(v);
    }
    result.push_back(make_pair(*leaves.begin(), *--leaves.end()));
    return result;
}
```

### Відновлення дерева по коду Прюфера за лінійне час

Для отримання алгоритму з лінійної асимптотикою можна застосувати той ж самий прийом, що применялся для отримання лінійного алгоритму обчислення коду Прюфера.

Насправді, для знаходження листа з найменшим номером необязательно заводить структуру данних для вилучення мінімуму. Замість цього можна замітити, що, після того як ми знаходимо і обрабатываем поточний лист, він додає в розгляд тільки одну нову вершину. Отже, ми можемо обійтися одним движущимся указателем разом з змінній, хранящей в собі поточний мінімальний лист:

<!--- TODO: specify code snippet id -->
``` cpp
vector<pair<int, int>> prufer_decode_linear(const vector<int> &prufer_code) {
    int n = (int)prufer_code.size() + 2;
    vector<int> degree(n, 1);
    for (int i = 0; i < n - 2; ++i)
        ++degree[prufer_code[i]];

    int ptr = 0;
    while (ptr < n && degree[ptr] != 1)
        ++ptr;
    int leaf = ptr;

    vector<pair<int, int>> result;
    for (int i = 0; i < n - 2; ++i) {
        int v = prufer_code[i];
        result.push_back(make_pair(leaf, v));

        --degree[leaf];
        if (--degree[v] == 1 && v < ptr)
            leaf = v;
        else {
            ++ptr;
            while (ptr < n && degree[ptr] != 1)
                ++ptr;
            leaf = ptr;
        }
    }
    for (int v = 0; v < n - 1; ++v)
        if (degree[v] == 1)
            result.push_back(make_pair(v, n - 1));
    return result;
}
```

### Взаимная однозначность соответствия між деревами і кодами Прюфера

З однієї сторони, для кожного дерева існує рівне один код Прюфера, відповідний йому (це випливає з визначення коду Прюфера).

З іншої сторони, з коректності алгоритму відновлення дерева по коду Прюфера випливає, що будь-якого коду Прюфера (тобто послідовності з $n-2$ чисел, де кожне число лежить в відрізку $[1;n]$) відповідає деякий дерево.

Таким чином, всі дерева і всі коди Прюфера утворюють **взаємно однозначное відповідність**.

## Формула Келі

Формула Келі свідчить, що **кількість остовних дерев в повному помеченном графі** з $n$ вершин рівне:

$$
n^{n-2}.
$$

Є багато **доказательств** цій формули, але доведення з допомогою кодів Прюфера наглядно і конструктивно.

Насправді, будь-якого набору з $n-2$ чисел з відрузку $[1;n]$ однозначно відповідає деякий дерево з $n$ вершин. Всього різних кодів Прюфера $n^{n-2}$. Оскільки в випадку повного графа з $n$ вершин в якості острови підходить будь-яке дерево, то і кількість остовних дерев рівне $n^{n-2}$, що і потрібно довести.

## Кількість способів зробити граф зв'язним

Мощь кодів Прюфера полягає в тому, що вони дозволяють получити більш загальну формулу, ніж формулу Келі.

Отже, дано граф з $n$ вершин і $m$ ребер; нехай $k$ - кількість компонент зв'язності в цим графі. Потрібно знайти число способів додати $k-1$ ребро, аби граф став зв'язним (очевидно, $k-1$ ребро - минимально необхідне кількість ребер, аби зробити граф зв'язним).

Выведем готовую формулу для розв'язку цій задачі.

Позначимо через $s_1, \ldots, s_k$ розміри компонент зв'язності цього графа. Оскільки додавати ребра всередині компонент зв'язності заборонено, то виходить, що задача дуже схожа на пошук кількості остовних дерев в повному графі з $k$ вершин: але відміну тут в тому, що кожна вершина має свій "вага" $s_i$: кожне ребро, суміжне з $i$-ой вершиною, примножує відповідь на $s_i$.

Таким чином, для підрахунку кількості способів виявляється важливим, які степені мають всі $k$ вершин в остові. Для отримання формули для задачі треба підсумувати відповіді по всім можливим степеням.

Нехай $d_1, \ldots, d_k$ - степені вершин в остові. Сума степеней вершин рівна удвоенному кількості ребер, тому:

$$
\sum_{i=1}^k d_i = 2k-2.
$$

Якщо $i$-я вершина має ступінь $d_i$, то в код Прюфера вона входити $d_i-1$ раз. Код Прюфера для дерева з $k$ вершин має довжину $k-2$. Кількість способів вибрати набір $k-2$ чисел, де число $i$ зустрічається рівне $d_i-1$ раз, рівне **мультиномиальному коэффициенту** (по аналогії з [биномиальным коефіцієнтом](binomial_coeff)):

$$
\binom{ k-2 }{ d_1-1, ~ d_2-1, ~ \ldots ~ , d_k-1 } = \frac{ (k-2)! }{ (d_1-1)! ~ (d_2-1)! ~ \ldots ~ (d_k-1)! }.
$$

З урахуванням того, що кожне ребро, суміжне з $i$-ой вершиною, примножує відповідь на $s_i$, отримуємо, що відповідь, при умови, що степені вершин рівні $d_1, \ldots, d_k$, рівний:

$$
s_1^{d_1} \cdot s_2^{d_2} \cdot \ldots \cdot s_k^{d_k} \cdot \frac{ (k-2)! }{ (d_1-1)! ~ (d_2-1)! ~ \ldots ~ (d_k-1)! }.
$$

Для отримання відповіді на задачу треба підсумувати цю формулу по всіляких допустимым наборам $\{ d_i \}_{i=1}^{i=k}$:

$$
\sum_{ \substack{ d_i \ge 1, \\ \sum_{i=1}^k d_i = 2k-2 } } s_1^{d_1} \cdot s_2^{d_2} \cdot \ldots \cdot s_k^{d_k} \cdot \frac{ (k-2)! }{ (d_1-1)! ~ (d_2-1)! ~ \ldots ~ (d_k-1)! }.
$$

Для свёртывания цій формули скористаємось определением мультиномиального коефіцієнта:

$$
(x_1 + \ldots x_m)^p = \sum_{ \substack{ c_i \ge 0, \\ \sum_{i=1}^{m} c_i = p } } x_1^{c_1} \cdot x_2^{c_2} \cdot \ldots \cdot x_m^{c_m} \cdot \binom{ m }{ c_1, ~ c_2, ~ \ldots ~ , c_k }.
$$

Порівнюючи цю формулу з попередньою, отримуємо, що якщо ввести позначення $e_i = d_i-1$:

$$
\sum_{ \substack{ e_i \ge 0, \\ \sum_{i=1}^k e_i = k-2 } } s_1^{e_1+1} \cdot s_2^{e_2+1} \cdot \ldots \cdot s_k^{e_k+1} \cdot \frac{ (k-2)! }{ e_1! ~ e_2! ~ \ldots ~ e_k! },
$$

то після сворачивания **відповідь на задачу** рівний:

$$
s_1 \cdot s_2 \cdot \ldots \cdot s_k \cdot (s_1 + s_2 + \ldots + s_k)^{k-2} = s_1 \cdot s_2 \cdot \ldots \cdot s_k \cdot n^{k-2}.
$$

(Ця формула вірна і при $k=1$, хоча формально з доведення це не следовало).

## Задачі в online judges

Задачі в online judges, в яких застосовуються коди Прюфера:

* [ UVA #10843 **"Anne's game"** ~~~~~~ [складність: низька] ](http://acm.uva.es/p/v108/10843.html)

* [ TIMUS #1069 **"Код Прюфера"** ~~~~~~ [складність: низька] ](http://acm.timus.ru/problem.aspx?space=1&num=1069)

* [ CODEFORCES 110D **"Улики"** ~~~~~~ [складність: середня] ](http://codeforces.ru/contest/156/problem/D)

* [ TopCoder SRM 460 **"TheCitiesAndRoadsDivTwo"** ~~~~~~ [складність: середня] ](http://community.topcoder.com/stat?c=problem_statement&pm=10774&rd=14146)
